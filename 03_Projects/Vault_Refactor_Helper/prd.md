# 产品需求文档 (PRD): Vault_Refactor_Helper v1.0

## 1. 背景与目标

**背景:** 随着知识体系的演进，用户需要进行大规模的结构性调整（重命名、移动文件和文件夹）以重新组织其知识网络。当前通过外部 Agent 自动化此类操作时，无法保证双向链接的完整性，对知识库的健壮性构成了严重威胁，并阻碍了高效的知识重构。

**核心目标:** 开发一个高性能的后台插件，**为大规模、批量的知识库重构操作提供坚实保障**。确保在任何情况下，对笔记文件的重命名和移动都不会破坏库内的链接结构，实现 100% 的链接完整性。

## 2. 用户故事 (User Stories)

1. **故事一：安全单文件重命名**
    
    - **角色:** 作为一名开发者/系统
        
    - **需求:** 当一个外部 Agent 将笔记 `A.md` 重命名为 `B.md` 时
        
    - **目标:** 我希望知识库中所有指向 `[[A]]` 的链接都能被自动、准确地更新为 `[[B]]`，以保证链接持续有效。
        
2. **故事二：安全单文件移动**
    
    - **角色:** 作为一名开发者/系统
        
    - **需求:** 当一个外部 Agent 将笔记 `Notes/A.md` 移动到 `Archive/B.md` 时
        
    - **目标:** 我希望知识库中所有相关的链接都能被自动更新，以反映新的文件路径。
        
3. **故事三：高效批量知识重构 (关键需求)**
    
    - **角色:** 作为一名知识管理者
        
    - **需求:** 当我对知识体系进行重新定位，需要通过自动化脚本**一次性重命名 100 个文件并移动 5 个文件夹**时
        
    - **目标:** 我希望 `Vault_Refactor_Helper` 能够**高效处理这一系列密集的连续操作**，并**确保在此过程中的每一步，链接的修复都是原子性的、无错误的**，最终保证整个重构操作完成后，知识库的链接网络完好无损。
        
4. **故事四：无感运行**
    
    - **角色:** 作为一名 Obsidian 用户
        
    - **需求:** 我希望插件能够在后台静默运行
        
    - **目标:** 它的存在对 Obsidian 的性能和我的日常使用体验不产生任何可察觉的影响。
        

## 3. 假设 (Assumptions)

- **API 稳定性:** 我们假设 Obsidian 官方插件 API 中 `vault.on('rename', ...)` 事件是稳定且可靠的，能够在批量操作中无遗漏地捕获每一个文件变更。
    
- **链接格式:** 我们假设库内的链接主要以标准的 `[[Wikilink]]` 格式存在。
    
- **用户环境:** 我们假设用户在标准的 Obsidian 桌面环境中运行此插件。
    

## 4. 功能范围 (Scope)

### 4.1. 范围内 (In Scope - MVP)

- 开发一个独立的 Obsidian 原生插件，项目名为 `Vault_Refactor_Helper`。
    
- 使用 TypeScript 和 Obsidian 官方插件 API。
    
- 监听 `rename` 事件，并**设计一个能够处理高并发事件的队列机制**。
    
- 自动扫描并修改库内所有 `.md` 文件，以修复链接。
    
- 支持标准的 `[[Wikilink]]` 格式链接的修复。
    
- **确保批量操作的事务完整性**，即一系列操作要么全部成功，要么在失败时能清晰报告问题。
    

### 4.2. 范围外 / 非目标 (Out of Scope / Non-Goals)

- **不修改社区项目:** 不对 `mcp-obsidian` 或 `obsidian-local-rest-api` 进行任何修改。
    
- **无用户界面:** v1.0 版本不提供任何用户界面 (UI) 或设置选项。
    
- **仅限标准链接:** 不支持修复除标准 Wikilink 之外的其他格式链接。
    

## 5. 风险与规避 (Risks & Mitigation)

1. **风险 - 批量操作性能瓶颈:** 对于大型知识库，在短时间内触发成百上千次 `rename` 事件，可能导致事件处理堆积和界面卡顿。
    
    - **规避策略:** **架构设计必须包含一个事件处理队列**。将接收到的 `rename` 事件先放入队列，然后由一个单独的处理器异步地、有序地、批量地执行链接修复工作，从而避免阻塞 UI 线程。
        
2. **风险 - 批量操作中的竞态条件与数据不一致:** 多个链接修复任务同时读写同一个文件，可能导致数据覆盖或更新丢失。
    
    - **规避策略:** 对文件修改操作进行加锁或采用串行处理机制。在架构设计中明确，在任何时间点，只能有一个进程正在修改某一个特定文件。
        
3. **风险 - 批量操作中断:** 如果一个包含 100 个步骤的重构操作在第 50 步失败或被中断，可能会导致知识库处于不一致的中间状态。
    
    - **规避策略:** v1.0 版本将优先保证操作的**向前恢复能力**，即插件会尽可能完成所有已触发的修复。同时，**必须实现详细的操作日志记录**，当发生中断时，用户或开发者可以通过日志清晰地了解哪些操作已完成，哪些未完成，以便手动恢复。暂不实现复杂的事务回滚功能。
        

## 6. 成功指标 (Success Metrics)

- **批量操作零断裂率:** 在一个包含 5000+ 笔记的测试库中，执行一个**包含 200 次文件重命名和 20 次文件夹移动的单次批量脚本**后，库内损坏的链接数量为 0。
    
- **批量处理效率:** 上述批量操作的总完成时间应在可接受的范围内（例如，少于 60 秒），且在此期间 Obsidian 界面不应出现完全冻结的情况。
    

## 7. 未来迭代 (Future Considerations - Post-MVP)

- **高级重构工具:** 提供用户界面，允许用户定义基于正则表达式或特定规则的批量重命名策略。
    
- **事务回滚:** 实现一个快照或日志回滚机制，允许用户撤销一次大规模的重构操作。
    
- **性能优化:** 为超大型知识库引入基于文件缓存的增量索引机制，进一步提升批量处理速度。