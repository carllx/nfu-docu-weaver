![cover1.jpeg](https://i.imgur.com/xKotgQ7.jpeg)

[]{#titlepage.xhtml}

```{=html}
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="100%" height="100%" viewbox="0 0 566 702" preserveaspectratio="none">
```
`<image width="566" height="702" xlink:href="cover1.jpeg">`{=html}`</image>`{=html}
```{=html}
</svg>
```

[]{#index_split_000.html}

[]{#index_split_000.html#p1}![index-1_1.png](https://i.imgur.com/XeMUyI8.jpeg){.calibre2}

![index-1_2.png](https://i.imgur.com/d9D0Ob4.jpeg){.calibre2}

![index-1_3.png](https://i.imgur.com/HprRhmb.jpeg){.calibre2}

![index-1_4.png](https://i.imgur.com/Lg0W8TU.jpeg){.calibre2}

![index-1_5.png](https://i.imgur.com/RunHZJi.jpeg){.calibre2}

![index-1_6.png](https://i.imgur.com/lfHYJqR.jpeg){.calibre2}

![index-1_7.png](https://i.imgur.com/lE1NzeH.jpeg){.calibre2}

![index-1_8.png](https://i.imgur.com/GwHFikD.jpeg){.calibre2}

[]{#index_split_000.html#p2}![index-2_1.png](https://i.imgur.com/SF2yAFa.jpeg){.calibre2}

清华开发者书库

ArduinoCaseinAction

Arduino案例实战(卷Ⅷ)

李永华　林家儒　王思野　编著

LiYonghuaLinJiaru WangSiye

[]{#index_split_000.html#p3}内 容 简 介

本书系统论述了 Arduino开源硬件的架构、原理、开发方法及１４个完整的项目设计案例.本书共１５

章,内容包括 Arduino设计 基 础、LED 多 模 式 显 示 时 钟 项 目 设 计、机 械 臂 控 制 图 像 识 别 项 目 设 计、基 于

Mathematica的自动接球系统项目设计、蓝牙遥控四自由度可自动避障机器人项目设计、遥控智能四驱车

项目设计、电机合奏团项目设计、教学电子 琴 项 目 设 计、微 型 激 光 雕 刻 机 项 目 设 计、遥 控 吸 尘 器 项 目 设 计、

写字报时机器人项目设计、棋盘小游戏之守护 绿 色 项 目 设 计、炮 弹 发 射 车 项 目 设 计、球 形 机 器 人 项 目 设 计

和多功能蓝牙小车项目设计.

在编排方式上,全书侧重对创新产品的项目设计过程进行介绍,分别从需求、分析、设计与实现等角度

论述硬件电路、软件设计、传感器和功能 模 块 等,并 剖 析 产 品 的 功 能、使 用、电 路 连 接 和 程 序 代 码 等.为 便

于读者高效学习,快速掌握 Arduino开发方法,本书配套提供项目设计的硬件电路图和程序代码,可供读

者举一反三,二次开发.

本书可作为高校电子信息类专业"开源硬件设计""电 子 系 统 设 计""创 新 创 业"等 课 程 的 教 材,也 可 以

作为创客及智能硬件爱好者的参考用书,还可作为从事物联网、创新开发和设计专业人员的技术参考书.

本书封面贴有清华大学出版社防伪标签,无标签者不得销售.

版权所有,侵权必究.侵权举报电话:010Ｇ62782989　13701121933

图书在版编目(CIP)数据

Arduino案例实战．卷Ⅷ/李永华,林家儒,王思野编著．---北京:清华大学出版社, ２０１８

(清华开发者书库)

ISBN９７８Ｇ７Ｇ３０２Ｇ５１１９１Ｇ５

Ⅰ．①A􀆺　Ⅱ．①李􀆺 ②林􀆺 ③王􀆺　Ⅲ．①单片微型计算机－程序设计　Ⅳ．①TP３６８．

１

中国版本图书馆 CIP数据核字(２０１８)第２１０６１５号

责任编辑:盛东亮

封面设计:李召霞

责任校对:时翠兰

责任印制:董　瑾

出版发行:清华大学出版社

网

址:http://www．

tup．com．cn,http://www．wqbook．com

地

址:北京清华大学学研大厦 A 座

邮 　 编:１０００８４

社 总 机:０１０Ｇ６２７７０１７５

邮 　 购:０１０Ｇ６２７８６５４４

投稿与读者服务:０１０Ｇ６２７７６９６９,cＧservice＠tup．

tsinghua．edu．cn

质量反馈:０１０Ｇ６２７７２０１５,zhiliang＠tup．

tsinghua．edu．cn

课件下载:http://www．

tup．com．cn,０１０Ｇ６２７９５９５４

印 装 者:三河市龙大印装有限公司

经

销:全国新华书店

开

本:１８６mm×２４０mm　　印　张:２６．

５　　

字　　数:５９９千字

版

次:２０１８年１２月第１版　

印　　次:２０１８年１２月第１次印刷

定

价:７９．

００元

产品编号:０７９３３７Ｇ０１

[]{#index_split_000.html#p4}![index-4_1.png](https://i.imgur.com/57fFbxe.jpeg){.calibre2}

物联网、智能硬件和大数据技术给社会带来了巨大的冲击,个性化、定制化和智能化的

硬件设备成为未来的发展趋势.中国制造２０２５计划、德国的工业４．

０及美国的工业互联网

都是将人、数据和机器连接起来,其本质是工业的深度信息化,为未来智能社会的发展提供

制造技术基础.

在"大众创业、万众创新"的时代背景下,人才的培养方法和模式也应该满足当前的时代

需求.依据当今信息社会的发展趋势,结合 Arduino开源硬件的发展及智能硬件的发展要

求,采取激励创新的工程教育方法,培养可以适应未来工业４．０发展的人才就显得相当重

要.因此,笔者试图基于创新工程教育的基本方法,并将其提炼为适合我国国情、具有自身

特色的创新实践教材.本书对实际教学中应用智能硬件的创新工程教学经验进行总结,包

括具体的创新方法和开发案例,希望对教育教学及工业界有所帮助,起到抛砖引玉的作用.

本 书 的 内 容 和 素 材 主 要 来 源 于 作 者 所 在 学 校 近 几 年 承 担 的 教 育 部 和 北 京 市 的 教 育

教 学 改 革 项 目 和 成 果 ,也 是 北 京 邮 电 大 学 信 息 工 程 专 业 的 同 学 们 创 新 产 品 的 设 计 成

果 . 书 中 系 统 地 介 绍 了 如 何 利 用 Arduino开发平台进行产品开发,包括相 关 的 设 计、实

现 与 产 品 应 用 ,主 要 内 容 包 括 Arduino设计基础及项目开发案例,涉及智能 控 制 类 开 发

案 例 、生 活 便 捷 类 开 发 案 例 、物 联 网 开 发 案 例 、人 机 交 互 类 开 发 案 例 及 其 他 创 意 类 开 发

案 例 .

本书由北京市教育委员会人才培养共建项目(教学名师)资助.本书的编写得到了教育

部电子信息类专业教学指导委员会、信息工程专业国家第一类特色专业建设项目、信息工程

专业国家第二类特色专业建设项目、教育部 CDIO 工程教育模式研究与实践项目、教育部本

科教学工程项目、信息工程专业北京市特色专业建设、北京市教育教学改革项目、北京邮电

大学教育教学改革项目(

２０１７JY０４)的大力支持,在此一并表示感谢!

李和禹、陈河泉、陈向梅、张秋彤、李昕烨、张国利参与了本书部分内容的编写.同时,感

谢林家儒教授的鼎力支持和悉心指导,感谢郑铖、谭扬、黄旭新、顾铁玥、高凡石、陈佳丰等研

究生的大力协助,感谢北京邮电大学信息工程专业所有同学,感谢父母、妻儿在精神上给予

的支持与鼓励,使本书得以问世.

[]{#index_split_000.html#p5}![index-5_1.png](https://i.imgur.com/Uo36H7f.jpeg){.calibre2}

Ⅱ

欢迎广大读者加入开源硬件学习 QQ 群６０５８９２８４６,以便获取本书配套资源,进行学习

交流.

由于作者水平有限,书中不妥之处在所难免,衷心希望各位读者多提宝贵意见及具体的

整改措施,以便作者进一步修改和完善.

李永华

于北京邮电大学

[]{#index_split_000.html#p6}![index-6_1.png](https://i.imgur.com/PycwBWY.jpeg){.calibre2}

第１章　Arduino设计基础 .............................................................................. １

１．

１　开源硬件概述 ................................................................................. １

１．

２　Arduino开源硬件 ........................................................................... ２

１．

２．

１　Arduino开发板 ..................................................................... ２

１．

２．

２　Arduino扩展板 ..................................................................... ５

１．

３　Arduino软件开发平台 ..................................................................... ６

１．

３．

１　Arduino平台特点 .................................................................. ７

１．

３．

２　ArduinoIDE的安装 ............................................................... ７

１．

３．

３　ArduinoIDE的使用 ............................................................ １０

１．

４　Arduino编程语言 ........................................................................... １１

１．

４．

１　Arduino编程基础 ............................................................... １２

１．

４．

２　数字I/O 引脚的操作函数 ...................................................... １２

１．

４．

３　模拟I/O 引脚的操作函数 ...................................................... １３

１．

４．

４　高级I/O 引脚的操作函数 ...................................................... １４

１．

４．

５　时间函数 ........................................................................... １４

１．

４．

６　中断函数 ........................................................................... １６

１．

４．

７　串口通信函数 ..................................................................... １９

１．

４．

８　Arduino的库文件 ............................................................... ２０

１．

５　Arduino硬件设计平台 ..................................................................... ２０

１．

５．

１　Fritzing软件简介 ............................................................... ２１

１．

５．

２　Fritzing使用方法 ............................................................... ２９

１．

５．

３　Arduino电路设计 ............................................................... ３９

１．

５．

４　Arduino开发平台样例与编程 ................................................ ４５

第２章　LED 多模式显示时钟项目设计 ............................................................ ４８

２．

１　项目背景....................................................................................... ４８

２．

２　创新描述....................................................................................... ４８

[]{#index_split_000.html#p7}![index-7_1.png](https://i.imgur.com/WxYDraH.jpeg){.calibre2}

Ⅳ

２．

３　功能及总体设计.............................................................................. ４８

２．

３．

１　功能介绍 ........................................................................... ４９

２．

３．

２　总体设计 ........................................................................... ４９

２．

３．

３　模块介绍 ........................................................................... ５２

２．

４　产品展示 .................................................................................... １００

２．

５　故障及问题分析 ........................................................................... １０１

２．

６　元件清单 .................................................................................... １０２

第３章　机械臂控制图像识别项目设计............................................................ １０３

３．

１　项目背景 .................................................................................... １０３

３．

２　创新描述 .................................................................................... １０３

３．

３　功能及总体设计 ........................................................................... １０３

３．

３．

１　功能介绍........................................................................... １０４

３．

３．

２　总体设计........................................................................... １０４

３．

３．

３　模块介绍........................................................................... １０６

３．

４　产品展示 .................................................................................... １３８

３．

５　故障及问题分析 ........................................................................... １３８

３．

６　元件清单 .................................................................................... １３９

第４章　基于 Mathematica的自动接球系统项目设计 .......................................... １４０

４．

１　项目背景 .................................................................................... １４０

４．

２　创新描述 .................................................................................... １４０

４．

３　功能及总体设计 ........................................................................... １４０

４．

３．

１　功能介绍........................................................................... １４１

４．

３．

２　总体设计........................................................................... １４１

４．

３．

３　模块介绍........................................................................... １４６

４．

４　产品展示 .................................................................................... １５７

４．

５　故障及问题分析 ........................................................................... １５９

４．

６　元件清单 .................................................................................... １６０

第５章　蓝牙遥控四自由度可自动避障机器人项目设计....................................... １６２

５．

１　项目背景 .................................................................................... １６２

５．

２　创新描述 .................................................................................... １６２

５．

３　功能及总体设计 ........................................................................... １６２

５．

３．

１　功能介绍........................................................................... １６２

５．

３．

２　总体设计........................................................................... １６２

[]{#index_split_000.html#p8}![index-8_1.png](https://i.imgur.com/I4XcEBJ.jpeg){.calibre2}

Ⅴ

５．

３．

３　模块介绍........................................................................... １６４

５．

４　产品展示 .................................................................................... １８２

５．

５　故障及问题分析 ........................................................................... １８３

５．

６　元件清单 .................................................................................... １８４

第６章　遥控智能四驱车项目设计.................................................................. １８５

６．

１　项目背景 .................................................................................... １８５

６．

２　创新描述 .................................................................................... １８５

６．

３　功能及总体设计 ........................................................................... １８５

６．

３．

１　功能介绍........................................................................... １８５

６．

３．

２　总体设计........................................................................... １８６

６．

３．

３　模块介绍........................................................................... １８８

６．

４　产品展示 .................................................................................... ２０５

６．

５　故障及问题分析 ........................................................................... ２０５

６．

６　元件清单 .................................................................................... ２０７

第７章　电机合奏团项目设计........................................................................ ２０８

７．

１　项目背景 .................................................................................... ２０８

７．

２　创新描述 .................................................................................... ２０８

７．

３　功能及总体设计 ........................................................................... ２０８

７．

３．

１　功能介绍........................................................................... ２０９

７．

３．

２　总体设计........................................................................... ２０９

７．

３．

３　模块介绍........................................................................... ２１１

７．

４　产品展示 .................................................................................... ２１７

７．

５　故障及问题分析 ........................................................................... ２１８

７．

６　元件清单 .................................................................................... ２１８

第８章　教学电子琴项目设计........................................................................ ２２０

８．

１　项目背景 .................................................................................... ２２０

８．

２　创新描述 .................................................................................... ２２０

８．

３　功能及总体设计 ........................................................................... ２２０

８．

３．

１　功能介绍........................................................................... ２２０

８．

３．

２　总体设计........................................................................... ２２１

８．

３．

３　模块介绍........................................................................... ２２２

８．

４　产品展示 .................................................................................... ２３７

８．

５　故障及问题分析 ........................................................................... ２３８

[]{#index_split_000.html#p9}![index-9_1.png](https://i.imgur.com/sANIc1w.jpeg){.calibre2}

Ⅵ

８．

６　元件清单 .................................................................................... ２３９

第９章　微型激光雕刻机项目设计.................................................................. ２４０

９．

１　项目背景 .................................................................................... ２４０

９．

２　创新描述 .................................................................................... ２４０

９．

３　功能及总体设计 ........................................................................... ２４０

９．

３．

１　功能介绍........................................................................... ２４１

９．

３．

２　总体设计........................................................................... ２４１

９．

３．

３　模块介绍........................................................................... ２４３

９．

４　产品展示 .................................................................................... ２５５

９．

５　故障及问题分析 ........................................................................... ２５６

９．

６　元件清单 .................................................................................... ２５７

第１０章　遥控吸尘器项目设计 ..................................................................... ２５８

１０．

１　项目背景 ................................................................................. ２５８

１０．

２　创新描述 ................................................................................. ２５８

１０．

３　功能及总体设计 ........................................................................ ２５８

１０．

３．

１　功能介绍 ..................................................................... ２５９

１０．

３．

２　总体设计 ..................................................................... ２５９

１０．

３．

３　模块介绍 ..................................................................... ２６１

１０．

４　产品展示 ................................................................................. ２７２

１０．

５　故障及问题分析 ........................................................................ ２７２

１０．

６　元件清单 ................................................................................. ２７４

第１１章　写字报时机器人项目设计 ............................................................... ２７５

１１．

１　项目背景 ................................................................................. ２７５

１１．

２　创新描述 ................................................................................. ２７５

１１．

３　功能及总体设计 ........................................................................ ２７５

１１．

３．

１　功能介绍 ..................................................................... ２７６

１１．

３．

２　总体设计 ..................................................................... ２７６

１１．

３．

３　模块介绍 ..................................................................... ２７８

１１．

４　产品展示 ................................................................................. ２９２

１１．

５　故障及问题分析 ........................................................................ ２９３

１１．

６　元件清单 ................................................................................. ２９４

[]{#index_split_000.html#p10}![index-10_1.png](https://i.imgur.com/0V0OSHT.jpeg){.calibre2}

Ⅶ

第１２章　棋盘小游戏之守护绿色项目设计 ...................................................... ２９５

１２．

１　项目背景 ................................................................................. ２９５

１２．

２　创新描述 ................................................................................. ２９５

１２．

３　功能及总体设计 ........................................................................ ２９５

１２．

３．

１　功能介绍 ..................................................................... ２９６

１２．

３．

２　总体设计 ..................................................................... ２９６

１２．

３．

３　模块介绍 ..................................................................... ２９８

１２．

４　产品展示 ................................................................................. ３２７

１２．

５　故障及问题分析 ........................................................................ ３２８

１２．

６　元件清单 ................................................................................. ３２９

第１３章　炮弹发射车项目设计 ..................................................................... ３３０

１３．

１　项目背景 ................................................................................. ３３０

１３．

２　创新描述 ................................................................................. ３３０

１３．

３　功能及总体设计 ........................................................................ ３３０

１３．

３．

１　功能介绍 ..................................................................... ３３０

１３．

３．

２　总体设计 ..................................................................... ３３１

１３．

３．

３　模块介绍 ..................................................................... ３３３

１３．

４　产品展示 ................................................................................. ３４７

１３．

５　问题及故障分析 ........................................................................ ３４８

１３．

６　元件清单 ................................................................................. ３４９

第１４章　球形机器人项目设计 ..................................................................... ３５０

１４．

１　项目背景 ................................................................................. ３５０

１４．

２　创新描述 ................................................................................. ３５２

１４．

３　功能及总体设计 ........................................................................ ３５３

１４．

３．

１　功能介绍 ..................................................................... ３５３

１４．

３．

２　总体设计 ..................................................................... ３５３

１４．

３．

３　模块介绍 ..................................................................... ３５６

１４．

４　产品展示 ................................................................................. ３８９

１４．

５　故障及问题分析 ........................................................................ ３９０

１４．

６　元件清单 ................................................................................. ３９２

第１５章　多功能蓝牙小车项目设计 ............................................................... ３９３

１５．

１　项目背景 ................................................................................. ３９３

[]{#index_split_000.html#p11}![index-11_1.png](https://i.imgur.com/rdPCLfx.jpeg){.calibre2}

Ⅷ

１５．

２　创新描述 ................................................................................. ３９３

１５．

３　功能及总体设计 ........................................................................ ３９３

１５．

３．

１　功能介绍 ..................................................................... ３９３

１５．

３．

２　总体设计 ..................................................................... ３９４

１５．

３．

３　模块介绍 ..................................................................... ３９７

１５．

４　产品展示 ................................................................................. ４１１

１５．

５　故障及问题分析 ........................................................................ ４１２

１５．

６　元件清单 ................................................................................. ４１３

参考文献................................................................................................... ４１４

[]{#index_split_000.html#p12}![index-12_1.png](https://i.imgur.com/1JIY2SK.jpeg){.calibre2}

第１章

Arduino设计基础

１．

１　开源硬件概述

电子电路是人类社会发展的重要成果,在早期的硬件设计和实现上都是公开的,包括电

子设备、电器设备、计算机设备以及各种外围设备的设计原理图,大家认为公开是十分正常

的事情,所以,早期公开的设计图并不称为开源.１９６０年左右,很多公司根据自身利益选择

了闭源,由此出现了贸易壁垒、技术壁垒、专利版权等问题,以及不同公司之间的互相起诉现

象.例如,国内外的IT 公司之间由于知识产权而法庭相见的案例屡见不鲜.虽然这种做

法在一定程度上有利于公司自身的利益,但是,不利于小公司或者个体创新者的发展.特别

是在互联网进入 Web２．

０的个性化时代后,更加需要开放、免费和开源的开发系统.

因此,在"大众创业、万众创新"的时代背景下,Web２．０时代的开发者开始思考是否可

以重新对硬件进行开源.电子爱好者、发烧友及广大的创客一直致力于开源的研究,推动开

源的发展.从最初研究很小的东西开始,发展到现在已经有３D 打印机、开源的单片机系统

等.一般认为,开源硬件是指采取与开源软件相同的方式设计的各种电子硬件的总称.也

就是说,开源硬件是考虑对软件以外的领域进行开源,是开源文化的一部分.开源硬件可以

自由传播硬件设计的各种详细信息,如电路图、材料清单和电路板布局数据.通常使用开源

软件来驱动开源的硬件系统.本质上,共享逻辑设计、可编程的逻辑器件重构也是一种开源

硬件,通过硬件描述语言代码实现电路图共享.硬件描述语言也称为硬件描述语言模块或

IPcores,通常用于芯片系统、可编程逻辑阵列,或直接用在专用集成电路中.

众所周知,Android就是开源软件之一.开源硬件和开源软件类似,通过开源软件可以

更好地理解开源硬件,就是在之前已有硬件的基础之上进行二次开发.二者也有差别,体现

在复制成本上,开源软件的成本几乎是零,而开源硬件的复制成本较高.另外,开源硬件延

伸着开源软件代码的定义,软件、电路原理图、材料清单、设计图等都使用开源许可协议,自

由使用分享,完全以开源的方式去授权,避免了以往 DIY 分享的授权问题;同时,开源硬件

把开源 软 件 常 用 的 GPL、CC 等 协 议 规 范 带 到 硬 件 分 享 领 域,为 开 源 硬 件 的 发 展 提 供 了

规范.

[]{#index_split_000.html#p13}![index-13_1.png](https://i.imgur.com/nv4l4M2.jpeg){.calibre2}

![index-13_2.png](https://i.imgur.com/aXfjSFX.jpeg){.calibre2}

![index-13_3.png](https://i.imgur.com/QloqOuV.jpeg){.calibre2}

２

１．

２　Arduino开源硬件

本节主要介绍 Arduino开源硬件的各种开发板和扩展板的使用方法、Arduino开发板

的特性 以 及 Arduino开源硬件的总体情况,以便更好地应用 Arduino开源硬件进行开发

创作.

１．

２．

１　Arduino开发板

Arduino开发板是基于开放原始代码的SimpleI/O 平台,并且使用类似Java、C/C++语

言的开发环境,可以快速使用 Arduino开发语言与 Flash或 Processing软件,完成各种创新

的作品.Arduino开发板可以使用各种电子元件,如各种传感器、显示设备、通信设备、控制

设备或其他可用设备.

Arduino开发板也可以独立使用,成为与其他软件沟通的平台,如 Flash、Processing、

Max/MSP、VVVV 或其他 互 动 软 件.Arduino 的 开 发 板 种 类 很 多,包 括 Arduino UNO、

YUN、DUE、Leonardo、Tre、Zero、Micro、Esplora、MEGA、Mini、NANO、Fio、Pro 以 及

LilyPadArduino.随着开源硬件的发展,将会出现更多的开源产品.下面介绍几种典型的

Arduino开发板.

ArduinoUNO 是 ArduinoUSB 接口系列的常用版本,是 Arduino平台的参考标准模

板,如图１Ｇ１所示.ArduinoUNO 的处理器核心是 ATmega３２８,具有１４个数字输入/输出

引脚(其中６个可作为 PWM 输出)、

６个模拟输入引脚、１个１６MHz晶体振荡器、１个 USB

接口、

１个电源插座、

１个ICSP插头和１个复位按钮.

如图１Ｇ２所示,ArduinoYUN 是一款基于 ATmega３２U４和 AtherosAR９３３１的单片机

开发板.AtherosAR９３３１可以运行基于 Linux和 OpenWRT 的操作系统 Linino.这款单

片机开发板具有内置的 Ethernet、WiFi、

１个 USB接口、

１个 Micro插槽、２０个数字输入/输

出引脚(其中７个可以用于 PWM、

１２个可以用于 ADC)、

１个 MicroUSB、

１个ICSP插头和

３个复位开关.

图１Ｇ１　ArduinoUNO

图１Ｇ２　ArduinoYUN

[]{#index_split_000.html#p14}![index-14_1.png](https://i.imgur.com/MYMI9xp.jpeg){.calibre2}

![index-14_2.png](https://i.imgur.com/FnDJ6Z5.jpeg){.calibre2}

![index-14_3.png](https://i.imgur.com/6y87Ild.jpeg){.calibre2}

３

如图１Ｇ３所示,ArduinoDUE是一块基于 AtmelSAM３X８ECPU 的微控制器板.它是

第一块基于３２位 ARM 核心的 Arduino开发板,有５４个数字输入/输出引脚(其中１２个可

用于 PWM 输 出)、１２ 个 模 拟 输 入 引 脚、４ 个 UART 硬 件 串 口、８４MHz的 时 钟 频 率、１ 个

USBOTG 接口、

２个 DAC(模数转换)、

２个 TWI、１个电源插座、１个 SPI接口、１个JTAG

接口、

１个复位按键和１个擦写按键.

如图１Ｇ４所示,ArduinoMEGA２５６０开发板也是采用 USB接口的核心电路板,它最大

的特点就是具有多达５４个数字输入/输出引脚,特别适合需要大量输入/输出引脚的设计.

MEGA２５６０开发板的处理器核心是 ATmega２５６０,具有５４个数字输入/输出引脚(其中１６

个可作为 PWM 输 出)、１６ 个 模 拟 输 入、４ 个 UART 接 口、１ 个 １６MHz晶 体 振 荡 器、１ 个

USB接口、

１个电源插座、

１个ICSP插头和１个复位按钮.ArduinoMEGA２５６０开发板也

能兼容为 ArduinoUNO 设计的扩展板.目前,ArduinoMEGA２５６０开发板已经发布到第

３版.与前两版相比,第３版有以下新的特点:

(１)在 AREF处增加了两个引脚SDA 和 SCL,支持I２C接口;增加IOREF和１个预

留引脚,以便将来扩展板能够兼容５V 和３．

３V 核心板;改进了复位电路设计;USB接口芯

片由 ATmega１６U２替代 ATmega８U２.

(２)第３版可以通过３种方式供电:外部直流电源通过电源插座供电;电池连接电源

连接器的 GND 和 VIN 引脚供电;USB接口直接供电.而且,它能自动选择供电方式.

图１Ｇ３　ArduinoDUE

图１Ｇ４　ArduinoMEGA２５６０

电源引脚说明如下:

VIN:当外部直流电源接入电源插座时,可以通过 VIN 向外部供电,也可以通过此引

脚向 MEGA２５６０直接供电;VIN 供电时将忽略从 USB或者其他引脚接入的电源.

５V:通过稳压器或 USB的５V 电压,为 ArduinoMEGA２５６０开发板上的５V 芯片供电.

３．

３V:通过稳压器产生的３．

３V 电压,最大驱动电流为５０mA.

GND:接地引脚.

如图１Ｇ５所示,ArduinoLeonardo是一款基于 ATmega３２U４的微控制器板.它有２０

个数字输入/输出引脚(其中 ７个可用作 PWM 输出、１２个可用作模拟输入)、１个１６MHz 晶体振荡器、

１个 MicroUSB接口、

１个电源插座、

１个ICSP头和１个复位按钮.它具有支

持微控制器所需的一切功能,只需通过 USB电缆将其连至计算机,或者通过电源适配器、电

[]{#index_split_000.html#p15}![index-15_1.png](https://i.imgur.com/SQYZOtG.jpeg){.calibre2}

![index-15_2.png](https://i.imgur.com/GsYnNLE.jpeg){.calibre2}

![index-15_3.png](https://i.imgur.com/lZRhHzB.jpeg){.calibre2}

![index-15_4.png](https://i.imgur.com/eSPaF4w.jpeg){.calibre2}

４

池为其供电即可使用.

ArduinoLeonardo与先前的所有电路板都不同,ATmega３２U４具有内置式 USB通信, 从而无须二级处理器.这样,除了虚拟(CDC)串行/通信端口,ArduinoLeonardo还可以充

当计算机的鼠标和键盘,它对电路板的性能也会产生影响.

如图１Ｇ６所示,ArduinoEthernet是一款基于 ATmega３２８的微控制器板.它有１４个

数字输入/输出引脚、

６个模拟输入、１个１６MHz晶体振荡器、１个 RJ４５连接、１个电源插

座、

１个ICSP头和１个复位按钮.引脚１０、１１、１２和１３只能用于连接以太网模块,不能作

为他用.可用引脚只有９个,其中４个可用作 PWM 输出.

图１Ｇ５　ArduinoLeonardo

图１Ｇ６　ArduinoEthernet

ArduinoEthernet没有板载 USB转串口驱动器芯片,但是有１个 Wiznet以太网接口, 该接口与以太网盾上的相同.板载 microSD 读卡器可用于存储文件,能够通过 SD 库进行

访问.引脚１０留作 Wiznet接口,SD 卡的SS在引脚４上.６引脚串行编程头与 USB串口

适配器兼容,与 FTDIUSB电缆或 SparkFun和 AdafruitFTDI式基本 USB转串口分线板

也兼容.它支持自动复位,从而无须按下电路板上的复位按钮即可上传程序代码.当插入

USB转串口适配器时,ArduinoEthernet由适配器供电.

ArduinoRobot是一款有轮子的 Arduino开发板,如图１Ｇ７所示.ArduinoRobot有控制板

和直流电机板,每个电路板上有１个处理器,共２个处理

器.直流电机板控制电机,控制板读取传感器的数据并

决定如 何 操 作.每 个 电 路 板 都 是 完 整 的 Arduino开发

板,用 ArduinoIDE进行编程.直流电机板和控制板都

是基 于 ATmega３２U４ 的微控制器板.ArduinoRobot

图１Ｇ７　ArduinoRobot

将它的一些引脚映射到板载的传感器和制动器上.

ArduinoRobot编 程 的 步 骤 与 ArduinoLeonardo 类似,

２个处理器都有内置式 USB通信,无须二级处理器,可以充当计算机的虚拟(CDC)串

行/通信端口.ArduinoRobot有一系列预焊接连接器,所有连接器都标注在电路板上,通

过 ArduinoRobot库文件映射到指定的引脚上,从而可使用标准 Arduino系统函数.在５V

电压下,每个引脚都可以提供或接收最高４０mA 的电流.

[]{#index_split_000.html#p16}![index-16_1.png](https://i.imgur.com/dzon4Pr.jpeg){.calibre2}

![index-16_2.png](https://i.imgur.com/VGJOhUW.jpeg){.calibre2}

![index-16_3.png](https://i.imgur.com/4aCHe2X.jpeg){.calibre2}

![index-16_4.png](https://i.imgur.com/DYL1SzL.jpeg){.calibre2}

５

如图１Ｇ８所示,ArduinoNANO 是一款小巧、全面、

基于 ATmega３２８ 的 开 发 板,与 ArduinoDuemilanove 的功 能 类 似,但 封 装 不 同,没 有 DC 电 源 插 座 且 采 用

MiniＧBUSB电缆.ArduinoNANO 上的１４个数字引

脚都可用作输入或输出,利用 pinMode()、digitalWrite() 图１Ｇ８　ArduinoNANO

和 digitalRead()函 数 可 以 对 它 们 操 作. 工 作 电 压 为

５V,每个引脚都可以提供或接收最高４０mA 的电流,都有１个２０\~５０kΩ 的内部上拉电阻器

(默认情况下断开).ArduinoNANO 有８个模拟输入,每个模拟输入都提供１０位的分辨率

(即１０２４个不同的数值).默认情况下,它们的电压为０\~５V,可以利用analogReference() 函数改变其电压范围的上限值.模拟引脚６和７不能用作数字引脚.

１．

２．

２　Arduino扩展板

在 Arduino开源硬件系列中,除了主要开发板之外,还有与之配合使用的各种扩展板, 可以插到开发板上增加额外的功能.选择适合的扩展板,可以增强系统开发的功能.常见

的扩展板有 ArduinoEthernetShield、ArduinoGSMShield、ArduinoMotorShield、Arduino ９AxesMotionShield等.

ArduinoEthernetShield(以太网盾)如图１Ｇ９所示,有１个标准的有线 RJ４５连接,具有

集成式线路变压器和以太网供电功能,可将 Arduino开发板连接到互联网.它基于 Wiznet W５５００以太网芯片,提供网络(

IP)堆栈,支持 TCP和 UDP协议,可以同时支持８个套接字

连接,使用以太网库写入程序代码.

以太网盾板利用贯穿盾板的长绕线排与 Arduino开发板连接,保持引脚布局完整无缺, 以便其 他 盾 板 可 以 堆 叠 在 其 上. 它 有 １ 个 板 载 microＧSD 卡 槽,可 用 于 存 储 文 件,且 与

ArduinoUNO 和 MEGA 兼容,可通过SD 库访问板载 microＧSD 读卡器.以太网盾板带有

１个供电(PoE)模块,可从传统的５类电缆获取电力.

ArduinoGSM Shield如图１Ｇ１０所示,为了连接蜂窝网络,电路板需要一张由网络运营

商提供的 SIM 卡.它通过移动通信网将 Arduino开发板连接到互联网,可拨打/接听语音

电话和发送/接收 SMS信息.

图１Ｇ９　ArduinoEthernetShield

图１Ｇ１０　ArduinoGSM Shield

[]{#index_split_000.html#p17}![index-17_1.png](https://i.imgur.com/DbinCog.jpeg){.calibre2}

![index-17_2.png](https://i.imgur.com/bQzwokr.jpeg){.calibre2}

![index-17_3.png](https://i.imgur.com/7IeZGba.jpeg){.calibre2}

６

ArduinoGSM Shield采用 Quectel的无线调制解调器 M１０,利用 AT 命令与电路板通

信.ArduinoGSM Shield利用数字引脚２、３与 M１０进行软件串行通信,引脚２连接 M１０

的 TX 引脚,引脚３连接 RX 引脚,调制解调器的 PWRKEY 引脚连接引脚７.

M１０是 一 款 四 频 GSM/GPRS 调 制 解 调 器,其 工 作 频 率 分 别 为 GSM８５０MHz、

GSM９００MHz、DCS１８００MHz 和 PCS１９００MHz. 它 通 过 GPRS 连 接 支 持 TCP/UDP 和

HTTP.其中 GPRS数据下行链路和上行链路的最大传输速率为８５．

６Kbps.

ArduinoMotorShield如图１Ｇ１１所示,用于驱动电感负载(如继电器、螺线管、DC 和步

进 电机)的双全桥驱动器 L２９８.利用 ArduinoMotorShield可以驱动２个 DC电机,独立控

制每个直流电机的速度和方向.因此,它有２条独立的通道,即 A 和 B,每条通道使用４个

引脚来驱动或感应电机,所以 ArduinoMotorShield上使用的引脚共８个.它不仅可以单

独驱动２个 DC电机,也可以将它们合并起来驱动１个双极步进电机.

Arduino９AxesMotionShield如图１Ｇ１２所示,它采用德国博世传感器技术有限公司

推出的 BNO０５５绝对方向传感器.这是一个使用系统级封装,集成三轴１４位加速计、三轴

１６位陀螺仪、三轴地磁传感器,并运行 BSX３．

０FusionLib软件的３２位微控制器.BNO０５５

在三个垂直的轴上具有三维加速度、角速度和磁场强度数据.

图１Ｇ１１　ArduinoMotorShield

图１Ｇ１２　Arduino９AxesMotionShield

另外,它还提供传感器融合信号,如四元数、欧拉角、旋转矢量、线性加速度、重力矢量.

结合智能中断引擎,它可以基于慢动作或误动作识别、任何动作(斜率)检测、高 g检测等项

触发中断.

Arduino９AxesMotionShield兼容 ArduinoUNO、YUN、Leonardo、Ethernet、MEGA 和 DUE电路板.在使用 Arduino９AxesMotionShield时,要根据使用的电路板将中断桥

和重置桥焊接在正确的位置.

１．

３　Arduino软件开发平台

本节主要介绍 Arduino开发环境的特点及使用方法,包括 Arduino开发环境的安装,以

及简单的硬件系统与软件系统调试方法.

[]{#index_split_000.html#p18}![index-18_1.png](https://i.imgur.com/H3Vb6fQ.jpeg){.calibre2}

![index-18_2.png](https://i.imgur.com/xzhWx1O.jpeg){.calibre2}

![index-18_3.png](https://i.imgur.com/6QDY3Fb.jpeg){.calibre2}

７

１．

３．

１　Arduino平台特点

作为目前最流行的开源硬件开发平台,Arduino平台具有非常多的优点,正是这些优点

使得 Arduino平台得以广泛地应用,包括:

(１)开放源代码的电路图设计和程序开发界面,可免费下载,也可依需求自己修改; Arduino可使用ICSP线上烧录器,将 Bootloader烧入新的IC芯片;可依据官方电路图,简

化 Arduino模组,完成独立运作的微处理控制.

(２)可以非常简便地与传感器或各式各样的电子元件连接(如红外线、超声波、热敏电

阻、光敏电 阻、伺 服 电 机 等);支 持 多 样 的 互 动 程 序,如 Flash、Max/Msp、VVVV、PD、C、

Processing等;使用低价格的微处理控制器;USB接口无须外接电源;可提供 DC９V 电源

输入以及多样化的 Arduino扩展模块.

(３)在应用方面,可通过各种各样的传感器来感知环境,并通过控制灯光、电机和其他

装置来反馈并影响环境;可以方便地 连 接 以 太 网 扩 展 模 块 进 行 网 络 传 输,使 用 蓝 牙 传 输、

WiFi传输、无线摄像头控制等多种应用.

１．

３．

２　ArduinoIDE的安装

ArduinoIDE是 Arduino平台的开放源代码的集成开发环境.它的界面友好,语法简

单且方便下载程序,这使得 Arduino平台的程序开发变得非常便捷.作为一款开放源代码

的软件,ArduinoIDE 也 是 由 Java、Processing、AVRＧGCC 等 开 放 源 代 码 的 软 件 写 成 的.

ArduinoIDE的另一个特点是跨平台的兼容性,适用于 Windows、MaxOSX 以及 Linux.

２０１１年１１月３０日,官方正式发布了 Arduino１．

０版本,可以下载不同操作系统的压缩包,

也可以在 GitHub上下载源代码重新编译自己的 ArduinoIDE.安装过程如下: (１)从官网下载最新版本 ArduinoIDE,下载界面如图１Ｇ１３所示.在下载界面选择适

合自己计算机操作系统的安装包.这里介绍在６４位 Windows７系统中的安装过程.

(２)双击EXE文件选择安装,弹出如图１Ｇ１４所示的界面.单击"是"按钮,弹出如图１Ｇ１５

所示的界面.

图１Ｇ１３　ArduinoIDE下载界面

图１Ｇ１４　ArduinoIDE安装界面

[]{#index_split_000.html#p19}![index-19_1.png](https://i.imgur.com/QFZzDXP.jpeg){.calibre2}

![index-19_2.png](https://i.imgur.com/oonWkYc.jpeg){.calibre2}

![index-19_3.png](https://i.imgur.com/Rn8tQW0.jpeg){.calibre2}

![index-19_4.png](https://i.imgur.com/w7BUOKE.jpeg){.calibre2}

![index-19_5.png](https://i.imgur.com/7niPZBo.jpeg){.calibre2}

![index-19_6.png](https://i.imgur.com/rMM5OfU.jpeg){.calibre2}

８

(３)单击IAgree按钮同意协议,弹出如图１Ｇ１６所示的界面.

(４)选择需要安装的组件,单击 Next按钮,弹出如图１Ｇ１７所示的界面.

图１Ｇ１５　ArduinoIDE协议界面

图１Ｇ１６　ArduinoIDE选择安装组件

(５)选择安装位置,单击Install按钮,弹出如图１Ｇ１８所示的安装界面.

图１Ｇ１７　ArduinoIDE选择安装位置

图１Ｇ１８　ArduinoIDE安装过程

(６)安装 USB驱动,如图１Ｇ１９所示.

图１Ｇ１９　ArduinoIDE安装 USB驱动

[]{#index_split_000.html#p20}![index-20_1.png](https://i.imgur.com/EwAVnH1.jpeg){.calibre2}

![index-20_2.png](https://i.imgur.com/62NyAuY.jpeg){.calibre2}

![index-20_3.png](https://i.imgur.com/oaY8JBx.jpeg){.calibre2}

９

(７)安装完成,如图１Ｇ２０所示.

图１Ｇ２０　ArduinoIDE安装完成

(８)进入 ArduinoIDE开发界面,如图１Ｇ２１所示.

图１Ｇ２１　ArduinoIDE开发界面

[]{#index_split_000.html#p21}![index-21_1.png](https://i.imgur.com/dGRIVi0.jpeg){.calibre2}

![index-21_2.png](https://i.imgur.com/ds1igT1.jpeg){.calibre2}

１０

１．

３．

３　ArduinoIDE的使用

首次使用 ArduinoIDE时,需要将 Arduino开发板通过 USB 线连接到计算机,计算机

会为 Arduino开发板安装驱动程序,并分配相应的 COM 端口,如 COM１、COM２等.不同

的计算机和系统分配的 COM 端口是不一样的,所以,安装完毕要在计算机的硬件管理中查

看 Arduino开发板被分配到了哪个 COM 端口,这个端口就是计算机与 Arduino开发板的

通信端口.

Arduino开发板的驱动安装完毕,需要在 ArduinoIDE 中设置相应的端口和开发板类

型.方法如下:在 Arduino集成开发环境启动后,在菜单栏中选择"工具"→"端口命令",进

行端口设置,设置为计算机硬件管理中分配的端口;然后,在菜单栏中选择"工具"→"开发

板"命令,选择 Arduino开发板的类型,如 ArduinoUNO、DUE、YUN 等前面介绍过的开发

板.这样,计算机就可以与开发板进行通信.工具栏显示的功能如图１Ｇ２２所示.

图１Ｇ２２　ArduinoIDE的工具栏功能

在 ArduinoIDE中带有很多种示例,包括基本的、数字的、模拟的、控制的、通信的、传感

器的、字符串的、存储卡的、音频的、网络的示例等.下面介绍一个最简单、最具有代表性的

例子---------Blink,以便于读者快速熟悉 ArduinoIDE,进而开发出新的产品.

在菜单栏中选择"文件"→"示例"→０１Basic→Blink命令,这时在主编辑窗口会出现可

以编辑的程序.这个 Blink范例程序的功能是控制 LED 的亮灭.在 ArduinoIDE 编译环

境中,是以 C/C++ 的风格来编写的.程序的前几行是注释行,介绍程序的作用及相关的声明

等;然后是变量的定义;最后是 Arduino开发程序的两个函数,即voidsetup()和voidloop().

voidsetup()中的代码会在导通电源时执行一次,voidloop()中的代码会不断重复地执行.

由于在 ArduinoUNO 开发板的第１３引脚上有 LED,所以定义整型变量 LED＝１３,用于函

[]{#index_split_000.html#p22}![index-22_1.png](https://i.imgur.com/SgnHwCv.jpeg){.calibre2}

１１

数的 控 制.另 外,程 序 中 用 了 一 些 函 数,pinMode()是设置引脚的作用为输入还是输 出; delay()是设置延迟的时间,单位为毫秒;digitalWrite()是向 LED 变量写入相关的值,使得

第１３引脚 LED 的电平发生变化,即 HIGH 或者 LOW,这样 LED 就会根据延迟的时间交

替地亮灭.这些函数将在１．

４节介绍.

完成程序编辑之后,在工具栏中找到存盘按钮,将程序进行存盘.然后,在工具栏中找

到上传按钮,该按钮将被编辑后的程序上传到 Arduino开发板中,使得开发板按照修改后的

程序运行.同时,还可以单击工具栏中的串口监视器,观察串口数据的传输情况.它是非常

直观高效的调试工具.

主编辑窗口如下:

∗

Blink例程 重复开关LED各１s敭

∗

多数Arduino开发板的第１３引脚有LED

定义引脚名称

intled ＝ １３

setup 程序运行一次

voidsetup

初始化数字引脚为输出

pinMode led OUTPUT

loop 程序不断重复运行

voidloop

digitalWrite led HIGH 　　　　　　　　　 开LED 高电平

delay １０００

等待１s

digitalWrite led LOW

关LED 低电平

delay １０００

等待１s

当然,目前还有其他支持 Arduino开源硬件的开发环境,如 SonxunStudio,它是由松迅

科技开发的集成开发环境,目前只支持 Windows系统的 Arduino系统开发,包括 Windows XP以及 Windows７,使用方法与 ArduinoIDE大同小异.由于篇幅的关系,这里不再赘述.

１．

４　Arduino编程语言

Arduino编程语言是建立在 C/C++ 语言基础上的,即以 C/C++ 语言为基础,把 AVR 单

片机(微控制器)相关的一些寄存器参数设置等进行函数化,以利于开发者更加快速地使用.

其主要使用的函数包括数字I/O 操作函数、模拟I/O 操作函数、高级I/O 操作函数、时间函

数、中断函数、通信函数和数学库等.

[]{#index_split_000.html#p23}![index-23_1.png](https://i.imgur.com/OPtbEec.jpeg){.calibre2}

１２

１．

４．

１　Arduino编程基础

关键字:if、

if􀆺else、

for、

switch、

case、while、do􀆺while、break、

continue、

return、goto.

语法符号:每条语句以";"结尾,每段程序以"{}"括起来.

数据类型:boolean、char、

int、unsignedint、long、unsignedlong、float、double、string、

array、void.

常量:HIGH 或者 LOW,表示数字I/O 引脚的电平,HIGH 表示高电平(１),LOW 表

示低电平(

０);INPUT 或者 OUTPUT,表示数字I/O 引脚的方向,

INPUT 表示输入(高阻

态),OUTPUT 表示输出(AVR 能提供５V 电压,

４０mA 电流);TRUE或者FALSE,TRUE

表示真(

１),FALSE表示假(０).

程序结构:主要包括两部分,即 voidsetup()和voidloop().其中,前者是声明变量及

引脚名称(如intval;

intledPin＝１３),在程序开始时使用,初始化变量和引脚模式,调用库

函数等\[如pinMode(

ledPin,OUTPUT)\];后者用在setup()函数之后,不断地循环执行,是

Arduino的主体.

１．

４．

２　数字I/O 引脚的操作函数

１．pinMode(pin,mode)

pinMode函数用于配置引脚以及设置输出或输入模式,是一个无返回值函数.该函数

有两个参数:pin和 mode.pin参数表示要配置的引脚,mode参数表示设置该引脚的模式

为INPUT(输入)或 OUTPUT(输出).

INPUT 用于读取信号,OUTPUT 用于输出控制信号.pin的范围是数字引脚０\~１３, 也可以把模拟引脚(A０\~A５)作为数字引脚使用,此时编号为１４的引脚对应模拟引脚０,编

号为１９的引脚对应模拟引脚５.该函数一般会放在setup里,先设置再使用.

２．digitalWrite(pin,value)

该函数的作用是设置引脚的输出电压为高电平或低电平,也是一个无返回值的函数.

pin参数表示所要设置的引脚,value参数表示输出的电压为 HIGH(高电平)或 LOW

(低电平).

注意:使用前必须先用pinMode设置.

３．digitalRead(pin)

该函数在引脚设置为输入的 情 况 下,可以获取引脚的电压情况:HIGH(高电平)或者

LOW(低电平).

数字I/O 引脚操作函数使用例程如下:

intbutton＝９ 　　　　　　　　　 设置９引脚为按钮输入引脚

intLED＝１３

设置１３引脚为LED输出引脚 内部连接开发板上的LED

voidsetup

[]{#index_split_000.html#p24}![index-24_1.png](https://i.imgur.com/GIIloxw.jpeg){.calibre2}

![index-24_2.png](https://i.imgur.com/bCzjksl.jpeg){.calibre2}

１３

pinMode button

INPUT

设置为输入

pinMode LED

OUTPUT

设置为输出

voidloop

if digitalRead button ＝＝LOW 如果读取高电平

digitalWrite LED HIGH １３引脚输出高电平

else

digitalWrite LED LOW 否则输出低电平

１．

４．

３　模拟I/O 引脚的操作函数

１．analogReference(

type)

该函数用于配置模拟引脚的参考电压.它有３种类型:DEFAULT 是默认模式,参考

电压是５V;INTERNAL是低电压模式,使用片内基准电压源２．

５６V;EXTERNAL是扩展模

式,通过 AREF引脚获取参考电压.

注意:若不使用该函数,默认是参考电压５V.若使用 AREF 作为参考电压,需接一个

５kΩ 的上拉电阻.

２．analogRead(pin)

该函数用于读取引脚的模拟量电压值,每读取一次需要花１００μs的时间.参数pin表

示所要获取模拟量电压值的引脚,返回为int型.它的精度为１０位,返回值为０\~１０２３.

注意:函数参数pin的取值范围是０\~５,对应开发板的模拟口 A０\~A５.

３．analogWrite(pin,value)

该函数是通过 PWM(PulseＧWidth Modulation,脉冲宽度调制)的方式在引脚上输出一

个模拟量.图１Ｇ２３所示为 PWM 输出的一般形式,也就是在一个脉冲的周期内高电平所占

的比例.它主要应用于 LED 亮度控制、直流电机转速控制等方面.

图１Ｇ２３　占空比的定义

注:PWM 波形的特点是波形频率恒定,占空比 D 可以改变.

Arduino开发板中的 PWM 的频率大约为４９０Hz,ArduinoUNO 开发板支持以下数字

引脚(不是模拟输入引脚)作为 PWM 模拟输出:３、５、６、９、１０、１１.开发板带 PWM 输出的

都有"\~"号.

注意:PWM 输出位数为８位,即０\~２５５.

模拟I/O 引脚的操作函数使用例程如下:

intsensor＝A０

A０引脚读取电位器

intLED＝１１

１１引脚输出LED电平

[]{#index_split_000.html#p25}![index-25_1.png](https://i.imgur.com/nIZfvw8.jpeg){.calibre2}

１４

voidsetup

Serial敭

begin ９６００

voidloop

intv

v＝analogRead sensor

Serial敭println v DEC 　　 可以观察读取的模拟量

analogWrite LED v ４

读回的值范围是０\~１０２３ 结果除以４才能得到０\~２５５的值

１．

４．

４　高级I/O 引脚的操作函数

PulseIn(pin,state,

timeout)函数用于读取引脚脉冲的时间长度,脉冲可以是 HIGH 或

者 LOW.如果是 HIGH,该函数将先等引脚变为高电平,然后开始计时,直到变为低电平

停止计时.返回脉冲持续的时间,单位为毫秒,如果超时没有读到时间,则返回０.

例程说明:做一个按钮脉冲计时器,测量按钮的持续时间,看谁的反应最快,即谁按按

钮时间最短.按钮接在３引脚.程序如下:

intbutton＝３

intcount

voidsetup

pinMode button

INPUT

voidloop

count＝pulseIn button

HIGH

if count

＝０

Serial敭println count DEC

count＝０

１．

４．

５　时间函数

１．delay()

该函数是延时函数,参数是延时的时长,单位是 ms(毫秒).应用延时函数的典型例程

是跑马灯的应用,使用 Arduino开发板控制４个 LED 依次点亮.程序如下: voidsetup

pinMode ６

OUTPUT

定义为输出

pinMode ７

OUTPUT

pinMode ８

OUTPUT

pinMode ９

OUTPUT

[]{#index_split_000.html#p26}![index-26_1.png](https://i.imgur.com/GPg9KRq.jpeg){.calibre2}

![index-26_2.png](https://i.imgur.com/x8Dneko.jpeg){.calibre2}

![index-26_3.png](https://i.imgur.com/0hOBT2G.jpeg){.calibre2}

１５

voidloop

inti

for i＝６

i ＝９

i++

依次循环４盏灯

digitalWrite i

HIGH

点亮LED

delay １０００

持续１s

digitalWrite i LOW 熄灭LED

delay １０００

持续１s

２．delayMicroseconds()

delayMicroseconds()也是延时函数,不过单位是μs(微秒),１ms＝１０００μs.该函数可以

产生更短的延时.

３．mi

l

l

is()

millis()为计时函数,应用该函数可以获取单片机通电到现在运行的时间长度,单位是

ms.系统最长的记录时间为９h２２min,超出则从０开始.返回值是unsignedlong型.

该函数适合作为定时器使用,不影响单片机的其他工作(而使用 delay函数期间无法进

行其他工作).计时时间函数使用示例(延时１０s后自动点亮 LED)程序如下: intLED＝１３

unsignedlongi

j

voidsetup

pinMode LED

OUTPUT

i＝millis

读入初始值

voidloop

j＝millis

不断读入当前时间值

if j－i １００００

如果延时超过１０s 点亮LED

digitalWrite LED HIGH

elsedigitalWrite LED LOW

４．micros()

micros()也是计时函数,该函数返回开机到现在运行的时间长度,单位为μs.返回值是

unsignedlong型,７０min溢出.程序如下:

unsignedlongtime

voidsetup

[]{#index_split_000.html#p27}![index-27_1.png](https://i.imgur.com/Ordrxf7.jpeg){.calibre2}

![index-27_2.png](https://i.imgur.com/jmxqsk1.jpeg){.calibre2}

１６

Serial敭

begin ９６００

voidloop

Serial敭

print ＂Time ＂

time ＝ micros

读取当前的微秒值

Serial敭

println time

打印开机到目前运行的微秒值

delay １０００

延时１s

以下例程为跑马灯的另一种实现方式:

intLED＝１３

unsignedlongi

j

voidsetup

pinMode LED

OUTPUT

i＝micros

读入初始值

voidloop

j＝micros

不断读入当前时间值

if j－i １００００００

如果延时超过１０s 点亮LED

digitalWrite LED HIGH

elsedigitalWrite LED LOW

１．

４．

６　中断函数

在人们的日常生活中,中断非常常见.

如图１Ｇ２４所示,你在看书,电话铃响,于是你在书上做上记号,去接电话,与对方通话; 门铃响了,有人敲门,你让打电话的对方稍等一下,然后去开门,并在门旁与来访者交谈,谈

话结束,关好门;回到电话机旁,继续通话,接完电话后再回来从做记号的地方接着看书.

同样的道理,在单片机中也存在中断概念,如图１Ｇ２５所示.在计算机或者单片机中,中

断是由于某个随机事件的发生,计算机暂停主程序的运行,转去执行另一程序(随机事件), 处理完毕又自动返回主程序继续运行的过程.也就是说,高优先级的任务中断了低优先级

的任务.在计算机中中断包括如下几部分:

① 中断源---------引起中断的原因,或能发生中断申请的来源.

② 主程序---------计算机现行运行的程序.

③ 中断服务子程序---------处理突发事件的程序.

[]{#index_split_000.html#p28}![index-28_1.png](https://i.imgur.com/w3GXBuc.jpeg){.calibre2}

![index-28_2.png](https://i.imgur.com/ASrtTk2.jpeg){.calibre2}

![index-28_3.png](https://i.imgur.com/2OcOX9N.jpeg){.calibre2}

１７

图１Ｇ２４　中断的概念

图１Ｇ２５　单片机中的中断

１．attachinterrupt(

interrupt,

funct

ion,mode)

该函数用于设置中断,函数有 ３个参数,分别表示中断源、中断处理函数和触发模式.

中断源可选０或者１,对应２或者３数字引脚.中断处理函数是一段子程序,当中断发生时

执行该子程序部 分. 触 发 模 式 有 ４ 种 类 型:LOW(低 电 平 触 发)、CHANGE(变 化 时 触

发)、RISING(低电平变为高电平触发)、FALLING(高 电 平 变 为 低 电 平 触 发).例 程 功 能

如下:

数字引脚２接按钮开关,引脚４接 LED１(红色),引脚５接 LED２(绿色).在例程中, LED３为开发板上的 LED,每秒闪烁一次.使用中断０来控制 LED１,中断１来控制 LED２.

按下按钮,立即响应中断,由于中断响应速度快,LED３不受影响,继续闪烁.使用不同的４

个参数,例程１试验 LOW 和 CHANGE参数,例程２试验 RISING 和 FALLING 参数.

例程１:

volatileintstate１＝LOW state２＝LOW

intLED１＝４

intLED２＝５

intLED３＝１３ 　　　　　　　　　　　　　　　 使用开发板上的LED

voidsetup

pinMode LED１ OUTPUT

pinMode LED２ OUTPUT

pinMode LED３ OUTPUT

attachInterrupt ０ LED１_Change LOW

低电平触发

attachInterrupt １ LED２_Change CHANGE

任意电平变化触发

voidloop

digitalWrite LED３ HIGH

delay ５００

[]{#index_split_000.html#p29}![index-29_1.png](https://i.imgur.com/19jo2L9.jpeg){.calibre2}

１８

digitalWrite LED３ LOW

delay ５００

voidLED１_Change

state１＝ state１

digitalWrite LED１ state１

delay １００

voidLED２_Change

state２＝ state２

digitalWrite LED２ state２

delay １００

例程２:

volatileintstate１＝LOW state２＝LOW

intLED１＝４

intLED２＝５

intLED３＝１３

voidsetup

pinMode LED１ OUTPUT

pinMode LED２ OUTPUT

pinMode LED３ OUTPUT

attachInterrupt ０ LED１_Change RISING 电平上升沿触发

attachInterrupt １ LED２_Change FALLING 电平下降沿触发

voidloop

digitalWrite LED３ HIGH

delay ５００

digitalWrite LED３ LOW

delay ５００

voidLED１_Change

state１＝ state１

digitalWrite LED１ state１

delay １００

voidLED２_Change

state２＝ state２

digitalWrite LED２ state２

[]{#index_split_000.html#p30}![index-30_1.png](https://i.imgur.com/vsgMn9W.jpeg){.calibre2}

![index-30_2.png](https://i.imgur.com/RhBbQY7.jpeg){.calibre2}

１９

delay １００

２．detachInterrupt(

interrupt)

该函数用于取消中断,参数interrupt表示所要取消的中断源.

１．

４．

７　串口通信函数

串行通信接口(

serialinterface)使数据一位一位地顺序传送,其特点是通信线路简单, 只要一对传输线就可以实现双向通信,如图１Ｇ２６所示.

串行通信接口出现在１９８０年前后,数据传输速率是１１５\~

２３０Kbps.串行通信接口出现的初期是为了实现计算机外设

的通信,初期串口一般用来连接鼠标和外置 Modem、老式摄像

头和写字板等设备.

由于串行 通 信 接 口 (COM)不支持热插 拔 及 传 输 速 率 较

图１Ｇ２６　串行通信接口

低,因此目前部分新主板和大部分便携计算机已开始取消该

接口,串口多用于工控和测量设备以及部分通信设备中,包括各种传感器采集装置、GPS信

号采集装置、多个单片机通信系统,门禁刷卡系统的数据传输、机械手控制和操纵面板控制

电机等,特别是广泛应用于低速数据传输的工程应用,主要函数如下:

１．Ser

ial．

begin()

该函数用于设置串口的波特率,即数据的传输速率,指每秒传输的符号个数.一般的波

特率有９６００、

１９２００、

５７６００、

１１５２００等.例如:

Serial敭begin ５７６００

２．Ser

ial．

avai

lable()

该函数用来判断串口是否收到数据,函数的返回值为int型,不带参数.

３．Ser

ial．

read()

该函数不带参数,只将串口数据读入.返回值为串口数据,

int型.

４．Ser

ial．

pr

int()

该函数向串口发送数据.可以发送变量,也可以发送字符串.例如:

Serial敭print ＂todayisgood＂

Serial敭

print x

DEC 　　　

以十进制发送x

Serial敭

print x

HEX 　　　

以十六进制发送变量x

５．Ser

ial．

pr

int

ln()

该函数与 Serial．print()类似,只是多了换行功能.

串口通信函数使用例程:

intx＝０

voidsetup

[]{#index_split_000.html#p31}![index-31_1.png](https://i.imgur.com/iBlKXX7.jpeg){.calibre2}

２０

Serial敭

begin ９６００

波特率９６００

voidloop

if Serial敭available

x＝Serial敭read

Serial敭print ＂Ihavereceived

＂

Serial敭println x DEC

输出并换行

delay ２００

１．

４．

８　Arduino的库文件

与 C语言和 C++ 一样,Arduino平台也有相关的库文件提供给开发者使用.这些库文

件的使用,与 C语言的头文件使用类似,需要＃include语句,可将库文件加入 Arduino的

IDE编辑环境中,如＃include"Arduino．h"语句.

在 Arduino 开 发 中,主 要 库 文 件 的 类 别 如 下:数 学 库 文 件 主 要 包 括 数 学 计 算; EEPROM 库 文 件 用 于 向 EEPROM 中 读 写 数 据;Ethernet库 文 件 用 于 以 太 网 的 通 信; LiquidCrystal库文件用于液晶屏幕的显示操作;Firmata库文件实现 Arduino与 PC 串口

之间的编程协议;SD 库文件用于读写SD 卡;Servo库文件用于舵机的控制;Stepper库文

件用于步进电机控制;WiFi库文件用于 WiFi的控制和使用等.诸如此类的库文件非常

多,还包括一些 Arduino爱好者自己开发的库文件.例如下列数学库文件中的函数: min(x,y);　　　　　//求两者最小值

max(x,y);

//求两者最大值

abs(x);

//求绝对值

sin(

rad);

//求正弦值

cos(

rad);

//求余弦值

tan(

rad);

//求正切值

random(small,big); //求两者之间的随机数

举例如下:

数学库文件random(

small,big),返回值为long

longx

x＝random ０

１００

可以生成０\~１００的整数

１．

５　Arduino硬件设计平台

电子设计自动化(ElectronicDesignAutomation,EDA)是２０世纪９０年代初,从计算机

辅助设计(CAD)、计 算 机 辅 助 制 造 (CAM)、计 算 机 辅 助 测 试 (CAT)和 计 算 机 辅 助 工 程

[]{#index_split_000.html#p32}![index-32_1.png](https://i.imgur.com/Wn7UsJS.jpeg){.calibre2}

![index-32_2.png](https://i.imgur.com/sYW7pjt.jpeg){.calibre2}

２１

(CAE)的概念上发展而来的.EDA 设计工具的出现使得电路设计的效率和可操作性都得

到了大幅度的提升.本书针对 Arduino平台的学习,主要介绍和使用 Fritzing工具,并配以

详细的示例操作说明.当然,很多软件也支持 Arduino平台的开发,在此不再一一罗列.

Fritzing是一款支持多国语言的电路设计软件,可以同时提供面包板、原理图、印制电

路板(PCB)图三种视图设计,设计者可以采用任意一种视图进行电路设计,软件都会自动同

步生成其他两种视图.此外,

Fritzing软件还能用来生成制板厂生产所需用的greber文件、

PDF、图片和 CAD 格式文件,这些都极大地普及和推广了 Fritzing的使用.下面将具体对

软件的使用说明进行介绍,有关 Fritzing的安装和启动请参考相关的书籍或者网络.

１．

５．

１　Fritzing软件简介

１．主界面

总体来说,Fritzing软件的主界面由两部分构成,如图１Ｇ２７所示.一部分是图中左边框

内的项目视图部分,用于显示设计者开 发 的 电 路,包 含 面 包 板 图、原 理 图 和 PCB 图三种视

图;另一部分是图中右边框内的工具栏部分,包含软件的元件库、指示栏、导航栏、撤销历史

栏和层次栏等子工具栏,是设计者主要操作和使用的地方.

图１Ｇ２７　Fritzing主界面

[]{#index_split_000.html#p33}![index-33_1.png](https://i.imgur.com/uSUpSdO.jpeg){.calibre2}

![index-33_2.png](https://i.imgur.com/b9XtK8N.jpeg){.calibre2}

２２

２．项目视图

设计者可以在项目视图中自由选择面包板、原理图或 PCB 视图进行开发,且设计者可

以利用项目视图框中 的 视 图 切 换 器 快 捷 轻 松 地 在 这 三 种 视 图 中 进 行 切 换,视 图 切 换 器 如

图１Ｇ２７项目视图中右边中部框图部分所示.此外,设计者也可以利用工具栏中的导航栏进

行快速切换,这将在工具部分进行详细说明.下面分别给出这三种视图的操作界面,按从上

到下的顺序依次是面包板视图、原理图视图和 PCB视图,分别如图１Ｇ２８\~图１Ｇ３０所示.

图１Ｇ２８　Fritzing面包板视图

细心的读者可能会发现,在这三种视图下的项目视图中操作可选项和工具栏中对应的

分栏内容都只有细微的 变 化.而 且,由 于 Fritzing的三个视图是默认同步生成的,在本书

中,首先以面包板为模板对软件的共性部分进行介绍,然后再对原理图、PCB图与面包板视

图之间的差异部分进行补充.之所以选择面包板视图作为模板,是为了方便 Arduino开源

硬件设计者从电路原理图过渡到实际电路,尽量减少可能出现的连线和引脚连接错误.

３．工具栏

用户可以根据自己的兴趣爱好选择工具栏显示的各种窗口,单击窗口下拉菜单,然后选

中希望出现在右边工具栏的分栏;也可以将这些分栏设置成单独的浮窗.为了方便初学者

迅速掌握 Fritzing软件,本书将详细介绍各个工具栏的作用.

[]{#index_split_000.html#p34}![index-34_1.png](https://i.imgur.com/5Gptw6W.jpeg){.calibre2}

![index-34_2.png](https://i.imgur.com/F7jsOag.jpeg){.calibre2}

![index-34_3.png](https://i.imgur.com/l2FY5CO.jpeg){.calibre2}

２３

图１Ｇ２９　Fritzing原理图视图

图１Ｇ３０　FritzingPCB视图

[]{#index_split_000.html#p35}![index-35_1.png](https://i.imgur.com/47l8DAX.jpeg){.calibre2}

![index-35_2.png](https://i.imgur.com/oehnU6t.jpeg){.calibre2}

![index-35_3.png](https://i.imgur.com/XgT2C7m.jpeg){.calibre2}

２４

１)元件库

元件库中包含了许多 电 子 元 件,这些电子元件是按容器分类盛放的.Fritzing软件一

共包含８个元件库,分别是 Fritzing的核心库、设计者自定义的库和其他６个库.这８个库

是设计者进行电路设计前所必须掌握的,下面将进行详细的介绍.

(１)MINE:MINE元件库是设计者自定义元件放置的容器.如图１Ｇ３１所示,设计者可

以在这部分添 加 一 些 常 用 元 件 或 软 件 缺 少 的 元 件.具 体 有 关 的 操 作 将 在 后 面 进 行 详 细

说明.

图１Ｇ３１　MINE元件库

(２)Arduino:Arduino元件库主要放置与 Arduino相关的开发板,是 Arduino设计者

需要特别关 心 的 元 件 库. 这 个 元 件 库 中 包 含 Arduino 的 ９ 块 开 发 板,分 别 是 Arduino、

ArduinoUNO R３、Arduino MEGA、Arduino Mini、Arduino NANO、Arduino Pro Mini ３􀆰３V、ArduinoFio、ArduinoLilyPad、ArduinoEthernetShield,如图１Ｇ３２所示.

图１Ｇ３２　Arduino元件库

(３)Parallax:Parallax元件库中主要包含 Parallax的微控制器 PropellerD４０和８款

BasicStamp微控制器开发板,如图１Ｇ３３所示.该系列 微 控 制 器 是 由 美 国 Parallax公 司

开 发 的 ,这 些 微 控 制 器 与 其 他 微 控 制 器 的 区 别 是 在 ROM 内存中内 建 了 一 套 小 型、特 有

的 BASIC 编 程 语 言 直 译 器 PBASIC,这 为 BASIC 语 言 的 设 计 者 降 低 了 嵌 入 式 设 计 的

门 槛 .

(４)Picaxe:Picaxe元件库中主要包括PICAXE系列的低价位单片机、电可擦只读存储

[]{#index_split_000.html#p36}![index-36_1.png](https://i.imgur.com/yyz3Mu0.jpeg){.calibre2}

![index-36_2.png](https://i.imgur.com/MThDgkg.jpeg){.calibre2}

![index-36_3.png](https://i.imgur.com/CXeeiy9.jpeg){.calibre2}

２５

图１Ｇ３３　Parallax元件库

器、实时时钟控制器、串行接口、舵机驱动等元件,如图１Ｇ３４所示.Picaxe系列芯片也是基

于 BASIC语言,设计者可以迅速掌握.

图１Ｇ３４　Picaxe元件库

(５)SparkFun:SparkFun元件库也是 Arduino设计者重点关注的元件库,其中包含了

许多 Arduino的扩展板.此外,这个元件库中还包含了一些传感器和 LilyPad系列的相关

元件,如图１Ｇ３５所示.

(６)Snootlab:Snootlab元件库包含４块开发板,分别是 Arduino的 LCD 扩展板、SD

卡扩展板、接线柱扩展板和舵机的扩展驱动板,如图１Ｇ３６所示.

(７)ContributedParts:ContributedParts元件库包含带开关电位表盘、开关、LED、反

相施密特触发器和放大器等器件,如图１Ｇ３７所示.

(８)Core:Core元件库包含许多平常会用到的基本元件,如 LED、电阻、电容、电感、晶

体管等,还有常见的输入元件、输出元件、集成电路元件、电源、连接、微控器等元件.此外, Core库中还包含面包板视图、原理图视图和印制电路板视图的格式以及工具(主要包含笔

记和尺子)的选择,如图１Ｇ３８所示.

[]{#index_split_000.html#p37}![index-37_1.png](https://i.imgur.com/EPhGqpX.jpeg){.calibre2}

![index-37_2.png](https://i.imgur.com/UiPwK3A.jpeg){.calibre2}

![index-37_3.png](https://i.imgur.com/mEWhMYk.jpeg){.calibre2}

![index-37_4.png](https://i.imgur.com/MRK2rpL.jpeg){.calibre2}

![index-37_5.png](https://i.imgur.com/yITXtNW.jpeg){.calibre2}

２６

图１Ｇ３５　SparkFun元件库

图１Ｇ３６　Snootlab元件库

图１Ｇ３７　ContributedParts元件库

图１Ｇ３８　Core元件库

[]{#index_split_000.html#p38}![index-38_1.png](https://i.imgur.com/Hq893rd.jpeg){.calibre2}

![index-38_2.png](https://i.imgur.com/t7F4iJn.jpeg){.calibre2}

![index-38_3.png](https://i.imgur.com/X1XTsWJ.jpeg){.calibre2}

２７

２)指示栏

指示栏会给出元件库或项目视图中鼠标所选定元件的详细信息,包括该元件的名称、标

签,以及在三种视图下的形态、类型、属性和连接数等.设计者可以根据这些信息加深对元

件的理解,或者检验所选定的元件是否是自己所需要的,甚至能在项目视图中选定相关元件

后直接在指示栏中修改元件的某些基本属性,如图１Ｇ３９所示.

图１Ｇ３９　指示栏

３)撤销历史栏

撤销历史栏中详细记录了设计步骤,并将这些步骤按照时间的先后顺序依次进行排列, 先显示最近发生的步骤,如图１Ｇ４０所示.设计者可以利用这些记录步骤回到之前的任一设

计状态,这为开发工作带来了极大的便利.

图１Ｇ４０　撤销历史栏

[]{#index_split_000.html#p39}![index-39_1.png](https://i.imgur.com/Zvr0yZ2.jpeg){.calibre2}

![index-39_2.png](https://i.imgur.com/Rng8gG0.jpeg){.calibre2}

![index-39_3.png](https://i.imgur.com/3HP0D1T.jpeg){.calibre2}

![index-39_4.png](https://i.imgur.com/tq9aert.jpeg){.calibre2}

２８

４)导航栏

导航栏中提供了对面包板视图、原理图视图和 PCB 视图的预览,设计者可以在导航栏

中任意选定三种视图中的某一视图进行查看,如图１Ｇ４１所示.

图１Ｇ４１　导航栏

５)层

不同的视图有不同的层结构,详细了解层结构有助于读者进一步理解这三种视图和提

升设计者对它 们 的 操 作 能 力.下 面 将 依 次 给 出 面 包 板 视 图、原 理 图 视 图、PCB 视 图 的 层

结构.

(１)面包板视图的层结构.从图１Ｇ４２中可以看出,面包板视图一共包含６层,设计者可

以通过选中层结构前边的矩形复选框在项目视图中显示相应的层.

图１Ｇ４２　面包板视图的层结构

(２)原理图视图的层结构.从图１Ｇ４３中可以看出,原理图视图一共包含７层,相对面包

板视图而言,原理图视图多包含了 Frame层.

图１Ｇ４３　原理图视图的层结构

[]{#index_split_000.html#p40}![index-40_1.png](https://i.imgur.com/7Rt4MuQ.jpeg){.calibre2}

![index-40_2.png](https://i.imgur.com/ZUNhmxu.jpeg){.calibre2}

![index-40_3.png](https://i.imgur.com/tOkRGAj.jpeg){.calibre2}

２９

(３)PCB视图的层结构.PCB视图是层结构最多的视图.从图１Ｇ４４中可以看出,PCB

视图具有１５层结构.由于篇幅有限,本书不再对这些层结构进行一一详解.

图１Ｇ４４　PCB视图的层结构

１．

５．

２　Fritzing使用方法

１．查看元件库已有元件

设计者在查看元件库中的元件时,既可以选择按图标形式查看,也可以选择按列表形式

查看,界面分别如图１Ｇ４５和图１Ｇ４６所示.

图１Ｇ４５　元件图标形式

[]{#index_split_000.html#p41}![index-41_1.png](https://i.imgur.com/EjoYGtL.jpeg){.calibre2}

![index-41_2.png](https://i.imgur.com/bF7Z86e.jpeg){.calibre2}

![index-41_3.png](https://i.imgur.com/GBlj2Wp.jpeg){.calibre2}

３０

图１Ｇ４６　元件列表形式

设计者可以直接在对应的元件库中寻找所需要的元件,但由于 Fritzing所带的库和元

件数目都相对比较多,所以在有些情况下,设计者

可能很难明确确定元件所在的具体位置.这时设

计者就可以利 用 元 件 库 中 自 带 的 搜 索 功 能,从 库

中找出所需要 的 元 件,这 个 方 法 能 极 大 地 提 升 设

计者的工作 效 率.在 此,举 一 个 简 单 的 例 子 进 行

说明,例如,设计者要寻找 ArduinoUNO 开发板,

那么,设计者可以在搜索栏输入 ArduinoUNO 开

发板,按下 Enter键,结果栏就会自动显示相应的

搜索结果,如图

图

１Ｇ４７所示.

１Ｇ４７　查找元件

２．添加新元件到元件库

１)从头开始添加新元件

设计者可以通过选择"元件"→"新建"命令进入添加新元件的界面,如图１Ｇ４８所示;也

可以通过单击元件库中右侧的 NewPart选项进入该界面,如图１Ｇ４９所示.无论采用哪一

种方式,最终进入的新元件编辑界面都如图１Ｇ５０所示.

设计者可在新元件的添加界面填写相关的信息,如新元件的名称、属性、连接等,并导入

相应的视图图片.尤其要注意添加连接,然后单击"保存"按钮,便能创建新的元件.但是在

开发过程中,建议设计者尽量在已有的库元件基础上进行修改来创建用户需要的新元件,这

样可以减少工作量,提高开发效率.

２)从已有元件添加新元件

关于如何基于已有的元件添加新元件,下面举两个简单的例子进行说明.

(１)针对ICs、电阻、引脚等标准元件.例如,现在设计者需要一个２．２kΩ 的电阻,可是

[]{#index_split_000.html#p42}![index-42_1.png](https://i.imgur.com/bbH37qU.jpeg){.calibre2}

![index-42_2.png](https://i.imgur.com/6sZovyI.jpeg){.calibre2}

![index-42_3.png](https://i.imgur.com/5yeOAmj.jpeg){.calibre2}

３１

图１Ｇ４８　添加新元件(方式一)

图１Ｇ４９　添加新元件(方式二)

在 Core库中只有２２０Ω 的标准电阻,这时,创建新电阻最简单的方法就是先将 Core库中

２２０Ω 的通用电阻添加到面包板上,然后选定该电阻,直接在右边的指示栏中将电阻值修改

为２．

２kΩ,如图１Ｇ５１所示.

除此之外,选定 元 件 后,也 可 以 选 择 "元 件"→ "编 辑"命 令 完 成 元 件 参 数 的 修 改,如

[]{#index_split_000.html#p43}![index-43_1.png](https://i.imgur.com/8T6jjlJ.jpeg){.calibre2}

![index-43_2.png](https://i.imgur.com/k2oQtjy.jpeg){.calibre2}

![index-43_3.png](https://i.imgur.com/bEyHYkK.jpeg){.calibre2}

３２

图１Ｇ５０　新元件添加界面

图１Ｇ５１　修改元件属性

图１Ｇ５２所示.

然后进入元件编辑界面,如图１Ｇ５３所示.

将resistance相应的数值改为２２００Ω,单击"另存为新元件"按钮,即可成功创建一个值

为２２００Ω 的电阻,如图１Ｇ５４所示.

此外,在选定元件后,右击元件,在弹出的快捷菜单中选择"编辑"命令,也可进入元件编

辑界面,如图１Ｇ５５所示.

[]{#index_split_000.html#p44}![index-44_1.png](https://i.imgur.com/eVD63eq.jpeg){.calibre2}

![index-44_2.png](https://i.imgur.com/rsLjoeA.jpeg){.calibre2}

![index-44_3.png](https://i.imgur.com/mbRICBC.jpeg){.calibre2}

３３

图１Ｇ５２　新元件添加界面

图１Ｇ５３　元件编辑界面１

基于标准元件添加新元件的操作与此类似,如改变引脚数、修改接口数目等,在此不再

赘述.

(２)相对复杂的元件.完成了基本元件的介绍后,下面介绍一个相对复杂的例子.在

这个例子中,要添加一个自定义元件---------SparkFunT５４０３气压仪,如图１Ｇ５６所示.

[]{#index_split_000.html#p45}![index-45_1.png](https://i.imgur.com/rXo6XXd.jpeg){.calibre2}

![index-45_2.png](https://i.imgur.com/TfBnYiV.jpeg){.calibre2}

![index-45_3.png](https://i.imgur.com/n9wMp6o.jpeg){.calibre2}

![index-45_4.png](https://i.imgur.com/pFpXlh3.jpeg){.calibre2}

３４

图１Ｇ５４　元件编辑界面２

图１Ｇ５５　新元件添加界面

图１Ｇ５６　SparkFunT５４０３的 PCB图

[]{#index_split_000.html#p46}![index-46_1.png](https://i.imgur.com/i2jmFzP.jpeg){.calibre2}

![index-46_2.png](https://i.imgur.com/eUsz6HN.jpeg){.calibre2}

![index-46_3.png](https://i.imgur.com/zsyViVX.jpeg){.calibre2}

![index-46_4.png](https://i.imgur.com/IFmPmlt.jpeg){.calibre2}

３５

在元件库中寻找该元件,在搜索框中输入 T５４０３,如图１Ｇ５７所示.

图１Ｇ５７　SparkFunT５４０３搜寻图

若没有发现该元件,则可以在该元件所在的库中寻找是否有类似的元件(根据名称容易

得知,

SparkFunT５４０３是SparkFun系列的元件),如图１Ｇ５８所示.

图１Ｇ５８　SparkFun系列元件

若发现还是没有与自定义元件相类似的元件,则可以选择从标准的集成电路ICs开始, 选择 Core元件库,找到ICs栏,将IC元件添加到面包板中,如图１Ｇ５９和图１Ｇ６０所示.

图１Ｇ５９　CoreICs

选定该IC元件,在指示栏中查看该元件的属性.将元件的名字命名为自定义元件的名

称 T５４０３BarometerBreakout,并将引脚数修改成所需要的数量.在本例中,需要的引脚数

为８,如图１Ｇ６１所示.

[]{#index_split_000.html#p47}![index-47_1.png](https://i.imgur.com/u1H8Hqj.jpeg){.calibre2}

![index-47_2.png](https://i.imgur.com/sQAmJX6.jpeg){.calibre2}

![index-47_3.png](https://i.imgur.com/hCQBRjW.jpeg){.calibre2}

![index-47_4.png](https://i.imgur.com/OvkhZuf.jpeg){.calibre2}

３６

图１Ｇ６０　添加ICs到面包板

图１Ｇ６１　自定义元件的参数修改

修改之后,面包板上的元件如图１Ｇ６２所示.

右击面包板视图中的IC元件,在弹出的快捷菜单中选择

"编辑"命令,会出现如图１Ｇ６３所示的编辑窗口.设计者需要

根据自定义元件 的 特 性 修 改 图 中 的 ６个部分,分别是元件图

标、面包板视图、原理图视图、

PCB视图、描述和接插件.这部

图１Ｇ６２　T５４０３Barometer

分的修改大都是细节性的问题,在此不再赘述,读者可参考下

Breakout

[]{#index_split_000.html#p48}![index-48_1.png](https://i.imgur.com/ql87Vt2.jpeg){.calibre2}

![index-48_2.png](https://i.imgur.com/wNoJM1L.jpeg){.calibre2}

![index-48_3.png](https://i.imgur.com/KN6fZsn.jpeg){.calibre2}

![index-48_4.png](https://i.imgur.com/raD9kw1.jpeg){.calibre2}

３７

面的 链 接 进 行 深 入 学 习:https://learn．sparkfun．com/tutorials/makeＧyourＧownＧfritzingＧ

parts.

图１Ｇ６３　T５４０３BarometerBreakout编辑窗口

３．添加新元件库

设计者不仅可以创建自定义的新元件,也可以根据自己的需求创建自定义的元件库,并

对元件库进行管理.在设计电路结构前,可以将所需的电路元件列一份清单,并将所需要的

元件都添加到自定义的库中,这可以为后续的电路设计提高效率.添加新元件库时,只需选

择图１Ｇ４６所示的元件栏中的 NewBin命令,便会出现如图１Ｇ６４所示的界面.

如图１Ｇ６４所示,给这个自定义的元件库取名为 ArduinoProject,单击 OK 按钮,新的元

件库便成功创建,如图１Ｇ６５所示.

图１Ｇ６４　添加新元件库

图１Ｇ６５　成功创建新元件库

[]{#index_split_000.html#p49}![index-49_1.png](https://i.imgur.com/nMu50Lj.jpeg){.calibre2}

![index-49_2.png](https://i.imgur.com/Dhayoum.jpeg){.calibre2}

![index-49_3.png](https://i.imgur.com/w5ZDDZZ.jpeg){.calibre2}

３８

４．添加或删除元件

下面主要介绍如何将元件库中的元件添加到面包板视图中.当需要添加某个元件时, 可以先在元件库相应的子库中寻找所需要的元件,然后在目标元件的图标上单击选定元件, 拖动至面包板上的目的位置,松开鼠标左键即可将元件插入面包板.需要特别注意的是,在

放置元件时,一定要确保元件的引脚已经成功插入面包板.如果插入成功,则元件引脚所在

的连线会显示绿色;如果插入不成功,则元件的引脚会显示红色.如图 １Ｇ６６所示,其中左

边表示添加成功,右边表示添加失败.

图１Ｇ６６　引脚状态图

如果在放置元件的过程中操作有误,则直接单击选定目标元件,然后再按 Delete键,即

可将元件从视图上删除.

５．添加元件间连线

添加元件间的连线是用 Fritzing绘制电路图必不可少的过程,接下来将对连线的方法

给出详细的介绍.连线的时候将想要连接的引脚拖动到要连接的目的引脚后松开即可.这

里需要注意的是,只有当连接线段的两端都显示绿色时(图１Ｇ６７左边),才代表导线连接成

功;若连线的两端显示红色(图１Ｇ６７右边),则表示连接出现问题.

图１Ｇ６７　连线状态图

此外,为了使电路更清晰明了,设计者还能根据自己的需求在导线上设置拐点,使导线

可以根据设计者的喜好而改变连线角度和方向.具体方法如下:光标处即为拐点处,设计

者能自由拖动光标来移动拐点的位置.此外设计者也可以先选定导线,然后将鼠标光标放

在想设置的拐点处,右击,在弹出的快捷菜单中选择"添加拐点"命令即可,如图１Ｇ６８所示.

除此之外,在连线的过程中,设计者还可以更改导线的颜色,不同的颜色将帮助设计者

更好地掌握绘制的电路.具体的修改方法为选定要更改颜色的导线,然后右击,选择"连线

颜色",如图１Ｇ６９所示.

[]{#index_split_000.html#p50}![index-50_1.png](https://i.imgur.com/pfJG00C.jpeg){.calibre2}

![index-50_2.png](https://i.imgur.com/CD4vixj.jpeg){.calibre2}

![index-50_3.png](https://i.imgur.com/z71EvtC.jpeg){.calibre2}

３９

图１Ｇ６８　拐点添加图

图１Ｇ６９　导线颜色修改图

１．

５．

３　Arduino电路设计

至此,已经完成了对软件主界面和基本功能的详细介绍.接下来,将通过一个具体的例

子系统地介绍如何利用 Fritzing软件绘制一幅完整的 Arduino电路图,即用 Arduino开发

板控制 LED 的亮灭.整体效果如图１Ｇ７０所示.

下面介绍 ArduinoBlink例程的电路图详细设计步骤.

首先打开软件并新建一个项目,具体操作为单击软件的运行图标,在软件的主界面选择

"文件"→"新建"命令,如图１Ｇ７１所示.

完成项目新建后,先保存该项目.选择"文件"→"另存为"命令,出现如图１Ｇ７２所示的界面, 在该对话框中输入保存的文件名和路径,然后单击"保存"按钮,即可完成对新建项目的保存.

一般来说,在绘制电路前,设计者应该先对开发环境进行设置.这里的开发环境主要指

设计者选择使用的面包板型号、类型,以及原理图和 PCB 视图的各种类型.因为本书以面

包板视图为重点,所以将编辑视图切换到面包板视图,并在 Core元件库中选好开发所用的

面包板类型和尺寸.图１Ｇ７３给出了各种尺寸的面包板图.

[]{#index_split_000.html#p51}![index-51_1.png](https://i.imgur.com/pTsSy7E.jpeg){.calibre2}

![index-51_2.png](https://i.imgur.com/JNUUSHZ.jpeg){.calibre2}

![index-51_3.png](https://i.imgur.com/bMl7t1R.jpeg){.calibre2}

４０

图１Ｇ７０　ArduinoBlink示例整体效果图

图１Ｇ７１　新建项目

[]{#index_split_000.html#p52}![index-52_1.png](https://i.imgur.com/b0ygWco.jpeg){.calibre2}

![index-52_2.png](https://i.imgur.com/FnMD7s5.jpeg){.calibre2}

![index-52_3.png](https://i.imgur.com/7M9zSOa.jpeg){.calibre2}

４１

图１Ｇ７２　保存项目

图１Ｇ７３　面包板类型和尺寸

[]{#index_split_000.html#p53}![index-53_1.png](https://i.imgur.com/m2tuGZm.jpeg){.calibre2}

![index-53_2.png](https://i.imgur.com/oNjLJSs.jpeg){.calibre2}

４２

由于本例中所需的元件数较少,因此此处省去建立自定义元件库的步骤,直接先将所有

的元件 都 放 置 在 面 包 板 上,如 图 １Ｇ７４所示.在本例中,需要１块 Arduino的开发板、１个

LED 和１个２２０Ω 电阻.

图１Ｇ７４　元件的放置

然后进行连线,即可得到最终的效果图,如图１Ｇ７５所示.

在编辑视图中切换到原理图,会看到如图１Ｇ７６所示的界面.

此时布线还没有完成,开发者可以单击编辑视图下方的自动布线,但要 注 意 自 动 布 线

后,检查是否所有的元件都完成了布线.对没有完成的,开发者要进行手动布线,即手动连

接引脚间的连线.最终可得到如图１Ｇ７７所示的效果图.

同理,可以在编辑视图中切换到 PCB视图,观察 PCB 视图下的电路.此时也要注意编

辑视图窗口下方是否提示布线未完成,如果是,开发者可以单击下面的"自动布线"按钮进行

布线处理,也可以自己手动进行布线.这里,将直接给出最终的效果图,如图１Ｇ７８所示.

完成所有操作后,就可以修改电路中各元件的属性.在本例中不需要修改任何值,在此

略过这部分.完成所有步骤后,就能根据需求导出所需要的文档或文件.在本例中,将以导

出一个 PDF格式的面包板视图为例对该流程进行说明.首先确保将编辑视图切换到面包

板视图,然后选择"文件"→"导出"→"作为图像"→PDF 命令,如图１Ｇ７９所示.输出的最终

PDF格式文档如图１Ｇ８０所示.

[]{#index_split_000.html#p54}![index-54_1.png](https://i.imgur.com/LUatfDi.jpeg){.calibre2}

![index-54_2.png](https://i.imgur.com/R0DnuyV.jpeg){.calibre2}

![index-54_3.png](https://i.imgur.com/uLiZTiG.jpeg){.calibre2}

![index-54_4.png](https://i.imgur.com/7j9l1HR.jpeg){.calibre2}

４３

图１Ｇ７５　元件连线图

图１Ｇ７６　原理图界面

图１Ｇ７７　原理图自动布线图

[]{#index_split_000.html#p55}![index-55_1.png](https://i.imgur.com/rVT8jwH.jpeg){.calibre2}

![index-55_2.png](https://i.imgur.com/Oe8MndO.jpeg){.calibre2}

![index-55_3.png](https://i.imgur.com/LlzvWmi.jpeg){.calibre2}

４４

图１Ｇ７８　PCB视图效果图

图１Ｇ７９　PDF图的生成步骤

[]{#index_split_000.html#p56}![index-56_1.png](https://i.imgur.com/HP9s9u7.jpeg){.calibre2}

![index-56_2.png](https://i.imgur.com/TJ7iC9J.jpeg){.calibre2}

![index-56_3.png](https://i.imgur.com/7Eq5XQq.jpeg){.calibre2}

４５

图１Ｇ８０　面包板的 PDF图

１．

５．

４　Arduino开发平台样例与编程

Fritzing软件不但能很好地支持 Arduino开发板的电路设计,而且提供了对 Arduino 开发板样例电路的支持,如图１Ｇ８１所示.用户可以选择"文件"→"打开例子"命令,然后选

择相应的 Arduino开发板,如此层层推进,最终选择想打开的样例电路.

图１Ｇ８１　Fritzing支持 Arduino开发板样例电路

[]{#index_split_000.html#p57}![index-57_1.png](https://i.imgur.com/Csxr7rx.jpeg){.calibre2}

![index-57_2.png](https://i.imgur.com/jw5dNCB.jpeg){.calibre2}

![index-57_3.png](https://i.imgur.com/IBB6s9n.jpeg){.calibre2}

４６

这里以基于 Arduino开 发 板 的 交 通 灯 为 例 进 行 说 明.选 择 "元 件"→ "打 开 例 子"→

Arduino→Digital→Output→TrafficLight命令,就能在 Fritzing软件的编辑视图中得到如

图１Ｇ８２所示的 Arduino平台开发的样例电路.需要注意的是,不管在哪种视图下进行操

作,打开的样例电路都会将编辑视图切换到面包板视图.如果想要获得相应的原理图视图

或 PCB视图,则可以在打开的样例电路中从面包板视图中切换到目标视图.

图１Ｇ８２　基于 Arduino开发板的交通灯样例

除了对 Arduino开发板样例的支持外,Fritzing还将电路

设计和编程脚本 放 置 在 了 一 起.对 于 每 个 设 计 电 路,Fritzing 都提供了一个编程界面,用户可以在编程界面中编写将要下载

到微控制器的脚本.具体操 作 如 图 １Ｇ８３所示,选择"窗口"→

"打开编程窗口"命令,即可进入编程界面,如图１Ｇ８４所示.

从图１Ｇ８４中可以发现,虽然每个设计电路只有一个编程

界面,但设计者可以在一个编程界面创造许多编程窗口来编写

不同版本的脚本,从而在其中选择最合适的脚本.单击"新建"

按钮即可创建新编 程 窗 口.而且,从编程界面中也可以看出,

图

目前

１Ｇ８３　编程界面进入步骤

Fritzing主要支持 Arduino平台和 PICAXE 两种脚本语

言,如图１Ｇ８５所示.设计者在选定脚本的编程语言后,就只能

编写该语言的脚本,并将脚本保存成相应类型的文件格式.同理,选定编程语言后,设计者

也只能打开同种类型的脚本.

[]{#index_split_000.html#p58}![index-58_1.png](https://i.imgur.com/2xDkuCE.jpeg){.calibre2}

![index-58_2.png](https://i.imgur.com/fYG99hj.jpeg){.calibre2}

![index-58_3.png](https://i.imgur.com/qmpWRlu.jpeg){.calibre2}

![index-58_4.png](https://i.imgur.com/po3MB6V.jpeg){.calibre2}

４７

图１Ｇ８４　编程界面

选定脚本语言后,设计者还应该选择串行端口.从 Fritzing界面可以看出,该软件一共

有两个默认端口,分别是 COM１和 LPT１,如图１Ｇ８６所示.当设计者将相应的微控制器连

接到 USB端口时,软件里会增加一个新的设备端口,然后可以根据自己的需求选择相应的

端口.

图１Ｇ８５　编程语言支持

图１Ｇ８６　支持端口

值得注意的是,虽然 Fritzing提供了脚本编写器,但是它并没有内置编译器,所以设计

者必须自行安装额外的编 程 软 件 将 编 写 的 脚 本 转 换 成 可 执 行 文 件.但是,Fritzing提供了

和编程软件交互的方法,设计者可以通过单击图１Ｇ８４所示的"程序"按钮获取相应的可执行

文件信息,所有这些内容都将显示在下面的控制端.

[]{#index_split_000.html#p59}![index-59_1.png](https://i.imgur.com/QU9TSUY.jpeg){.calibre2}

第２章 LED多模式显示时钟项目设计

２．

１　项目背景

数字电子时钟具有走时准确、一钟多用等特点,在生活中已经得到广泛应用.虽然市场

上已有现成的电子时钟集成电路芯片,价格低、使用方便,但是人们对电子产品的应用要求

越来越高.数字时钟不但可以显示当前的时间,而且可以显示日期、农历、星期等,给人们的

生活带来了方便.另外,数字时钟还具备秒表和闹钟的功能,闹钟铃声可自选,使其具备了

多媒体的色彩.单片机具有体积小、功能强、可靠性高、价格低廉等一系列优点,已成为工业

测控领域普遍采用的智能化控制工具,并且已渗入人们工作和生活的各个领域,有力地推动

了各行业的技术改造和产品的更新换代,应用前景广阔.基于此,本项目用 LED 设计一款

有多种显示模式的创意时钟.

２．

２　创新描述

本项目设计一款基于 HT１６３２C 的 LED 多模式显示时钟,具有五种显示模式,可以通

过 LED 屏幕设置时间.LED 屏幕具有很大的可塑性,可以按照任意想法设计想要的图案.

其中,最大的创新点在于乒乓球模式,为闹钟的显示增加了趣味性.

２．

３　功能及总体设计

本作品主要分时间读取和时间 显 示 两 部 分 进 行 设 计.时间读取部分,将 DS１３０７时钟

芯片的时间传入 Arduino开发板;时间显示部分,通过 Arduino开发板将时钟芯片中的时

间传入两块级联的 LED 显示屏中,并通过不同模式显示.

本章根据凌楠淼、张亚红项目设计整理而成.

[]{#index_split_000.html#p60}![index-60_1.png](https://i.imgur.com/eIENJBI.jpeg){.calibre2}

![index-60_2.png](https://i.imgur.com/SLsTYe0.jpeg){.calibre2}

４９

２．

３．

１　功能介绍

时钟的主要功能是显示时间,但是显示时间的方式有所不同,包含５种显示模式以及一

个设置功能.５种显示模式分别是 Normal、Pong、Digital、Words以及Slide.在５种显示模

式下,按下 B键可以调出日期和星期;按下 A 键可以切换模式.通过设置功能可以设置当

前时间、屏幕亮度、时间显示格式以及随机显示模式.当前时间包括年、月、日、时和分;时

间显示格式包括２４h模式和１２h模式;随机显示模式指首先进入Slide模式,然后每隔１h可

以切换到另一个模式.

２．

３．

２　总体设计

实现上述功能需要将作品分成两部分进行设 计.第一部分是从时钟芯片(DS１３０７)中

读取当前时间并写入 Arduino开发板,再通过 Arduino开发板传入２４１６LED 点阵显示屏, 通过显示屏显示时间,即显示模式的设计和实现;第二部分是菜单的设计,通过两个按钮控

制进入菜单,在各个模式中调出日期、星期、亮度、时间显示格式等设置,具体实现在代码中

体现.

１．整体框架图

项目整体框架如图２Ｇ１所示.

图２Ｇ１　整体框架图

２．系统流程图

图２Ｇ２为模式选择流程图;图２Ｇ３为设置流程图.

３．总电路图

系统总电路如图２Ｇ４所示.

[]{#index_split_000.html#p61}![index-61_1.png](https://i.imgur.com/kKkWkVO.jpeg){.calibre2}

![index-61_2.png](https://i.imgur.com/gtsTbNI.jpeg){.calibre2}

５０

图２Ｇ２　模式选择流程图

[]{#index_split_000.html#p62}![index-62_1.png](https://i.imgur.com/YAWoZ9l.jpeg){.calibre2}

![index-62_2.png](https://i.imgur.com/OOXmcv3.jpeg){.calibre2}

５１

图２Ｇ３　设置流程图

[]{#index_split_000.html#p63}![index-63_1.png](https://i.imgur.com/0UdyKoV.jpeg){.calibre2}

![index-63_2.png](https://i.imgur.com/ZXcqImr.jpeg){.calibre2}

５２

图２Ｇ４　总电路图

Arduino开发板与元件之间的引脚连线如表２Ｇ１所示.

表２Ｇ１　电路连线

Arduino开发板

２４１６LED 点阵显示屏

DS１３０７时钟模块

按键开关

２

---

---

按键开关１

３

---

---

按键开关２

４

LED_CS１

---

---

５

LED_CS２

---

---

１０

LED_DATA

---

---

１１

LED_WR

---

---

A４

---

DS１３０７_SDA

---

A５

---

DS１３０７_SCL

---

VCC

VCC

VCC

---

GND

GND

GND

GND

２．

３．

３　模块介绍

本项目主要包括主程序控制模块、基于 HD１６３２C的LED级联显示模块和DS１３０７时钟芯

片模块,模块连接如图２Ｇ５所示.下面分别给出各模块的功能、元件、电路图和相关代码.

１．模式控制模块

１)功能介绍

连接 DS１３０７时钟芯片,进行时间数据的传输.发送指令控制 LED 显示屏的启动和显

[]{#index_split_000.html#p64}![index-64_1.png](https://i.imgur.com/hT5N9aO.jpeg){.calibre2}

![index-64_2.png](https://i.imgur.com/eLR2xeW.jpeg){.calibre2}

![index-64_3.png](https://i.imgur.com/lvamsQu.jpeg){.calibre2}

![index-64_4.png](https://i.imgur.com/ImmC81t.jpeg){.calibre2}

５３

图２Ｇ５　模块连接关系

示.设置端口,检测按钮输入,并设置不同的显示模式.本模块使用的元件包括面包板、四

脚按钮和 ArduinoUno开发板,电路如图２Ｇ６所示.

２)相关代码

Button部分引用了一个 Button库,旨在解决菜单变化时长时间按压造成的菜单多次

变换的问题,类似于JK 触发器的一次翻转.

＃include Button敭h 按钮库函数

ButtonbuttonA ＝ Button ２

BUTTON_PULLUP

设置按键A

ButtonbuttonB ＝ Button ３

BUTTON_PULLUP

设置按键B

voidsetup

digitalWrite ２ HIGH

为引脚２写入高电平

digitalWrite ３ HIGH

为引脚３写入高电平

按键A和B的使用

while run_mode

读取时钟芯片上的时间

get_time

检查按钮是否被按下

if buttonA敭

uniquePress

[]{#index_split_000.html#p65}![index-65_1.png](https://i.imgur.com/NBAtMZN.jpeg){.calibre2}

![index-65_2.png](https://i.imgur.com/NVFFcbO.jpeg){.calibre2}

５４

图２Ｇ６　模式控制模块电路

switch_mode 　　　　　　 选择新模式

return

退出当前模式并返回循环 新的时钟模式可以被调用

if buttonB敭

uniquePress

display_date

fade_down

return

退出当前模式并返回循环 重新进入该功能 并再次启动时钟模式 这将刷新显示

主程序部分是一个菜单 不同的菜单项目有不同的显示 通过case语句选择clock_mode 菜单部分

byteclock_mode ＝０

默认为０

voidloop

以clock_mode设置的任何模式运行时钟 默认设置在代码顶部

switch clock_mode

case０

normal

break

case１

pong

break

[]{#index_split_000.html#p66}![index-66_1.png](https://i.imgur.com/7QSzqNf.jpeg){.calibre2}

![index-66_2.png](https://i.imgur.com/wVW2UX5.jpeg){.calibre2}

![index-66_3.png](https://i.imgur.com/w7XY5sd.jpeg){.calibre2}

![index-66_4.png](https://i.imgur.com/SrrhqHk.jpeg){.calibre2}

![index-66_5.png](https://i.imgur.com/c3oD9Nf.jpeg){.calibre2}

５５

case２

digits

break

case３

word_clock

break

case４

slide

break

和菜单相关的菜单选择函数

byteclock_mode ＝０

默认为０

byteold_mode ＝ clock_mode 存储当前模式 设置完时间后即可知道接下来应切回到哪一个模式

voidswitch_mode

建立时钟模式选择列表 old_mode为当前所在的模式 clock_mode为当前选择的模式 next\_

clock_code为下一个选择的模式敭记住当前old_mode 使我们可以在任何时候从settingmode ６

最后一个模式 返回到当前模式

old_mode ＝ clock_mode

char∗ modes ＝

＂Normal＂ ＂Pong＂ ＂Digits＂ ＂Words＂ ＂Slide＂ ＂Setup＂

bytenext_clock_mode

bytefirstrun ＝１

循环等待按钮 ３５次循环后超时 返回模式X

for intcount＝０ count ３５ count++

单击按钮 改变时钟模式

if buttonA敭

uniquePress \|\|firstrun＝＝１

count＝０

cls

if firstrun＝＝０

clock_mode++

if clock_mode NUM_DISPLAY_MODES＋１

clock_mode＝０

显示部分 显示当前模式和下一个模式 在当前模式前面加上箭头

charstr_top ９

charstr_bot ９

strcpy str_top ＂＂

strcat str_top modes clock_mode

next_clock_mode＝ clock_mode＋１

if next_clock_mode NUM_DISPLAY_MODES＋１

next_clock_mode＝０

strcpy str_bot ＂＂

strcat str_bot modes next_clock_mode

bytei ＝０

[]{#index_split_000.html#p67}![index-67_1.png](https://i.imgur.com/NmJqUDX.jpeg){.calibre2}

![index-67_2.png](https://i.imgur.com/CXactC6.jpeg){.calibre2}

５６

在顶部显示当前模式

while str_top i

ht１６３２_putchar i∗６ ０ str_top i

i++

i＝０

在底部显示下一模式

while str_bot i

ht１６３２_putchar i∗６ ８ str_bot i

i++

firstrun＝０

delay ５０

２．DS１３０７时钟芯片模块

１)功能介绍

记录时间,通过晶振保持时间的走动,与 Arduino开发板进行通信,提供时间数据.本

模块使用的元件包括集成了３２kHz晶振的 DS１３０７时钟芯片和纽扣电池,模块电路如图２Ｇ７

所示.

图２Ｇ７　DS１３０７时钟芯片模块

[]{#index_split_000.html#p68}![index-68_1.png](https://i.imgur.com/XQtUxfV.jpeg){.calibre2}

![index-68_2.png](https://i.imgur.com/UqQ5CIa.jpeg){.calibre2}

![index-68_3.png](https://i.imgur.com/6SCyjD6.jpeg){.calibre2}

５７

２)相关代码

DS１３０７芯片的使用贯穿于整个代码文件中,并没有特定的模块代码.下面截取有关获

取当前时间和设定时间的部分.

staticuint８_tbegin void 　　　　　　　　 初始化函数

staticvoidadjust constDateTime&dt 调整时间

uint８_tisrunning void

判断DS１３０７是否工作

staticDateTimenow

获取当前时间

＃include Wire敭h

DS１３０７时钟芯片

＃include＂RTClib敭h＂

DS１３０７时钟芯片

RTC_DS１３０７ds１３０７

intrtc ７

保持实时时钟输出

voidsetup

if ds１３０７敭

isrunning

Serial敭

println ＂RTCisNOTrunning

＂

ds１３０７敭adjust DateTime \_\_DATE\_\_ \_\_TIME\_\_

获取当前时间

voidget_time

获取当前时间

gettime

DateTimenow＝ ds１３０７敭now

rtc ６ ＝ now敭year

rtc ５ ＝ now敭month

rtc ４ ＝ now敭day

rtc ３ ＝ now敭dayOfWeek

返回０\~６ 其中０ ＝星期日

rtc ２ ＝ now敭hour

rtc １ ＝ now敭minute

rtc ０ ＝ now敭second

Arduino开发板引脚１３所对应的LED按秒闪烁

if rtc ０ ％２ ＝＝０

digitalWrite １３

HIGH

else

digitalWrite １３

LOW

打印到串口的时间

Serial敭

print rtc ２

Serial敭

print ＂

＂

Serial敭

print rtc １

Serial敭

print ＂

＂

Serial敭

println rtc ０

[]{#index_split_000.html#p69}![index-69_1.png](https://i.imgur.com/dIlDj6A.jpeg){.calibre2}

![index-69_2.png](https://i.imgur.com/XFKhbmR.jpeg){.calibre2}

５８

完整的set_time包含了两个函数 总体的set_time存储时间和每个时间单位 年月日时分秒 的

用户输入

voidset_time

cls

用从时钟读取的当前时钟值填充设置

get_time

byteset_min ＝ rtc １

byteset_hr ＝ rtc ２

byteset_date ＝ rtc ４

byteset_mnth ＝ rtc ５

intset_yr ＝ rtc ６

设置功能 需要传入的参数包括显示在顶部的设置消息、当前值、重置值和翻转限制

set_date ＝ set_value ２ set_date １ ３１

set_mnth ＝ set_value ３ set_mnth １ １２

set_yr ＝ set_value ４ set_yr ２０１３ ２０９９

set_hr ＝ set_value １ set_hr ０ ２３

set_min ＝ set_value ０ set_min ０ ５９

ds１３０７敭

adjust DateTime set_yr set_mnth set_date set_hr set_min cls

功能 返回用户输入的当前值

intset_value bytemessage intcurrent_value intreset_value introllover_limit cls

charmessages ６ １７ ＝

＂SetMins＂ ＂SetHour＂ ＂SetDay＂ ＂SetMnth＂ ＂SetYear＂

在顶层打印"设置xyz"

bytei ＝０

while messages message i

ht１６３２_putchar i∗６ ０ messages message i i++

在底层打印数据

charbuffer ５ ＝＂＂

itoa current_value

buffer

１０

ht１６３２_putchar ０ ８ buffer ０

ht１６３２_putchar ６ ８ buffer １

ht１６３２_putchar １２ ８ buffer ２

ht１６３２_putchar １８ ８ buffer ３

delay ３００

等待按钮输入

while

buttonA敭

uniquePress

while buttonB敭

isPressed

if current_value rollover_limit

current_value++

else

[]{#index_split_000.html#p70}![index-70_1.png](https://i.imgur.com/xt1swPW.jpeg){.calibre2}

![index-70_2.png](https://i.imgur.com/c4vsrkq.jpeg){.calibre2}

５９

current_value＝ reset_value

打印新值

itoa current_value buffer

１０

ht１６３２_putchar ０ ８ buffer ０

ht１６３２_putchar ６ ８ buffer １

ht１６３２_putchar １２ ８ buffer ２

ht１６３２_putchar １８ ８ buffer ３

delay １５０

returncurrent_value

３．LED 级联显示模块

１)功能介绍

通过 LED 的逐行点亮控制时间、设置等显示.购买的点阵器件里集成了 HT１６３２C 数

码管驱动芯片和 RAM.本模块用到的元件为２块１６×２４绿色 LED 矩阵显示屏,如图２Ｇ８

所示.

图２Ｇ８　LED 级联外观以及接口

[]{#index_split_000.html#p71}![index-71_1.png](https://i.imgur.com/mf5rS8n.jpeg){.calibre2}

![index-71_2.png](https://i.imgur.com/fQrfrio.jpeg){.calibre2}

![index-71_3.png](https://i.imgur.com/7zrKXEZ.jpeg){.calibre2}

![index-71_4.png](https://i.imgur.com/SIcJ9no.jpeg){.calibre2}

![index-71_5.png](https://i.imgur.com/wLbyNhK.jpeg){.calibre2}

６０

２)相关代码

LED 的代码最为 复 杂 和 多 样.下 面 针 对 其 中 一 个 显 示 模 式 来 举 例 说 明 它 是 如 何 工

作的.

voidht１６３２_chipselect bytechipno 　　　　　　　 芯片选择

voidht１６３２_chipfree bytechipno

芯片不选择

voidht１６３２_setup

初始化

voidht１６３２_plot charx chary charval

显示一个点

voidht１６３２_clear

清屏 在主程序中被定义为cls

voidfade_down

屏幕渐渐变暗

voidfade_up

屏幕渐渐变亮

voidht１６３２_putchar bytex bytey charc

放置５×７的字符

voidht１６３２_putbigchar bytex bytey charc 放置８×１０的字符

voidht１６３２_puttinychar bytex bytey charc 放置３×５的字符

应用１ 打印当前时钟版本名字

voidprintver

bytei ＝０

charver_top １６ ＝＂PongClock＂

charver_lower １６ ＝＂buptver敭

１＂

检测所有LED

for bytex＝０ x ４８ x++

for bytey＝０ y １６ y++

plot x y

１

delay １０００

fade_down

画框

for bytex＝０ x ４８ x++

plot x

０

１

plot x

１５

１

for bytey＝０ y １５ y++

plot ０ y

１

plot ４７ y

１

顶层

while ver_top i

ht１６３２_puttinychar i∗４ ＋２ ２ ver_top i delay ３５

i++

i＝０

底层

while ver_lower i

[]{#index_split_000.html#p72}![index-72_1.png](https://i.imgur.com/lcOflIM.jpeg){.calibre2}

![index-72_2.png](https://i.imgur.com/d4xd0Px.jpeg){.calibre2}

![index-72_3.png](https://i.imgur.com/OGZU1g7.jpeg){.calibre2}

６１

ht１６３２_puttinychar i∗４ ＋２ ９ ver_lower i delay ３５

i++

delay ４０００

fade_down

版本信息

应用２ 在屏幕中央画虚线

voidpong

画中央虚线

byteoffset ＝random ０

２

for bytei＝０ i １６ i++

取消中央排线框

if i％２＝＝０

绘图点为偶数

plot ２４ i＋offset １

delay ３０

应用３ 正常显示时间

voidnormal

chartextchar １６

显示屏上的１６个字符

bytemins ＝１００

分钟

bytesecs ＝ rtc ０

秒

byteold_secs ＝ secs

保持旧秒值

cls

run_mode返回true 运行时钟主循环

while run_mode

get_time

检测按钮

if buttonA敭

uniquePress

switch_mode

return

if buttonB敭

uniquePress

display_date

fade_down

return

若秒数变了则更新显示屏上的显示

secs＝ rtc ０

if secs

＝ old_secs

秒

charbuffer ３

itoa secs buffer

１０

修正

if secs １０

[]{#index_split_000.html#p73}![index-73_1.png](https://i.imgur.com/MIjqXcI.jpeg){.calibre2}

![index-73_2.png](https://i.imgur.com/ogDgJIi.jpeg){.calibre2}

![index-73_3.png](https://i.imgur.com/gy9Qd7z.jpeg){.calibre2}

![index-73_4.png](https://i.imgur.com/EjjHoyN.jpeg){.calibre2}

![index-73_5.png](https://i.imgur.com/a32yNCQ.jpeg){.calibre2}

６２

buffer １ ＝buffer ０

buffer ０ ＝ \'０\'

ht１６３２_putchar ３０ ０ \' \'

ht１６３２_putchar ３６ ０ buffer ０

ht１６３２_putchar ４２ ０ buffer １

old_secs＝ secs

若分钟变化则改变时间

if mins

＝ rtc １

重新设置用于下一次的比较

mins＝ rtc １

bytehours ＝ rtc ２

if hours １２

hours＝ hours－ ampm∗１２

if hours １

hours＝ hours＋ ampm∗１２

bytedow ＝ rtc ３ 敭

bytedate ＝ rtc ４

设置字符

charbuffer ３

itoa hours buffer

１０

if hours １０

buffer １ ＝buffer ０

１２h模式下空白的前导零

if ampm

buffer ０ ＝ \' \'

else

buffer ０ ＝ \'０\'

设置小时字符

textchar ０ ＝buffer ０

textchar １ ＝buffer １

textchar ２ ＝ \' \'

itoa mins buffer １０

if mins １０

buffer １ ＝buffer ０

buffer ０ ＝ \'０\'

设置分钟字符

textchar ３ ＝buffer ０

textchar ４ ＝buffer １

设置秒数字符

[]{#index_split_000.html#p74}![index-74_1.png](https://i.imgur.com/5FOn1E5.jpeg){.calibre2}

![index-74_2.png](https://i.imgur.com/NCzVEmE.jpeg){.calibre2}

![index-74_3.png](https://i.imgur.com/t4nnOs2.jpeg){.calibre2}

![index-74_4.png](https://i.imgur.com/TCTHv3v.jpeg){.calibre2}

６３

textchar ５ ＝ \' \'

buffer ３

secs＝ rtc ０

itoa secs buffer

１０

if secs １０

buffer １ ＝buffer ０

buffer ０ ＝ \'０\'

设置秒

textchar ６ ＝buffer ０

textchar ７ ＝buffer １

设置日期

itoa date buffer １０

if date １０

buffer １ ＝buffer ０

buffer ０ ＝ \'０\'

工作日期２个字母后缀 例如st、

nd、

rd、

th

在代码顶部定义charsuffix ４ ３ ＝ ＂st＂ ＂nd＂ ＂rd＂ ＂th＂

bytes ＝３

if date＝＝１\|\|date＝＝２１\|\|date＝＝３１

s＝０

elseif date＝＝２\|\|date＝＝２２

s＝１

elseif date＝＝３\|\|date＝＝２３

s＝２

设置底层

textchar ８ ＝ days dow ０

textchar ９ ＝ days dow １

textchar １０ ＝ days dow ２

textchar １１ ＝ \' \'

textchar １２ ＝buffer ０

textchar １３ ＝buffer １

textchar １４ ＝ suffix s ０

textchar １５ ＝ suffix s １

bytex ＝０

bytey ＝０

打印每个字符

for bytex＝０ x ８ x++

ht１６３２_putchar x∗６ ０ textchar x

ht１６３２_putchar x∗６ ８ textchar x＋８

delay ５０

[]{#index_split_000.html#p75}![index-75_1.png](https://i.imgur.com/xdZjQmE.jpeg){.calibre2}

![index-75_2.png](https://i.imgur.com/ECADmua.jpeg){.calibre2}

![index-75_3.png](https://i.imgur.com/Wb7Czh5.jpeg){.calibre2}

![index-75_4.png](https://i.imgur.com/8j6Pgfy.jpeg){.calibre2}

![index-75_5.png](https://i.imgur.com/QwE85s2.jpeg){.calibre2}

![index-75_6.png](https://i.imgur.com/4rlrrbq.jpeg){.calibre2}

![index-75_7.png](https://i.imgur.com/jAczEvu.jpeg){.calibre2}

![index-75_8.png](https://i.imgur.com/ykNHGeg.jpeg){.calibre2}

![index-75_9.png](https://i.imgur.com/neV1H8c.jpeg){.calibre2}

![index-75_10.png](https://i.imgur.com/LyRhzcu.jpeg){.calibre2}

![index-75_11.png](https://i.imgur.com/dvjLqry.jpeg){.calibre2}

６４

fade_down

４．主程序模块

１)功能介绍

本部分是实现产品的主程序模块,实现了本产品的主要功能.

２)相关代码

＃include ht１６３２c敭h

ht１６３２c库文件

＃include avr pgmspace敭h

＃include Font敭h

字体文件

＃include Wire敭h

＃include＂RTClib敭h＂

时钟芯片库文件

＃include Button敭h

处理按钮的库文件

定义变量

＃defineASSERT condition

断言

＃defineX_MAX４７

最大屏幕宽度

＃defineY_MAX１５

最大屏幕高度

＃defineNUM_DISPLAYS２

显示屏数量

＃defineFADEDELAY３０

＃defineNUM_MODES９

模式数量

＃defineNUM_SETTINGS_MODES５

菜单编号

＃defineNUM_DISPLAY_MODES４

显示模式数量

＃defineBAT１_X２

左边的球板

＃defineBAT２_X４５

右边的球板

＃defineplot x y v ht１６３２_plot x y v

放置点

＃defineclsht１６３２_clear

清屏

＃defineSLIDE_DELAY５

滑动延时

＃defineNEXT_DATE_MIN１０

下一个日期的最小值

＃defineNEXT_DATE_MAX１５

下一个日期的最大值

staticconstbyteht１６３２_data ＝１０

HT１６３２CLED的data引脚接Arduino开发板引脚１０

staticconstbyteht１６３２_wrclk ＝１１

HT１６３２CLED的write引脚接Arduino开发板引脚１１

staticconstbyteht１６３２_cs ２ ＝ ４

５

cs１、

cs２引脚接Arduino开发板引脚４、引脚５

ButtonbuttonA ＝ Button ２

BUTTON_PULLUP

按钮A接Arduino开发板引脚２

ButtonbuttonB ＝ Button ３

BUTTON_PULLUP

按钮B接Arduino开发板引脚３

RTC_DS１３０７ds１３０７

实例化DS１３０７

intrtc ７

存储从rtc读取的时间

byteclock_mode ＝０

当前的时钟模式

byteold_mode ＝ clock_mode

上一个时钟模式

boolampm ＝０

１２h制和２４h制的转换

boolrandom_mode ＝０

随机模式开关

booldaylight_mode ＝０

夏令时模式开关

bytechange_mode_time ＝０

是否到了改变模式的时间 随机模式用

bytebrightness ＝１５

亮度

[]{#index_split_000.html#p76}![index-76_1.png](https://i.imgur.com/0vAM0Rp.jpeg){.calibre2}

６５

bytenext_display_date

下一个显示是日期

chardays ７ ４ ＝

＂Sun＂

＂Mon＂

＂Tue＂ ＂Wed＂ ＂Thu＂ ＂Fri＂ ＂Sat＂

chardaysfull ７ ９ ＝ ＂Sunday＂ ＂Monday＂ ＂Tuesday＂ ＂Wed＂ ＂Thursday＂ ＂Friday＂ ＂Saturday＂

charsuffix ４ ３ ＝ ＂st＂ ＂nd＂ ＂rd＂ ＂th＂

voidsetup

digitalWrite ２ HIGH

digitalWrite ３ HIGH

初始化ht１６３２c

Serial敭

begin ５７６００

ht１６３２_setup

randomSeed analogRead １

ht１６３２_sendcmd ０ HT１６３２_CMD_PWM＋ brightness ht１６３２_sendcmd １ HT１６３２_CMD_PWM＋ brightness 初始化DS１３０７

＃ifdefAVR

Wire敭

begin

＃else

Wire１敭

begin

＃endif

ds１３０７敭begin

if ds１３０７敭

isrunning

Serial敭println ＂RTCisNOTrunning

＂

ds１３０７敭adjust DateTime \_\_DATE\_\_ \_\_TIME\_\_

启动界面显示

printver

voidloop

switch clock_mode

case０

normal

break

case１

pong

break

case２

digits

break

case３

word_clock

break

case４

slide

[]{#index_split_000.html#p77}![index-77_1.png](https://i.imgur.com/kUJfBM5.jpeg){.calibre2}

![index-77_2.png](https://i.imgur.com/p0H67x1.jpeg){.calibre2}

![index-77_3.png](https://i.imgur.com/DwEx7DF.jpeg){.calibre2}

![index-77_4.png](https://i.imgur.com/4VitjJA.jpeg){.calibre2}

![index-77_5.png](https://i.imgur.com/DKAdyhB.jpeg){.calibre2}

![index-77_6.png](https://i.imgur.com/W7Rsrsv.jpeg){.calibre2}

![index-77_7.png](https://i.imgur.com/Cv6M53x.jpeg){.calibre2}

６６

break

case５

setup_menu

break

∗∗∗∗∗∗∗∗∗HT１６３２C相关处理∗∗∗∗∗∗∗∗

将cs选中 低电平有效

voidht１６３２_chipselect bytechipno

DEBUGPRINT ＂\\nHT１６３２ ％d ＂ chipno

digitalWrite chipno ０

Serial敭

println ＂selectingadisplay＂

解除cs选中

voidht１６３２_chipfree bytechipno

DEBUGPRINT ＂ done％d ＂ chipno

digitalWrite chipno １

Serial敭

println ＂chipfreeing＂

写入地址数据信息 参考说明书

voidht１６３２_writebits bytebits bytefirstbit DEBUGPRINT ＂＂

Serial敭

println ＂writing＂

while firstbit

DEBUGPRINT bits&firstbit

＂１＂

＂０＂

digitalWrite ht１６３２_wrclk LOW

if bits&firstbit

digitalWrite ht１６３２_data HIGH

else

digitalWrite ht１６３２_data LOW

digitalWrite ht１６３２_wrclk HIGH

firstbit ＝１

发送命令

staticvoidht１６３２_sendcmd byted bytecommand ht１６３２_chipselect ht１６３２_cs d

ht１６３２_writebits HT１６３２_ID_CMD １ ２

ht１６３２_writebits command １ ７

ht１６３２_writebits ０ １

ht１６３２_chipfree ht１６３２_cs d

[]{#index_split_000.html#p78}![index-78_1.png](https://i.imgur.com/wgd6Bjz.jpeg){.calibre2}

![index-78_2.png](https://i.imgur.com/7WZLlLv.jpeg){.calibre2}

![index-78_3.png](https://i.imgur.com/R11doeF.jpeg){.calibre2}

![index-78_4.png](https://i.imgur.com/yjdjlad.jpeg){.calibre2}

![index-78_5.png](https://i.imgur.com/4Oonniy.jpeg){.calibre2}

![index-78_6.png](https://i.imgur.com/KCudNK0.jpeg){.calibre2}

![index-78_7.png](https://i.imgur.com/b6Ay9De.jpeg){.calibre2}

![index-78_8.png](https://i.imgur.com/iO6jTBN.jpeg){.calibre2}

![index-78_9.png](https://i.imgur.com/5PZELyA.jpeg){.calibre2}

![index-78_10.png](https://i.imgur.com/wLYxNfJ.jpeg){.calibre2}

![index-78_11.png](https://i.imgur.com/ykmHpg8.jpeg){.calibre2}

![index-78_12.png](https://i.imgur.com/H7AuydT.jpeg){.calibre2}

![index-78_13.png](https://i.imgur.com/mhJ1b3S.jpeg){.calibre2}

![index-78_14.png](https://i.imgur.com/xVG3hQJ.jpeg){.calibre2}

![index-78_15.png](https://i.imgur.com/gxMqtt6.jpeg){.calibre2}

![index-78_16.png](https://i.imgur.com/jykQrls.jpeg){.calibre2}

![index-78_17.png](https://i.imgur.com/QjvAP7y.jpeg){.calibre2}

![index-78_18.png](https://i.imgur.com/9MFTt7G.jpeg){.calibre2}

[]{#index_split_001.html}

![index-78_19.png](https://i.imgur.com/F2M3H2F.jpeg){.calibre2}

![index-78_20.png](https://i.imgur.com/Rze07x5.jpeg){.calibre2}

![index-78_21.png](https://i.imgur.com/CKMZ2Ax.jpeg){.calibre2}

![index-78_22.png](https://i.imgur.com/Pll8XPw.jpeg){.calibre2}

![index-78_23.png](https://i.imgur.com/avEU0Aa.jpeg){.calibre2}

６７

Serial敭println ＂writing＂

发送数据

staticvoidht１６３２_senddata byted byteaddress bytedata ht１６３２_chipselect ht１６３２_cs d

ht１６３２_writebits HT１６３２_ID_WR １ ２

ht１６３２_writebits address １ ６

ht１６３２_writebits data １ ３

ht１６３２_chipfree ht１６３２_cs d

初始化HT１６３２C

voidht１６３２_setup

for byted＝０ d NUM_DISPLAYS d++

pinMode ht１６３２_cs d OUTPUT

digitalWrite ht１６３２_cs d HIGH

pinMode ht１６３２_wrclk OUTPUT

pinMode ht１６３２_data OUTPUT

ht１６３２_sendcmd d HT１６３２_CMD_SYSON

ht１６３２_sendcmd d HT１６３２_CMD_LEDON

ht１６３２_sendcmd d HT１６３２_CMD_COMS０１

for bytei＝０ i １２８ i++

ht１６３２_senddata d i ０

定义sram的大小

byteht１６３２_shadowram NUM_DISPLAYS∗９６

放置一个点

voidht１６３２_plot charx chary charval

charaddr bitval

ASSERT x ＝０

ASSERT x ＝ X_MAX

ASSERT y ＝０

ASSERT y ＝ y_MAX

byted

if x ＝０&&x ＝２３

d＝０

if x ＝２４&&x ＝４７

d＝１

x＝ x－２４

bitval＝８ y&３

addr ＝ x ２ ＋ y ２

if val

[]{#index_split_001.html#p79}![index-79_1.png](https://i.imgur.com/HpasxqJ.jpeg){.calibre2}

![index-79_2.png](https://i.imgur.com/CMevCVF.jpeg){.calibre2}

![index-79_3.png](https://i.imgur.com/P0X8rPO.jpeg){.calibre2}

![index-79_4.png](https://i.imgur.com/WJm4I6f.jpeg){.calibre2}

![index-79_5.png](https://i.imgur.com/5uYjxh1.jpeg){.calibre2}

![index-79_6.png](https://i.imgur.com/K6NlIVp.jpeg){.calibre2}

![index-79_7.png](https://i.imgur.com/N9CH2fN.jpeg){.calibre2}

![index-79_8.png](https://i.imgur.com/HWdZRi8.jpeg){.calibre2}

![index-79_9.png](https://i.imgur.com/0BqTgRz.jpeg){.calibre2}

![index-79_10.png](https://i.imgur.com/pGMeC7f.jpeg){.calibre2}

![index-79_11.png](https://i.imgur.com/jqGT0P3.jpeg){.calibre2}

![index-79_12.png](https://i.imgur.com/QnQg6BM.jpeg){.calibre2}

![index-79_13.png](https://i.imgur.com/j7G0T19.jpeg){.calibre2}

![index-79_14.png](https://i.imgur.com/t6nsMRH.jpeg){.calibre2}

![index-79_15.png](https://i.imgur.com/gF1hSqL.jpeg){.calibre2}

![index-79_16.png](https://i.imgur.com/q9UTZot.jpeg){.calibre2}

![index-79_17.png](https://i.imgur.com/uzXW8Ul.jpeg){.calibre2}

![index-79_18.png](https://i.imgur.com/hrJCr37.jpeg){.calibre2}

![index-79_19.png](https://i.imgur.com/sHQzH5m.jpeg){.calibre2}

![index-79_20.png](https://i.imgur.com/54hTu1r.jpeg){.calibre2}

![index-79_21.png](https://i.imgur.com/AIOWyWT.jpeg){.calibre2}

![index-79_22.png](https://i.imgur.com/BzPZ2gH.jpeg){.calibre2}

![index-79_23.png](https://i.imgur.com/TLL0WMz.jpeg){.calibre2}

６８

ht１６３２_shadowram d∗９６ ＋ addr \|＝ bitval else

ht１６３２_shadowram d∗９６ ＋ addr &＝\~bitval ht１６３２_senddata d addr ht１６３２_shadowram d∗９６ ＋ addr byteget_shadowram bytex bytey

byteaddr bitval d

if x ＝０&&x ＝２３

d＝０

if x ＝２４&&x ＝４７

d＝１

x＝ x－２４

bitval＝８ y&３

addr＝ x ２ ＋ y ２

return ０

＝ ht１６３２_shadowram d∗９６ ＋ addr &bitval voidsnapshot_shadowram

for bytei＝０ i sizeofht１６３２_shadowram i++

ht１６３２_shadowram i ＝ ht１６３２_shadowram i &０x０F \|ht１６３２_shadowram i ４

byteget_snapshotram bytex bytey

byteaddr bitval

byted ＝０

if x ＝２４&&x ＝４７

d＝１

x＝ x－２４

bitval＝１２８ y&３

addr＝ x ２ ＋ y ２

if ht１６３２_shadowram d∗９６ ＋ addr &bitval return１

return０

清屏

voidht１６３２_clear

chari

for byted＝０ d NUM_DISPLAYS d++

[]{#index_split_001.html#p80}![index-80_1.png](https://i.imgur.com/iCrmdbk.jpeg){.calibre2}

![index-80_2.png](https://i.imgur.com/XlvCwGn.jpeg){.calibre2}

![index-80_3.png](https://i.imgur.com/58CoWQi.jpeg){.calibre2}

![index-80_4.png](https://i.imgur.com/xaeyQIB.jpeg){.calibre2}

![index-80_5.png](https://i.imgur.com/SGfiMOl.jpeg){.calibre2}

![index-80_6.png](https://i.imgur.com/WaaAdgB.jpeg){.calibre2}

![index-80_7.png](https://i.imgur.com/xHO4GbF.jpeg){.calibre2}

![index-80_8.png](https://i.imgur.com/p6HbMy3.jpeg){.calibre2}

![index-80_9.png](https://i.imgur.com/i0aWoxj.jpeg){.calibre2}

![index-80_10.png](https://i.imgur.com/5p102xI.jpeg){.calibre2}

![index-80_11.png](https://i.imgur.com/vH9stkX.jpeg){.calibre2}

![index-80_12.png](https://i.imgur.com/OeyZBdP.jpeg){.calibre2}

![index-80_13.png](https://i.imgur.com/O4e84w0.jpeg){.calibre2}

![index-80_14.png](https://i.imgur.com/B43LGFd.jpeg){.calibre2}

![index-80_15.png](https://i.imgur.com/Hb8ZGXN.jpeg){.calibre2}

![index-80_16.png](https://i.imgur.com/8itVwUA.jpeg){.calibre2}

![index-80_17.png](https://i.imgur.com/I8uOwvm.jpeg){.calibre2}

６９

ht１６３２_chipselect ht１６３２_cs d

ht１６３２_writebits HT１６３２_ID_WR １ ２

ht１６３２_writebits ０ １ ６

for i＝０ i ９６ ２ i++

ht１６３２_writebits ０ １ ７

ht１６３２_chipfree ht１６３２_cs d

for i＝０ i ９６ i++

ht１６３２_shadowram ９６∗d＋ i ＝０

按亮度逐渐减弱

voidfade_down

charintensity

for intensity＝brightness intensity ＝０ intensity－－

ht１６３２_sendcmd ０ HT１６３２_CMD_PWM＋ intensity ht１６３２_sendcmd １ HT１６３２_CMD_PWM＋ intensity delay FADEDELAY

cls

ht１６３２_sendcmd ０ HT１６３２_CMD_PWM＋ brightness ht１６３２_sendcmd １ HT１６３２_CMD_PWM＋ brightness 按亮度逐渐增强

voidfade_up

charintensity

for intensity＝０ intensity brightness intensity++

ht１６３２_sendcmd ０ HT１６３２_CMD_PWM＋ intensity ht１６３２_sendcmd １ HT１６３２_CMD_PWM＋ intensity delay FADEDELAY

放置５×７的字符

voidht１６３２_putchar bytex bytey charc

bytedots

if c ＝ \'A\'&&c ＝ \'Z\'

c&＝０x１F

elseif c ＝ \'a\'&&c ＝ \'z\'

c＝ c－ \'a\' ＋４１

elseif c ＝ \'０\'&&c ＝ \'９\'

c＝ c－ \'０\' ＋３１

elseif c＝＝ \' \'

c＝０

[]{#index_split_001.html#p81}![index-81_1.png](https://i.imgur.com/s2cvWGH.jpeg){.calibre2}

![index-81_2.png](https://i.imgur.com/zEGvb7G.jpeg){.calibre2}

![index-81_3.png](https://i.imgur.com/nWq4KYZ.jpeg){.calibre2}

![index-81_4.png](https://i.imgur.com/xlrZfdy.jpeg){.calibre2}

![index-81_5.png](https://i.imgur.com/Uh06RIZ.jpeg){.calibre2}

![index-81_6.png](https://i.imgur.com/x51KAJa.jpeg){.calibre2}

![index-81_7.png](https://i.imgur.com/nzhkCtY.jpeg){.calibre2}

![index-81_8.png](https://i.imgur.com/skPvq58.jpeg){.calibre2}

![index-81_9.png](https://i.imgur.com/3njeyri.jpeg){.calibre2}

![index-81_10.png](https://i.imgur.com/v9nnaB9.jpeg){.calibre2}

![index-81_11.png](https://i.imgur.com/vRDWGJP.jpeg){.calibre2}

![index-81_12.png](https://i.imgur.com/gghoJ2U.jpeg){.calibre2}

![index-81_13.png](https://i.imgur.com/jCqVWtt.jpeg){.calibre2}

![index-81_14.png](https://i.imgur.com/Q0XmDn0.jpeg){.calibre2}

![index-81_15.png](https://i.imgur.com/EXKseEG.jpeg){.calibre2}

![index-81_16.png](https://i.imgur.com/TD3RTza.jpeg){.calibre2}

![index-81_17.png](https://i.imgur.com/uUKzZTg.jpeg){.calibre2}

![index-81_18.png](https://i.imgur.com/WlekSI9.jpeg){.calibre2}

![index-81_19.png](https://i.imgur.com/W2ikVbr.jpeg){.calibre2}

![index-81_20.png](https://i.imgur.com/4ucLbJ4.jpeg){.calibre2}

![index-81_21.png](https://i.imgur.com/qWEuUKN.jpeg){.calibre2}

![index-81_22.png](https://i.imgur.com/QV5R9dQ.jpeg){.calibre2}

７０

elseif c＝＝ \'敭\'

c＝２７

elseif c＝＝ \'\\\' \'

c＝２８

elseif c＝＝ \' \'

c＝２９

elseif c＝＝ \' \'

c＝３０

elseif c ＝－８０&&c ＝－６７

c∗＝－１

for charcol＝０ col ５ col++

dots＝ pgm_read_byte_near &myfont c col for charrow＝０ row ７ row++

if x ＝０ && x ＝ X_MAX && y ＝０ && y ＝ Y_MAX

if dots& ６４ row

plot x＋col y＋row １

else

plot x＋col y＋row ０

放置８×１０的字符

voidht１６３２_putbigchar bytex bytey charc bytedots

if c ＝ \'A\'&&c ＝ \'Z\'\|\| c ＝ \'a\'&&c ＝ \'z\'

return

if c ＝ \'０\'&&c ＝ \'９\'

c＝ c－ \'０\'

c&＝０x１F

for bytecol＝０ col １０ col++

dots＝ pgm_read_byte_near &mybigfont c col for charrow＝０ row ８ row++

if dots& １２８ row

plot x＋col y＋row １

else

plot x＋col y＋row ０

[]{#index_split_001.html#p82}![index-82_1.png](https://i.imgur.com/N3N5kgH.jpeg){.calibre2}

![index-82_2.png](https://i.imgur.com/gQknl3B.jpeg){.calibre2}

![index-82_3.png](https://i.imgur.com/WEjjSvT.jpeg){.calibre2}

![index-82_4.png](https://i.imgur.com/lL3UKfe.jpeg){.calibre2}

![index-82_5.png](https://i.imgur.com/8u6J5pF.jpeg){.calibre2}

![index-82_6.png](https://i.imgur.com/astjlgP.jpeg){.calibre2}

![index-82_7.png](https://i.imgur.com/ROqjUTI.jpeg){.calibre2}

![index-82_8.png](https://i.imgur.com/3J9yIeK.jpeg){.calibre2}

![index-82_9.png](https://i.imgur.com/3E5OySP.jpeg){.calibre2}

![index-82_10.png](https://i.imgur.com/1VIFtQC.jpeg){.calibre2}

![index-82_11.png](https://i.imgur.com/a36djAa.jpeg){.calibre2}

![index-82_12.png](https://i.imgur.com/YXZhyzy.jpeg){.calibre2}

![index-82_13.png](https://i.imgur.com/6gUiobq.jpeg){.calibre2}

![index-82_14.png](https://i.imgur.com/HDgVDkc.jpeg){.calibre2}

７１

dots＝ pgm_read_byte_near &mybigfont c col＋１０

for charrow＝０ row ８ row++

if dots& １２８ row

plot x＋col y＋row＋８ １

else

plot x＋col y＋row＋８ ０

放置３×５的字符

voidht１６３２_puttinychar bytex bytey charc bytedots

if c ＝ \'A\'&&c ＝ \'Z\'\|\| c ＝ \'a\'&&c ＝ \'z\'

c&＝０x１F

elseif c ＝ \'０\'&&c ＝ \'９\'

c＝ c－ \'０\' ＋３１

elseif c＝＝ \' \'

c＝０

elseif c＝＝ \'敭\'

c＝２７

elseif c＝＝ \'\\\' \'

c＝２８

elseif c＝＝ \' \'

c＝２９

elseif c＝＝ \' \'

c＝３０

for bytecol＝０ col ３ col++

dots＝ pgm_read_byte_near &mytinyfont c col for charrow＝０ row ５ row++

if dots& １６ row

plot x＋col y＋row １

else

plot x＋col y＋row ０

∗∗∗∗∗∗∗∗∗显示模式函数∗∗∗∗∗∗∗∗

数字显示模式

voiddigits

[]{#index_split_001.html#p83}![index-83_1.png](https://i.imgur.com/lwlopRl.jpeg){.calibre2}

![index-83_2.png](https://i.imgur.com/jnXrm4l.jpeg){.calibre2}

![index-83_3.png](https://i.imgur.com/av0Gqqs.jpeg){.calibre2}

７２

清屏

cls

charbuffer ３

byteoffset ＝０

bytex

y

１２h和２４h制的调整

bytehours ＝ rtc ２

if hours １２

hours＝ hours－ ampm∗１２

if hours １

hours＝ hours＋ ampm∗１２

set_next_date

bytesecs ＝１００

bytemins ＝１００

intcount ＝０

当没有到达随机模式变化时间点时显示以下代码

while run_mode

get_time

按A键进入设置

if buttonA敭

uniquePress

switch_mode

return

按B键显示日期

if buttonB敭

uniquePress

display_date

fade_down

return

检查此时是否到了下一个日期

check_show_date

检查秒数变动并更新显示

if secs

＝ rtc ０

secs＝ rtc ０

plot ２３－ offset

４

１

plot ２３－ offset

５

１

plot ２４－ offset

４

１

plot ２４－ offset

５

１

plot ２３－ offset

１０

１

plot ２３－ offset

１１

１

plot ２４－ offset

１０

１

plot ２４－ offset

１１

１

count＝４００

[]{#index_split_001.html#p84}![index-84_1.png](https://i.imgur.com/NODNJ5P.jpeg){.calibre2}

![index-84_2.png](https://i.imgur.com/6OBNh5W.jpeg){.calibre2}

![index-84_3.png](https://i.imgur.com/os6lPU9.jpeg){.calibre2}

![index-84_4.png](https://i.imgur.com/wknEFCA.jpeg){.calibre2}

![index-84_5.png](https://i.imgur.com/8n8srh3.jpeg){.calibre2}

![index-84_6.png](https://i.imgur.com/EAHKgk5.jpeg){.calibre2}

７３

if count＝＝０

plot ２３－ offset

４

０

plot ２３－ offset

５

０

plot ２４－ offset

４

０

plot ２４－ offset

５

０

plot ２３－ offset

１０

０

plot ２３－ offset

１１

０

plot ２４－ offset

１０

０

plot ２４－ offset

１１

０

else

count－－

检查分钟 小时变动并更新显示

if mins

＝ rtc １

mins＝ rtc １

hours＝ rtc ２

if hours １２

hours＝ hours－ ampm∗１２

if hours １

hours＝ hours＋ ampm∗１２

itoa hours buffer

１０

if hours １０

buffer １ ＝buffer ０

buffer ０ ＝ \'０\'

if ampm&&hours １０

offset＝５

if hours＝＝１&&mins＝＝０

cls

else

offset＝０

if hours＝＝１０&&mins＝＝０

cls

显示小时

ht１６３２_putbigchar ０ １ buffer ０

ht１６３２_putbigchar １２－ offset １ buffer １

itoa mins buffer １０

if mins １０

buffer １ ＝buffer ０

buffer ０ ＝ \'０\'

[]{#index_split_001.html#p85}![index-85_1.png](https://i.imgur.com/VXa9DUP.jpeg){.calibre2}

![index-85_2.png](https://i.imgur.com/kjczPkS.jpeg){.calibre2}

![index-85_3.png](https://i.imgur.com/V2aRDd8.jpeg){.calibre2}

７４

ht１６３２_putbigchar ２６－ offset １ buffer ０

ht１６３２_putbigchar ３８－ offset １ buffer １

fade_down

乒乓球显示模式

voidpong

floatballpos_x ballpos_y

球的当前位置

byteerase_x ＝１０

byteerase_y ＝１０

floatballvel_x ballvel_y

球速或者球的方向

intbat１_y ＝５

球拍位置X

intbat２_y ＝５

球拍位置Y

intbat１_target_y ＝５

球拍目标位置X

intbat２_target_y ＝５

球拍目标位置Y

bytebat１_update ＝１

bytebat２_update ＝１

bytebat１miss bat２miss

是否掉球

byterestart ＝１

bytebat_start_range

bytebat_end_range

pong_setup

while run_mode

if buttonA敭

uniquePress

switch_mode

return

if buttonB敭

uniquePress

display_date

fade_down

return

if restart

if check_show_date

pong_setup

plot erase_x erase_y ０

bytemins ＝ rtc １

bytehours ＝ rtc ２

if hours １２

hours＝ hours－ ampm∗１２

if hours １

hours＝ hours＋ ampm∗１２

[]{#index_split_001.html#p86}![index-86_1.png](https://i.imgur.com/oUbDLRS.jpeg){.calibre2}

![index-86_2.png](https://i.imgur.com/drHjG8X.jpeg){.calibre2}

![index-86_3.png](https://i.imgur.com/XOdBL0z.jpeg){.calibre2}

![index-86_4.png](https://i.imgur.com/Fe1BSM2.jpeg){.calibre2}

![index-86_5.png](https://i.imgur.com/P5iYNeg.jpeg){.calibre2}

![index-86_6.png](https://i.imgur.com/jwV21GC.jpeg){.calibre2}

７５

charbuffer ３

itoa hours

buffer

１０

if hours １０

buffer １ ＝buffer ０

buffer ０ ＝ \'０\'

ht１６３２_puttinychar １４ ０ buffer ０

ht１６３２_puttinychar １８ ０ buffer １

itoa mins

buffer

１０

if mins １０

buffer １ ＝buffer ０

buffer ０ ＝ \'０\'

ht１６３２_puttinychar ２８ ０ buffer ０

ht１６３２_puttinychar ３２ ０ buffer １

ballpos_x ＝２３

ballpos_y ＝random ４

１２

if random ０

２ ０

ballvel_x＝１

else

ballvel_x＝－１

if random ０

２ ０

ballvel_y＝０敭

５

else

ballvel_y＝－０敭

５

bat１miss ＝０

bat２miss ＝０

restart ＝０

delay １０

get_time

if rtc ０ ＝＝５９&&rtc １ ５９

bat１miss＝１

if rtc ０ ＝＝５９&&rtc １ ＝＝５９

bat２miss＝１

if ballpos_x＝＝random ３０

４１

bat１_target_y＝ ballpos_y

if ballpos_x＝＝random ８

１９

bat２_target_y＝ ballpos_y

[]{#index_split_001.html#p87}![index-87_1.png](https://i.imgur.com/apkkjME.jpeg){.calibre2}

![index-87_2.png](https://i.imgur.com/Izq60K0.jpeg){.calibre2}

![index-87_3.png](https://i.imgur.com/ezvKQku.jpeg){.calibre2}

![index-87_4.png](https://i.imgur.com/yQKOBo9.jpeg){.calibre2}

![index-87_5.png](https://i.imgur.com/7EK5JaT.jpeg){.calibre2}

![index-87_6.png](https://i.imgur.com/LgkIJ82.jpeg){.calibre2}

![index-87_7.png](https://i.imgur.com/hmgbhO2.jpeg){.calibre2}

![index-87_8.png](https://i.imgur.com/9Xm5Dfz.jpeg){.calibre2}

![index-87_9.png](https://i.imgur.com/jjXJ5gY.jpeg){.calibre2}

７６

if ballpos_x＝＝２３&&ballvel_x ０

byteend_ball_y ＝ pong_get_ball_endpoint ballpos_x ballpos_y ballvel_x ballvel_y if bat１miss＝＝１

bat１miss＝０

if end_ball_y ８

bat１_target_y＝random ０

３

else

bat１_target_y＝８＋random ０

３

else

if end_ball_y ＝５

bat_start_range＝０

else

bat_start_range＝ end_ball_y－５

if end_ball_y ＝１０

bat_end_range＝ end_ball_y

else

bat_end_range＝１０

bat１_target_y＝random bat_start_range bat_end_range＋１

if ballpos_x＝＝２５&&ballvel_x ０

byteend_ball_y ＝ pong_get_ball_endpoint ballpos_x ballpos_y ballvel_x ballvel_y if bat２miss＝＝１

bat２miss＝０

if end_ball_y ８

bat２_target_y＝random ０

３

else

bat２_target_y＝８＋random ０

３

else

if end_ball_y ＝５

bat_start_range＝０

else

bat_start_range＝ end_ball_y－５

if end_ball_y ＝１０

bat_end_range＝ end_ball_y

else

bat_end_range＝１０

[]{#index_split_001.html#p88}![index-88_1.png](https://i.imgur.com/Aihkg7P.jpeg){.calibre2}

![index-88_2.png](https://i.imgur.com/tEJB6OC.jpeg){.calibre2}

![index-88_3.png](https://i.imgur.com/NYrAlvP.jpeg){.calibre2}

![index-88_4.png](https://i.imgur.com/Ceyvq7h.jpeg){.calibre2}

![index-88_5.png](https://i.imgur.com/yBYLqWQ.jpeg){.calibre2}

![index-88_6.png](https://i.imgur.com/Dmhj84Y.jpeg){.calibre2}

![index-88_7.png](https://i.imgur.com/pMTkadC.jpeg){.calibre2}

![index-88_8.png](https://i.imgur.com/sDRf5dh.jpeg){.calibre2}

![index-88_9.png](https://i.imgur.com/caTpK4L.jpeg){.calibre2}

![index-88_10.png](https://i.imgur.com/us1uOri.jpeg){.calibre2}

![index-88_11.png](https://i.imgur.com/tmeblg0.jpeg){.calibre2}

![index-88_12.png](https://i.imgur.com/zoPd2cL.jpeg){.calibre2}

![index-88_13.png](https://i.imgur.com/opC13nd.jpeg){.calibre2}

![index-88_14.png](https://i.imgur.com/0SquYVX.jpeg){.calibre2}

![index-88_15.png](https://i.imgur.com/MQUlZpr.jpeg){.calibre2}

![index-88_16.png](https://i.imgur.com/L8cuZGZ.jpeg){.calibre2}

７７

bat２_target_y＝random bat_start_range bat_end_range＋１

if bat１_y bat１_target_y&&bat１_y ０

bat１_y－－

bat１_update＝１

if bat１_y bat１_target_y&&bat１_y １０

bat１_y++

bat１_update＝１

if bat１_update

for bytei＝０ i １６ i++

if i－ bat１_y ６&&i－ bat１_y －１

plot BAT１_X－１ i １

plot BAT１_X－２ i １

else

plot BAT１_X－１ i ０

plot BAT１_X－２ i ０

if bat２_y bat２_target_y&&bat２_y ０

bat２_y－－

bat２_update＝１

if bat２_y bat２_target_y&&bat２_y １０

bat２_y++

bat２_update＝１

if bat２_update

for bytei＝０ i １６ i++

if i－ bat２_y ６&&i－ bat２_y －１

plot BAT２_X＋１ i １

plot BAT２_X＋２ i １

else

plot BAT２_X＋１ i ０

plot BAT２_X＋２ i ０

ballpos_x＝ ballpos_x＋ ballvel_x

ballpos_y＝ ballpos_y＋ ballvel_y

if ballpos_y ＝０

ballvel_y＝ ballvel_y∗－１

[]{#index_split_001.html#p89}![index-89_1.png](https://i.imgur.com/xvAYPhT.jpeg){.calibre2}

![index-89_2.png](https://i.imgur.com/FGEW5km.jpeg){.calibre2}

![index-89_3.png](https://i.imgur.com/xU877bN.jpeg){.calibre2}

![index-89_4.png](https://i.imgur.com/RhtpmyM.jpeg){.calibre2}

![index-89_5.png](https://i.imgur.com/SoYAlEa.jpeg){.calibre2}

![index-89_6.png](https://i.imgur.com/JmJ7QSL.jpeg){.calibre2}

![index-89_7.png](https://i.imgur.com/90Cy6pj.jpeg){.calibre2}

![index-89_8.png](https://i.imgur.com/P6SrXQx.jpeg){.calibre2}

![index-89_9.png](https://i.imgur.com/3k2utq2.jpeg){.calibre2}

![index-89_10.png](https://i.imgur.com/9E2uQ8H.jpeg){.calibre2}

![index-89_11.png](https://i.imgur.com/v9iUL1M.jpeg){.calibre2}

![index-89_12.png](https://i.imgur.com/iXr1uB0.jpeg){.calibre2}

７８

ballpos_y＝０

if ballpos_y ＝１５

ballvel_y＝ ballvel_y∗－１

ballpos_y＝１５

if int ballpos_x＝＝ BAT１_X&& bat１_y ＝ int ballpos_y&& int ballpos_y ＝ bat１_y＋５

if

random ０

３

ballvel_x＝ ballvel_x∗－１

else

bat１_update＝１

byteflick

if bat１_y １\|\|bat１_y ８

flick＝random ０

２

if bat１_y ＝１

flick＝０

if bat１_y ＝８

flick＝１

switch flick

case０

bat１_target_y＝ bat１_target_y＋random １

３

ballvel_x＝ ballvel_x∗－１

if ballvel_y ２

ballvel_y＝ ballvel_y＋０敭

２

break

case１

bat１_target_y＝ bat１_target_y－random １

３

ballvel_x＝ ballvel_x∗－１

if ballvel_y ０敭

２

ballvel_y＝ ballvel_y－０敭

２

break

if int ballpos_x＝＝ BAT２_X&& bat２_y ＝ int ballpos_y&& int ballpos_y ＝ bat２_y＋５

if

random ０

３

ballvel_x＝ ballvel_x∗－１

else

bat１_update＝１

[]{#index_split_001.html#p90}![index-90_1.png](https://i.imgur.com/ajZ0KyZ.jpeg){.calibre2}

![index-90_2.png](https://i.imgur.com/sMfMc0N.jpeg){.calibre2}

![index-90_3.png](https://i.imgur.com/MdWKsPb.jpeg){.calibre2}

![index-90_4.png](https://i.imgur.com/yV1uI0l.jpeg){.calibre2}

![index-90_5.png](https://i.imgur.com/MIdbDRu.jpeg){.calibre2}

![index-90_6.png](https://i.imgur.com/UC2M9hg.jpeg){.calibre2}

![index-90_7.png](https://i.imgur.com/QGRS64F.jpeg){.calibre2}

７９

byteflick

if bat２_y １\|\|bat２_y ８

flick＝random ０

２

if bat２_y ＝１

flick＝０

if bat２_y ＝８

flick＝１

switch flick

case０

bat２_target_y＝ bat２_target_y＋random １

３

ballvel_x＝ ballvel_x∗－１

if ballvel_y ２

ballvel_y＝ ballvel_y＋０敭

２

break

case１

bat２_target_y＝ bat２_target_y－random １

３

ballvel_x＝ ballvel_x∗－１

if ballvel_y ０敭

２

ballvel_y＝ ballvel_y－０敭

２

break

byteplot_x ＝ int ballpos_x＋０敭

５f

byteplot_y ＝ int ballpos_y＋０敭

５f

snapshot_shadowram

if get_shadowram plot_x plot_y

plot erase_x erase_y ０

else

plot plot_x plot_y １

plot erase_x erase_y ０

erase_x＝ plot_x

erase_y＝ plot_y

if int ballpos_x＝＝０\|\| int ballpos_x＝＝４７

restart＝１

delay ２０

fade_down

[]{#index_split_001.html#p91}![index-91_1.png](https://i.imgur.com/9kXTpg6.jpeg){.calibre2}

![index-91_2.png](https://i.imgur.com/uhKspu4.jpeg){.calibre2}

![index-91_3.png](https://i.imgur.com/TWQSULA.jpeg){.calibre2}

![index-91_4.png](https://i.imgur.com/7AHegJo.jpeg){.calibre2}

![index-91_5.png](https://i.imgur.com/odfWyLy.jpeg){.calibre2}

![index-91_6.png](https://i.imgur.com/TtCV0ej.jpeg){.calibre2}

![index-91_7.png](https://i.imgur.com/4awBvcw.jpeg){.calibre2}

８０

获取乒乓球的结束位置 以便调整乒乓球台位置

bytepong_get_ball_endpoint floattempballpos_x floattempballpos_y floattempballvel_x floattempballvel_y

while tempballpos_x BAT１_X&&tempballpos_x BAT２_X

tempballpos_x＝ tempballpos_x＋ tempballvel_x tempballpos_y＝ tempballpos_y＋ tempballvel_y if tempballpos_y ＝０

tempballvel_y＝ tempballvel_y∗－１

tempballpos_y＝０

if tempballpos_y ＝１５

tempballvel_y＝ tempballvel_y∗－１

tempballpos_y＝１５

returntempballpos_y

进入乒乓球模式的引导界面

voidpong_setup

cls

bytei ＝０

charintro１ ６ ＝＂Ready＂

while intro１ i

delay ２５

ht１６３２_puttinychar i∗４ ＋１２ ４ intro１ i i++

for bytei＝０ i ２ i++

ht１６３２_puttinychar ３４ ４ \' \'

delay ２００

ht１６３２_puttinychar ３４ ４ \' \'

delay ４００

cls

i＝０

charintro２ １１ ＝＂PlayPong

＂

while intro２ i

ht１６３２_puttinychar i∗４ ＋６ ４ intro２ i i++

delay ８００

cls

get_time

byteoffset ＝random ０

２

for bytei＝０ i １６ i++

if i％２＝＝０

plot ２４ i＋offset １

[]{#index_split_001.html#p92}![index-92_1.png](https://i.imgur.com/Ca1BV0W.jpeg){.calibre2}

![index-92_2.png](https://i.imgur.com/sZ7gQXo.jpeg){.calibre2}

![index-92_3.png](https://i.imgur.com/CYXGgzS.jpeg){.calibre2}

![index-92_4.png](https://i.imgur.com/JCGz4Wt.jpeg){.calibre2}

８１

delay ３０

delay １２０

文字时钟

voidword_clock

cls

charnumbers １９ １０ ＝

＂one＂ ＂two＂ ＂three＂ ＂four＂

＂five＂

＂six＂

＂seven＂

＂eight＂

＂nine＂

＂ten＂

＂eleven＂

＂twelve＂ ＂thirteen＂

＂fourteen＂

＂fifteen＂

＂sixteen＂

＂seventeen＂

＂eighteen＂

＂nineteen＂

charnumberstens ５ ７ ＝

＂ten＂

＂twenty＂

＂thirty＂

＂forty＂

＂fifty＂

bytehours_y mins_y

bytehours ＝ rtc ２

if hours １２

hours＝ hours－ ampm∗１２

if hours １

hours＝ hours＋ ampm∗１２

get_time

byteold_mins ＝１００

bytemins

while run_mode

if buttonA敭

uniquePress

switch_mode

return

if buttonB敭

uniquePress

display_date

fade_down

return

get_time

mins＝ rtc １

if mins

＝ old_mins

old_mins＝ mins

mins＝ rtc １

hours＝ rtc ２

if hours １２

hours＝ hours－１２

if hours＝＝０

hours＝１２

[]{#index_split_001.html#p93}![index-93_1.png](https://i.imgur.com/sZSTu1K.jpeg){.calibre2}

![index-93_2.png](https://i.imgur.com/hVLMDc5.jpeg){.calibre2}

![index-93_3.png](https://i.imgur.com/6sUxycG.jpeg){.calibre2}

![index-93_4.png](https://i.imgur.com/uLqCyb5.jpeg){.calibre2}

８２

intminsdigit ＝ rtc １ ％１０

byteminsdigitten ＝ rtc １ １０ ％１０

charstr_top １２

charstr_bot １２

if mins １０

strcpy str_top numbers minsdigit－１

strcat str_top

＂PAST＂

strcpy str_bot numbers hours－１

if mins＝＝１０

strcpy str_top numbers ９

strcat str_top

＂PAST＂

strcpy str_bot numbers hours－１

elseif minsdigitten

＝０&&minsdigit

＝０

strcpy str_top numbers hours－１

if mins ＝１１&&mins ＝１９

strcpy str_bot numbers mins－１

else

strcpy str_bot numberstens minsdigitten－１

strcat str_bot ＂＂

strcat str_bot numbers minsdigit－１

elseif minsdigitten

＝０&&minsdigit ＝＝０

strcpy str_top numbers hours－１

strcpy str_bot numberstens minsdigitten－１

elseif minsdigitten＝＝０&&minsdigit＝＝０

strcpy str_top numbers hours－１

strcpy str_bot ＂O\'CLOCK＂

bytelen ＝０

while str_top len

len++

byteoffset_top ＝ X_MAX－ len－１ ∗４ ２

len＝０

while str_bot len

len++

byteoffset_bot ＝ X_MAX－ len－１ ∗４ ２

fade_down

bytei ＝０

while str_top i

ht１６３２_puttinychar i∗４ ＋ offset_top ２ str_top i

[]{#index_split_001.html#p94}![index-94_1.png](https://i.imgur.com/ofBnATw.jpeg){.calibre2}

![index-94_2.png](https://i.imgur.com/lLcB5WB.jpeg){.calibre2}

![index-94_3.png](https://i.imgur.com/j4TgYwx.jpeg){.calibre2}

８３

i++

i＝０

while str_bot i

ht１６３２_puttinychar i∗４ ＋ offset_bot ９ str_bot i i++

delay ５０

fade_down

正常显示

voidnormal

chartextchar １６

bytemins ＝１００

bytesecs ＝ rtc ０

byteold_secs ＝ secs

cls

while run_mode

get_time

if buttonA敭

uniquePress

switch_mode

return

if buttonB敭

uniquePress

display_date

fade_down

return

secs＝ rtc ０

if secs

＝ old_secs

charbuffer ３

itoa secs buffer

１０

if secs １０

buffer １ ＝buffer ０

buffer ０ ＝ \'０\'

ht１６３２_putchar ３０ ０ \' \'

ht１６３２_putchar ３６ ０ buffer ０

ht１６３２_putchar ４２ ０ buffer １

old_secs＝ secs

if mins

＝ rtc １

mins＝ rtc １

bytehours ＝ rtc ２

if hours １２

[]{#index_split_001.html#p95}![index-95_1.png](https://i.imgur.com/O9JDpaF.jpeg){.calibre2}

![index-95_2.png](https://i.imgur.com/NTSi94z.jpeg){.calibre2}

![index-95_3.png](https://i.imgur.com/mnUjFkk.jpeg){.calibre2}

![index-95_4.png](https://i.imgur.com/t0YpVTA.jpeg){.calibre2}

![index-95_5.png](https://i.imgur.com/QkLwJgm.jpeg){.calibre2}

![index-95_6.png](https://i.imgur.com/dwcL6H4.jpeg){.calibre2}

８４

hours＝ hours－ ampm∗１２

if hours １

hours＝ hours＋ ampm∗１２

bytedow ＝ rtc ３

bytedate ＝ rtc ４

charbuffer ３

itoa hours

buffer

１０

if hours １０

buffer １ ＝buffer ０

if ampm

buffer ０ ＝ \' \'

else

buffer ０ ＝ \'０\'

textchar ０ ＝buffer ０

textchar １ ＝buffer １

textchar ２ ＝ \' \'

itoa mins buffer １０

if mins １０

buffer １ ＝buffer ０

buffer ０ ＝ \'０\'

textchar ３ ＝buffer ０

textchar ４ ＝buffer １

textchar ５ ＝ \' \'

buffer ３

secs＝ rtc ０

itoa secs buffer

１０

if secs １０

buffer １ ＝buffer ０

buffer ０ ＝ \'０\'

textchar ６ ＝buffer ０

textchar ７ ＝buffer １

itoa date buffer １０

if date １０

buffer １ ＝buffer ０

buffer ０ ＝ \'０\'

bytes ＝３

if date＝＝１\|\|date＝＝２１\|\|date＝＝３１

s＝０

[]{#index_split_001.html#p96}![index-96_1.png](https://i.imgur.com/bIYLMWf.jpeg){.calibre2}

![index-96_2.png](https://i.imgur.com/qlxSDc7.jpeg){.calibre2}

８５

elseif date＝＝２\|\|date＝＝２２

s＝１

elseif date＝＝３\|\|date＝＝２３

s＝２

textchar ８ ＝ days dow ０

textchar ９ ＝ days dow １

textchar １０ ＝ days dow ２

textchar １１ ＝ \' \'

textchar １２ ＝buffer ０

textchar １３ ＝buffer １

textchar １４ ＝ suffix s ０

textchar １５ ＝ suffix s １

bytex ＝０

bytey ＝０

for bytex＝０ x ８ x++

ht１６３２_putchar x∗６ ０ textchar x

ht１６３２_putchar x∗６ ８ textchar x＋８

delay ５０

fade_down

滑动显示

voidslide

bytedigits_old ８ ＝

９９

９９

９９

９９

９９

９９

９９

９９

bytedigits_new ８

bytedigits_x\_pos ８ ＝

４２

３６

２４

１８

６

０

３０

２４

charold_char ２

charnew_char ２

charold_chars ６ ＝＂AAAAA＂

cls

ht１６３２_putchar １２ ０ \' \'

ht１６３２_putchar ３０ ０ \' \'

byteold_secs ＝ rtc ０

while run_mode

get_time

if buttonA敭

uniquePress

switch_mode

return

if buttonB敭

uniquePress

display_date

[]{#index_split_001.html#p97}![index-97_1.png](https://i.imgur.com/I4wabQz.jpeg){.calibre2}

![index-97_2.png](https://i.imgur.com/nCq4ra7.jpeg){.calibre2}

![index-97_3.png](https://i.imgur.com/bBRjluA.jpeg){.calibre2}

![index-97_4.png](https://i.imgur.com/PSVO5NB.jpeg){.calibre2}

![index-97_5.png](https://i.imgur.com/wnuO0AR.jpeg){.calibre2}

![index-97_6.png](https://i.imgur.com/BUl9VsJ.jpeg){.calibre2}

![index-97_7.png](https://i.imgur.com/SwIACto.jpeg){.calibre2}

![index-97_8.png](https://i.imgur.com/mSAu0Js.jpeg){.calibre2}

８６

fade_down

return

if rtc ０

＝ old_secs

old_secs＝ rtc ０

bytehours ＝ rtc ２

if hours １２

hours＝ hours－ ampm∗１２

if hours １

hours＝ hours＋ ampm∗１２

digits_new ０ ＝ rtc ０ ％１０

digits_new １ ＝ rtc ０ １０ ％１０

digits_new ２ ＝ rtc １ ％１０

digits_new ３ ＝ rtc １ １０ ％１０

digits_new ４ ＝ hours％１０

digits_new ５ ＝ hours １０ ％１０

digits_new ６ ＝ rtc ４ ％１０

digits_new ７ ＝ rtc ４ １０ ％１０

for bytei＝０ i ＝５ i++

if digits_old i

＝ digits_new i

for byteseq＝０ seq ＝８ seq++

itoa digits_old i old_char

１０

itoa digits_new i new_char

１０

if ampm&&i＝＝５

if digits_new ５ ＝＝０

new_char ０ ＝ \' \'

if digits_old ５ ＝＝０

old_char ０ ＝ \' \'

slideanim digits_x\_pos i

０

seq

old_char ０

new_char ０

delay SLIDE_DELAY

if digits_old ６

＝ digits_new ６ \|\| digits_old ７

＝ digits_new ７

for byteday_char＝０ day_char ＝２ day_char++

for byteseq＝０ seq ＝８ seq++

slideanim ６∗day_char

８

seq

old_chars day_char

days rtc ３ day_char

delay SLIDE_DELAY

old_chars day_char ＝ days rtc ３ day_char for bytei＝７ i ＝６ i－－

[]{#index_split_001.html#p98}![index-98_1.png](https://i.imgur.com/RzaagzC.jpeg){.calibre2}

![index-98_2.png](https://i.imgur.com/YqtB4G4.jpeg){.calibre2}

![index-98_3.png](https://i.imgur.com/ML6OTVz.jpeg){.calibre2}

![index-98_4.png](https://i.imgur.com/CMdPmKZ.jpeg){.calibre2}

![index-98_5.png](https://i.imgur.com/yaUSWrb.jpeg){.calibre2}

![index-98_6.png](https://i.imgur.com/gnZYBA6.jpeg){.calibre2}

![index-98_7.png](https://i.imgur.com/3hemlPv.jpeg){.calibre2}

![index-98_8.png](https://i.imgur.com/p2YNSk9.jpeg){.calibre2}

![index-98_9.png](https://i.imgur.com/p4Rr2Ig.jpeg){.calibre2}

![index-98_10.png](https://i.imgur.com/5HhqHLb.jpeg){.calibre2}

![index-98_11.png](https://i.imgur.com/luddK0t.jpeg){.calibre2}

![index-98_12.png](https://i.imgur.com/7zmHlB9.jpeg){.calibre2}

８７

if digits_old i

＝ digits_new i

for byteseq＝０ seq ＝８ seq++

itoa digits_old i old_char

１０

itoa digits_new i new_char

１０

slideanim digits_x\_pos i

８

seq

old_char ０

new_char ０

delay SLIDE_DELAY

bytes ＝３

bytedate ＝ rtc ４

if date＝＝１\|\|date＝＝２１\|\|date＝＝３１

s＝０

elseif date＝＝２\|\|date＝＝２２

s＝１

elseif date＝＝３\|\|date＝＝２３

s＝２

for bytesuffix_char＝０ suffix_char ＝１ suffix_char++

for byteseq＝０ seq ＝８ seq++

slideanim suffix_char∗６ ＋３６

８

seq

old_chars suffix_char＋３

suffix s suffix_char

delay SLIDE_DELAY

old_chars suffix_char＋３ ＝ suffix s suffix_char for bytei＝０ i ＝７ i++

digits_old i ＝ digits_new i

fade_down

单个字符滑动动画

voidslideanim bytex bytey bytesequence charcurrent_c charnew_c if sequence ７

bytedots

if current_c ＝ \'A\'&&current_c ＝ \'Z\'

current_c&＝０x１F

elseif current_c ＝ \'a\'&&current_c ＝ \'z\'

current_c＝ current_c－ \'a\' ＋４１

elseif current_c ＝ \'０\'&&current_c ＝ \'９\'

current_c＝ current_c－ \'０\' ＋３１

[]{#index_split_001.html#p99}![index-99_1.png](https://i.imgur.com/3Duipey.jpeg){.calibre2}

![index-99_2.png](https://i.imgur.com/noVoBEx.jpeg){.calibre2}

![index-99_3.png](https://i.imgur.com/uJDzvja.jpeg){.calibre2}

![index-99_4.png](https://i.imgur.com/pcx09DS.jpeg){.calibre2}

![index-99_5.png](https://i.imgur.com/XJJ2frW.jpeg){.calibre2}

![index-99_6.png](https://i.imgur.com/BX4912f.jpeg){.calibre2}

![index-99_7.png](https://i.imgur.com/C1VHKab.jpeg){.calibre2}

![index-99_8.png](https://i.imgur.com/6SH4lEh.jpeg){.calibre2}

![index-99_9.png](https://i.imgur.com/muonTX9.jpeg){.calibre2}

![index-99_10.png](https://i.imgur.com/8CdGx07.jpeg){.calibre2}

![index-99_11.png](https://i.imgur.com/cOeSgIj.jpeg){.calibre2}

![index-99_12.png](https://i.imgur.com/nkrZT39.jpeg){.calibre2}

![index-99_13.png](https://i.imgur.com/6J5DoOp.jpeg){.calibre2}

![index-99_14.png](https://i.imgur.com/sdSnnFF.jpeg){.calibre2}

![index-99_15.png](https://i.imgur.com/2VlEqan.jpeg){.calibre2}

![index-99_16.png](https://i.imgur.com/S3yeE9r.jpeg){.calibre2}

８８

elseif current_c＝＝ \' \'

current_c＝０

elseif current_c＝＝ \'敭\'

current_c＝２７

elseif current_c＝＝ \'\\\' \'

current_c＝２８

elseif current_c＝＝ \' \'

current_c＝２９

elseif current_c＝＝ \' \'

current_c＝３０

bytecurr_char_row_max＝６－sequence

bytestart_y ＝ sequence

for bytecurr_char_row＝０ curr_char_row ＝ curr_char_row_max curr_char_row++

for bytecol＝０ col ５ col++

dots＝ pgm_read_byte_near &myfont current_c col if dots& ６４ curr_char_row

plot x＋col y＋ start_y １

else

plot x＋col y＋ start_y ０

start_y++

if sequence ＝１&&sequence ＝７

for bytecol＝０ col ５ col++

plot x＋col y＋ sequence－１ ０

if sequence ＝２

bytedots

if new_c ＝ \'A\'&&new_c ＝ \'Z\'

new_c&＝０x１F

elseif new_c ＝ \'a\'&&new_c ＝ \'z\'

new_c＝ new_c－ \'a\' ＋４１

elseif new_c ＝ \'０\'&&new_c ＝ \'９\'

new_c＝ new_c－ \'０\' ＋３１

elseif new_c＝＝ \' \'

new_c＝０

[]{#index_split_001.html#p100}![index-100_1.png](https://i.imgur.com/tII3MAH.jpeg){.calibre2}

![index-100_2.png](https://i.imgur.com/dbjdXAu.jpeg){.calibre2}

![index-100_3.png](https://i.imgur.com/D7OvzMc.jpeg){.calibre2}

![index-100_4.png](https://i.imgur.com/8hAuhhT.jpeg){.calibre2}

![index-100_5.png](https://i.imgur.com/xDfk8es.jpeg){.calibre2}

![index-100_6.png](https://i.imgur.com/1AAMzEB.jpeg){.calibre2}

![index-100_7.png](https://i.imgur.com/pJKZm2B.jpeg){.calibre2}

８９

elseif new_c＝＝ \'敭\'

new_c＝２７

elseif new_c＝＝ \'\\\' \'

new_c＝２８

elseif new_c＝＝ \' \'

new_c＝２９

elseif new_c＝＝ \' \'

new_c＝３０

bytenewcharrowmin ＝６－ sequence－２

bytestart_y ＝０

for bytenewcharrow＝ newcharrowmin newcharrow ＝６ newcharrow++

for bytecol＝０ col ５ col++

dots＝ pgm_read_byte_near &myfont new_c col if dots& ６４ newcharrow

plot x＋col y＋ start_y １

else

plot x＋col y＋ start_y ０

start_y++

∗∗∗∗∗∗∗∗∗用于显示和处理的相关函数∗∗∗∗∗∗∗∗

当日期改变时显示下一个日期

boolcheck_show_date

if rtc １ ＝＝ next_display_date

fade_down

display_date

fade_down

set_next_date

return１

else

return０

设置下一个日期

voidset_next_date

get_time

next_display_date＝ rtc １ ＋random NEXT_DATE_MIN NEXT_DATE_MAX

if next_display_date ＝５９

next_display_date＝random NEXT_DATE_MIN NEXT_DATE_MAX

[]{#index_split_001.html#p101}![index-101_1.png](https://i.imgur.com/RdfWlhI.jpeg){.calibre2}

![index-101_2.png](https://i.imgur.com/BoG1Mlc.jpeg){.calibre2}

![index-101_3.png](https://i.imgur.com/4pKiQDS.jpeg){.calibre2}

９０

显示日期

voiddisplay_date

cls

bytedow ＝ rtc ３

bytedate ＝ rtc ４

bytemonth ＝ rtc ５ －１

charmonthnames １２ ９ ＝ ＂January＂ ＂February＂ ＂March＂ ＂April＂ ＂May＂ ＂June＂ ＂July＂

＂August＂ ＂Sept＂ ＂October＂ ＂November＂ ＂December＂

闪烁光标并显示

flashing_cursor ０

０

５

７

１

inti ＝０

while daysfull dow i

flashing_cursor i∗６

０

５

７

０

ht１６３２_putchar i∗６ ０ daysfull dow i i++

if buttonA敭uniquePress \|\|buttonB敭uniquePress return

if i∗６ ４８

flashing_cursor i∗６

０

５

７

１

else

delay ３００

flashing_cursor ０

８

５

７

０

charbuffer ３

itoa date

buffer

１０

bytes ＝３

if date＝＝１\|\|date＝＝２１\|\|date＝＝３１

s＝０

elseif date＝＝２\|\|date＝＝２２

s＝１

elseif date＝＝３\|\|date＝＝２３

s＝２

ht１６３２_putchar ０ ８ buffer ０

bytesuffixposx ＝６

if date ９

suffixposx＝１２

flashing_cursor ６

８

５

７

０

[]{#index_split_001.html#p102}![index-102_1.png](https://i.imgur.com/mPkHRSO.jpeg){.calibre2}

![index-102_2.png](https://i.imgur.com/PyCET3c.jpeg){.calibre2}

![index-102_3.png](https://i.imgur.com/6AoLt8b.jpeg){.calibre2}

![index-102_4.png](https://i.imgur.com/eSBAjwc.jpeg){.calibre2}

![index-102_5.png](https://i.imgur.com/wzd2ikH.jpeg){.calibre2}

![index-102_6.png](https://i.imgur.com/96GuIhi.jpeg){.calibre2}

![index-102_7.png](https://i.imgur.com/6FhPzE0.jpeg){.calibre2}

９１

ht１６３２_putchar ６ ８ buffer １

flashing_cursor suffixposx ８

５

７

０

ht１６３２_putchar suffixposx ８ suffix s ０

flashing_cursor suffixposx＋６

８

５

７

０

ht１６３２_putchar suffixposx＋６ ８ suffix s １

flashing_cursor suffixposx＋１２

８

５

７

１

cls

ht１６３２_putchar ０ ０ buffer ０

ht１６３２_putchar ６ ０ buffer １

ht１６３２_putchar suffixposx ０ suffix s ０

ht１６３２_putchar suffixposx＋６ ０ suffix s １

flashing_cursor suffixposx＋１２

０

５

７

０

i＝０

while monthnames month i

flashing_cursor i∗６

８

５

７

０

ht１６３２_putchar i∗６ ８ monthnames month i i++

if buttonA敭

uniquePress \|\|buttonB敭uniquePress

return

if i∗６ ４８

flashing_cursor i∗６

８

５

７

２

else

delay １０００

delay ３０００

画线

voidlevelbar bytexpos byteypos bytexbar byteybar for bytex＝０ x ＝ xbar x++

for bytey＝０ y ＝ ybar y++

plot x＋xpos y＋ypos １

闪烁光标

voidflashing_cursor bytexpos byteypos bytecursor_width bytecursor_height byterepeats for byter＝０ r ＝ repeats r++

for bytex＝０ x ＝ cursor_width x++

for bytey＝０ y ＝ cursor_height y++

plot x＋xpos y＋ypos １

[]{#index_split_001.html#p103}![index-103_1.png](https://i.imgur.com/E9gqaNA.jpeg){.calibre2}

![index-103_2.png](https://i.imgur.com/hIcbiHk.jpeg){.calibre2}

![index-103_3.png](https://i.imgur.com/5m8VLHF.jpeg){.calibre2}

![index-103_4.png](https://i.imgur.com/fYdOxVL.jpeg){.calibre2}

![index-103_5.png](https://i.imgur.com/qHulZxK.jpeg){.calibre2}

![index-103_6.png](https://i.imgur.com/Pskiedy.jpeg){.calibre2}

![index-103_7.png](https://i.imgur.com/5CUT9Cm.jpeg){.calibre2}

![index-103_8.png](https://i.imgur.com/Opjg5fL.jpeg){.calibre2}

９２

if repeats ０

delay ２００

else

delay ７０

for bytex＝０ x ＝ cursor_width x++

for bytey＝０ y ＝ cursor_height y++

plot x＋xpos y＋ypos ０

if repeats ０

delay ２００

按钮延迟

voidbutton_delay intwait

inti ＝０

while i wait

if buttonA敭

uniquePress \|\|buttonB敭uniquePress

return

delay １

i++

∗∗∗∗∗∗∗∗∗∗∗菜单相关操作∗∗∗∗∗∗∗∗∗∗∗

一级总菜单 改变模式或者进入设置

voidswitch_mode

记录当前模式以便回滚

old_mode ＝ clock_mode

定义模式

char∗ modes ＝

＂Normal＂ ＂Pong＂ ＂Digits＂ ＂Words＂ ＂Slide＂ ＂Setup＂

bytenext_clock_mode

bytefirstrun ＝１

等待按下按钮进入下一个菜单选项

for intcount＝０ count ３５ count++

if buttonA敭

uniquePress \|\|firstrun＝＝１

count＝０

cls

if firstrun＝＝０

clock_mode++

if clock_mode NUM_DISPLAY_MODES＋１

[]{#index_split_001.html#p104}![index-104_1.png](https://i.imgur.com/15qVNir.jpeg){.calibre2}

![index-104_2.png](https://i.imgur.com/A9EO93A.jpeg){.calibre2}

![index-104_3.png](https://i.imgur.com/TlFKq6E.jpeg){.calibre2}

![index-104_4.png](https://i.imgur.com/Cw6mRhV.jpeg){.calibre2}

![index-104_5.png](https://i.imgur.com/FY8yT01.jpeg){.calibre2}

９３

clock_mode＝０

charstr_top ９

charstr_bot ９

strcpy str_top ＂＂

strcat str_top modes clock_mode

next_clock_mode＝ clock_mode＋１

if next_clock_mode NUM_DISPLAY_MODES＋１

next_clock_mode＝０

打印菜单

strcpy str_bot ＂＂

strcat str_bot modes next_clock_mode

bytei ＝０

while str_top i

ht１６３２_putchar i∗６ ０ str_top i

i++

i＝０

while str_bot i

ht１６３２_putchar i∗６ ８ str_bot i

i++

firstrun＝０

delay ５０

二级设置菜单

voidsetup_menu

char∗ set_modes ＝ ＂GoBack＂ ＂Random＂ ＂２４Hour＂

＂SetClk＂ ＂Bright＂

＂DSTAdj＂

if ampm＝＝０

set_modes ２ ＝ ＂１２Hour＂

bytesetting_mode ＝０

bytenext_setting_mode

bytefirstrun ＝１

for intcount＝０ count ３５ count++

if buttonA敭

uniquePress \|\|firstrun＝＝１

count＝０

cls

if firstrun＝＝０

setting_mode++

if setting_mode NUM_SETTINGS_MODES

setting_mode＝０

[]{#index_split_001.html#p105}![index-105_1.png](https://i.imgur.com/pS5cMPR.jpeg){.calibre2}

![index-105_2.png](https://i.imgur.com/j6eBsAZ.jpeg){.calibre2}

![index-105_3.png](https://i.imgur.com/WQjqNT3.jpeg){.calibre2}

９４

charstr_top ９

charstr_bot ９

strcpy str_top ＂＂

strcat str_top set_modes setting_mode next_setting_mode ＝ setting_mode ＋１

if next_setting_mode NUM_SETTINGS_MODES

next_setting_mode＝０

strcpy str_bot ＂＂

strcat str_bot set_modes next_setting_mode bytei ＝０

while str_top i

ht１６３２_putchar i∗６ ０ str_top i

i++

i＝０

while str_bot i

ht１６３２_putchar i∗６ ８ str_bot i

i++

firstrun＝０

delay ５０

switch setting_mode

case０

break

case１

set_random

break

case２

set_ampm

break

case３

set_time

break

case４

set_brightness

break

case５

set_dst

break

clock_mode＝old_mode

设置是否开启夏令时

voidset_dst

[]{#index_split_001.html#p106}![index-106_1.png](https://i.imgur.com/PqsOcsU.jpeg){.calibre2}

![index-106_2.png](https://i.imgur.com/U6DAl0e.jpeg){.calibre2}

![index-106_3.png](https://i.imgur.com/UDAFAPV.jpeg){.calibre2}

９５

cls

chartext_a ９ ＝＂Daylight＂

chartext_b ９ ＝＂ModeOn＂

chartext_c ９ ＝＂ModeOff＂

bytei ＝０

get_time

bytehr ＝ rtc ２

if daylight_mode

daylight_mode＝０

if hr ０

hr－－

else

hr＝２３

while text_a i

ht１６３２_putchar i∗６ ０ text_a i

ht１６３２_putchar i∗６ ８ text_c i

i++

else

daylight_mode＝１

if hr ２３

hr++

else

hr＝０

while text_a i

ht１６３２_putchar i∗６ ０ text_a i

ht１６３２_putchar i∗６ ８ text_b i

i++

DateTimenow＝ ds１３０７敭now

ds１３０７敭adjust DateTime now敭year now敭month now敭day hr now敭minute now敭

second

delay １５００

进入下一个模式

byterun_mode

if random_mode

if change_mode_time＝＝ rtc ２

set_next_random

return０

return１

[]{#index_split_001.html#p107}![index-107_1.png](https://i.imgur.com/EHhhz3a.jpeg){.calibre2}

![index-107_2.png](https://i.imgur.com/Juzzq6b.jpeg){.calibre2}

９６

设置是否开启随机模式 每１h换一种模式

voidset_random

cls

chartext_a ９ ＝＂Random＂

chartext_b ９ ＝＂ModeOn＂

chartext_c ９ ＝＂ModeOff＂

bytei ＝０

if random_mode

random_mode＝０

while text_a i

ht１６３２_putchar i∗６ ０ text_a i

ht１６３２_putchar i∗６ ８ text_c i

i++

else

random_mode＝１

set_next_random

while text_a i

ht１６３２_putchar i∗６ ０ text_a i

ht１６３２_putchar i∗６ ８ text_b i

i++

delay １５００

设置下一个随机模式

voidset_next_random

get_time

change_mode_time＝ rtc ２ ＋random ２

５

if change_mode_time ２３

change_mode_time＝random １

４

clock_mode＝random ０ NUM_DISPLAY_MODES＋１

设置时间进制

voidset_ampm

ampm ＝ ampmÙ１

cls

chartext_a ８ ＝＂２４Hour＂

chartext_b ８ ＝＂１２Hour＂

bytei ＝０

if ampm＝＝０

while text_a i

ht１６３２_putchar i∗６ ＋３ ４ text_a i

i++

[]{#index_split_001.html#p108}![index-108_1.png](https://i.imgur.com/33C8NE1.jpeg){.calibre2}

![index-108_2.png](https://i.imgur.com/1cbjS5D.jpeg){.calibre2}

９７

else

while text_a i

ht１６３２_putchar i∗６ ＋３ ４ text_b i

i++

delay １５００

cls

设置亮度

voidset_brightness

cls

bytei ＝０

chartext ７ ＝＂Bright＂

while text i

ht１６３２_putchar i∗６ ＋６ ０ text i

i++

while

buttonA敭

uniquePress

levelbar １

８

brightness∗３

６

while buttonB敭

isPressed

if brightness＝＝１５

brightness＝０

cls

else

brightness++

i＝０

while text i

ht１６３２_putchar i∗６ ＋６ ０ text i

i++

levelbar １

８

brightness∗３

６

ht１６３２_sendcmd ０ HT１６３２_CMD_PWM＋ brightness ht１６３２_sendcmd １ HT１６３２_CMD_PWM＋ brightness delay １５０

打印版本信息

voidprintver

bytei ＝０

charver_top １６ ＝＂PongClock＂

charver_lower １６ ＝＂buptver敭

１＂

按列点亮全屏

for bytex＝０ x ４８ x++

[]{#index_split_001.html#p109}![index-109_1.png](https://i.imgur.com/sifpigy.jpeg){.calibre2}

![index-109_2.png](https://i.imgur.com/ULoYmul.jpeg){.calibre2}

![index-109_3.png](https://i.imgur.com/6mc7s5K.jpeg){.calibre2}

![index-109_4.png](https://i.imgur.com/uMSKl47.jpeg){.calibre2}

９８

for bytey＝０ y １６ y++

plot x y

１

delay １０００

fade_down

画外框

for bytex＝０ x ４８ x++

plot x

０

１

plot x

１５

１

for bytey＝０ y １５ y++

plot ０ y

１

plot ４７ y

１

显示字符串

while ver_top i

ht１６３２_puttinychar i∗４ ＋２ ２ ver_top i delay ３５

i++

i＝０

while ver_lower i

ht１６３２_puttinychar i∗４ ＋２ ９ ver_lower i delay ３５

i++

delay ４０００

fade_down

∗∗∗∗∗∗∗∗∗DS１３０７时间相关操作∗∗∗∗∗∗∗∗

设置时间模式

voidset_time

cls

get_time

byteset_min ＝ rtc １

byteset_hr ＝ rtc ２

byteset_date ＝ rtc ４

byteset_mnth ＝ rtc ５

intset_yr ＝ rtc ６

set_yr ＝ set_value ４ set_yr ２０１５ ２０２５

set_mnth ＝ set_value ３ set_mnth １ １２

set_date ＝ set_value ２ set_date １ ３１

set_hr ＝ set_value １ set_hr ０ ２３

set_min ＝ set_value ０ set_min ０ ５９

写入DS１３０７

ds１３０７敭

adjust DateTime set_yr set_mnth set_date set_hr set_min

[]{#index_split_001.html#p110}![index-110_1.png](https://i.imgur.com/neo81yx.jpeg){.calibre2}

![index-110_2.png](https://i.imgur.com/TEofxyu.jpeg){.calibre2}

９９

cls

具体设置项

intset_value bytemessage intcurrent_value intreset_value introllover_limit cls

charmessages ６ １７ ＝ ＂SetMins＂ ＂SetHour＂ ＂SetDay＂ ＂SetMnth＂ ＂SetYear＂

bytei ＝０

while messages message i

ht１６３２_putchar i∗６ ０ messages message i i++

charbuffer ５ ＝＂＂

itoa current_value

buffer

１０

ht１６３２_putchar ０ ８ buffer ０

ht１６３２_putchar ６ ８ buffer １

ht１６３２_putchar １２ ８ buffer ２

ht１６３２_putchar １８ ８ buffer ３

delay ３００

while

buttonA敭

uniquePress

while buttonB敭

isPressed

if current_value rollover_limit

current_value++

else

current_value＝ reset_value

itoa current_value buffer

１０

ht１６３２_putchar ０ ８ buffer ０

ht１６３２_putchar ６ ８ buffer １

ht１６３２_putchar １２ ８ buffer ２

ht１６３２_putchar １８ ８ buffer ３

delay １５０

returncurrent_value

从Ds１３０７获取时间

voidget_time

DateTimenow＝ ds１３０７敭now

rtc ６ ＝ now敭year

rtc ５ ＝ now敭month

rtc ４ ＝ now敭day

rtc ３ ＝ now敭dayOfWeek

rtc ２ ＝ now敭hour

rtc １ ＝ now敭minute

[]{#index_split_001.html#p111}![index-111_1.png](https://i.imgur.com/G1EhQ0H.jpeg){.calibre2}

![index-111_2.png](https://i.imgur.com/C1VlLjj.jpeg){.calibre2}

![index-111_3.png](https://i.imgur.com/nUSPLqn.jpeg){.calibre2}

![index-111_4.png](https://i.imgur.com/9kJ7cKg.jpeg){.calibre2}

![index-111_5.png](https://i.imgur.com/U5guMSr.jpeg){.calibre2}

１００

rtc ０ ＝ now敭

second

if rtc ０ ％２ ＝＝０

digitalWrite １３

HIGH

else

digitalWrite １３

LOW

Serial敭

print rtc ２

Serial敭

print ＂

＂

Serial敭

print rtc １

Serial敭

print ＂

＂

Serial敭

println rtc ０

２．

４　产品展示

本项目的产品展示如图２Ｇ９\~图２Ｇ１７所示.图２Ｇ９为版本信息;图２Ｇ１０为 Normal模

式;图２Ｇ１１为 Pong模式;图２Ｇ１２为 Digital模式;图２Ｇ１３为 Words模式;图２Ｇ１４为时间

显示模式转换;图２Ｇ１５为设置时间;图２Ｇ１６为设置亮度;图２Ｇ１７为内部结构.

图２Ｇ９　版本信息

图２Ｇ１０　Normal模式

图２Ｇ１１　Pong模式

图２Ｇ１２　Digital模式

[]{#index_split_001.html#p112}![index-112_1.png](https://i.imgur.com/rnKmSx5.jpeg){.calibre2}

![index-112_2.png](https://i.imgur.com/GBD0eXt.jpeg){.calibre2}

![index-112_3.png](https://i.imgur.com/XjgXk3i.jpeg){.calibre2}

![index-112_4.png](https://i.imgur.com/AsanPDD.jpeg){.calibre2}

![index-112_5.png](https://i.imgur.com/hNqL7BP.jpeg){.calibre2}

![index-112_6.png](https://i.imgur.com/qtypz9g.jpeg){.calibre2}

１０１

图２Ｇ１３　Words模式

图２Ｇ１４　时间显示模式转换

图２Ｇ１５　设置时间

图２Ｇ１６　设置亮度

图２Ｇ１７　内部结构图

２．

５　故障及问题分析

问题１:前期购买的 LED 屏幕总是不亮,无法驱动,连接到 Arduino开发板后其他元件

停止工作.

解决方案:更换 LED 板,采用 USB供电.

问题２:LED 屏幕经常出现乱码和点阵错位.

解决方案:在程序成功编译之后,发现 Arduino开发板出现了告警,由于 LED 屏幕的

[]{#index_split_001.html#p113}![index-113_1.png](https://i.imgur.com/jvPI8Pd.jpeg){.calibre2}

１０２

刷新非常频繁,占用了８０％ Arduino开发板的 RAM 空间,导致内存不足.由于线路连接

不稳定,稍微一动就会产生额外的脉冲,致使地址或者数据发送错误,在屏幕上的表现就是

乱码和显示错位.因为 LED 屏幕的引脚是只有焊接才能稳定的孔状,直插杜邦线受外部物

理运动比较大;为此,减少一些占用资源的功能,改进代码,即可在外界稳定的情况下正常

显示.

问题３:LED 刷新速度太慢,无法按照程序设计的间隔刷新.

解决方案:LED 是串行发送数据的,逐列刷新(

refreshedbyCOM).刷新时本身就有

较大的时间延迟,即使不在程序里设计任何延迟,"

pongclock"显示时也非常慢.多次手动

调整延迟,使其尽量在乒乓球掉球的时候为１min,减小其余部分程序中设计的延迟.

问题４:按钮不灵敏,在字符显示过程中,按下按钮时无反应.

解决方案:为了降低按钮的延迟,根本方法是降低屏幕刷新的延迟,在程序中减少延迟

的时间能收到一定的效果.同时,为了防止因为按键时间过长而多次变换菜单值,引入了已

经编写好的 Button库文件,用来初始化按钮的多种检测模式,包括检测按键时长和是否只

有一次下降沿(按压一次)等.

问题５:接线不稳定,容易断开,造成供电不稳和指令错误等一系列问题.

解决方案:用透明胶带固定接线,使用时轻拿轻放,不触碰内部装置.

问题６:两块 LED 屏级联后,第二块一直不亮.

解决方案:故障原因是只给第一块 LED 屏供电,打算靠两块屏幕级联的电源引脚给第

二块屏幕供电.但是由级联引脚提供的电流太小,所以无法驱动第二块屏幕.解决办法是

采用面包板连接给两块屏幕单独供电.

２．

６　元件清单

完成本项目所用到的元件及数量如表２Ｇ２所示.

表２Ｇ２　LED多模式显示时钟元件清单

模　　块

元　　件

数量

按钮

２个

杜邦线

若干

DS１３０７实时时钟芯片(带电源和晶振)

１个

面包板

１个

时间读取模块

ArduinoUNOR３开发板

１个

ArduinoUNOR３开发板(DFRobot出品)

１个

零件收纳盒

１个

５V２A 变压器

１个

时间显示模块

２４１６LED 绿色点阵显示屏(使用芯片 HT１６３２C)

２个

[]{#index_split_001.html#p114}![index-114_1.png](https://i.imgur.com/NHkpeNP.jpeg){.calibre2}

第３章 机械臂控制图像识别项目设计

３．

１　项目背景

机械臂是一类能够模仿人手臂的某些动作功能,按固定程序抓取、搬运物件或操作工具

的自动操作装置.第一代机械臂能够按事先示教的位置和姿态重复地执行动作.目前,国

际上使用的机械臂大多仍是这种工作方式.人脸肖像绘制机器人是当今的热点研究方向之

一,基于机器视觉的技术在生产和生活等各个方面都有广泛的应用.本项目基于 Arduino 开发板,通过蓝牙控制摄像头,在后台对人脸进行艺术化处理.

３．

２　创新描述

外接摄像头搭载在可控的机械臂上,通过调节机械臂来调控摄像头朝向,以寻找最佳的

取图角度.当找到合适角度后进行拍照并将照片存储在后台,进而识别程序可以自动识别

图片中的人脸,并进行精确的器官识别,进行艺术化处理.

与网上常见的处理方法相比,本项目的程序可以自动识别图片相关部分并进行处理,不

需要额外的人为调控,节约了时间与人力成本.另外,处理后的彩图效果较为美观,对于边

缘部分与细节的处理比较好.

３．

３　功能及总体设计

本作品主要分为三部分进行设计:可自由调控的机械臂与摄像头;图像采集程序;人

脸识别与图像处理程序.通过控制机械臂的转动可以调节摄像头角度;图像采集程序可以

通过摄像头进行拍照;人脸识别与图像处理程序可以对已拍下的照片进行艺术化处理.搭

载摄像头的机械臂可以在人工操控下调节方向,寻找一个合适的角度进行拍照;图像采集

本章根据刘泽萱、马铭阳项目设计整理而成.

[]{#index_split_001.html#p115}![index-115_1.png](https://i.imgur.com/0ytrtXg.jpeg){.calibre2}

![index-115_2.png](https://i.imgur.com/lQ7dhqo.jpeg){.calibre2}

１０４

程序可以实时显示摄像头拍摄的内容,以确定拍照时存储照片;人脸识别与图像处理程序

可以读取拍下的照片并对照片中的人脸进行识别,精确地分析并提取出人脸器官轮廓后进

行预设的艺术化处理.

３．

３．

１　功能介绍

人脸识别与图像处理程序可以读取预定目录中的图片,并识别图片中的人脸.当图中

有人脸时,程序可以继续运行并精确地识别出图中的左眼、右眼、鼻子与嘴巴.在识别完五

官后,可以按照设定的方法对图片进行处理并输出处理好的图片.

３．

３．

２　总体设计

要实现上述 功 能 需 要 将 作 品 分 成 输 入 与 处 理 两 部 分 进 行 设 计. 输 入 部 分 选 用 基 于

Arduino开发板可自由 转 动 的 机 械 臂 搭 载 USB 摄 像 头 进 行 图 像 采 集;处 理 部 分 由 基 于

OpenCV 的库文件完成.

１．整体框架图

项目整体框图如图３Ｇ１所示.

图３Ｇ１　整体框架图

２．系统流程图

系统流程图如图３Ｇ２所示.

３．总电路图

系统总电路图如图３Ｇ３所示.

扩展板与 Arduino开发板直接连接,底部旋转舵机连接扩展板的９引脚,右边舵机接５

引脚,左边舵机接６ 引脚.蓝牙模块的 T、R、G 和 V４ 个 引 脚 直 接 与 扩 展 板 对 应 的 引 脚

相连.

[]{#index_split_001.html#p116}![index-116_1.png](https://i.imgur.com/MlUvvHX.jpeg){.calibre2}

![index-116_2.png](https://i.imgur.com/MHbtjZY.jpeg){.calibre2}

![index-116_3.png](https://i.imgur.com/y8TVZGM.jpeg){.calibre2}

１０５

图３Ｇ２　系统流程图

图３Ｇ３　总电路图

[]{#index_split_001.html#p117}![index-117_1.png](https://i.imgur.com/P29np4k.jpeg){.calibre2}

![index-117_2.png](https://i.imgur.com/lfRUSSS.jpeg){.calibre2}

１０６

３．

３．

３　模块介绍

本项目包括机械臂模块,图像采集模块、人脸识别模块、图像预处理模块和添加文字模

块.下面对各模块的功能和相关代码进行介绍.

１．机械臂模块

１)功能介绍

通过编程和 Arduino开发板的控制,完成对 USB 摄像头的蓝牙控制,为获取不同角度

的照片,提供 角 度 的 旋 转 等 功 能.可 通 过 手 机 控 制 机 械 臂 转 动,由 蓝 牙 进 行 通 信. 安 装

APPServoControl,打开 APP后,选取 HCＧ０６蓝牙编号,实现手机与舵机的连接,手机操控

界面如图３Ｇ４所示,通过拖动滑块可调节舵机角度.

图３Ｇ４　舵机控制界面

２)相关代码

＃include＂CommProtocolData敭h＂ 通信协议

BYTEbuf_len ＝ ０

BYTEbuffer １０

voidPrintChar BYTEc

Serial敭print c

[]{#index_split_001.html#p118}![index-118_1.png](https://i.imgur.com/WiR8StY.jpeg){.calibre2}

![index-118_2.png](https://i.imgur.com/mGAarxy.jpeg){.calibre2}

![index-118_3.png](https://i.imgur.com/XK1F1LH.jpeg){.calibre2}

![index-118_4.png](https://i.imgur.com/xbcxTbk.jpeg){.calibre2}

１０７

voidcopyBuf BYTE∗data

for inti＝ ０ i buf_len i++

data i ＝ buffer i

写入二进制数据 data

buf_len 到串口

voidInitComm intBaud

Serial敭begin Baud

BYTEGetBuffer BYTE∗data

while Serial敭available

buffer buf_len ＝ Serial敭read

串口输出数据函数 写二进制数据到串口

buf_len++

returnbuf_len

BYTEGetFrameDataPart BYTE∗data

串口输出数据函数 写二进制数据到串口

GetBuffer data

if buf_len ＝ ８ && buffer buf_len－ １ ＝＝ ０X０A copyBuf data

for inti＝ ６ i buf_len i++

if data i ＝＝ ０X０D

data ９ ＝ i

break

data １ －＝ \'０\'

data ３ －＝ \'０\'

data ４ －＝ \'０\'

data ５ －＝ \'０\'

if data ９ ＝＝ ７

[]{#index_split_001.html#p119}![index-119_1.png](https://i.imgur.com/WPZ5KNE.jpeg){.calibre2}

![index-119_2.png](https://i.imgur.com/sbw5UIr.jpeg){.calibre2}

![index-119_3.png](https://i.imgur.com/HYzpyZD.jpeg){.calibre2}

![index-119_4.png](https://i.imgur.com/eSywHJi.jpeg){.calibre2}

![index-119_5.png](https://i.imgur.com/d6uBurN.jpeg){.calibre2}

![index-119_6.png](https://i.imgur.com/S7TMAtC.jpeg){.calibre2}

![index-119_7.png](https://i.imgur.com/GLiOt8l.jpeg){.calibre2}

１０８

data ６ －＝ \'０\'

buf_len＝ ０

return１

else

return０

voidClearBuffer

buf_len＝ ０

＃include＂def敭h＂

＃include avr eeprom敭h

＃ifndefMEM_H\_

＃defineMEM_H\_

＃defineMEM_LEN５１２

＃defineMEM_START０x１０

＃defineMEM_ENDMEM_LEN

BYTEWrite_section uint１６_taddr BYTE∗buf BYTElen 设定舵机旋转角度

BYTERead_section uint１６_taddr BYTE∗buf BYTElen 读取舵机旋转角度

BYTESave_toE２PROM Servo_info∗ pInfo

保存舵机的旋转模式

BYTERead_fromE２PROM Servo_info∗ pInfo 读取保存舵机的旋转模式

BYTEWrite_section uint１６_taddr BYTE∗buf BYTElen 设定舵机旋转角度

uint１６_ti＝ ０

for i len i++

if i ＝ MEM_END

returni

eeprom_write_byte uint８_t∗ addr＋ i buf i return０

BYTERead_section uint１６_taddr BYTE∗buf BYTElen 读取舵机旋转角度

uint１６_ti＝ ０

for i len i++

if i＋ len ＝ MEM_END

[]{#index_split_001.html#p120}![index-120_1.png](https://i.imgur.com/RfBfRkJ.jpeg){.calibre2}

![index-120_2.png](https://i.imgur.com/r74LdSG.jpeg){.calibre2}

![index-120_3.png](https://i.imgur.com/4ufZRvh.jpeg){.calibre2}

![index-120_4.png](https://i.imgur.com/2UsZ7R3.jpeg){.calibre2}

１０９

returni

buf i ＝ eeprom_read_byte uint８_t∗ addr＋ i return０

BYTESave_toE２PROM Servo_info∗ pInfo

保存舵机的旋转模式

uint１６_tlen＝ pInfo－ section_num∗ sizeof SECTION_INFO ＋８

BYTE∗p＝ BYTE∗ pInfo

uint１６_twrite_len＝ ８

constBYTEsave_step＝ sizeof SECTION_INFO

Write_section ０ p ８

p＋＝ ８

while write_len len－ ８

Write_section write_len p save_step

write_len＋＝ save_step

p＋＝ save_step

returnwrite_len

BYTERead_fromE２PROM Servo_info∗ pInfo 读取保存舵机的旋转模式

BYTEbHasData＝ eeprom_read_byte uint８_t∗ ０x０１

if bHasData

＝ HAS_DATA

uint１６_tlen＝ eeprom_read_byte uint８_t∗ ０x０１ ＋ １

len＝ len∗sizeof SECTION_INFO

BYTE∗p＝ BYTE∗ pInfo

uint１６_tread_len＝ ８

constBYTEread_step＝ sizeof SECTION_INFO

Read_section ０ p ８

p＋＝ ８

while read_len len－ １

Read_section read_len p read_step

read_len＋＝ read_step

p＋＝ read_step

returnread_len

[]{#index_split_001.html#p121}![index-121_1.png](https://i.imgur.com/sci5mNc.jpeg){.calibre2}

![index-121_2.png](https://i.imgur.com/WbMrxiI.jpeg){.calibre2}

![index-121_3.png](https://i.imgur.com/dzPB22B.jpeg){.calibre2}

![index-121_4.png](https://i.imgur.com/lltL281.jpeg){.calibre2}

１１０

＃endif

＃include＂ServoDriver敭h＂

typedefstructservo_info

BYTEcurr_pos

BYTEdest_pos

BYTEmove_spe

BYTEis_moving

SERVO_INFO

SERVO_INFOservo_info SERVO_NUM

Servoservo SERVO_NUM

BYTEis_anyservo_moving ＝ false

voidInitServoPort

pinMode ５ OUTPUT

pinMode ６ OUTPUT

pinMode ９ OUTPUT

定义要连接的引脚

servo １ 敭attach ５

servo ２ 敭attach ６

servo ３ 敭attach ９

连接舵机与引脚

for inti＝ ０ i SERVO_NUM i++

初始化引脚

servo_info i 敭curr_pos＝ ９０

servo_info i 敭dest_pos＝ ９０

servo_info i 敭move_spe＝ １

servo_info i 敭is_moving＝ false

BYTESetServoMoveto BYTEservo_num BYTEdestpos BYTEspe if servo_num SERVO_NUM

return１

servo_info servo_num 敭dest_pos＝ destpos servo_info servo_num 敭move_spe＝ spe

return０

BYTEMoveAllServoToDest

设定转动角度

BYTEservo_cnt＝ ０

is_anyservo_moving＝ false

for servo_cnt SERVO_NUM servo_cnt++

[]{#index_split_001.html#p122}![index-122_1.png](https://i.imgur.com/ZP7cS0M.jpeg){.calibre2}

![index-122_2.png](https://i.imgur.com/gTnC7xK.jpeg){.calibre2}

![index-122_3.png](https://i.imgur.com/jXul1de.jpeg){.calibre2}

![index-122_4.png](https://i.imgur.com/8k9HPOH.jpeg){.calibre2}

![index-122_5.png](https://i.imgur.com/ZM5Z24C.jpeg){.calibre2}

１１１

if servo_info servo_cnt 敭curr_pos servo_info servo_cnt 敭dest_pos is_anyservo_moving＝ true

if servo_info servo_cnt 敭curr_pos＋ servo_info servo_cnt 敭move_spe servo\_

info servo_cnt 敭

dest_pos

servo_info servo_cnt 敭curr_pos＋＝ servo_info servo_cnt 敭move_spe servo servo_cnt 敭write servo_info servo_cnt 敭curr_pos else

servo_info servo_cnt 敭curr_pos＝ servo_info servo_cnt 敭dest_pos servo servo_cnt 敭write servo_info servo_cnt 敭dest_pos elseif servo_info servo_cnt 敭curr_pos servo_info servo_cnt 敭dest_pos is_anyservo_moving＝ true

if servo_info servo_cnt 敭curr_pos－ servo_info servo_cnt 敭move_spe servo\_

info servo_cnt 敭

dest_pos

servo_info servo_cnt 敭curr_pos－＝ servo_info servo_cnt 敭move_spe servo servo_cnt 敭write servo_info servo_cnt 敭curr_pos else

servo_info servo_cnt 敭curr_pos＝ servo_info servo_cnt 敭dest_pos servo servo_cnt 敭write servo_info servo_cnt 敭dest_pos returnis_anyservo_moving

主程序代码

＃include＂Mem敭h＂

＃include＂ServoMain敭h＂

＃include＂ServoDriver敭h＂

＃include＂CommProtocolData敭h＂

BYTEdata ６４ ＝ ０x５A １ ０x５A １ ０x５A １ ０x５A １ ０x５A １ １

BYTEflag ＝ ０

BYTEbIsPrintDown ＝ ０

BYTEd １０ ＝ ０x３１ ０x３２ ０x３３ ０x３４ ０x３５ ０x３６ ０x３７ ０x３８ ０x３９ ０x４０

[]{#index_split_001.html#p123}![index-123_1.png](https://i.imgur.com/p4yaXAs.jpeg){.calibre2}

１１２

BYTEaddr ＝ ０xF０

BYTElen ＝ １０

BYTERUN_CMD ＝ CMD_DEBUG

Servo_infomem_info

BYTEbIsLoadE２PROM ＝ ０

BYTERunDebug

intrundata rdi＝ ７

BYTErdata

ClearBuffer

while １

if GetFrameDataPart data

if data ０

＝ ０x２３

Serial敭write data data ９

return０

if data data ９ ＋ １

＝ ０X０A

return０

if data ９ ＝＝ ６

rundata＝ data ３ ∗ １００ ＋ data ４ ∗ １０ ＋ data ５

elseif data ９ ＝＝ ７

rundata＝ data ３ ∗ １０００ ＋ data ４ ∗ １００ ＋ data ５ ∗ １０ ＋ data ６

rdata＝ rundata－ ５００ ∗ ９ １００

SetServoMoveto data １ － １ rdata ServoSpeedResolution MoveAllServoToDest

voidsetup

Serial敭begin ９６００

InitServoPort

mem_info敭section_hasData＝ HAS_DATA

[]{#index_split_001.html#p124}![index-124_1.png](https://i.imgur.com/DEEDvKY.jpeg){.calibre2}

１１３

voidloop

RunDebug

＃ifndefDEF_H\_

＃defineDEF_H\_

＃include＂Arduino敭h＂

＃defineATmega_１６８

＃defineHAS_DATA０x５５

enum CMD_DEBUG＝ ０xF０ CMD_AUTO CMD_LOAD CMD_PRG CMD_UPLOAD 　 ０XF０\~０XF４

＃defineBYTEunsignedchar

＃defineTRUE１

＃defineFALSE０

typedefstruct

BYTEspe_l ４

BYTEspe_h ４

SPEED

typedefstruct

BYTEservo１_pos

BYTEservo２_pos

BYTEservo３_pos

BYTEservo４_pos

BYTEservo５_pos

BYTEservo６_pos

SPEEDspe１_２

SPEEDspe３_４

SPEEDspe５_６

BYTEdelay_s

SECTION_INFO

typedefstruct

BYTEsection_hasData

BYTEsection_num

BYTEndef ６

SECTION_INFOinfo １００

Servo_info

＃endif

２．图像采集模块

１)功能介绍

通过程序实现打开摄像头、拍取并保存照片以及关闭摄像头的功能.

[]{#index_split_001.html#p125}![index-125_1.png](https://i.imgur.com/47XLFnE.jpeg){.calibre2}

![index-125_2.png](https://i.imgur.com/9LIuS6K.jpeg){.calibre2}

![index-125_3.png](https://i.imgur.com/fj6RDhF.jpeg){.calibre2}

![index-125_4.png](https://i.imgur.com/dGxct1T.jpeg){.calibre2}

![index-125_5.png](https://i.imgur.com/HzwfA3g.jpeg){.calibre2}

![index-125_6.png](https://i.imgur.com/YMHMv2V.jpeg){.calibre2}

![index-125_7.png](https://i.imgur.com/cBNXOTn.jpeg){.calibre2}

![index-125_8.png](https://i.imgur.com/rMhDrnL.jpeg){.calibre2}

![index-125_9.png](https://i.imgur.com/7Chzj5W.jpeg){.calibre2}

![index-125_10.png](https://i.imgur.com/2cHN2Vs.jpeg){.calibre2}

![index-125_11.png](https://i.imgur.com/tgh0AV1.jpeg){.calibre2}

![index-125_12.png](https://i.imgur.com/gPXvEiZ.jpeg){.calibre2}

![index-125_13.png](https://i.imgur.com/RgiNpsX.jpeg){.calibre2}

![index-125_14.png](https://i.imgur.com/zpYmYrF.jpeg){.calibre2}

![index-125_15.png](https://i.imgur.com/TB8EafI.jpeg){.calibre2}

![index-125_16.png](https://i.imgur.com/cIjqNYZ.jpeg){.calibre2}

![index-125_17.png](https://i.imgur.com/vgAr7ll.jpeg){.calibre2}

１１４

２)相关代码

＃include opencv２ opencv敭hpp

＃include iostream

＃include thread

usingnamespacecv

usingnamespacestd

Matframe

stringphotoFileName ＝ ＂photo１敭

jpg＂

VideoCapturecap

voidshowVideo

打开摄像头

cap敭open １

打开外置摄像头

if

cap敭

isOpened

检查摄像头是否成功打开

cerr ＂Cannotopenacameraorfile敭

＂ endl

return

namedWindow ＂edges＂

创建窗口

for

cap frame

从 cap 中读一帧 存到 frame

if frame敭

empty

如果未读到图像

break

imshow ＂edges＂ frame

读到图像后输出

waitKey ３０

等待 ３０ms 如果有按键按下则退出循环

退出时自动释放 cap 中占用的资源

voidtakePhoto stringfileName

拍摄相片

if

[]{#index_split_002.html}

frame敭

empty

imwrite fileName frame

按照设定好的名称保存当前的图像

else

cout ＂frameisempty＂ endl

voidshowImage stringfileName

展示拍摄的图片

Matimg ＝ imread fileName

[]{#index_split_002.html#p126}![index-126_1.png](https://i.imgur.com/GybJjp6.jpeg){.calibre2}

![index-126_2.png](https://i.imgur.com/5HDuH5r.jpeg){.calibre2}

![index-126_3.png](https://i.imgur.com/z7QvmbR.jpeg){.calibre2}

![index-126_4.png](https://i.imgur.com/YJFl4gC.jpeg){.calibre2}

![index-126_5.png](https://i.imgur.com/tTeHmU2.jpeg){.calibre2}

![index-126_6.png](https://i.imgur.com/5amww4B.jpeg){.calibre2}

![index-126_7.png](https://i.imgur.com/AWIB5UR.jpeg){.calibre2}

![index-126_8.png](https://i.imgur.com/9asQ8xP.jpeg){.calibre2}

![index-126_9.png](https://i.imgur.com/tZgeKpJ.jpeg){.calibre2}

![index-126_10.png](https://i.imgur.com/2697yGl.jpeg){.calibre2}

![index-126_11.png](https://i.imgur.com/648aiJ8.jpeg){.calibre2}

![index-126_12.png](https://i.imgur.com/fOAT3xT.jpeg){.calibre2}

![index-126_13.png](https://i.imgur.com/5Yusxnm.jpeg){.calibre2}

![index-126_14.png](https://i.imgur.com/43uFUrA.jpeg){.calibre2}

![index-126_15.png](https://i.imgur.com/FRO5ZyQ.jpeg){.calibre2}

![index-126_16.png](https://i.imgur.com/9STwnTd.jpeg){.calibre2}

![index-126_17.png](https://i.imgur.com/nYfUO9x.jpeg){.calibre2}

![index-126_18.png](https://i.imgur.com/KowrZiM.jpeg){.calibre2}

![index-126_19.png](https://i.imgur.com/SPK2wab.jpeg){.calibre2}

![index-126_20.png](https://i.imgur.com/O4jWhIo.jpeg){.calibre2}

![index-126_21.png](https://i.imgur.com/k17vtDV.jpeg){.calibre2}

![index-126_22.png](https://i.imgur.com/iNdzw3l.jpeg){.calibre2}

![index-126_23.png](https://i.imgur.com/XhUzos8.jpeg){.calibre2}

![index-126_24.png](https://i.imgur.com/1Gc1VHN.jpeg){.calibre2}

![index-126_25.png](https://i.imgur.com/G1TXter.jpeg){.calibre2}

![index-126_26.png](https://i.imgur.com/2af6pom.jpeg){.calibre2}

![index-126_27.png](https://i.imgur.com/VZrcAKb.jpeg){.calibre2}

![index-126_28.png](https://i.imgur.com/iy14VBf.jpeg){.calibre2}

![index-126_29.png](https://i.imgur.com/SejwGP5.jpeg){.calibre2}

![index-126_30.png](https://i.imgur.com/ekt16gZ.jpeg){.calibre2}

![index-126_31.png](https://i.imgur.com/6tcrI6B.jpeg){.calibre2}

１１５

if img敭

empty

cout ＂打开图像失败

＂ endl

return

namedWindow ＂Demo＂

创建一个名为Demo的窗口

imshow ＂Demo＂ img

在窗口中显示图片

waitKey ３０００

等待３０００ms后窗口自动关闭

cv

destroyWindow ＂Demo＂

需要主动释放窗体 否则再次打开窗口时可能显示不出来

voidcloseVideo

关闭摄像头

if cap敭

isOpened

cap敭

release

cv

destroyAllWindows

需要主动释放窗体 否则再次打开窗口时可能显示不出来

return

intmain intargc char∗∗argv

boolbRun ＝ true

while bRun

cout ＂１ 打开摄像头＂ endl

cout ＂２ 拍照＂ endl

cout ＂３ 显示图片＂ endl

cout ＂４ 关闭摄像头＂ endl

cout ＂９ 退出程序＂ endl

cout ＂请选择＂ endl

inti ＝ ０

cin i

switch i

case１

打开视频

std threadt１ showVideo

t１敭detach

如果不使用detach 会报R６０１０错误

break

case２

照相

[]{#index_split_002.html#p127}![index-127_1.png](https://i.imgur.com/7EQdBjm.jpeg){.calibre2}

![index-127_2.png](https://i.imgur.com/XWCttK9.jpeg){.calibre2}

![index-127_3.png](https://i.imgur.com/BiNVme7.jpeg){.calibre2}

![index-127_4.png](https://i.imgur.com/CUdOxro.jpeg){.calibre2}

![index-127_5.png](https://i.imgur.com/XtJP1pz.jpeg){.calibre2}

![index-127_6.png](https://i.imgur.com/1Yr5hz5.jpeg){.calibre2}

![index-127_7.png](https://i.imgur.com/lZnMPSU.jpeg){.calibre2}

１１６

std threadt１ takePhoto photoFileName t１敭

detach

break

case３

显示图片

std threadt２ showImage photoFileName t２敭

detach

break

case４

关闭视频

closeVideo

break

case９

bRun ＝ false

break

default

cout ＂请重新输入＂ endl

break

return０

３．人脸识别模块

１)功能介绍

建立图库与训练级联分类器.OpenCV 自带眼睛和面部的级联分类器,所以可以直接

使用 haarcascade_eye．xml和haarcascade_frontalface_alt．xml.但是 OpenCV 没有嘴巴和

鼻子 的 级 联 分 类 器,需 要 自 行 训 练. 训 练 级 联 分 类 器 traincascade 需 要 OpenCV 中 的

opencv_createsamples．exe和opencv_traincascade．exe文件.训练过程可分为以下几步: (１)准备正负训练样本.

正样本用于后续批量处理,实现尺寸统一;负样本的尺寸无须统一,负样本越多,检测

结果的误检率越小.准备好训练样本后,创建两个文件夹,以pos和neg分别为存放正负样

本的文件名,并将 这 两 个 文 件 夹 与 opencv_createsamples．exe和 opencv_traincascade．exe 文件放在同一目录下.

(２)在 DOS环境下生成正负样本描述.

首先,进入正负样本所在的目录.若处于正样本所在目录,输入命令 dir/b pos．txt, 则生成正样本描述文件;若处于负样本所在目录,输入命令 dir/b neg．

txt,则生成负样本

[]{#index_split_002.html#p128}![index-128_1.png](https://i.imgur.com/GfAdKkB.jpeg){.calibre2}

![index-128_2.png](https://i.imgur.com/GAZlwAt.jpeg){.calibre2}

１１７

描述文件.生成的正负样本描述文件为．

txt文件,打开后可见样本的名称.然后,将正负

样本作以下处理:

对于负样本,在样本名称前加上"

neg/",即负样本所在的文件夹,所有的样本名称都要

修改,修改完成后把最后一行的 neg．

txt去掉,并将最后一行的空行去掉,否则训练过程会

报错.

对于正样本,除了在样本名称前加上其所在的文件夹名称,还要在后缀名后面加上样本

描述,即样本的尺寸大小,

１表示样本数为１,

００表示样本左上角的坐标为(０,０),４４表示

右下角的坐标.同样,修改完成后把最后一行的pos．

txt以及空行去掉.

(３)生成．vec文件.

生成．vec文件需要用到opencv_createsamples．exe文件,．vec文件是为后面训练分类

器所准备的.在 DOS环境下的相对目录下输入以下命令:

opencv_createsamples敭exe－vecpos敭vec－infopos敭txt－num１０００ －w３０ －h３０

此时,可在opencv_createsamples．exe文件所在目录中看到生成的．vec文件.由命令

行可知,

Ｇw３０Ｇh３０ 为 正 样 本 的 尺 寸 大 小,也 间 接 说 明 了 正 样 本 的 尺 寸 大 小 必 须 一 致.

Ｇnum 为需要生成的正样本数目,对于负样本则无须生成．vec文件.

(４)级联分类器的训练.

在命令行输入以下命令:

opencv_traincascade敭exe －dataxml －vecpos敭vec －bgneg敭txt －numPos９００numNeg７８８ －

numStage２０ －precalValBufSize３００ －precalIdxBufSize１００ －featureTypeHAAR －w４ －h４ －

modeALL

－dataxml

xml为一个文件夹的名字,该文件夹用来存放训练好的分类器;Ｇdata为分类器所在的

文件夹;ＧbgnumPos９００是训练正样本的数目;numNeg７８８是负样本数目;ＧnumStage２０

为训练阶数.

最终,训练完成鼻 子 和 嘴 巴 的 级 联 分 类 器 并 命 名 为 haarcascade_mcs_mouth．xml与

haarcascade_mcs_nose．xml,图库如图３Ｇ５和图３Ｇ６所示.

２)相关代码

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

由于人脸识别需要对图片进行大量的计算 故最好先识别人脸 并把人脸的框架勾勒出来 然后

用 cvSetImageROI 函数分别选定感兴趣的区域 再 识 别 眼 睛、鼻 子、嘴 就 可 以 减 少 运 算.为 了 方 便

调试 可将定位实现的五官用红色框选中 并保存为一个中间图像 这样可以更加直观地 看 出 问 题 所

在并加以调整.

在测试过程中发现 经常出现识别错误 如将眉毛上形状和颜色都与眼睛类似的一小部分识别

为眼睛 以及眼睛只选中一半 眼角部分在选择框之外 于是根据眼睛进行定位的鼻子和 嘴 巴 的 定 位

就都会出错.但是 调试时发现 如检测左眼时 级联分类器识别出来的并不 是 一 只 左 眼 而 是 一 组

共∗－ total个左眼的集合 而编写代码的时候没有考虑到这个隐蔽的问题 只选用了第一个识别

[]{#index_split_002.html#p129}![index-129_1.png](https://i.imgur.com/7fpNCBR.jpeg){.calibre2}

![index-129_2.png](https://i.imgur.com/Kq9lXbC.jpeg){.calibre2}

![index-129_3.png](https://i.imgur.com/wzefdQh.jpeg){.calibre2}

１１８

图３Ｇ５　嘴巴图库

图３Ｇ６　鼻子图库

出来的左眼 故出错.大量测试与仔 细 分 析 后 发 现 希 望 得 到 的 左 眼 比 其 他 识 别 出 来 错 误 的 左 眼 或

只勾勒出一半的左眼都会大 只要 选 择 识 别 出 来 的 区 域 最 大 的 部 分 即 可.所 以 所 有 五 官 识 别 的 代

码都加入了选择最大区域的代码.

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

voidPicture

FaceDecetion

[]{#index_split_002.html#p130}![index-130_1.png](https://i.imgur.com/4Xuv1Zi.jpeg){.calibre2}

![index-130_2.png](https://i.imgur.com/kiOapLc.jpeg){.calibre2}

![index-130_3.png](https://i.imgur.com/l1f0QTV.jpeg){.calibre2}

![index-130_4.png](https://i.imgur.com/Y913A3A.jpeg){.calibre2}

![index-130_5.png](https://i.imgur.com/ITbdrbL.jpeg){.calibre2}

１１９

CvMemStorage∗ storage_f＝ ０ storage_f＝ cvCreateMemStorage ０ 　　　 创建缓存区域

CvHaarClassifierCascade∗cascade_f＝ ０

创建哈尔特征分类器 导入已训练好的人脸特征向量xml文件

constchar∗cascade_name１ ＝ ＂haarcascade_frontalface_alt２敭xml＂

cascade_f＝ CvHaarClassifierCascade∗ cvLoad cascade_name１ ０ ０ ０ 　 加载分类器

assert cascade_f

＝ NULL

判断是否加载成功

CvRect∗face＝ CvRect∗ cvGetSeqElem cvHaarDetectObjects img cascade_f storage_f １敭

１ ３ １１ cvSize ３０ ３０ １

人脸哈尔特征检测

if face

exit ０

没检测到则停止

Face敭x＝ face－ x

Face敭y＝ face－ y

Face敭height＝ face－ height

Face敭width＝ face－ height

cvRectangle img cvPoint Face敭x Face敭y cvPoint Face敭x ＋ Face敭width Face敭y ＋ Face 敭

height CV_RGB ２５５ ０ ０ １ ８ ０ 画出脸的轮廓

EyesDetection

NoseDetection

MouthDetection

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

由于眼睛相对脸部的位置固定 几乎都处于上半部分 故可设定感兴趣区域为从检测到的面部

开始 即选定起始坐标为 Face敭

x

Face敭

y 长度为Face敭

width 宽度为Face敭

height １敭

６ 的矩形区域

但是在调试过程中发现 如果直接用haarcascade_eye敭

xml这个级联分类器去同时 识 别 双 眼 就 会 出

现有眼睛只框住了一般的 现 象 这 是 我 们 不 想 要 的 因 为 我 们 要 对 整 个 眼 睛 进 行 处 理 若 只 处 理 一

半 对比就 会 相 当 明 显. 所 以 最 终 选 用 了 haarcascade_mcs_lefteye敭xml 和 haarcascade_mcs\_

righteye敭

xml 两个独立的级联分类器 分别检测左右眼 以使结果更加准确.

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

voidPicture

EyesDetection

检测左眼

cvSetImageROI img cvRect Face敭

x Face敭

y Face敭

width １敭

６ Face敭

height １敭

６

CvMemStorage∗ storage_e\_l＝ ０ storage_e\_l＝ cvCreateMemStorage ０

创建第２个缓存区

CvHaarClassifierCascade∗ cascade_le＝ ０

创建哈尔特征分类器 导入已训练好的人眼特征向量xml文件

constchar∗ cascade_name２_l＝ ＂haarcascade_mcs_lefteye敭xml＂

加载分类器

cascade_le＝ CvHaarClassifierCascade∗ cvLoad cascade_name２_l ０ ０ ０

assert cascade_le

＝ NULL

判断是否加载成功

CvSeq∗eye\_\_l ＝ cvHaarDetectObjects img cascade_le storage_e\_l １敭０１ ３ ３ cvSize ２０ ２０

[]{#index_split_002.html#p131}![index-131_1.png](https://i.imgur.com/TFsZjxY.jpeg){.calibre2}

![index-131_2.png](https://i.imgur.com/nU1Za8H.jpeg){.calibre2}

![index-131_3.png](https://i.imgur.com/ReSp1Ob.jpeg){.calibre2}

![index-131_4.png](https://i.imgur.com/9e0yQEW.jpeg){.calibre2}

![index-131_5.png](https://i.imgur.com/vefrxou.jpeg){.calibre2}

![index-131_6.png](https://i.imgur.com/9ixG5RA.jpeg){.calibre2}

![index-131_7.png](https://i.imgur.com/vAgFrkL.jpeg){.calibre2}

![index-131_8.png](https://i.imgur.com/Uyz6LXC.jpeg){.calibre2}

![index-131_9.png](https://i.imgur.com/UeEPRVl.jpeg){.calibre2}

![index-131_10.png](https://i.imgur.com/k0NnfsO.jpeg){.calibre2}

![index-131_11.png](https://i.imgur.com/i5q6Wag.jpeg){.calibre2}

![index-131_12.png](https://i.imgur.com/494SSmy.jpeg){.calibre2}

![index-131_13.png](https://i.imgur.com/6cc7Fos.jpeg){.calibre2}

![index-131_14.png](https://i.imgur.com/wgmAPUZ.jpeg){.calibre2}

![index-131_15.png](https://i.imgur.com/GLRWY58.jpeg){.calibre2}

![index-131_16.png](https://i.imgur.com/6TogWmp.jpeg){.calibre2}

![index-131_17.png](https://i.imgur.com/b2zwAGL.jpeg){.calibre2}

![index-131_18.png](https://i.imgur.com/6tHNTsw.jpeg){.calibre2}

![index-131_19.png](https://i.imgur.com/4k0SXKj.jpeg){.calibre2}

![index-131_20.png](https://i.imgur.com/4stwGHE.jpeg){.calibre2}

![index-131_21.png](https://i.imgur.com/3KKDYNT.jpeg){.calibre2}

![index-131_22.png](https://i.imgur.com/su25ghR.jpeg){.calibre2}

![index-131_23.png](https://i.imgur.com/golGJzw.jpeg){.calibre2}

![index-131_24.png](https://i.imgur.com/rK36lUI.jpeg){.calibre2}

![index-131_25.png](https://i.imgur.com/kuigLYP.jpeg){.calibre2}

１２０

CvRect∗eye_l＝ CvRect∗ cvGetSeqElem eye\_\_l １

if

eye_l

exit ０

没检测到则停止

在eye\_\_l－ total个识别出来的左眼中选择区域最大的

for inti＝ １ i ＝ eye\_\_l－ total－ １ i++

CvRect∗eye_l\_ ＝ CvRect∗ cvGetSeqElem eye\_\_l i＋ １

if eye_l\_－ width eye_l－ width

eye_l＝ eye_l\_

lefteye敭x＝ eye_l－ x

lefteye敭y＝ eye_l－ y

lefteye敭height＝ eye_l－ height

lefteye敭width＝ eye_l－ width

cvRectangle img cvPoint eye_l－ x eye_l－ y cvPoint eye_l－ x ＋ eye_l－ width eye_l－ y ＋ eye_l－ height CV_RGB ２５５ ０ ０ １ ８ ０

cvResetImageROI img

检测右眼

cvSetImageROI img cvRect Face敭x ＋ Face敭width ２敭５ Face敭y Face敭width １敭６ Face敭

height １敭

６

CvMemStorage∗ storage_e\_r＝ ０ storage_e\_r＝ cvCreateMemStorage ０

创建第３个缓存区

CvHaarClassifierCascade∗ cascade_re＝ ０

创建哈尔特征分类器 导入已训练好的人眼特征向量xml文件

constchar∗ cascade_name２_r＝ ＂haarcascade_mcs_righteye敭xml＂

加载分类器

cascade_re＝ CvHaarClassifierCascade∗ cvLoad cascade_name２_r ０ ０ ０

assert cascade_re

＝ NULL

判断是否加载成功

CvSeq∗eye\_\_r ＝ cvHaarDetectObjects img cascade_re storage_e\_r １敭０１ ３ ３ cvSize ２０ ２０

CvRect∗eye_r＝ CvRect∗ cvGetSeqElem eye\_\_r １

if

eye_r

exit ０

没检测到则停止

在eye\_\_r－ total个识别出来的左眼中选择区域最大的

for inti＝ １ i ＝ eye\_\_r－ total－ １ i++

CvRect∗eye_r\_ ＝ CvRect∗ cvGetSeqElem eye\_\_r i＋ １

if eye_r\_－ width eye_r－ width

eye_r＝ eye_r\_

righteye敭x＝ eye_r－ x

righteye敭y＝ eye_r－ y

[]{#index_split_002.html#p132}![index-132_1.png](https://i.imgur.com/JkD7CHE.jpeg){.calibre2}

![index-132_2.png](https://i.imgur.com/QWNcNaL.jpeg){.calibre2}

![index-132_3.png](https://i.imgur.com/HUBVTf9.jpeg){.calibre2}

![index-132_4.png](https://i.imgur.com/L5Atnzs.jpeg){.calibre2}

![index-132_5.png](https://i.imgur.com/Plgqr0k.jpeg){.calibre2}

![index-132_6.png](https://i.imgur.com/ebijrEk.jpeg){.calibre2}

![index-132_7.png](https://i.imgur.com/1pp6jNV.jpeg){.calibre2}

![index-132_8.png](https://i.imgur.com/0E1LwfW.jpeg){.calibre2}

![index-132_9.png](https://i.imgur.com/RZN1V4L.jpeg){.calibre2}

![index-132_10.png](https://i.imgur.com/5xAKbxp.jpeg){.calibre2}

![index-132_11.png](https://i.imgur.com/Z9NKc9U.jpeg){.calibre2}

![index-132_12.png](https://i.imgur.com/wDaQwsG.jpeg){.calibre2}

![index-132_13.png](https://i.imgur.com/Ydp0dc2.jpeg){.calibre2}

![index-132_14.png](https://i.imgur.com/lhKwH9v.jpeg){.calibre2}

![index-132_15.png](https://i.imgur.com/Cp0CKiS.jpeg){.calibre2}

![index-132_16.png](https://i.imgur.com/lOQUBpu.jpeg){.calibre2}

![index-132_17.png](https://i.imgur.com/dzrMh9T.jpeg){.calibre2}

![index-132_18.png](https://i.imgur.com/xQIaTBn.jpeg){.calibre2}

![index-132_19.png](https://i.imgur.com/hPqOt3m.jpeg){.calibre2}

１２１

righteye敭height＝ eye_r－ height

righteye敭width＝ eye_r－ width

cvRectangle img cvPoint eye_r－ x eye_r－ y cvPoint eye_r－ x ＋ eye_r－ width eye_r－ y ＋ eye_r－ height CV_RGB ２５５ ０ ０ １ ８ ０

cvResetImageROI img

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

嘴巴和鼻子也采取相同的方法 先选定感兴趣的区域以减少运算量 再进行模 式 识 别 与 框 选敭但

是 在调试的过程中发现 嘴巴的级联分类器训练得并不是很理想 总是会出现框选出一 半 嘴 巴 的 现

象.于是 只能对代码进行调整来弥补这个缺陷 即利用识别嘴部的中心位置 根据嘴巴相对面部、左

右眼的位置 将嘴部矩形框的长度调大为righteye敭

x ＋ Face敭

width ２ － lefteye敭

x 左右眼横坐标

的差值加上面部宽度的一半 宽度也调为Face敭

height 面部宽度的１ ４ .为了区别级联分类器识

别的嘴部与修改后框选出的嘴部 级联分类器选择的框用绿色线条勾勒.

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

voidPicture

NoseDetection

intwidth＝ righteye敭x＋ Face敭width １敭

５

intheight＝ Face敭height ４ ＋ lefteye敭height＋ righteye敭height ２

cvSetImageROI img cvRect Face敭x＋ lefteye敭width Face敭y＋ Face敭height ５ ＋ lefteye敭

height ＋ righteye敭

height ２ width height

CvMemStorage∗ storage_n＝ ０ storage_n＝ cvCreateMemStorage ０ 　 创建第４个缓存区

CvHaarClassifierCascade∗ cascade_n＝ ０

创建哈尔特征分类器 导入已训练好的鼻子特征向量xml文件

constchar∗ cascade_name４ ＝ ＂haarcascade_mcs_nose敭xml＂

cascade_n＝ CvHaarClassifierCascade∗ cvLoad cascade_name４ ０ ０ ０

加载分类器

assert cascade_n

＝ NULL

判断是否加载成功

CvSeq∗nose\_ ＝ cvHaarDetectObjects img cascade_n storage_n １敭

０１ ３ ３ cvSize ２０ ２０

CvRect∗nose＝ CvRect∗ cvGetSeqElem nose\_ １

if

nose

exit ０

没检测到则停止

在nose\_－ total个识别出来的鼻子中选择区域最大的

for inti＝ １ i ＝ nose\_－ total－ １ i++

CvRect∗nose\_\_ ＝ CvRect∗ cvGetSeqElem nose\_ i＋ １

if nose\_\_－ width nose－ width

nose＝ nose\_\_

Nose敭x＝ nose－ x

Nose敭y＝ nose－ y

Nose敭height＝ nose－ height

Nose敭width＝ nose－ width

[]{#index_split_002.html#p133}![index-133_1.png](https://i.imgur.com/y71jpTG.jpeg){.calibre2}

![index-133_2.png](https://i.imgur.com/TK5gUux.jpeg){.calibre2}

![index-133_3.png](https://i.imgur.com/n4SLyu3.jpeg){.calibre2}

![index-133_4.png](https://i.imgur.com/Zi4KXpd.jpeg){.calibre2}

![index-133_5.png](https://i.imgur.com/Ulwig3h.jpeg){.calibre2}

![index-133_6.png](https://i.imgur.com/81Vzquf.jpeg){.calibre2}

![index-133_7.png](https://i.imgur.com/4buAaBU.jpeg){.calibre2}

![index-133_8.png](https://i.imgur.com/eiHSU8y.jpeg){.calibre2}

![index-133_9.png](https://i.imgur.com/NIR6EXc.jpeg){.calibre2}

![index-133_10.png](https://i.imgur.com/k0NQE8D.jpeg){.calibre2}

![index-133_11.png](https://i.imgur.com/EUl3p0V.jpeg){.calibre2}

![index-133_12.png](https://i.imgur.com/AYKbKyT.jpeg){.calibre2}

![index-133_13.png](https://i.imgur.com/g3Dj0qp.jpeg){.calibre2}

![index-133_14.png](https://i.imgur.com/aC8IrzV.jpeg){.calibre2}

![index-133_15.png](https://i.imgur.com/bVXDyZX.jpeg){.calibre2}

![index-133_16.png](https://i.imgur.com/mVZuM4y.jpeg){.calibre2}

![index-133_17.png](https://i.imgur.com/DtlG3QT.jpeg){.calibre2}

![index-133_18.png](https://i.imgur.com/eM5qnkZ.jpeg){.calibre2}

![index-133_19.png](https://i.imgur.com/zG6ulnd.jpeg){.calibre2}

![index-133_20.png](https://i.imgur.com/ZxD4MUC.jpeg){.calibre2}

![index-133_21.png](https://i.imgur.com/SaxaHli.jpeg){.calibre2}

![index-133_22.png](https://i.imgur.com/5WSM4cB.jpeg){.calibre2}

![index-133_23.png](https://i.imgur.com/hUpWE8p.jpeg){.calibre2}

１２２

cvRectangle img cvPoint nose－ x nose－ y cvPoint nose－ x ＋ nose－ width nose

－ y ＋ nose－ height CV_RGB ２５５ ０ ０ １ ８ ０

cvResetImageROI img

voidPicture

MouthDetection

intwidth＝ righteye敭x＋ Face敭width ２ － lefteye敭x intheight＝ Face敭height ４

cvSetImageROI img cvRect Face敭x ＋ lefteye敭x Face敭height ３敭５ ＋ Face敭y ＋ Nose敭y ＋

Nose敭

height righteye敭

x ＋ Face敭

width １敭

５ － lefteye敭

x Face敭

height ２敭

５

CvMemStorage∗ storage_m＝ ０ storage_m＝ cvCreateMemStorage ０

创建第５个缓存区

CvHaarClassifierCascade∗ cascade_m＝ ０

创建哈尔特征分类器 导入已训练好的嘴巴特征向量xml文件

constchar∗ cascade_name５ ＝ ＂haarcascade_mcs_mouth敭xml＂

cascade_m＝ CvHaarClassifierCascade∗ cvLoad cascade_name５ ０ ０ ０

加载分类器

assert cascade_m

＝ NULL

判断是否加载成功

CvSeq∗mouth\_ ＝ cvHaarDetectObjects img cascade_m storage_m １敭０１ ３ ３ cvSize ２０

２０

CvRect∗mouth＝ CvRect∗ cvGetSeqElem mouth\_ １

if

mouth

exit ０

没检测到则停止

在mouth\_－ total个识别出来的嘴巴中选择区域最大的

for inti＝ １ i ＝ mouth\_－ total－ １ i++

CvRect∗mouth\_\_ ＝ CvRect∗ cvGetSeqElem mouth\_ i＋ １

if mouth\_\_－ width mouth－ width

mouth＝ mouth\_\_

利用检测出的嘴部的中心位置 扩大选区

cvRectangle img cvPoint mouth－ x mouth－ y cvPoint mouth－ x ＋ mouth－ width mouth－ y ＋ mouth－ height CV_RGB ０ ２５５ ０ １ ８ ０ 　　 绿色线条

Mouth敭width＝ righteye敭x＋ Face敭width ２ － lefteye敭x 　 调长嘴部矩形框

Mouth敭height＝ Face敭height ４ 　　　 调宽嘴部矩形框

Mouth敭x＝ mouth－ x＋ mouth－ width ２ － width ２

Mouth敭y＝ mouth－ y＋ mouth－ height ２ － height ２

cvRectangle img cvPoint Mouth敭x Mouth敭y cvPoint Mouth敭x ＋ Mouth敭width Mouth敭y ＋

Mouth敭

height CV_RGB ２５５ ０ ０ １ ８ ０ 　 依旧采用红色线条

cvResetImageROI img

[]{#index_split_002.html#p134}![index-134_1.png](https://i.imgur.com/XziUJGK.jpeg){.calibre2}

![index-134_2.png](https://i.imgur.com/zzbpFaq.jpeg){.calibre2}

１２３

４．图像预处理模块

１)功能介绍

在大量的测试中发现,如果直接对图片进行二值处理,大量细节都会丢失,尤其是五官

部分.为了尽量减少失真,必须对五官再进行单独的灰度处理、Gamma矫正来增强、突出细

节,五官单独二值化后与原图像的二值图进行运算(叠加运算)来补充原图像直接二值化丢

失的细节.

２)相关代码

(１)灰度处理

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

直接调用 OpenCV的颜色空间转换函数cvCvtColor 可以实现 RGB颜色向 HSV、

HSI等 颜 色 空 间 的 转

换 也可以转换为灰度图像 参数CV_RGB２GRAY是RGB到gray.

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

voidprocess

gray

IplImage∗ img_gray＝ cvCreateImage cvGetSize img img－ depth １ 创建目标图像

cvCvtColor img img_gray CV_BGR２GRAY

img＝ img_gray

cvSaveImage ＂Gray敭jpg＂ img ０

保存

(２)Gamma矫正

当 Gamma大于１时,随着 Gamma的变大,高光区对应的自变量区间逐渐变小,而低光

区对应的自变量区间逐渐变大;相反,当 Gamma小于１时,随着 Gamma的变小,高光区对

应的自变量区间逐渐变大,而低光区对应的自变量区间逐渐变小.也就是说,Gamma矫正

的值大于１时,图像的高光部分被压缩而暗调部分被扩展,当 Gamma矫正的值小于１时, 图像的高光部分被扩展而暗调部分被压 缩.通过调节 Gamma值,可以针对性地控制高光

区或者低光区的显示细节(Gamma大于１时,低光区被扩展高光区被压缩,表现为"越来越

灰暗";Gamma小于时,低光区压缩而高光区扩展,表现为"越来越明亮").要增加五官的

细节,就要扩张低光区,压缩高光区,这样二值化时才能保留更多的细节,因为像素越亮,就

越接近于白色,二值化时就越容易被丢掉.在大量的测试过程中发现,Gamma值选择１．１

时对图像进行校正更加理想,既增加了部分细节,又不至于使图片过暗、保留的信息过多.

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

Gamma矫正首先要进行归一化处理 即将像素值转换为０\~１的实数 算法为 i＋０敭

５ ２５６ 再进行预补

偿 求出像素归一化后的数据以１ Gamma为指数的对应值 算法为pow f fPrecompensation 最后 进行

反归一化 将经过预补偿的实数值反变换为０\~２５５的整数值 具体算法为 f∗２５６－０敭５.如果每一

个像素点都要进行这三步运算 则 计 算 量 比 较 大 故 选 择 建 立 一 个 索 引 表 用 一 个 数 组 存 储 ０\~２５５

所对应的 Gamma矫正后的像素值 遍历图片时就只需要根据索引表进行处理.

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

[]{#index_split_002.html#p135}![index-135_1.png](https://i.imgur.com/T85czOX.jpeg){.calibre2}

![index-135_2.png](https://i.imgur.com/UkpiYHl.jpeg){.calibre2}

![index-135_3.png](https://i.imgur.com/yUq0Pbg.jpeg){.calibre2}

![index-135_4.png](https://i.imgur.com/PekfwML.jpeg){.calibre2}

![index-135_5.png](https://i.imgur.com/YT7zMOP.jpeg){.calibre2}

![index-135_6.png](https://i.imgur.com/wnWEqub.jpeg){.calibre2}

![index-135_7.png](https://i.imgur.com/eQSep2R.jpeg){.calibre2}

![index-135_8.png](https://i.imgur.com/1sFEXqq.jpeg){.calibre2}

![index-135_9.png](https://i.imgur.com/Oh9ahJo.jpeg){.calibre2}

![index-135_10.png](https://i.imgur.com/OSgO01f.jpeg){.calibre2}

１２４

voidprocess

BuildTable floatfPrecompensation

inti

floatf

for i＝ ０ i ２５６ i++

f＝ i＋ ０敭

５F ２５６

归一化

f＝ float pow f fPrecompensation

预补偿

g_GammaL i ＝ unsignedchar f∗ ２５６ － ０敭

５F

反归一化

voidprocess

GammaCorrect IplImage∗img\_

degree＝０敭

１ ５敭

０

inti j

遍历图片

for i＝ ０ i img\_－ height i++

for j＝ ０ j img\_－ width j++

检索获取当前的像素值所对应的Gamma矫正后的像素值并修改为后者

cvSet２D img\_ i j g_GammaL unsignedchar cvGet２D img\_ i j 敭val ０

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

利用人脸检测部分对五官的定位矩形框 从灰度图上将五官部分截取下来 分别对五官进行 Gamma矫

正处理和保存.

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

voidprocess GammaCorrect_All CvRectFace\_ CvRectlefteye\_ CvRectrighteye\_ CvRectnose\_

CvRectmouth\_

左眼

cvSetImageROI img CvRect Face_敭x ＋ lefteye_敭x Face_敭y lefteye_敭width lefteye_敭y ＋

lefteye_敭

height

感兴趣的区域大小一样

lefteye＝ cvCreateImage cvGetSize img img－ depth img－ nChannels 截取并复制

cvCopy img lefteye NULL

重置

cvSaveImage ＂lefteye敭jpg＂ lefteye

把图像写入文件

GammaCorrect lefteye

cvSaveImage ＂lefteye_gamma敭jpg＂ lefteye 把图像写入文件

cvResetImageROI img

右眼

cvSetImageROI img CvRect Face_敭x ＋ righteye_敭x＋ Face_敭width ２敭５ Face_敭y righteye\_

敭

width righteye_敭

y ＋ righteye_敭

height

感兴趣的区域大小一样

righteye＝ cvCreateImage cvGetSize img img－ depth img－ nChannels 截取并复制

cvCopy img righteye NULL

重置

cvSaveImage ＂righteye敭jpg＂ righteye

把图像写入文件

GammaCorrect righteye

[]{#index_split_002.html#p136}![index-136_1.png](https://i.imgur.com/Ie4c01Z.jpeg){.calibre2}

![index-136_2.png](https://i.imgur.com/BKDboIr.jpeg){.calibre2}

![index-136_3.png](https://i.imgur.com/Z76kQEQ.jpeg){.calibre2}

![index-136_4.png](https://i.imgur.com/0ZkmlvC.jpeg){.calibre2}

![index-136_5.png](https://i.imgur.com/o9ea2cf.jpeg){.calibre2}

![index-136_6.png](https://i.imgur.com/Q2QCuVT.jpeg){.calibre2}

１２５

cvSaveImage ＂righteye_gamma敭jpg＂ righteye 把图像写入文件

cvResetImageROI img

鼻子

cvSetImageROI img CvRect Face_敭x＋ nose_敭x＋ lefteye_敭width Face_敭y＋ Face_敭height ５ ＋ lefteye_敭

height ＋ righteye_敭

height ２ ＋ nose_敭

y nose_敭

width nose_敭

height

感兴趣的区域大小一样

Nose＝ cvCreateImage cvGetSize img img－ depth img－ nChannels 　 截取并复制

cvCopy img Nose NULL

重置

cvSaveImage ＂nose敭jpg＂ Nose

把图像写入文件

GammaCorrect Nose

cvSaveImage ＂nose_gamma敭jpg＂ Nose

把图像写入文件

cvResetImageROI img

嘴

cvSetImageROI img CvRect Face_敭

x＋ lefteye_敭

x＋ mouth_敭

x Face_敭

height ３敭

５ ＋ Face_敭

y＋

nose_敭

y＋ nose_敭

height＋ mouth_敭

y mouth_敭

width mouth_敭

height 　 感兴趣的区域大小一样

Mouth＝ cvCreateImage cvGetSize img img－ depth img－ nChannels 　 截取并复制

cvCopy img Mouth NULL

重置

cvSaveImage ＂mouth敭jpg＂ Mouth

把图像写入文件

GammaCorrect Mouth

cvSaveImage ＂mouth_gamma敭jpg＂ Mouth

把图像写入文件

cvResetImageROI img

Gamma矫正前后的图像对比如图３Ｇ７所示,右侧为矫正后的图片.

图３Ｇ７　矫正图片对比

(３)与运算叠加

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

虽然图像转化为了二值图像 像素存储上依旧为２４位 所以类似于二值图像的与运算叠加 只要有一

个像素为黑色 ０ 叠加就为黑色 ０&０＝０

１&０＝０

０&１＝０ 否则为白色 １&１＝１ .由于前面的操作

图 像中只存在 ０

０

０ 和 ２５５

２５５

２５５ 的像素点 只需要判断两个像素的 R值、G值或 B值是否都为

２５５ 白色 即可判断叠加的像素的颜色.代码中选择 R值进行判断 对五官分别进行处理与叠加 生

[]{#index_split_002.html#p137}![index-137_1.png](https://i.imgur.com/Fjf0eLb.jpeg){.calibre2}

![index-137_2.png](https://i.imgur.com/ZT4toml.jpeg){.calibre2}

![index-137_3.png](https://i.imgur.com/Xjm6CNw.jpeg){.calibre2}

![index-137_4.png](https://i.imgur.com/ALQjIai.jpeg){.calibre2}

![index-137_5.png](https://i.imgur.com/IG2w6zk.jpeg){.calibre2}

![index-137_6.png](https://i.imgur.com/CHds93L.jpeg){.calibre2}

![index-137_7.png](https://i.imgur.com/DHrXh9n.jpeg){.calibre2}

![index-137_8.png](https://i.imgur.com/mqbtTXH.jpeg){.calibre2}

![index-137_9.png](https://i.imgur.com/O8GeCfN.jpeg){.calibre2}

![index-137_10.png](https://i.imgur.com/DUyUXQ2.jpeg){.calibre2}

![index-137_11.png](https://i.imgur.com/9DeJvZu.jpeg){.calibre2}

![index-137_12.png](https://i.imgur.com/Jrhts1N.jpeg){.calibre2}

![index-137_13.png](https://i.imgur.com/Tne7WKU.jpeg){.calibre2}

１２６

成的中间图片用于参考与对比.

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

voidprocess

binary CvRectFace\_ CvRectlefteye\_ CvRectrighteye\_ CvRectnose\_ CvRectmouth\_

inti j

左眼

IplImage∗ img_binary＝ cvCreateImage cvGetSize img img－ depth img－ nChannels 复制

cvThreshold img img_binary １４５ ２５５ CV_THRESH_BINARY 　　　 二值化

img ＝ img_binary

cvSaveImage ＂face_bi敭

jpg＂ img

把图像写入文件

img_binary ＝cvCreateImage cvGetSize img img－ depth img－ nChannels img_final_binary ＝ img

img_binary ＝cvCreateImage cvGetSize lefteye lefteye－ depth lefteye－ nChannels

复制

cvThreshold lefteye img_binary １４５ ２５５ CV_THRESH_BINARY 二值化

lefteye ＝ img_binary

cvSaveImage ＂lefteye_bi敭

jpg＂ lefteye

把图像写入文件

CvScalars t

q

doublem

for i＝ ０ i lefteye_敭

height ＋ lefteye_敭

y i++

for j＝ ０ j lefteye_敭

width j++

s＝ cvGet２D img_final_binary i＋ Face_敭y j＋ Face_敭x＋ lefteye_敭x t＝ cvGet２D lefteye i j

if s敭val ０ ＝＝ ２５５敭

０&&t敭

val ０ ＝＝ ２５５敭

０

m＝ ２５５敭

０

elsem＝ ０

cvSet２D img_final_binary i＋ Face_敭y j＋ Face_敭x＋ lefteye_敭x m cvSaveImage ＂face_bi_１敭

jpg＂ img_final_binary

把图像写入文件

右眼

img_binary＝cvCreateImage cvGetSize righteye righteye－ depth

righteye－ nChannels

复制

cvThreshold righteye img_binary １４５ ２５５ CV_THRESH_BINARY 二值化

righteye ＝ img_binary

cvSaveImage ＂righteye_bi敭

jpg＂ righteye

把图像写入文件

for i＝ ０ i righteye_敭

y ＋ righteye_敭

height i++

for j＝ ０ j righteye_敭

width j++

s＝ cvGet２D img_final_binary i＋ Face_敭

y j＋ Face_敭

x＋ righteye_敭

x＋ Face_敭

width ２敭

５

[]{#index_split_002.html#p138}![index-138_1.png](https://i.imgur.com/9DcpbFt.jpeg){.calibre2}

![index-138_2.png](https://i.imgur.com/tjF1kLi.jpeg){.calibre2}

![index-138_3.png](https://i.imgur.com/CCuwawt.jpeg){.calibre2}

![index-138_4.png](https://i.imgur.com/iQzd8gG.jpeg){.calibre2}

![index-138_5.png](https://i.imgur.com/y8nG2AF.jpeg){.calibre2}

![index-138_6.png](https://i.imgur.com/J7ylN3K.jpeg){.calibre2}

![index-138_7.png](https://i.imgur.com/FAXWMEE.jpeg){.calibre2}

![index-138_8.png](https://i.imgur.com/bCNPoir.jpeg){.calibre2}

![index-138_9.png](https://i.imgur.com/jMec1ii.jpeg){.calibre2}

１２７

t ＝ cvGet２D righteye i j

if s敭

val ０ ＝＝ ２５５敭

０&&t敭

val ０ ＝＝ ２５５敭

０

m＝ ２５５敭

０

elsem＝ ０

cvSet２D img_final_binary i＋ Face_敭

y j ＋ Face_敭

x ＋ righteye_敭

x ＋ Face_敭

width ２敭

５ m

cvSaveImage ＂face_bi_２敭

jpg＂ img_final_binary

把图像写入文件

鼻子

img_binary ＝ cvCreateImage cvGetSize Nose Nose－ depth Nose－ nChannels 复制

cvThreshold Nose img_binary １４５ ２５５ CV_THRESH_BINARY

二值化

Nose ＝ img_binary

cvSaveImage ＂Nose_bi敭

jpg＂ Nose

把图像写入文件

for i＝ ０ i nose_敭height i++

for j＝ ０ j nose_敭width j++

s＝ cvGet２D img_final_binary i＋ Face_敭y＋ Face_敭height ５＋ lefteye_敭height＋

righteye_敭

height ２ ＋ nose_敭

y j ＋ Face_敭

x ＋ nose_敭

x ＋ lefteye_敭

width

t＝ cvGet２D Nose i j

if s敭val ０ ＝＝ ２５５敭

０&&t敭

val ０ ＝＝ ２５５敭

０

m＝ ２５５敭

０

elsem＝ ０

cvSet２D img_final_binary i ＋ Face_敭y ＋ Face_敭height ５ ＋ lefteye_敭height ＋

righteye_敭

height ２ ＋ nose_敭

y j ＋ Face_敭

x ＋ nose_敭

x ＋ lefteye_敭

width m

cvSaveImage ＂face_bi_３敭jpg＂ img_final_binary 把图像写入文件

嘴巴

img_binary＝ cvCreateImage cvGetSize Mouth Mouth－ depth Mouth－ nChannels 复制

cvThreshold Mouth img_binary １４５ ２５５ CV_THRESH_BINARY 二值化

Mouth＝ img_binary

cvSaveImage ＂Mouth_bi敭jpg＂ Mouth

把图像写入文件

for i＝ ０ i mouth_敭height i++

for j＝ ０ j mouth_敭width j++

s＝ cvGet２D img_final_binary i＋ Face_敭height ３敭

５ ＋ Face_敭

y＋ nose_敭

y＋ nose\_

敭

height ＋ mouth_敭

y j ＋ Face_敭

x ＋ lefteye_敭

x ＋ mouth_敭

x

t＝ cvGet２D Mouth i j

if s敭val ０ ＝＝ ２５５敭

０&&t敭

val ０ ＝＝ ２５５敭

０

m＝ ２５５敭

０

elsem＝ ０

cvSet２D img_final_binary i ＋ Face_敭height ３敭５ ＋ Face_敭y ＋ nose_敭y ＋ nose\_

[]{#index_split_002.html#p139}![index-139_1.png](https://i.imgur.com/e36goJH.jpeg){.calibre2}

![index-139_2.png](https://i.imgur.com/Jh7U3wj.jpeg){.calibre2}

![index-139_3.png](https://i.imgur.com/kEkst2A.jpeg){.calibre2}

![index-139_4.png](https://i.imgur.com/Se758l0.jpeg){.calibre2}

![index-139_5.png](https://i.imgur.com/SunOeMd.jpeg){.calibre2}

![index-139_6.png](https://i.imgur.com/gnd1Ih1.jpeg){.calibre2}

![index-139_7.png](https://i.imgur.com/5rnmMs6.jpeg){.calibre2}

![index-139_8.png](https://i.imgur.com/QS5XPCK.jpeg){.calibre2}

![index-139_9.png](https://i.imgur.com/aB4lYZ8.jpeg){.calibre2}

![index-139_10.png](https://i.imgur.com/QkYlx1e.jpeg){.calibre2}

１２８

敭

height ＋ mouth_敭

y j ＋ Face_敭

x ＋ lefteye_敭

x ＋ mouth_敭

x m

cvSaveImage ＂face_bi_４敭jpg＂ img_final_binary 把图像写入文件

与运算叠加前后的图片如图３Ｇ８所示,右侧为处理后的图片.

图３Ｇ８　与运算叠加前后图片对比

５．添加文字模块

１)功能介绍

对预处理后的图片进行文字添加,实现图片处理的最终目的.

２)相关代码

(１)在空白图片上打印文字.

用 C++ 的 Win３２控制台程序很难实现把文字打印到图片的功能,而且即使可以做到, 字号的控制、字体的控制都很难实现,所以要借用 GDI工具,在 MFC程序中实现该功能.

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

首先 按照图片的大小生成一张空白图片用于填充文字.

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

IplImage∗img＝ cvLoadImage ＂eyePhoto ３ 敭jpg＂

CvSizesize＝ cvSize img－ width img－ height IplImage∗ img\_ ＝ cvCreateImage size IPL_DEPTH_８U ３

for inti＝ ０ i img\_－ height i++

unsignedchar∗Pout＝ unsignedchar∗ img\_－ imageData＋ i∗img\_－ widthStep for intj＝ ０ j img\_－ width j++

Pout ３ ∗ j＋ ０ ＝ ２５５

Pout ３ ∗ j＋ １ ＝ ２５５

Pout ３ ∗ j＋ ２ ＝ ２５５

[]{#index_split_002.html#p140}![index-140_1.png](https://i.imgur.com/7X6hSMH.jpeg){.calibre2}

![index-140_2.png](https://i.imgur.com/KOQhgAg.jpeg){.calibre2}

![index-140_3.png](https://i.imgur.com/vmkoUdr.jpeg){.calibre2}

１２９

cvSaveImage ＂blank敭jpg＂ img\_

把图像写入文件

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

利用 MFC和GDI工具 将文字按照随机的大小打印在图片上 大文字控制每个字的长度为２０\~４０磅

小文字则不必要求大小 因为小文字越 密 越 好.由 像 素 和 磅 的 换 算 关 系 １px＝４ ３ 磅 求 出 每 个 字

长度的像素值 计 算 每 行 的 字 数 再 填 充. 其 中 GetEncoderClsid 函 数 用 于 获 得 编 码 器 的 CLSID

Windows系统对于不同的应用程序、文件 类 型、

OLE对 象、特 殊 文 件 夹 以 及 各 种 系 统 组 件 分 配 一 个 唯

一表示它的 ID代码 用于对其身份进行标识以与其他对象进行区分.

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

Imageimage L＂F

\\\\设计\\\\图片文件夹\\\\blank敭jpg＂ 加载图片

intwidth＝ image敭GetWidth

获取图片的长度

intheight＝ image敭GetHeight

获取图片的宽度

intsum_height

intsum_width

intSize

２０\~４０

intNum

每一行文字的大小

intthreshold＝ min height width ２５

intpx

每个字的像素值

intcount

每行需要的文字数目

intcircle

循环次数

GraphicsimageGraphics &image

通过image对象创建绘图句柄 使用

句柄对图片进行操作

imageGraphics敭SetTextRenderingHint TextRenderingHintAntiAlias WCHARstring ＝ L＂程序设计实践＂

要写的字

FontFamilyfontFamily L＂楷体＂

SolidBrushblackBrush Color ２５５ ０ ０ ０

半透明＋文字RGB颜色

StringFormatFormat

Format敭SetAlignment StringAlignmentNear 文本排列方式 在对应位置居中、靠

左或靠右

srand unsigned time NULL

for sum_height＝ ０ sum_height height

sum_width＝ ０

Num＝ rand ％ threshold

if Num threshold ２

continue

else

Size＝ Num

每一行文字的大小

px＝ ceil double Num∗ ４ ３

每个字的像素值

count＝ ceil double width px

每行需要的文字数目

circle＝ ceil double count ６

[]{#index_split_002.html#p141}![index-141_1.png](https://i.imgur.com/Gv01S9H.jpeg){.calibre2}

![index-141_2.png](https://i.imgur.com/TnfAUIS.jpeg){.calibre2}

![index-141_3.png](https://i.imgur.com/O94wIif.jpeg){.calibre2}

１３０

for intj＝ ０ j circle j++

PointFschool_site REAL sum_width REAL sum_height 　 文字放置的像素坐标

Gdiplus FontmyFont &fontFamily Size FontStyleRegular UnitPoint imageGraphics敭DrawString string wcslen string &myFont school_site &Format

&blackBrush

把string绘制到图上

sum_width＝ sum_width＋ px∗ ６

sum_height＝ sum_height＋ px

CLSIDpngClsid

GetEncoderClsid L＂image jpeg＂ &pngClsid image敭Save L＂F

\\\\设计\\\\图片文件夹\\\\大文字敭jpg＂ &pngClsid NULL

保存添加文字的图像

intGetEncoderClsid constWCHAR∗ format CLSID∗ pClsid UINTnum＝ ０

UINTsize＝ ０

ImageCodecInfo∗ pImageCodecInfo＝ NULL

GetImageEncodersSize &num &size if size＝＝ ０

return－１

pImageCodecInfo＝ ImageCodecInfo∗ malloc size if pImageCodecInfo＝＝ NULL

return－１

GetImageEncoders num size pImageCodecInfo for UINTj＝ ０ j num ++j

if wcscmp pImageCodecInfo j 敭MimeType format ＝＝ ０

∗pClsid＝ pImageCodecInfo j 敭Clsid

free pImageCodecInfo

returnj

free pImageCodecInfo

return－１

[]{#index_split_002.html#p142}![index-142_1.png](https://i.imgur.com/TubWlYJ.jpeg){.calibre2}

![index-142_2.png](https://i.imgur.com/WAqiMwb.jpeg){.calibre2}

![index-142_3.png](https://i.imgur.com/lp7XXq8.jpeg){.calibre2}

![index-142_4.png](https://i.imgur.com/6K3K61g.jpeg){.calibre2}

![index-142_5.png](https://i.imgur.com/UmKM0iK.jpeg){.calibre2}

![index-142_6.png](https://i.imgur.com/3KYyliJ.jpeg){.calibre2}

![index-142_7.png](https://i.imgur.com/0uTmZsO.jpeg){.calibre2}

![index-142_8.png](https://i.imgur.com/StzqgjW.jpeg){.calibre2}

![index-142_9.png](https://i.imgur.com/Db1bdyF.jpeg){.calibre2}

![index-142_10.png](https://i.imgur.com/8FOtDxL.jpeg){.calibre2}

１３１

添加文字后的效果如图３Ｇ９所示.

图３Ｇ９　添加文字后的效果

(２)文字叠加

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

建立一个新图片 如果与运算叠加形 成 的 二 值 图 像 的 某 一 像 素 为 黑 色 则 保 留 该 文 字 图 片 此 处 的 像

素值 如果二值图像的某一像素为白色 则新图片此处像素值为白色.由于五官是特别关注的 所以

要先定位并处理五官部分 最后再叠加其余部分 即处理完五官后 如果二值图像的像素 为 黑 色 且 新

图像此处像素不为黑色 则保留二值图像此处的像素值即可.

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

voidAdd

AddWord CvRectface

CvRectlefteye CvRectrighteye CvRectnose CvRectmouth CvSizesize＝ cvSize img－ width img－ height IplImage∗ img\_ ＝ cvCreateImage size IPL_DEPTH_８U ３

for inti＝ ０ i img\_－ height i++

unsignedchar∗Pout＝ unsignedchar∗ img\_－ imageData＋ i∗img\_－ widthStep for intj＝ ０ j img\_－ width j++

Pout ３ ∗ j＋ ０ ＝ ２５５

Pout ３ ∗ j＋ １ ＝ ２５５

Pout ３ ∗ j＋ ２ ＝ ２５５

[]{#index_split_002.html#p143}![index-143_1.png](https://i.imgur.com/5pRsXmX.jpeg){.calibre2}

![index-143_2.png](https://i.imgur.com/ze5X0qO.jpeg){.calibre2}

![index-143_3.png](https://i.imgur.com/KnJDP6Y.jpeg){.calibre2}

![index-143_4.png](https://i.imgur.com/8qh4YOR.jpeg){.calibre2}

![index-143_5.png](https://i.imgur.com/ZwVQvaC.jpeg){.calibre2}

![index-143_6.png](https://i.imgur.com/bWrH10e.jpeg){.calibre2}

![index-143_7.png](https://i.imgur.com/whpPJie.jpeg){.calibre2}

![index-143_8.png](https://i.imgur.com/CHAqTY6.jpeg){.calibre2}

![index-143_9.png](https://i.imgur.com/ve0Nu63.jpeg){.calibre2}

![index-143_10.png](https://i.imgur.com/S0us42G.jpeg){.calibre2}

![index-143_11.png](https://i.imgur.com/EpJcP5q.jpeg){.calibre2}

![index-143_12.png](https://i.imgur.com/aMxMseC.jpeg){.calibre2}

![index-143_13.png](https://i.imgur.com/vOxfFs5.jpeg){.calibre2}

![index-143_14.png](https://i.imgur.com/PfVHypR.jpeg){.calibre2}

![index-143_15.png](https://i.imgur.com/btnThTD.jpeg){.calibre2}

![index-143_16.png](https://i.imgur.com/QbPbJQv.jpeg){.calibre2}

![index-143_17.png](https://i.imgur.com/7hFZS86.jpeg){.calibre2}

![index-143_18.png](https://i.imgur.com/SdxNWfX.jpeg){.calibre2}

![index-143_19.png](https://i.imgur.com/MPzOBGt.jpeg){.calibre2}

![index-143_20.png](https://i.imgur.com/jf6xeJb.jpeg){.calibre2}

![index-143_21.png](https://i.imgur.com/LQrx8lS.jpeg){.calibre2}

![index-143_22.png](https://i.imgur.com/giMe8lD.jpeg){.calibre2}

![index-143_23.png](https://i.imgur.com/LroBamM.jpeg){.calibre2}

１３２

左眼

cvSetImageROI img\_ CvRect face敭x ＋ lefteye敭x face敭y lefteye敭width lefteye敭y ＋

lefteye敭

height

感兴趣的区域

for inti＝ face敭y i\_＝０ i lefteye敭height＋ face敭y＋lefteye敭y i\_ lefteye敭height＋

lefteye敭

y i++

i\_++

unsignedchar∗P＝ unsignedchar∗ img－ imageData＋ i∗img－ widthStep unsignedchar∗Pout＝ unsignedchar∗ img\_－ imageData＋ i∗img\_－ widthStep unsignedchar∗pout_small＝ unsignedchar∗ img_small－ imageData＋i\_∗img_small

－ widthStep

for intj＝ face敭x＋ lefteye敭x j\_＝０ j lefteye敭width＋ face敭x＋ lefteye敭x j\_

lefteye敭

width j++

j\_++

if P ３ ∗ j＋ ０ ３０

Pout ３ ∗ j＋ ０ ＝ pout_small ３ ∗ j\_ ＋ ０

Pout ３ ∗ j＋ １ ＝ pout_small ３ ∗ j\_ ＋ １

Pout ３ ∗ j＋ ２ ＝ pout_small ３ ∗ j\_ ＋ ２

右眼

cvSetImageROI img CvRect Face_敭

x ＋ righteye_敭

x ＋ Face_敭

width ２敭

５ Face_敭

y righteye_敭

width righteye_敭

y ＋ righteye_敭

height

感兴趣的区域

for inti＝ face敭y i\_ ＝ ０ i righteye敭height ＋ face敭y ＋ righteye敭y i\_ righteye敭

height ＋ righteye敭

y i++ i\_++

unsignedchar∗P＝ unsignedchar∗ img－ imageData＋ i∗img－ widthStep unsignedchar∗Pout＝ unsignedchar∗ img\_－ imageData＋ i∗img\_－ widthStep unsignedchar∗pout_small ＝ unsignedchar∗ img_small－ imageData ＋ i\_ ∗img\_

small－ widthStep

for intj ＝ face敭x ＋ righteye敭x＋face敭width ２敭５ j\_ ＝ ０ j righteye敭width ＋

face敭

x ＋ righteye敭

x＋face敭

width ２敭

５ j\_ righteye敭

width j++ j\_++

if P ３ ∗ j＋ ０ ３０

Pout ３ ∗ j＋ ０ ＝ pout_small ３ ∗ j\_ ＋ ０

Pout ３ ∗ j＋ １ ＝ pout_small ３ ∗ j\_ ＋ １

Pout ３ ∗ j＋ ２ ＝ pout_small ３ ∗ j\_ ＋ ２

[]{#index_split_002.html#p144}![index-144_1.png](https://i.imgur.com/yX9MeOo.jpeg){.calibre2}

![index-144_2.png](https://i.imgur.com/wPBPOuQ.jpeg){.calibre2}

![index-144_3.png](https://i.imgur.com/Ven8uWt.jpeg){.calibre2}

![index-144_4.png](https://i.imgur.com/S09GpqP.jpeg){.calibre2}

![index-144_5.png](https://i.imgur.com/OUyRkGV.jpeg){.calibre2}

![index-144_6.png](https://i.imgur.com/Jn1IHX3.jpeg){.calibre2}

![index-144_7.png](https://i.imgur.com/U1FuPKt.jpeg){.calibre2}

![index-144_8.png](https://i.imgur.com/7ZEbOsk.jpeg){.calibre2}

![index-144_9.png](https://i.imgur.com/TRQnavY.jpeg){.calibre2}

![index-144_10.png](https://i.imgur.com/NxUNpyA.jpeg){.calibre2}

![index-144_11.png](https://i.imgur.com/lkjYMMl.jpeg){.calibre2}

![index-144_12.png](https://i.imgur.com/ut4SFcc.jpeg){.calibre2}

![index-144_13.png](https://i.imgur.com/WPIOCH6.jpeg){.calibre2}

![index-144_14.png](https://i.imgur.com/oB4R7ZK.jpeg){.calibre2}

![index-144_15.png](https://i.imgur.com/P1ZTLGI.jpeg){.calibre2}

![index-144_16.png](https://i.imgur.com/8xe4cOy.jpeg){.calibre2}

![index-144_17.png](https://i.imgur.com/qeIdmfW.jpeg){.calibre2}

![index-144_18.png](https://i.imgur.com/23r63dM.jpeg){.calibre2}

![index-144_19.png](https://i.imgur.com/EgRYevX.jpeg){.calibre2}

![index-144_20.png](https://i.imgur.com/WUlgZld.jpeg){.calibre2}

![index-144_21.png](https://i.imgur.com/JMu9I3M.jpeg){.calibre2}

１３３

鼻子

cvSetImageROI img CvRect Face_敭

x ＋ nose_敭

x ＋ lefteye_敭

width Face_敭

y ＋ Face_敭

height

５ ＋ lefteye_敭

height ＋ righteye_敭

height ２ ＋ nose_敭

y nose_敭

width nose_敭

height

感兴趣的区域

for inti ＝ face敭y ＋ face敭height ５ ＋ lefteye敭height ＋ righteye敭height ２ ＋

nose敭

y i\_ ＝ ０ i nose敭

height＋ face敭

y＋ face敭

height ５ ＋ lefteye敭

height＋ righteye敭

height

２ ＋ nose敭

y i++ i\_++

unsignedchar∗P＝ unsignedchar∗ img－ imageData＋ i∗img－ widthStep unsignedchar∗Pout＝ unsignedchar∗ img\_－ imageData＋ i∗img\_－ widthStep unsignedchar∗pout_small ＝ unsignedchar∗ img_small－ imageData ＋ i\_ ∗img\_

small－ widthStep

for intj ＝ face敭x ＋ nose敭x ＋ lefteye敭width j\_ ＝ ０ j face敭x ＋ nose敭x ＋

lefteye敭

width ＋nose敭

width j\_ nose敭

width j++ j\_++

if P ３ ∗ j＋ ０ ３０

Pout ３ ∗ j＋ ０ ＝ pout_small ３ ∗ j\_ ＋ ０

Pout ３ ∗ j＋ １ ＝ pout_small ３ ∗ j\_ ＋ １

Pout ３ ∗ j＋ ２ ＝ pout_small ３ ∗ j\_ ＋ ２

嘴巴

cvSetImageROI img CvRect Face_敭x ＋ lefteye_敭x ＋ mouth_敭x Face_敭height ３敭５ ＋

Face_敭

y ＋ nose_敭

y ＋ nose_敭

height ＋ mouth_敭

y mouth_敭

width mouth_敭

height

感兴趣的区域

for inti＝ face敭height ３敭

５ ＋ face敭

y ＋ nose敭

y ＋ nose敭

height ＋ mouth敭

y i\_ ＝ ０ i

face敭

height ３敭

５ ＋ face敭

y ＋ nose敭

y ＋ nose敭

height ＋ mouth敭

y＋mouth敭

height i++ i\_++

unsignedchar∗P＝ unsignedchar∗ img－ imageData＋ i∗img－ widthStep unsignedchar∗Pout＝ unsignedchar∗ img\_－ imageData＋ i∗img\_－ widthStep unsignedchar∗pout_small ＝ unsignedchar∗ img_small－ imageData ＋ i\_ ∗img\_

small－ widthStep

for intj ＝ face敭x ＋ lefteye敭x ＋ mouth敭x j\_ ＝ ０ j face敭x ＋ lefteye敭x ＋

mouth敭

x ＋ mouth敭

width j\_ mouth敭

width j++ j\_++

if P ３ ∗ j＋ ０ ３０

Pout ３ ∗ j＋ ０ ＝ pout_small ３ ∗ j\_ ＋ ０

Pout ３ ∗ j＋ １ ＝ pout_small ３ ∗ j\_ ＋ １

Pout ３ ∗ j＋ ２ ＝ pout_small ３ ∗ j\_ ＋ ２

[]{#index_split_002.html#p145}![index-145_1.png](https://i.imgur.com/Mqx1DEU.jpeg){.calibre2}

![index-145_2.png](https://i.imgur.com/qd9U4nm.jpeg){.calibre2}

![index-145_3.png](https://i.imgur.com/NNPmQST.jpeg){.calibre2}

![index-145_4.png](https://i.imgur.com/H87twK1.jpeg){.calibre2}

![index-145_5.png](https://i.imgur.com/PEBPs9A.jpeg){.calibre2}

![index-145_6.png](https://i.imgur.com/aE9OZWE.jpeg){.calibre2}

![index-145_7.png](https://i.imgur.com/8ovLJQH.jpeg){.calibre2}

![index-145_8.png](https://i.imgur.com/SaIEZoZ.jpeg){.calibre2}

![index-145_9.png](https://i.imgur.com/tt53YSm.jpeg){.calibre2}

![index-145_10.png](https://i.imgur.com/4UEyFS7.jpeg){.calibre2}

![index-145_11.png](https://i.imgur.com/ymqV2wg.jpeg){.calibre2}

![index-145_12.png](https://i.imgur.com/z553kd3.jpeg){.calibre2}

![index-145_13.png](https://i.imgur.com/ZWl78f1.jpeg){.calibre2}

![index-145_14.png](https://i.imgur.com/XAYFnps.jpeg){.calibre2}

![index-145_15.png](https://i.imgur.com/UQ1B9pf.jpeg){.calibre2}

![index-145_16.png](https://i.imgur.com/qGgIPXk.jpeg){.calibre2}

１３４

其余部分

for inti＝ ０ i img\_－ height i++

unsignedchar∗P＝ unsignedchar∗ img－ imageData＋ i∗img－ widthStep unsignedchar∗Pout＝ unsignedchar∗ img\_－ imageData＋ i∗img\_－ widthStep unsignedchar∗pout_big ＝ unsignedchar∗ img_big－ imageData ＋ i∗img_big－

widthStep

for intj＝ ０ j img\_－ width j++

if P ３ ∗ j ３０&&Pout ３ ∗ j ２２０&&Pout ３ ∗ j＋１ ２２０&&Pout ３ ∗ j＋１

２２０

Pout ３ ∗ j＋ ０ ＝ pout_big ３ ∗ j＋ ０

Pout ３ ∗ j＋ １ ＝ pout_big ３ ∗ j＋ １

Pout ３ ∗ j＋ ２ ＝ pout_big ３ ∗ j＋ ２

cvSaveImage ＂black_example敭jpg＂ img\_

把图像写入文件

img_final＝ img\_

文字叠加后的效果如图３Ｇ１０所示.

图３Ｇ１０　文字叠加后的效果

[]{#index_split_002.html#p146}![index-146_1.png](https://i.imgur.com/0QOxJQo.jpeg){.calibre2}

![index-146_2.png](https://i.imgur.com/H4LDeU0.jpeg){.calibre2}

![index-146_3.png](https://i.imgur.com/XG09WO8.jpeg){.calibre2}

![index-146_4.png](https://i.imgur.com/ScRigHz.jpeg){.calibre2}

![index-146_5.png](https://i.imgur.com/vh00OYo.jpeg){.calibre2}

![index-146_6.png](https://i.imgur.com/F5xJNgM.jpeg){.calibre2}

![index-146_7.png](https://i.imgur.com/Wlex9W1.jpeg){.calibre2}

![index-146_8.png](https://i.imgur.com/UfTzMhM.jpeg){.calibre2}

![index-146_9.png](https://i.imgur.com/EOgUa3M.jpeg){.calibre2}

![index-146_10.png](https://i.imgur.com/R1H7sQj.jpeg){.calibre2}

![index-146_11.png](https://i.imgur.com/w1n6Tuq.jpeg){.calibre2}

![index-146_12.png](https://i.imgur.com/DsHz7NC.jpeg){.calibre2}

![index-146_13.png](https://i.imgur.com/A8CKqm5.jpeg){.calibre2}

![index-146_14.png](https://i.imgur.com/BQSBAJJ.jpeg){.calibre2}

![index-146_15.png](https://i.imgur.com/C5e2T97.jpeg){.calibre2}

１３５

(３)彩色处理

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

由于２４位图颜色的变化可分为以下６阶段的循环

２５５

０

０ → ２５５

０

２５５ → ０ ０ ２５５ → ０ ２５５

２５５ → ０

２５５

０ → ２５５

２５５

０ → ２５５

０

０ 故可以按照行数的变化使颜色也均匀地变化.

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

voidAdd

colorful

intsection＝ img_final－ height ６

每一部分的行数

intsection_color＝ ２５６ section

颜色步长

for intcount＝ ０ count ６ count++

if count＝＝ ０

第１变化阶段

for inti＝ ０ i section i++

unsignedchar ∗P ＝ unsignedchar∗ img_final－ imageData ＋ i∗img－

widthStep

for intj＝ ０ j img_final－ width j++

if P ３ ∗ j＋ ０ １２５

P ３ ∗ j＋ ０ ＝ ２５５

P ３ ∗ j＋ １ ＝ ０

P ３ ∗ j＋ ２ ＝ section_color∗i

if count＝＝ １

第２变化阶段

for inti＝ section i ２ ∗ section i++

unsignedchar ∗P ＝ unsignedchar∗ img_final－ imageData ＋ i∗img－

widthStep

for intj＝ ０ j img_final－ width j++

if P ３ ∗ j＋ ０ １２５

P ３ ∗ j＋ ０ ＝ ２５５ － section_color∗ i－ section P ３ ∗ j＋ １ ＝ ０

P ３ ∗ j＋ ２ ＝ ２５５

[]{#index_split_002.html#p147}![index-147_1.png](https://i.imgur.com/XCAi5np.jpeg){.calibre2}

![index-147_2.png](https://i.imgur.com/J5Symcx.jpeg){.calibre2}

![index-147_3.png](https://i.imgur.com/HepHtQt.jpeg){.calibre2}

![index-147_4.png](https://i.imgur.com/YUEoVrC.jpeg){.calibre2}

![index-147_5.png](https://i.imgur.com/KOmh6l1.jpeg){.calibre2}

![index-147_6.png](https://i.imgur.com/R9GT9oW.jpeg){.calibre2}

![index-147_7.png](https://i.imgur.com/ZlRkFEy.jpeg){.calibre2}

![index-147_8.png](https://i.imgur.com/5T2bXTU.jpeg){.calibre2}

![index-147_9.png](https://i.imgur.com/CD6X9ft.jpeg){.calibre2}

![index-147_10.png](https://i.imgur.com/yeiwswv.jpeg){.calibre2}

![index-147_11.png](https://i.imgur.com/0VipPLX.jpeg){.calibre2}

![index-147_12.png](https://i.imgur.com/WkJNpYS.jpeg){.calibre2}

![index-147_13.png](https://i.imgur.com/4vyJKJO.jpeg){.calibre2}

![index-147_14.png](https://i.imgur.com/9UffG0i.jpeg){.calibre2}

![index-147_15.png](https://i.imgur.com/UeR6BrS.jpeg){.calibre2}

![index-147_16.png](https://i.imgur.com/K9S6GDh.jpeg){.calibre2}

![index-147_17.png](https://i.imgur.com/xrKuZEX.jpeg){.calibre2}

![index-147_18.png](https://i.imgur.com/burW6Tv.jpeg){.calibre2}

![index-147_19.png](https://i.imgur.com/xIpGpoy.jpeg){.calibre2}

１３６

if count＝＝ ２

第３变化阶段

for inti＝ ２∗section i ３ ∗ section i++

unsignedchar ∗P ＝ unsignedchar∗ img_final－ imageData ＋ i∗img－

widthStep

for intj＝ ０ j img_final－ width j++

if P ３ ∗ j＋ ０ １２５

P ３ ∗ j＋ ０ ＝ ０

P ３ ∗ j＋ １ ＝ section_color∗ i－ ２ ∗ section P ３ ∗ j＋ ２ ＝ ２５５

if count＝＝３

第４变化阶段

for inti＝ ３ ∗ section i ４ ∗ section i++

unsignedchar ∗P ＝ unsignedchar∗ img_final－ imageData ＋ i∗img－

widthStep

for intj＝ ０ j img_final－ width j++

if P ３ ∗ j＋ ０ １２５

P ３ ∗ j＋ ０ ＝ ０

P ３ ∗ j＋ １ ＝ ２５５

P ３ ∗ j＋ ２ ＝ ２５５ － section_color∗ i－ ３ ∗ section if count＝＝４

第５变化阶段

for inti＝ ４ ∗ section i ５ ∗ section i++

unsignedchar ∗P ＝ unsignedchar∗ img_final－ imageData ＋ i∗img－

widthStep

for intj＝ ０ j img_final－ width j++

if P ３ ∗ j＋ ０ １２５

[]{#index_split_002.html#p148}![index-148_1.png](https://i.imgur.com/aAJ5Lbm.jpeg){.calibre2}

![index-148_2.png](https://i.imgur.com/1Zs8BMQ.jpeg){.calibre2}

![index-148_3.png](https://i.imgur.com/QAz4AhN.jpeg){.calibre2}

![index-148_4.png](https://i.imgur.com/Vo8AdBT.jpeg){.calibre2}

![index-148_5.png](https://i.imgur.com/Vdhq77U.jpeg){.calibre2}

![index-148_6.png](https://i.imgur.com/NulgS7s.jpeg){.calibre2}

![index-148_7.png](https://i.imgur.com/fZoCANO.jpeg){.calibre2}

![index-148_8.png](https://i.imgur.com/k0eKgrs.jpeg){.calibre2}

![index-148_9.png](https://i.imgur.com/HrxSv2t.jpeg){.calibre2}

![index-148_10.png](https://i.imgur.com/tedUOIk.jpeg){.calibre2}

![index-148_11.png](https://i.imgur.com/XrjDqKn.jpeg){.calibre2}

![index-148_12.png](https://i.imgur.com/3TkJszY.jpeg){.calibre2}

![index-148_13.png](https://i.imgur.com/ecx0QvM.jpeg){.calibre2}

![index-148_14.png](https://i.imgur.com/3m7vpW7.jpeg){.calibre2}

１３７

P ３ ∗ j＋ ０ ＝ section_color∗ i－ ４ ∗ section P ３ ∗ j＋ １ ＝ ２５５

P ３ ∗ j＋ ２ ＝ ０

if count＝＝５

第６变化阶段

for inti＝ ５ ∗ section i ６ ∗ section i++

unsignedchar ∗P ＝ unsignedchar∗ img_final－ imageData ＋ i∗img－

widthStep

for intj＝ ０ j img_final－ width j++

if P ３ ∗ j＋ ０ １２５

P ３ ∗ j＋ ０ ＝ ２５５

P ３ ∗ j＋ １ ＝ ２５５ － section_color∗ i－ ５ ∗ section P ３ ∗ j＋ ２ ＝ ０

for inti＝ ６∗section i img_final－ height i++

剩下的行数不够一个阶段的变化 重新开始直到遍历完即可

unsignedchar∗P＝ unsignedchar∗ img_final－ imageData＋ i∗img－ widthStep for intj＝ ０ j img_final－ width j++

if P ３ ∗ j＋ ０ １２５

P ３ ∗ j＋ ０ ＝ ２５５

P ３ ∗ j＋ １ ＝ ０

P ３ ∗ j＋ ２ ＝ section_color∗ i－ ６ ∗ section cvSaveImage ＂color_example敭jpg＂ img_final 把图像写入文件

[]{#index_split_002.html#p149}![index-149_1.png](https://i.imgur.com/xNarUP9.jpeg){.calibre2}

![index-149_2.png](https://i.imgur.com/VuttF3F.jpeg){.calibre2}

![index-149_3.png](https://i.imgur.com/pWJUfBM.jpeg){.calibre2}

１３８

３．

４　产品展示

整体外观如图３Ｇ１１所示,实现效果如图３Ｇ１２所示.

图３Ｇ１１　整体外观

图３Ｇ１２　实现效果

３．

５　故障及问题分析

问题１:检测五官及后续的过程中,如果检测每一部分时都要对整张图片进行扫描处

理,则运行比较慢.

解决方法:设定感兴趣的区域,每一步只对感兴趣的区域进行处理.

问题２:检测部分过小,只将眼睛的一部分勾选出来.

解决方法:进行大量调试后发现,检测到的左眼是一系列形似左眼的集合,而其中区域

最大的就是想要得到的结果.

问题３:检测部分错误,将眉毛识别成眼睛,且最初识别的嘴巴的范围较小.

解决方法:改变算法,根据识别出嘴巴的中心位置,依靠眼睛与鼻子的相对位置估算嘴

巴位置.

问题４:对侧脸图 片 识 别 不 出 某 只 眼 睛 或 者 嘴 巴 时,有 一 些 指 针 为 ０,程 序 不 能 继 续

运行.

解决方法:每一次检测五官后,判断指针是否为空,若为空则报错并结束运行.

问题５:当人脸的光照比较强时,二值化会丢失很多细节,尤其是五官部分.

解决方法:进行 Gamma矫正,并将校正后的图片叠加上去.

问题６:Gamma矫正时每个像素点的值都要进行修改,若每个点都要计算,则运行次数

比较多,复杂度较高.

[]{#index_split_002.html#p150}![index-150_1.png](https://i.imgur.com/dhrdhXj.jpeg){.calibre2}

１３９

解决方法:建立索引表.

问题７:如果要根据二值图像的黑色像素区域进行文字的依次输出,边缘控制不好,效

果会很差,运算量也极大.

解决方法:单独生成一张文字图片,然后再进行叠加运算.

问题８:用 Win３２控制台程序将文字叠加到图片上时,很难进行字号、字体的控制.

解决方法:用 GDI工具,在 MFC程序上运行.

问题９:当某张照片像素很低时,虽然人脸识别不会出问题,但是后期的文字生成与叠

加效果很差,因为完全是按照原来图像的大小来进行处理的,比如生成的文字就很模糊,后

期彩色处理后效果就很差.

解决方法:不要选取像素很低的图片,因为没有个性化与艺术化处理的意义.

问题１０:初始使用 OV７０６０摄像模块与 ArduinoMEGA 开发板,但是图像不够清晰且

很快就烧坏了 Arduino开发板.

解决方法:改用 USB摄像头进行输入,问题得以解决.

３．

６　元件清单

完成本项目所用到的元件及数量如表３Ｇ１所示.

表３Ｇ１　机械臂元件清单

元　　件

数量/个

Miniarm 亚力克外壳

１

POWER HD１９００A 舵机

４

舵机延长线(

１５cm)

１

ArduinoUNOR３开发板

１

M３/M２双用扳手

１

Arduino舵机扩展板

１

橡胶垫

４

M３×６螺丝

１８

M３×１０螺丝

１０

M３×２螺丝

１８

M３×１６螺丝

６

M３防松螺母

２４

M３普通螺母

１０

M３×１０通孔铜螺柱

４

M３×２５通孔铜螺柱

４

USB摄像头

１

[]{#index_split_002.html#p151}![index-151_1.png](https://i.imgur.com/e30eomZ.jpeg){.calibre2}

第４章

基于 Mathematica的

自动接球系统项目设计

４．

１　项目背景

在练习网球的过程中发现,捡球十分麻烦,费时费力.如果能够设计一款能自动识别网

球的飞行轨迹,预测其落点并接住网球的系统,能够很好地辅助练习者.因而,希望通过计

算机视觉原理解决这一问题.

同时,进一步引申,该项目可应用于多种体育项目.例如,在足球运动中可利用该系统

控制机器人进行自动守门;在乒乓球运动中可利用该系统实现人机对打;在篮球运动中可

以应用该系统分析运动者的投篮轨迹以辅助练习.可见,该项目的应用较为广泛.

４．

２　创新描述

本项目的创新点在于利用计算机视觉原理实现了 Mathematica与 Arduino开发板的融

合.目前,将 Arduino开发板与 Mathematica软件相结合的项目设计很少,而将计算机视觉

原理融入 Arduino开发板的项目更是稀少,个别项目也只是利用摄像头进行拍照、检测等.

通过摄像头采集画面,并运用多种复杂计算方法实现轨迹的预测,能够较为准确地判断球的

落点,进而控制接球机器人的运动,实现了较为完整的系统.

４．

３　功能及总体设计

本项目主要分四个模块进行设计:图像检测与采集模块、图像分析与处理模块、无线通

信模块和接球机器人模块.其中,前两个模块由 Mathematica软件以及摄像头硬件设备组

成,而后两个模块主要由 Arduino开发板及蓝牙、直流电机等外围子模块构成.

本章根据徐子晗、贾玉冬项目设计整理而成.

[]{#index_split_002.html#p152}![index-152_1.png](https://i.imgur.com/3xgaV5m.jpeg){.calibre2}

![index-152_2.png](https://i.imgur.com/w6Rzzzo.jpeg){.calibre2}

１４１

４．

３．

１　功能介绍

整体而言,系统的主要功能由 Mathematica软件和 Arduino开发板实现.Mathematica 软件主要用于图像处理、分析、计算等;Arduino开发板用于无线通信以及控制接球机器人

的行进轨迹.

首先,系统启动后,图像采集与检测模块每隔一定时间(

０．１s)自动采集图像,并检测前

后两张图像是否有变化.一旦检测到图像变化(说明有球进入摄像头画面),则采集摄像头

当前图像,分析 小 球 的 运 动 轨 迹,并 将 轨 迹 或 落 点 数 据 传 输 给 与 计 算 机 连 接 的 Arduino NANO 开发板.通过无线蓝牙通信,实现接球机器人所搭载的 ArduinoUNO 开发板对数

据的接收.最后,ArduinoUNO 开发板利用所接收的数据控制机器人的转向、前进等运动.

另外需要说明的是,系统在设计和实现时,分三种运行模式.模式一,外接摄像头从俯

视角度采集画面,用于分析在地面上滚动小球的直线运动轨迹;模式二,计算机内置摄像头

从平视角度采集画面,用于分析小球在二维平面内空中运动的抛物线轨迹;模式三是模式

一和模式二的结合,通过两个摄像头对两个视角的画面采集,可分析小球在三维空间内的抛

物线轨迹.在机器人的实现上,模式三与模式二合为同一模式(模式二是模式三的特例),而

模式一和模式二、模式三之间可通过拨码开关进行切换.

４．

３．

２　总体设计

首先,摄像头(包括计算机内置摄像头和外接摄像头)将采集的图像回传给计算机用于

图像分析和计算,Mathematica软件将计算得到的数据通过串口传送给 ArduinoNANO 开

发板.ArduinoNANO 开发板上搭载的 HCＧ０５蓝牙模块通过无线通信,继续将数据传送给

搭载在 ArduinoUNO 开发板上的另一个 HCＧ０５模块.ArduinoUNO 开发板接收到数据

后,启动机器人,机器人开始运动,借助直流电机驱动模块 L２９８N,控制其在地面的转向、前

进,实现接球功能.

１．整体框架图

系统整体框架如图４Ｇ１所示.

图４Ｇ１　整体框架图

[]{#index_split_002.html#p153}![index-153_1.png](https://i.imgur.com/NSdUNT4.jpeg){.calibre2}

![index-153_2.png](https://i.imgur.com/mn8tAAB.jpeg){.calibre2}

１４２

２．系统流程图

系统流程图如图４Ｇ２所示.

图４Ｇ２　系统流程图

系统开始工作后,启动 Mathematica软件与摄像头及 ArduinoNANO 开发板间的串口

通信.选择模式后,机器人进入准备接球的状态,Mathematica自动检测画面变化.当画面

发生变化即有小球抛入时,Mathematica采集实时图像并分析计算小球的运动轨迹及落点, 并将数据通过 ArduinoNANO 开发板上的蓝牙模块传送给 ArduinoUNO 开发板,进而控

制机器人移动到指定位置.完成一次接球后,重新启动系统即开始下一次的运行.

[]{#index_split_002.html#p154}![index-154_1.png](https://i.imgur.com/glxH5br.jpeg){.calibre2}

![index-154_2.png](https://i.imgur.com/ixCuwP4.jpeg){.calibre2}

１４３

３．总电路图

系统总电路(机器人部分)如图４Ｇ３所示.

图４Ｇ３　总电路图(机器人部分)

ArduinoUNO 开发板与元件之间的引脚连接如表４Ｇ１所示.

表４Ｇ１　ArduinoUNO 开发板与元件之间的引脚连接

元　　件

引脚

ArduinoUNO 开发板及直流电机驱动板

IN１

５

IN２

４

IN３

３

IN４

２

OUT１

直流电机１的负极

L２９８N直流电机驱动模块

OUT２

直流电机１的正极

OUT３

直流电机２的正极

OUT４

直流电机２的负极

VCC

外接９V 电源正极

GND

外接９V 电源负极

[]{#index_split_002.html#p155}![index-155_1.png](https://i.imgur.com/FxEaF4y.jpeg){.calibre2}

１４４

续表

元　　件

引脚

ArduinoUNO 开发板及直流电机驱动板

Key

置空

VCC

５V

GND

GND

HCＧ０５蓝牙模块

TX

８

RX

９

STATE

置空

正极

３．

３V

红外线发射管

负极

GND

正极

３．

３V

红外线接收管

负极

GND

输出

６

R 引脚

１１

G 引脚

１２

RGB三色 LED

B引脚

１３

GND

GND

左端引脚

置空

拨码开关

中间引脚

５V

右端引脚

GND

正极

L２９８N 直流电机驱动板 OUT２

直流电机１

负极

L２９８N 直流电机驱动板 OUT１

正极

L２９８N 直流电机驱动板 OUT３

直流电机２

负极

L２９８N 直流电机驱动板 OUT４

图４Ｇ３ 所 示 为 由 Arduino UNO 开 发 板 主 控 的 部 分. 可 以 看 到,图 中 左 上 角 是 与

ArduinoUNO 开发板连接的蓝牙无线通信模块 HCＧ０５,用于接收另一块 HCＧ０５传输的数

据.HCＧ０５的 TX、RX 引脚分别与 ArduinoUNO 开发板上对应的数字引脚连接,用于数据

的传输.RGB三色 LED 与 HCＧ０５ 处 在 同 一 块 面 包 板 上,当 机 器 人 处 于 不 同 状 态 时,该

LED 会通过不同颜色和方式进行提示(具体参见后续说明及代码中的注释).面包板上的

拨码开关用于切换机器人的工作模式,面包板置于机器人前端.

图４Ｇ３右侧部分是由L２９８N 控制的直流电机驱动部分,主要包括L２９８N 驱动模块及两

个直流电机.L２９８N 的４个输入端与 ArduinoUNO 开发板连接, ４个输出端分别接至２个

直流电机的正负极.L２９８N 模块由９V 电源供电.

图４Ｇ３左下侧部分为一组红外线对射管,用于检测机器人是否成功接住小球.该对射

管由一个红外线发射管和一个红外线接收管构成.红外线发射管由 ArduinoUNO 开发板

供电,而红外线接收管不但需要由 ArduinoUNO 开发板供电,还需要将是否接收到红外线

的信息传输给 ArduinoUNO 开发板的数字引脚.在实际搭建机器人时,该红外线对射管

置于接球盒子的两端,一旦成功接住小球,红外线接收管即无法接收红外线.

[]{#index_split_002.html#p156}![index-156_1.png](https://i.imgur.com/2eGKzvf.jpeg){.calibre2}

![index-156_2.png](https://i.imgur.com/yRONzCC.jpeg){.calibre2}

１４５

另外,主控板 ArduinoUNO 开发板采用与 L２９８N 相同的 ９V 电源供电,电源正极与

VIN 引脚连接.各元件与 ArduinoUNO 开发板的实际连接可参见图４Ｇ３所示的 Arduino UNO 开发板中的详细引脚分布.

系统总电路(ArduinoNANO 开发板部分)如图４Ｇ４所示.

图４Ｇ４　总电路图(ArduinoNANO 部分)

ArduinoNANO 开发板与元件之间的引脚连接如表４Ｇ２所示(注:计算机通过 USB接

口实现与 ArduinoNANO 开发板的连接).

表４Ｇ２　ArduinoNANO 开发板与元件之间的引脚连接

元　　件

引　　脚

ArduinoNANO 开发板

Key

置空

VCC

ArduinoNANO５V 输出

GND

ArduinoNANO GND

HCＧ０５蓝牙模块

TX

ArduinoNANO 引脚８

RX

ArduinoNANO 引脚９

STATE

置空

图４Ｇ５所示为由 ArduinoNano主控的部分.该 部 分 结 构 较 为 简 单,主 要 由 Arduino NANO 开发板及 HCＧ０５蓝牙模块组成.

该部分的主控板 ArduinoNANO 开发板与计算机直接通过 USB 接口连接,供电也由

此实现,不 必 外 接 电 源. 各 元 件 与 Arduino NANO 开 发 板 的 实 际 连 接 可 参 见 Arduino NANO 开发板的详细引脚分布.

[]{#index_split_002.html#p157}![index-157_1.png](https://i.imgur.com/y3CwuSv.jpeg){.calibre2}

１４６

４．

３．

３　模块介绍

系统主要包括图像采集与处理模块、无线通信模块和接球机器人模块.下面分别给出

各模块的主要功能、元件、电路图和相关代码.

１．图像采集与处理模块

１)功能介绍

图像采集与处理模块的功 能 主 要 由 计 算 机 内 置 摄 像 头、外接摄像头以及 Mathematica 软件实现.摄像头用于检测和采集图像,Mathematica软件主要用于图像处理、分析和计算

等.系统启动后,有如下三种运行模式:

模式一:系统通过外接摄像头进行俯视视角的图像采集,以分析小球直线运动轨迹; 模式二:系统通过内置摄像头进行平视视角的图像采集,以分析小球抛物线运动轨迹; 模式三:从原理和实现而言,模式三是模式一和模式二的融合,系统通过外接摄像头和

内置摄像头进行两个视角的图像采集,外接摄像头用于采集俯视视角的画面(小球在空中运

动向下的直线投影),而内置摄像头用于采集平视视角的画面(小球在空中运动向墙面的抛

物线投影),以分析小球在三维空间内的运动轨迹.

确定模式后,摄像头每隔０．１s自动采集图像,并通过 Mathematica循环体不断检测前

后两张图像是否有变化.一旦检测到变化,说明有小球进入画面,则跳出循环,采集当前图

像并送入 Mathematica软件.

当前图像传输至 Mathematica后,图像分析与处理模块用设定好的算法对图像进行处

理和分析,并将计算得到的轨迹或落点数据通过 USB接口传输给 ArduinoNANO 开发板.

对于模式一,系统采集一张画面,以分析小球直线运动轨迹,计算相对原点(设置为图像

的上边中点)的直线斜率;对于模式二,系统采集连续的三张画面(间隔为０．１s),以分析小

球抛物线运动轨迹,计算其落点的一维坐标;对于模式三,系统通过外接摄像头采集一张画

面,内置摄像头采集连续的三张画面,以分析小球的三维运动轨迹.

图像处理过程包括图像差、图像二值化等算法,具体实现请参见后续代码.计算得到数

据后,Mathematica软件通过 USB接口将数据传输给 ArduinoNANO 开发板.

２)模式一代码

USBCamera＝DeviceOpen ＂Camera＂ ＂USBCamera＂

打开USB摄像头

Nano ＝ DeviceOpen ＂Arduino＂ ＂COM６＂

打开与Arduino开发板相连的串口

DeviceWriteBuffer NANO

＂begin＂

启动系统 此时机器人进入准备接球状态

LaunchSpot１＝１６０

LaunchSpot２＝２４０

发射点的位置参数

InitialPic＝CurrentImage

上位摄像头的初始画面

∗１敭图像检测∗

ClearAll a

b

c

Pic

s ＝Module m＝０

mean＝ ０

０

０

a＝CurrentImage 获取实时图像 每隔０敭

１s取一次

Pause ０敭

１

b＝CurrentImage

[]{#index_split_002.html#p158}![index-158_1.png](https://i.imgur.com/Sa9UWqL.jpeg){.calibre2}

![index-158_2.png](https://i.imgur.com/gzr91aE.jpeg){.calibre2}

![index-158_3.png](https://i.imgur.com/eARZxrH.jpeg){.calibre2}

![index-158_4.png](https://i.imgur.com/JP5lrEW.jpeg){.calibre2}

１４７

c＝ImageSubtract a

b

k＝ImageTake c

４

截取上侧一长条的图像

ImageScan mean＋＝＃& k mean ＝Times＠＠ImageDimensions k m＝ mean １ ＋mean ２ ＋mean ３ ３

Round m

计算两图像差的像素均值

While s ２０

s

Print s

不断检测画面

∗２敭图像采集与处理∗

Pause ０敭

４

Pic＝CurrentImage

PicSub＝ImageSubtract Pic

InitialPic

与初始画面比对

PicSub＝MinDetect PicSub

０敭

３

p＝PixelValuePositions PicSub

Black

p＝Round Mean p

计算圆心坐标

p和LaunchSpot构成一条直线 计算直线方程斜率 xielv

xielv＝N p １ －LaunchSpot１ LaunchSpot２－p ２

３

N 函数用于将精度转化为３位小数

k＝xielv∗１０００

保证向ArduinoNANO传输的为整数

∗３敭传输斜率∗

DeviceWriteBuffer NANO

＂k＂

串口通信 传给ArduinoNANO 例如斜率为

１敭

６８ 则通信格式为＂k１６８０＂

DeviceWriteBuffer Nano

ToString k

３ 模式二代码

DeviceOpen ＂Camera＂

NANO ＝ DeviceOpen ＂Arduino＂ ＂COM６＂

DeviceWriteBuffer NANO

＂begin＂

启动系统 此时机器人进入准备接球状态

tran＝０敭

２

比列系数 单位

cm 像素

∗１敭图像检测∗

ClearAll AA

BB

CC

s ＝Module m＝０

mean＝ ０

０

０

a＝CurrentImage 获取实时图像 每隔０敭

１s取一次

Pause ０敭

１

b＝CurrentImage

c＝ImageSubtract a

b

k＝ImageTake c

All

２

截取左侧一长条的图像

ImageScan mean＋＝＃& k mean ＝Times＠＠ImageDimensions k m＝ mean １ ＋mean ２ ＋mean ３ ３

Round m

计算两图像差的像素均值

While s １０

s

Print s

循环执行 直至s １０时跳出

∗２敭图像采集∗

a＝CurrentImage

Pause ０敭

１

获取三张间隔为０敭

１s的图像

b＝CurrentImage

Pause ０敭

１

c＝CurrentImage

Pause ０敭

１

∗３敭图像处理∗

[]{#index_split_002.html#p159}![index-159_1.png](https://i.imgur.com/XY0BROJ.jpeg){.calibre2}

![index-159_2.png](https://i.imgur.com/rcf0yDk.jpeg){.calibre2}

![index-159_3.png](https://i.imgur.com/C1tUogv.jpeg){.calibre2}

１４８

a＝ MaxDetect a

０敭

３５

参数可调

b＝ MaxDetect b

０敭

３５

c＝ MaxDetect c

０敭

３５

i＝PixelValuePositions a

Black

计算像素点集合

j＝PixelValuePositions b

Black

k＝PixelValuePositions c

Black

l＝Mean i

计算圆心坐标

m＝Mean j

n＝Mean k

s＝Solve AA∗ l １ Ù２＋BB∗l １ ＋CC＝＝l ２

&&AA∗ m １ Ù２＋BB∗m １ ＋CC＝＝m ２

&&AA∗ n １ Ù２＋BB∗n １ ＋CC＝＝n ２

AA

BB

CC 　　 解抛物线方程

A＝AA 敭

s １

１

B＝BB 敭

s １

２

CT＝CC 敭

s １

３

s２＝Solve A∗xÙ２＋B∗x＋CT＝＝０ x

求解落点

抛物线方程有正负两个解 用If函数提取正解 并转化成整型

data ＝ If Round x 敭s２ １ ０ Round x 敭s２ １ ０

data ＝ If Round x 敭s２ ２ ０ Round x 敭s２ ２ data

∗４敭图像坐标与实际坐标间的转换 ∗

data＝data∗tran

将像素转化为cm

∗５敭传输坐标 ∗

DeviceWriteBuffer NANO

＂x＂

串口通信 传给ArduinoNANO 格式为＂x１２３＂

DeviceWriteBuffer NANO

ToString data

由于模式三实际上为模式一和模式二的融合,故此处省略模式三的代码.

２．无线通信模块

１)功能介绍

该模块主要由两个 HCＧ０５蓝牙模块实现.Mathematica将计算得到的数据传输到与

计算机连接的 ArduinoNANO 开发板后,通过 HCＧ０５蓝牙模块将其传送至搭载在 Arduino UNO 开发板上的另一个 HCＧ０５模块,实现落点坐标或斜率的传输.需要注意的是,在使用

前需要对蓝牙进行 AT 设置,将两个蓝牙模块的密码设置成相同的(实际中设置为４３２１), 并将一个蓝牙模块设置为主机,另一个设置为从机,通过 ArduinoIDE进行 AT 设置的具体

过程如图４Ｇ５所示.

另外,需 要 说 明 的 是 数 据 的 传 输 格 式 问 题.对 于 模 式 一,传 输 的 数 据 为 斜 率,格 式 为

"k％",并将斜率扩大了１０００倍以便于通信(例如 Mathematica计算得到的斜率为０．６８,则

通信数据为"

k６８０");对于模式二,传输的数据为一维坐标,格式为"x％",单位为cm(例如

Mathematica计算得到的坐标为１０８cm,则通信数据为"x１０８");对于模式三,传输的是二维

坐标,类似于模式二,通信格式为"

x％y％".在数据接收端通过拨码开关选择具体模式.

[]{#index_split_002.html#p160}![index-160_1.png](https://i.imgur.com/7YRQf14.jpeg){.calibre2}

![index-160_2.png](https://i.imgur.com/NvPCDNj.jpeg){.calibre2}

![index-160_3.png](https://i.imgur.com/SZIlBuS.jpeg){.calibre2}

１４９

图４Ｇ５　蓝牙模块的 AT 设置

天线通信模块的具体电路如图４Ｇ６所示.

图４Ｇ６　无线通信模块电路图

电路中的引脚连接如表４Ｇ３所示.

表４Ｇ３　Arduino开发板与无线通信模块的引脚连接

子　模　块

引　　脚

Arduino开发板

Key

置空

VCC

ArduinoNANO５V 输出

GND

ArduinoNANO GND

HCＧ０５蓝牙模块

TX

ArduinoNANO 引脚８

RX

ArduinoNANO 引脚９

STATE

置空

[]{#index_split_002.html#p161}![index-161_1.png](https://i.imgur.com/7qUDRYa.jpeg){.calibre2}

![index-161_2.png](https://i.imgur.com/EH72TRF.jpeg){.calibre2}

![index-161_3.png](https://i.imgur.com/bGArZUK.jpeg){.calibre2}

![index-161_4.png](https://i.imgur.com/NWwavEL.jpeg){.calibre2}

![index-161_5.png](https://i.imgur.com/lKoqVdd.jpeg){.calibre2}

１５０

续表

子　模　块

引　　脚

Arduino开发板

Key

置空

VCC

ArduinoUNO５V 输出

GND

ArduinoUNO GND

HCＧ０５蓝牙模块

TX

ArduinoUNO 引脚８

RX

ArduinoUNO 引脚９

STATE

置空

２)相关代码

＃include SoftwareSerial敭h

引用软接口库函数

SoftwareSerialBT ８ ９

接收引脚 发送引脚

charc

voidsetup

Serial敭

begin １１５２００

与Mathematica通信的波特率

Serial敭

println ＂BTisready

＂

BT敭

begin ３８４００

与Arduino开发板通信的波特率

voidloop

if Serial敭

available

c＝ Serial敭read

BT敭

print c

if BT敭

available

c＝ BT敭read

Serial敭

print c

∗ArduinoUNO开发板上的无线通信部分代码及注释∗

＃include SoftwareSerial敭h

引用软接口库函数

SoftwareSerialBT ８ ９

接收引脚 发送引脚

intsw＝７

拨码开关

intx

y

回传坐标点 单位为cm

charc

voidsetup

BT敭

begin ３８４００

pinMode sw

INPUT

voidloop

if BT敭

available

[]{#index_split_002.html#p162}![index-162_1.png](https://i.imgur.com/Q2WGTbq.jpeg){.calibre2}

![index-162_2.png](https://i.imgur.com/Gww3cVL.jpeg){.calibre2}

１５１

c＝BT敭read

if digitalRead sw ＝＝HIGH

if c＝＝ \'x\'

回传横坐标x

x＝BT敭parseInt

提取缓冲区内的第一个int型数据

if c＝＝ \'y\'

回传横坐标y

y＝BT敭parseInt

else

if c＝＝ \'k\'

回传斜率

k＝BT敭parseInt

取出缓冲区内的第一个int型数据

３．接球机器人模块

１)功能介绍

当 ArduinoUNO 开发板上的 HCＧ０５蓝牙模块接收到数据后,通过 L２９８N 直流电机驱

动模块控制机器人从预设的坐标原点起,进行转向、行进,到达预定接球点并接住小球.

对于模式一,机器人按照斜率计算小球滚动的方向,在预设直线上前进(或后退)相应距

离以接住小球;对于模式二,机器人按照落点位置与预设起始位置前进(或后退)相应距离

以接住小球;对于模式三,机器人按照二维坐标(

x,y)先转向,再前进以到达指定位置.

本模块的具体电路如图４Ｇ７所示.

图４Ｇ７　接球机器人模块电路图

[]{#index_split_002.html#p163}![index-163_1.png](https://i.imgur.com/3l1gtRv.jpeg){.calibre2}

１５２

电路中的引脚连接如表４Ｇ４所示.

表４Ｇ４　接球机器人模块的引脚连接

元　　件

引　　脚

电 路 连 接

IN１

ArduinoUNO 引脚５

IN２

ArduinoUNO 引脚４

IN３

ArduinoUNO 引脚３

IN４

ArduinoUNO 引脚２

OUT１

直流电机１负极

L２９８N 直流电机驱动模块

OUT２

直流电机１正极

OUT３

直流电机２正极

OUT４

直流电机２负极

VCC

外接９V 电源正极

GND

外接９V 电源负极

Key

置空

VCC

ArduinoUNO５V 输出

GND

ArduinoUNO GND

HCＧ０５蓝牙模块

TX

ArduinoUNO 引脚８

RX

ArduinoUNO 引脚９

STATE

置空

正极

ArduinoUNO３．

３V 输出

红外线发射管

负极

ArduinoUNO GND

正极

ArduinoUNO３．

３V 输出

红外线接收管

负极

ArduinoUNO GND

输出

ArduinoUNO 引脚６

R 引脚

ArduinoUNO 引脚１１

G 引脚

ArduinoUNO 引脚１２

RGB三色 LED

B引脚

ArduinoUNO 引脚１３

GND

ArduinoUNO GND

左端引脚

置空

拨码开关

中间引脚

ArduinoUNO５V 输出

右端引脚

ArduinoUNO GND

正极

L２９８N 直流电机驱动模块 OUT２

直流电机１

负极

L２９８N 直流电机驱动模块 OUT１

正极

L２９８N 直流电机驱动模块 OUT３

直流电机２

负极

L２９８N 直流电机驱动模块 OUT４

２)相关代码

∗程序注释

小车上搭载的 ArduinoUNO开发板程序

假设小车初始处于 ０

０ 方向同y轴.

[]{#index_split_002.html#p164}![index-164_1.png](https://i.imgur.com/z47HY3b.jpeg){.calibre2}

![index-164_2.png](https://i.imgur.com/BTo9wWw.jpeg){.calibre2}

![index-164_3.png](https://i.imgur.com/tqSUhcg.jpeg){.calibre2}

１５３

蓝牙传输数据为落点坐标或斜率.

功能描述

１敭准备接球状态 闪白灯

２敭移动状态 亮白灯

３敭结束状态 接到球 闪绿灯 没接到 闪红灯

４敭通过红外对射开关识别是否接到球∗

＃include SoftwareSerial敭h

引用软接口库函数

SoftwareSerialBT ８ ９

接收引脚 发送引脚

＃definev４０

定义车轮线速度 单位为cm s

＃defineR１５

定义车轮到中心的距离 单位为cm

＃definex０_１１００

定义初始位置 模式一 单位为cm

＃definex０_２２０

定义初始位置 模式二 单位为cm

intsw＝７

拨码开关切换模式

intRed＝１１

三色灯输出

intGreen＝１２

intBlue＝１３

intlight＝６

红外对射输入

intleft１ ＝ ４

定义ArduinoUNO的引脚 ４向 left１ 输出 L２９８N

intleft２ ＝ ５

定义ArduinoUNO的引脚 ５向 left２ 输出

intright１ ＝ ３

定义ArduinoUNO的引脚 ３向 right１ 输出

intright２ ＝ ２

定义ArduinoUNO的引脚 ２向 right２ 输出

floatx

y

回传坐标点 单位为cm

floatk

回传斜率

charc

接收数据

floatP

前进距离 单位为cm

floatu

旋转角度 单位为度

voidsetup

pinMode sw

INPUT

pinMode Red

OUTPUT

pinMode Green

OUTPUT

pinMode Blue

OUTPUT

pinMode light

INPUT

pinMode left１

OUTPUT

pinMode left２

OUTPUT

pinMode right１

OUTPUT

pinMode right２

OUTPUT

BT敭

begin ３８４００

voidloop

while

BT敭

available

当未接收到位置信号时 闪白灯

digitalWrite Red

HIGH

白灯由三色组合而成

[]{#index_split_002.html#p165}![index-165_1.png](https://i.imgur.com/Q5YqWdv.jpeg){.calibre2}

![index-165_2.png](https://i.imgur.com/huprUMs.jpeg){.calibre2}

１５４

digitalWrite Green

HIGH

digitalWrite Blue

HIGH

delay ５００

digitalWrite Red

LOW

digitalWrite Green

LOW

digitalWrite Blue

LOW

delay ５００

while digitalRead sw ＝＝HIGH

如果拨码开关为高电平 对应模式二 模式三

x＝０

if BT敭

available

若收到蓝牙数据 则控制小车运动

c＝BT敭

read

if c＝＝ \'x\'

回传横坐标x

x＝BT敭parseInt

取出缓冲区内的第一个int型数据

if c＝＝ \'y\'

回传横坐标y

y＝BT敭

parseInt

P＝sqrt sq x ＋sq y

前进距离

u＝acos y P

旋转角度

if x

＝０\|\|y

＝０

digitalWrite Red

HIGH

持续亮白灯

digitalWrite Green

HIGH

digitalWrite Blue

HIGH

左轮前转u ２ 右轮后转u ２ 总体转u

floatt_rotate

置高电平时长

t_rotate＝u∗R v∗２

弧度关系式

u∗R ２＝l＝vt

digitalWrite left１

HIGH

左轮前转

digitalWrite left２

LOW

digitalWrite right１

LOW

右轮后转

digitalWrite right２

HIGH

delay t_rotate∗１０００

if P ０

∗前进P∗

floatt_forward

置高电平时长

t_forward＝P v

距离 线速度

digitalWrite left１

HIGH

左轮前转

digitalWrite left２

LOW

digitalWrite right１

HIGH

右轮前转

digitalWrite right２

LOW

delay t_forward∗１０００

[]{#index_split_002.html#p166}![index-166_1.png](https://i.imgur.com/35IfPOC.jpeg){.calibre2}

１５５

else

∗后退P∗

floatt_backward

置高电平时长

t_backward＝－P v

距离 线速度

digitalWrite left１

LOW

左轮后转

digitalWrite left２

HIGH

digitalWrite right１

LOW

右轮后转

digitalWrite right２

HIGH

delay t_backward∗１０００

stop 停止

digitalWrite left１

LOW

digitalWrite left２

LOW

digitalWrite right１

LOW

digitalWrite right２

LOW

digitalWrite Red

LOW

灭白灯

digitalWrite Green

LOW

digitalWrite Blue

LOW

if x

＝０

x＝０

break

跳出循环

while digitalRead sw ＝＝LOW

如果拨码开关为低电平 对应模式一

k＝０

if BT敭

available

c＝BT敭read

if c＝＝ \'k\'

回传斜率

k＝BT敭parseInt

取出缓冲区内的第一个int型数据

P＝k∗x０_１ １０００

计算需要前进的距离

前进距离除以１０００ 因为前面为了通信方便 将斜率扩大了１０００倍

if k

＝０

如果斜率恰好为０ 小车就不用移动了

digitalWrite Red

HIGH

亮白灯

digitalWrite Green

HIGH

digitalWrite Blue

HIGH

∗前进P∗

floatt_forward

置高电平时长

[]{#index_split_002.html#p167}![index-167_1.png](https://i.imgur.com/53VHpuv.jpeg){.calibre2}

１５６

t_forward＝P v

距离 线速度

digitalWrite left１

HIGH

左轮前转

digitalWrite left２

LOW

digitalWrite right１

HIGH

右轮前转

digitalWrite right２

LOW

delay t_forward∗１０００

∗stop停止∗

digitalWrite left１

LOW

digitalWrite left２

LOW

digitalWrite right１

LOW

digitalWrite right２

LOW

digitalWrite Red

LOW

灭白灯

digitalWrite Green

LOW

digitalWrite Blue

LOW

if k

＝０

k＝０

break

跳出循环

if digitalRead light ＝＝HIGH

如果接到球 红外对射管关闭

while １

无限循环 直至重启

digitalWrite Green

HIGH

一直闪绿灯 表示成功接到小球

delay ５００

digitalWrite Green

LOW

delay ５００

else

while １

digitalWrite Red

HIGH

一直闪红灯 表示未接到小球

delay ５００

digitalWrite Red

LOW

delay ５００

[]{#index_split_002.html#p168}![index-168_1.png](https://i.imgur.com/nr8VgxA.jpeg){.calibre2}

![index-168_2.png](https://i.imgur.com/ZGLhq2w.jpeg){.calibre2}

![index-168_3.png](https://i.imgur.com/R3lj0S7.jpeg){.calibre2}

１５７

４．

４　产品展示

图像采集与处理模块 和 无 线 通 信 模 块 如 图 ４Ｇ８ 所示,接球机器人模块如图 ４Ｇ９ 所示.

外接摄像头与计算机连接,Mathematica软件与 ArduinoNANO 开发板连接实现数据的传

输.ArduinoNANO 开发板搭载的 HCＧ０５蓝牙模块与 ArduinoUNO 开发板搭载的 HCＧ０５

实现无线通信,两个蓝牙模块双闪说明连接成 功.ArduinoUNO 开发板通过控制 L２９８N

直流电机驱动模块以间接控制机器人的行进.另外,机器人上面搭载的 RGB 三色 LED 实

现机器人状态的显示,红外线对射管实现是否成功接到小球的判断.

图４Ｇ８　图像采集与处理模块和无线通信模块

图４Ｇ９　接球机器人模块

本项目需要大量的实际测试以确定系统各项参数,提高系统工作性能,以下是选取的部

分系统测试结果.模式一两次测试结果分别如图４Ｇ１０(a)和如图４Ｇ１０(b)所示.其中,每幅

图包含的四个子图从左上到右下依次为:原始图像、采集图像、两图像差和二值化后的图像

差.Mathematica软件通过分析黑色像素点的平均位置计算得到斜率.图４Ｇ１１所示是由

图４Ｇ１０分析得到的黑色像素点的平均位置,坐标为(２２７,

１５３),斜率为０．７７,结果与实际吻

合度较高.

[]{#index_split_002.html#p169}![index-169_1.png](https://i.imgur.com/XM7fvqP.jpeg){.calibre2}

![index-169_2.png](https://i.imgur.com/XS2pffL.jpeg){.calibre2}

![index-169_3.png](https://i.imgur.com/TsrRoaF.jpeg){.calibre2}

![index-169_4.png](https://i.imgur.com/J0wdGxW.jpeg){.calibre2}

１５８

图４Ｇ１０　模式一测试结果

图４Ｇ１１　根据测试结果计算的斜率

[]{#index_split_002.html#p170}![index-170_1.png](https://i.imgur.com/99jwWwh.jpeg){.calibre2}

![index-170_2.png](https://i.imgur.com/k9DOdLq.jpeg){.calibre2}

![index-170_3.png](https://i.imgur.com/l8lMySH.jpeg){.calibre2}

１５９

模式二测试结果如图４Ｇ１２所示.其中,图中包含的三个子图从左到右依次为连续采集

的三张画面.Mathematica软件对图像进行二值化处理,结果如图４Ｇ１３所示.

图４Ｇ１２　模式二测试结果

图４Ｇ１３　模式二测试结果的图像处理结果

４．

５　故障及问题分析

问题１:如何检测有小球抛入.

解决方案:开始设计系统时并无实时检测部分,导致很难在合适的时间捕获小球的运

动.于是,对该部分加以重新设计,采用 Mathematica软件自动采集实时图像(每隔０．

１s取

一次),并不断检测前后两图像的差别.检测前后两图像的差别即计算两图像平均像素的差

值.当像素差值较大时,说明画面有变化,即有物体进入画面.

[]{#index_split_002.html#p171}![index-171_1.png](https://i.imgur.com/9XRFZXV.jpeg){.calibre2}

１６０

问题２:自动检测小球所消耗的时间太长,影响系统的实时性.

解决方案:经实验发现,时间复杂度主要来源于对两图像差的分析过程,而实际中,小

球总是从画面一端进入,故只需截取图像的小部分进行图像分析,即如果小球从左端抛入, 则检测左边小部分画面;如果小球从右端抛入,则检测右边小部分画面.通过这种原理,优

化代码,以降低时间复杂度.实际测试发现,此方法确实大大提高了系统实时性,也提升了

系统的实用性.

问题３:Mathematica与 Arduino开发板之间无法正常通信.

解决方 案:只 要 Mathematica 与 接 入 串 口 的 Arduino NANO 开 发 板 成 功 连 接, ArduinoNANO 开发板即可显示接收到了数据.然而,数据在传输过程中出现了错误.经

分析发现,导致该错误的原因在于通信波特率的不匹配.Mathematica与 Arduino开发板

间的 串 口 通 信 波 特 率 需 设 置 为 １１５２００. 另 外,升 级 Mathematica 的 版 本 也 能 够 使 其 与

Arduino开发板之间的通信更简单方便.

问题４:蓝牙之间通信异常.

解决 方 案:首 先,需 要 对 蓝 牙 进 行 AT 设 置.具 体 方 法 为 调 节 蓝 牙 至 AT 模 式,在

ArduinoIDE串口监视器内输入 AT 指令,将两个蓝牙模块的密码设置成相同的(实际中设

置为４３２１),并将一个设置为主机,另一个设置为从机.当蓝牙工作于正常模式时,即可自

动识别和连接.通信时,两个蓝牙与各自的 Arduino开发板的通信波特率均设置为３８４００.

问题５:在提取的图像中常会引入噪声,影响对轨迹的分析.

解决方案:经实验发现,提取的图像含有大量噪声,主要由背景光线强弱分布不均匀导

致.原本采用的 Mathematica函数是 Binarize\[\],该函数的缺点是不能设置二值化阈值,只

能按一种方式对图像进行二值转化.于是,将该函数用 MinDetect\[\]函数替代,通过控制该

函数的阈值参数,保证滤除阴影的影响,实现对噪声的滤除.

问题６:供给 L２９８N 的电压不足,导致机器人无法正常运动.

解 决方案:起初,将 ArduinoUNO 开发板上的５V 电压输出引脚直接接在L２９８N 的电

压输入端,由于电压不足,导致有时机器人一侧轮子无法转动,或转动不均匀.因此,将供给

ArduinoUNO 开发板的９V 电源引出同时供给 L２９８N,此时 L２９８N 能够正常地控制轮子

的转动及机器人的正常前进.

４．

６　元件清单

完成本项目所用到的元件及数量如表４Ｇ５所示.

[]{#index_split_002.html#p172}![index-172_1.png](https://i.imgur.com/xWeWfXD.jpeg){.calibre2}

１６１

表４Ｇ５　基于 Mathematica的自动接球系统元件清单

模　　块

元件/测试仪表

数量

外接摄像头

１个

内置摄像头

１个

图像采集与处理模块

计算机及相关软件

１台

摄像头 USB连接线

１条

ArduinoNANO 开发板

１个

HCＧ０５蓝牙模块

２个

无线通信模块

杜邦线

若干

ArduinoNANO 传输线

１个

面包板

１个

ArduinoUNO 开发板

１个

直流电机

２个

L２９８N 直流电机驱动模块

１个

RGB三色 LED

１个

红外线发射管

１个

接球机器人模块

红外线接收管

１个

双轮小车

１个

螺钉

若干

杜邦线

若干

导线

若干

[]{#index_split_002.html#p173}![index-173_1.png](https://i.imgur.com/dd9Dial.jpeg){.calibre2}

第５章

蓝牙遥控四自由度可

自动避障机器人项目设计

５．

１　项目背景

各种各样的机器人是未来社会的刚性需求,本项目利用开源硬件 Arduino开发一款可

遥控的机器人,实现基础行走功能以及拓展功能.

５．

２　创新描述

手柄遥控四自由度机器人是市场上比较受欢迎的一款机器人,可以利用其具体框架,结

合 Arduino平台编程实现机器人更具实用性的功能.

５．

３　功能及总体设计

本作品主要分为４部分进行设计:蓝牙传输部分、超声波探测部分、单元动作编程和动

作函数实现.蓝牙传输部分的功能是使机器人能够接收远程操控指令;超声波探测部分通

过超声波传感器实现避障;单元动作编程部分 的 主 要 功 能 是 对 各 舵 机 编 程 以 完 成 基 本 动

作;动作函数的主要功能是通过输入指令来控制机器人的各项动作.

[]{#index_split_003.html}

５．

３．

１　功能介绍

四组机器人能够完成前进、左转、右转、后退、右后转、左后转及跳舞等动作,并且可以开

启自动避障功能,即在前方无障碍物时直行,

２０cm 内有障碍物时,通过超声波模块探测左右

并改变行进方向.

５．

３．

２　总体设计

要实现上述功能需要将作品分成三部分进行设计:传输部分、编程部分和函数实现部

本章根据刘雨飞、张昭郗项目设计整理而成.

[]{#index_split_003.html#p174}![index-174_1.png](https://i.imgur.com/bvim7np.jpeg){.calibre2}

![index-174_2.png](https://i.imgur.com/ab7CPOD.jpeg){.calibre2}

![index-174_3.png](https://i.imgur.com/i86N0vJ.jpeg){.calibre2}

１６３

分.传输部分选用 HCＧ０６蓝牙模块,实现手机到 Arduino开发板的遥控;编程部分对各个

舵机以及模块进行单元编程;函数实现部分通过指令控制机器人完成各项动作.

１．整体框架图

项目整体框架如图５Ｇ１所示.

图５Ｇ１　整体框架图

２．系统流程图

系统流程图如图５Ｇ２所示.

图５Ｇ２　系统流程图

接通电源后,如果发送指令被读取,则机器人开始工作.若为自动避障指令,则进入自

动状态,再次发送指令可退出自动状态;若为普通行为指令,则进行各项行为,直到松开行

为按钮,机器人停止运行.

３．总电路图

系统总电路及 ArduinoMEGA 开发板引脚连接如图５Ｇ３所示.

[]{#index_split_003.html#p175}![index-175_1.png](https://i.imgur.com/OsM4XLo.jpeg){.calibre2}

![index-175_2.png](https://i.imgur.com/0jaQI93.jpeg){.calibre2}

１６４

图５Ｇ３　总电路图

各模块对应引脚连线如表５Ｇ１所示.

表５Ｇ１　元件引脚对应连线

元　　件

元 件 引 脚

Arduino开发板对应引脚

RX

１

蓝牙模块　

TX

０

EchoPin

３

超声波模块

TrigPin

２

SDA

２０

舵机控制板

SCL

２１

５．

３．

３　模块介绍

本项目主要包括蓝牙模块、超声波模块和舵机控制模块.下面分别给出各模块的功能、

元件、电路图和相关代码.

１．蓝牙模块

手机发送指令,ArduinoMEGA 开发板接收指令.元件包括 HCＧ０６和 ArduinoMEGA 开发板,如图５Ｇ４所示.使用手机蓝牙串口 APP连接 Arduino控制的 HCＧ０６蓝牙模块.主

要引脚连接:VCC接 Arduino开发板的５V;GND 接 Arduino开发板的 GND;TXD 发送

端接 Arduino开发板的 RX;RXD 接收端接 Arduino开发板的 TX.线接好后,Arduino开

[]{#index_split_003.html#p176}![index-176_1.png](https://i.imgur.com/MR2SVD1.jpeg){.calibre2}

![index-176_2.png](https://i.imgur.com/l6eqsCh.jpeg){.calibre2}

![index-176_3.png](https://i.imgur.com/35x5RR7.jpeg){.calibre2}

１６５

发板通电,蓝牙的指示灯是闪烁的,表明没有设备连接上(未建立 RFCOMM 信道),然后进

行匹配和连接.

"匹配"说明对方设备发现了本设备的存在,并拥有一个共同的识别码,可以进行连接;

"连接"成功表示当前设备共享一个 RFCOMM 信道并且二者可以交换数据.

图５Ｇ４　蓝牙模块

２．超声波模块

１)功能介绍

用于 检 测 前 方 障 碍 物,实 现 避 障 功 能.主 要 元 件 为 HCＧSR０４.实际电路如图 ５Ｇ５ 所

示.主要引脚接法:VCC接 Arduino开发板的５V;GND 接 Arduino开发板的 GND;Trig 接 Arduino开发板的引脚 ２;Echo接 Arduino开发板的引脚３.

图５Ｇ５　超声波模块

[]{#index_split_003.html#p177}![index-177_1.png](https://i.imgur.com/6r4H2Ow.jpeg){.calibre2}

![index-177_2.png](https://i.imgur.com/PH3nviV.jpeg){.calibre2}

![index-177_3.png](https://i.imgur.com/MgJKEBh.jpeg){.calibre2}

![index-177_4.png](https://i.imgur.com/dgc7CUp.jpeg){.calibre2}

![index-177_5.png](https://i.imgur.com/240UYOl.jpeg){.calibre2}

![index-177_6.png](https://i.imgur.com/DallxT9.jpeg){.calibre2}

![index-177_7.png](https://i.imgur.com/2LUVeAB.jpeg){.calibre2}

![index-177_8.png](https://i.imgur.com/IU9KV9v.jpeg){.calibre2}

![index-177_9.png](https://i.imgur.com/b1GujDR.jpeg){.calibre2}

１６６

２)相关代码

＃include Servo敭h

＃include Wire敭h

＃include Adafruit_PWMServoDriver敭h

Adafruit_PWMServoDriverpwm ＝ Adafruit_PWMServoDriver

＃defineSERVOMIN１５０

＃defineSERVOMAX６００

＃defineSERVOBEGIN_０３７５

＃defineSERVOBEGIN_４３７５

＃defineSERVOBEGIN_５３７５

＃defineSERVOBEGIN_６３７５

＃defineSERVOBEGIN_７３７５

constintTrigPin ＝ ２

constintEchoPin ＝ ３

定义SR０４引脚

floatda

floatdl

floatdr

将距离存储为单精度浮点数 前、左、右共三组数据

voidsetup

Serial敭

begin ９６００

Serial敭println ＂１６channelServotest

＂

pwm敭

begin

pwm敭

setPWMFreq ６０ Analogservosrunat\~６０Hzupdates pinMode TrigPin OUTPUT

pinMode EchoPin INPUT

初始化串口 定义舵机和SR０４引脚

pwm敭

setPWM ０ ０ SERVOBEGIN_０

机器人初始化 停止且头朝前看

Serial敭

println ＂Syatemstartcomplete＂

delay １０００

voidprewalk

for uint１６_tpulselen＝３７５ pulselen ４５０ pulselen++

pwm敭setPWM ４

０

pulselen

pwm敭setPWM ６

０

pulselen

delay ７５０

for uint１６_tpulselen＝３７５ pulselen ４５０ pulselen++

pwm敭setPWM ５

０

pulselen

pwm敭setPWM ７

０

pulselen

delay ７５０

[]{#index_split_003.html#p178}![index-178_1.png](https://i.imgur.com/TnOWbvz.jpeg){.calibre2}

![index-178_2.png](https://i.imgur.com/EMjXp5z.jpeg){.calibre2}

![index-178_3.png](https://i.imgur.com/JA6txNA.jpeg){.calibre2}

![index-178_4.png](https://i.imgur.com/cCuzoa1.jpeg){.calibre2}

![index-178_5.png](https://i.imgur.com/fJaEAtw.jpeg){.calibre2}

![index-178_6.png](https://i.imgur.com/PPhh5az.jpeg){.calibre2}

![index-178_7.png](https://i.imgur.com/rgU7dbN.jpeg){.calibre2}

![index-178_8.png](https://i.imgur.com/b71UItL.jpeg){.calibre2}

![index-178_9.png](https://i.imgur.com/ATrLAr0.jpeg){.calibre2}

１６７

voiddwalk

倒退

for uint１６_tpulselen＝ ４５０ pulselen ３００ pulselen－－

pwm敭

setPWM ４ ０ pulselen

pwm敭

setPWM ６ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ４５０ pulselen ３００ pulselen－－

pwm敭

setPWM ５ ０ pulselen

pwm敭

setPWM ７ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ３００ pulselen ４５０ pulselen++

pwm敭

setPWM ４ ０ pulselen

pwm敭

setPWM ６ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ３００ pulselen ４５０ pulselen++

pwm敭

setPWM ５ ０ pulselen

pwm敭

setPWM ７ ０ pulselen

delay ５００

voidoverwalk

for uint１６_tpulselen＝４５０ pulselen ３７５ pulselen－－

pwm敭setPWM ４

０

pulselen

pwm敭setPWM ６

０

pulselen

delay ７５０

for uint１６_tpulselen＝４５０ pulselen ３７５ pulselen－－

pwm敭setPWM ５

０

pulselen

pwm敭setPWM ７

０

pulselen

delay ７５０

voiddleft

左后转

for uint１６_tpulselen＝ ４５０ pulselen ３００ pulselen－－

pwm敭

setPWM ４ ０ pulselen

pwm敭

setPWM ６ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ４２５ pulselen ３２５ pulselen－－

pwm敭

setPWM ５ ０ pulselen

[]{#index_split_003.html#p179}![index-179_1.png](https://i.imgur.com/9TwjAXw.jpeg){.calibre2}

![index-179_2.png](https://i.imgur.com/QlHZupT.jpeg){.calibre2}

![index-179_3.png](https://i.imgur.com/GsiFPHa.jpeg){.calibre2}

![index-179_4.png](https://i.imgur.com/LdLAGEP.jpeg){.calibre2}

![index-179_5.png](https://i.imgur.com/FOozTW9.jpeg){.calibre2}

![index-179_6.png](https://i.imgur.com/K9zNiOp.jpeg){.calibre2}

![index-179_7.png](https://i.imgur.com/9t3QHOX.jpeg){.calibre2}

![index-179_8.png](https://i.imgur.com/VQ4Dc7d.jpeg){.calibre2}

![index-179_9.png](https://i.imgur.com/mlsq1s7.jpeg){.calibre2}

１６８

delay ５００

for uint１６_tpulselen＝ ３００ pulselen ４５０ pulselen++

pwm敭

setPWM ４ ０ pulselen

pwm敭

setPWM ６ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ３２５ pulselen ４２５ pulselen++

pwm敭

setPWM ５ ０ pulselen

delay ５００

voiddright

右后转

for uint１６_tpulselen＝ ４５０ pulselen ３００ pulselen－－

pwm敭

setPWM ４ ０ pulselen

pwm敭

setPWM ６ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ４２５ pulselen ３２５ pulselen－－

pwm敭

setPWM ７ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ３００ pulselen ４５０ pulselen++

pwm敭

setPWM ４ ０ pulselen

pwm敭

setPWM ６ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ３２５ pulselen ４２５ pulselen++

pwm敭

setPWM ７ ０ pulselen

delay ５００

voidwalk

直行

for uint１６_tpulselen＝ ４５０ pulselen ３００ pulselen－－

pwm敭

setPWM ４ ０ pulselen

pwm敭

setPWM ６ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ３００ pulselen ４５０ pulselen++

pwm敭

setPWM ５ ０ pulselen

pwm敭

setPWM ７ ０ pulselen

[]{#index_split_003.html#p180}![index-180_1.png](https://i.imgur.com/7rBI0s9.jpeg){.calibre2}

![index-180_2.png](https://i.imgur.com/SirOcSf.jpeg){.calibre2}

![index-180_3.png](https://i.imgur.com/pxAn8S1.jpeg){.calibre2}

![index-180_4.png](https://i.imgur.com/cEFfrPZ.jpeg){.calibre2}

![index-180_5.png](https://i.imgur.com/JC3Yi5Z.jpeg){.calibre2}

![index-180_6.png](https://i.imgur.com/z7E90fs.jpeg){.calibre2}

![index-180_7.png](https://i.imgur.com/ErZlqlj.jpeg){.calibre2}

![index-180_8.png](https://i.imgur.com/IL7v9Bs.jpeg){.calibre2}

![index-180_9.png](https://i.imgur.com/RdAhAwv.jpeg){.calibre2}

１６９

delay ５００

for uint１６_tpulselen＝ ３００ pulselen ４５０ pulselen++

pwm敭

setPWM ４ ０ pulselen

pwm敭

setPWM ６ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ４５０ pulselen ３００ pulselen－－

pwm敭

setPWM ５ ０ pulselen

pwm敭

setPWM ７ ０ pulselen

delay ５００

voidleft

左转

for uint１６_tpulselen＝ ４５０ pulselen ３００ pulselen－－

pwm敭

setPWM ４ ０ pulselen

pwm敭

setPWM ６ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ３２５ pulselen ４２５ pulselen++

pwm敭

setPWM ５ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ３００ pulselen ４５０ pulselen++

pwm敭

setPWM ４ ０ pulselen

pwm敭

setPWM ６ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ４２５ pulselen ３２５ pulselen－－

pwm敭

setPWM ５ ０ pulselen

delay ５００

voidright

右转

for uint１６_tpulselen＝ ４５０ pulselen ３００ pulselen－－

pwm敭

setPWM ４ ０ pulselen

pwm敭

setPWM ６ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ３２５ pulselen ４２５ pulselen++

pwm敭

setPWM ７ ０ pulselen

delay ５００

[]{#index_split_003.html#p181}![index-181_1.png](https://i.imgur.com/aTgWFif.jpeg){.calibre2}

![index-181_2.png](https://i.imgur.com/AbISVvD.jpeg){.calibre2}

![index-181_3.png](https://i.imgur.com/YxUu7wW.jpeg){.calibre2}

![index-181_4.png](https://i.imgur.com/rxfYBTr.jpeg){.calibre2}

![index-181_5.png](https://i.imgur.com/WJUziAa.jpeg){.calibre2}

１７０

for uint１６_tpulselen＝ ３００ pulselen ４５０ pulselen++

pwm敭

setPWM ４ ０ pulselen

pwm敭

setPWM ６ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ４２５ pulselen ３２５ pulselen－－

pwm敭

setPWM ７ ０ pulselen

delay ５００

intp ＝ ０

intq ＝ ０

intf ＝ ０

voidloop

if f＝＝０

pwm敭setPWM ４ ０ SERVOBEGIN_０

pwm敭setPWM ５ ０ SERVOBEGIN_１

pwm敭setPWM ６ ０ SERVOBEGIN_２

pwm敭setPWM ７ ０ SERVOBEGIN_３

delay ５００

f＝１

if q ＝ ０ p＝ Serial敭read

Serial敭println p

Serial敭println q

if p ０

if p＝＝ ４９

walk

delay １５０

q＝ １

if p＝＝ ５０

left

delay １５０

q＝ １

if p＝＝ ５１

right

delay １５０

q＝ １

if p＝＝ ５２

[]{#index_split_003.html#p182}![index-182_1.png](https://i.imgur.com/HGVW82X.jpeg){.calibre2}

![index-182_2.png](https://i.imgur.com/7phjIhT.jpeg){.calibre2}

![index-182_3.png](https://i.imgur.com/s5Avkmv.jpeg){.calibre2}

１７１

dwalk

delay １５０

q＝ １

if p＝＝ ５３

dleft

delay １５０

q＝ １

if p＝＝ ５４

dright

delay １５０

q＝ １

if q＝＝ １

q＝ Serial敭read

if q ＝ ０

pwm敭setPWM ４ ０ SERVOBEGIN_４

pwm敭setPWM ５ ０ SERVOBEGIN_５

pwm敭setPWM ６ ０ SERVOBEGIN_６

pwm敭setPWM ７ ０ SERVOBEGIN_７

delay ５００

digitalWrite TrigPin LOW

delayMicroseconds ２

digitalWrite TrigPin HIGH

delayMicroseconds １０

digitalWrite TrigPin LOW

产生一个１０μs的高脉冲触发SR０４

da ＝ pulseIn EchoPin HIGH ５８敭

００

读取接收到反射的时长 计算距离并换算成cm

∗超声波传感器探头被遮挡或者距离过短时 声波无法回射 由于长时间接收不到返回声波 会

返回一个很大的值.此时 其实探头 距 离 障 碍 物 非 常 近 判 断 时 应 认 为 此 时 的 距 离 非 常 小 而 不 是 非

常大 这种特殊情况请注意∗

if da ＝ ２０

walk

pwm敭

setPWM ４ ０ SERVOBEGIN_４

pwm敭

setPWM ５ ０ SERVOBEGIN_５

pwm敭

setPWM ６ ０ SERVOBEGIN_６

[]{#index_split_003.html#p183}![index-183_1.png](https://i.imgur.com/cWhnMPK.jpeg){.calibre2}

![index-183_2.png](https://i.imgur.com/JuYqmYZ.jpeg){.calibre2}

![index-183_3.png](https://i.imgur.com/ojGX8Vy.jpeg){.calibre2}

![index-183_4.png](https://i.imgur.com/RpXkWHP.jpeg){.calibre2}

１７２

pwm敭

setPWM ７ ０ SERVOBEGIN_７

delay ５００

Serial敭

print ＂Distance ＝ ＂

Serial敭

print da

Serial敭

print ＂＂

Serial敭

println ＂Movingadvance＂

delay ５００

如果距离大于２０cm则前进 并输出＂正在前进＂

elseif da ＝ ２０

pwm敭

setPWM ４ ０ SERVOBEGIN_４

pwm敭

setPWM ５ ０ SERVOBEGIN_５

pwm敭

setPWM ６ ０ SERVOBEGIN_６

pwm敭

setPWM ７ ０ SERVOBEGIN_７

delay ５００

Serial敭

print ＂Distance ＝ ＂

Serial敭

print da

Serial敭

print ＂＂

Serial敭

println ＂Stopped＂

如果距离小于２０cm则停止 并输出＂已停止＂

for uint１６_tpulselen＝ ３７５ pulselen ６００ pulselen++

pwm敭

setPWM ０ ０ pulselen

delay １０００

digitalWrite TrigPin LOW

delayMicroseconds ２

digitalWrite TrigPin HIGH

delayMicroseconds １０

digitalWrite TrigPin LOW

dl ＝ pulseIn EchoPin HIGH ５８敭

００

Serial敭

print ＂Leftdistance ＝ ＂

Serial敭

print dl

Serial敭

print ＂＂

头部舵机左转 测量左边距离并输出

for uint１６_tpulselen＝ ６００ pulselen １５０ pulselen－－

pwm敭

setPWM ０ ０ pulselen

delay １０００

digitalWrite TrigPin LOW

delayMicroseconds ２

digitalWrite TrigPin HIGH

delayMicroseconds １０

[]{#index_split_003.html#p184}![index-184_1.png](https://i.imgur.com/mp0lqFP.jpeg){.calibre2}

![index-184_2.png](https://i.imgur.com/xQho0p8.jpeg){.calibre2}

![index-184_3.png](https://i.imgur.com/WDun3mT.jpeg){.calibre2}

![index-184_4.png](https://i.imgur.com/OpYtNCj.jpeg){.calibre2}

![index-184_5.png](https://i.imgur.com/8rm0wHu.jpeg){.calibre2}

![index-184_6.png](https://i.imgur.com/waF59B8.jpeg){.calibre2}

![index-184_7.png](https://i.imgur.com/Aq4HsV1.jpeg){.calibre2}

![index-184_8.png](https://i.imgur.com/Qfoe4u7.jpeg){.calibre2}

![index-184_9.png](https://i.imgur.com/YcT4ha1.jpeg){.calibre2}

１７３

digitalWrite TrigPin LOW

dr ＝ pulseIn EchoPin HIGH ５８敭

００

Serial敭

print ＂Rightdistance ＝ ＂

Serial敭

print dr

Serial敭

print ＂＂

Serial敭

println

头部舵机右转 测量右边距离并输出

for uint１６_tpulselen＝ １５０ pulselen ３７５ pulselen++

pwm敭

setPWM ０ ０ pulselen

delay ５００

if dl ＝ ２０&&dl ＝ １０００&&dl dr left

left

left

pwm敭

setPWM ４ ０ SERVOBEGIN_４

pwm敭

setPWM ５ ０ SERVOBEGIN_５

pwm敭

setPWM ６ ０ SERVOBEGIN_６

pwm敭

setPWM ７ ０ SERVOBEGIN_７

delay ５００

Serial敭

println ＂Turningleft＂

delay ８７０

判断左右距离 若左边大则左转

elseif dl ＝ １０００

right

right

right

pwm敭

setPWM ４ ０ SERVOBEGIN_４

pwm敭

setPWM ５ ０ SERVOBEGIN_５

pwm敭

setPWM ６ ０ SERVOBEGIN_６

pwm敭

setPWM ７ ０ SERVOBEGIN_７

delay ５００

Serial敭

println ＂Turningright＂

delay ８７０

特殊情况 若左边返回距离大于１０００ 则说明探头被遮挡 此时右转

elseif dr ＝ ２０&&dr ＝ １０００&&dr dl right

right

[]{#index_split_003.html#p185}![index-185_1.png](https://i.imgur.com/CZZPTUb.jpeg){.calibre2}

![index-185_2.png](https://i.imgur.com/uYZGBfr.jpeg){.calibre2}

![index-185_3.png](https://i.imgur.com/ghgVlG8.jpeg){.calibre2}

![index-185_4.png](https://i.imgur.com/nFImMkh.jpeg){.calibre2}

１７４

right

pwm敭

setPWM ４ ０ SERVOBEGIN_４

pwm敭

setPWM ５ ０ SERVOBEGIN_５

pwm敭

setPWM ６ ０ SERVOBEGIN_６

pwm敭

setPWM ７ ０ SERVOBEGIN_７

delay ５００

Serial敭

println ＂Turningright＂

delay ８７０

判断左右距离 若右边大则右转

elseif dr ＝ １０００

left

left

left

pwm敭

setPWM ４ ０ SERVOBEGIN_４

pwm敭

setPWM ５ ０ SERVOBEGIN_５

pwm敭

setPWM ６ ０ SERVOBEGIN_６

pwm敭

setPWM ７ ０ SERVOBEGIN_７

delay ５００

Serial敭

println ＂Turningleft＂

delay ８７０

特殊情况 若右边返回距离大于１０００ 则说明探头被遮挡 此时左转

elseif dr ＝ ２０&&dl ＝ ２０

left

left

left

left

left

left

pwm敭

setPWM ４ ０ SERVOBEGIN_４

pwm敭

setPWM ５ ０ SERVOBEGIN_５

pwm敭

setPWM ６ ０ SERVOBEGIN_６

pwm敭

setPWM ７ ０ SERVOBEGIN_７

delay ５００

Serial敭

println ＂Turningaround＂

delay １７２０

若左右两边距离均小于２０cm 则掉头

[]{#index_split_003.html#p186}![index-186_1.png](https://i.imgur.com/YHYN5fC.jpeg){.calibre2}

![index-186_2.png](https://i.imgur.com/uby0K7s.jpeg){.calibre2}

![index-186_3.png](https://i.imgur.com/9dQyzXA.jpeg){.calibre2}

![index-186_4.png](https://i.imgur.com/g8QTMMq.jpeg){.calibre2}

![index-186_5.png](https://i.imgur.com/FDdqKgm.jpeg){.calibre2}

![index-186_6.png](https://i.imgur.com/qap2wta.jpeg){.calibre2}

![index-186_7.png](https://i.imgur.com/GKfy1GU.jpeg){.calibre2}

![index-186_8.png](https://i.imgur.com/YBZJrxL.jpeg){.calibre2}

１７５

３．舵机控制模块

１)功能介绍

给舵机供电,并给舵机适当脉冲使之完成相应动作,如图５Ｇ６所示.舵机控制板与舵机

连线如表５Ｇ２所示.

图５Ｇ６　舵机控制模块

表５Ｇ２　舵机控制板与舵机引脚接线

元　　件

元件引脚

舵机控制板对应引脚

关节舵机１

PWM

４

关节舵机２

PWM

５

关节舵机３

PWM

６

关节舵机４

PWM

７

超声波云台舵机

PWM

０

２)相关代码

＃include Servo敭h

＃include Wire敭h

＃include Adafruit_PWMServoDriver敭h

Adafruit_PWMServoDriverpwm ＝ Adafruit_PWMServoDriver

＃defineSERVOMIN１５０

＃defineSERVOMAX６００

[]{#index_split_003.html#p187}![index-187_1.png](https://i.imgur.com/5W79q0r.jpeg){.calibre2}

![index-187_2.png](https://i.imgur.com/Nba2MBW.jpeg){.calibre2}

![index-187_3.png](https://i.imgur.com/PR4lql3.jpeg){.calibre2}

![index-187_4.png](https://i.imgur.com/6PisagJ.jpeg){.calibre2}

![index-187_5.png](https://i.imgur.com/GH38y2O.jpeg){.calibre2}

![index-187_6.png](https://i.imgur.com/r42FEOK.jpeg){.calibre2}

![index-187_7.png](https://i.imgur.com/xots67l.jpeg){.calibre2}

１７６

＃defineSERVOBEGIN_４３７５

＃defineSERVOBEGIN_５３７５

＃defineSERVOBEGIN_６３７５

＃defineSERVOBEGIN_７３７５

voidsetup

Serial敭

begin ９６００

Serial敭println ＂１６channelServotest

＂

pwm敭

begin

pwm敭

setPWMFreq ６０ Analogservosrunat\~６０Hzupdates voidprewalk

for uint１６_tpulselen＝３７５ pulselen ４５０ pulselen++

pwm敭setPWM ４

０

pulselen

pwm敭setPWM ６

０

pulselen

delay ７５０

for uint１６_tpulselen＝３７５ pulselen ４５０ pulselen++

pwm敭setPWM ５

０

pulselen

pwm敭setPWM ７

０

pulselen

delay ７５０

voiddwalk

倒退

for uint１６_tpulselen＝ ４５０ pulselen ３００ pulselen－－

pwm敭

setPWM ４ ０ pulselen

pwm敭

setPWM ６ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ４５０ pulselen ３００ pulselen－－

pwm敭

setPWM ５ ０ pulselen

pwm敭

setPWM ７ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ３００ pulselen ４５０ pulselen++

pwm敭

setPWM ４ ０ pulselen

pwm敭

setPWM ６ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ３００ pulselen ４５０ pulselen++

pwm敭

setPWM ５ ０ pulselen

pwm敭

setPWM ７ ０ pulselen

delay ５００

[]{#index_split_003.html#p188}![index-188_1.png](https://i.imgur.com/upvIJm5.jpeg){.calibre2}

![index-188_2.png](https://i.imgur.com/sDrjU2z.jpeg){.calibre2}

![index-188_3.png](https://i.imgur.com/FTn1MVw.jpeg){.calibre2}

![index-188_4.png](https://i.imgur.com/mZ2G1VJ.jpeg){.calibre2}

![index-188_5.png](https://i.imgur.com/RXX9yTe.jpeg){.calibre2}

![index-188_6.png](https://i.imgur.com/JrYX5w7.jpeg){.calibre2}

![index-188_7.png](https://i.imgur.com/3f0Qaqp.jpeg){.calibre2}

![index-188_8.png](https://i.imgur.com/EMbK6OM.jpeg){.calibre2}

![index-188_9.png](https://i.imgur.com/ugmHI2H.jpeg){.calibre2}

１７７

voidoverwalk

结束行走 收脚

for uint１６_tpulselen＝４５０ pulselen ３７５ pulselen－－

pwm敭setPWM ４

０

pulselen

pwm敭setPWM ６

０

pulselen

delay ７５０

for uint１６_tpulselen＝４５０ pulselen ３７５ pulselen－－

pwm敭setPWM ５

０

pulselen

pwm敭setPWM ７

０

pulselen

delay ７５０

voiddleft

左后转

for uint１６_tpulselen＝ ４５０ pulselen ３００ pulselen－－

pwm敭

setPWM ４ ０ pulselen

pwm敭

setPWM ６ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ４２５ pulselen ３２５ pulselen－－

pwm敭

setPWM ５ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ３００ pulselen ４５０ pulselen++

pwm敭

setPWM ４ ０ pulselen

pwm敭

setPWM ６ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ３２５ pulselen ４２５ pulselen++

pwm敭

setPWM ５ ０ pulselen

delay ５００

voiddright

右后转

for uint１６_tpulselen＝ ４５０ pulselen ３００ pulselen－－

pwm敭

setPWM ４ ０ pulselen

pwm敭

setPWM ６ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ４２５ pulselen ３２５ pulselen－－

pwm敭

setPWM ７ ０ pulselen

delay ５００

[]{#index_split_003.html#p189}![index-189_1.png](https://i.imgur.com/2SAkwNK.jpeg){.calibre2}

![index-189_2.png](https://i.imgur.com/S8lQNZQ.jpeg){.calibre2}

![index-189_3.png](https://i.imgur.com/FzL2Hrz.jpeg){.calibre2}

![index-189_4.png](https://i.imgur.com/tCqUjvE.jpeg){.calibre2}

![index-189_5.png](https://i.imgur.com/bKvhqXh.jpeg){.calibre2}

![index-189_6.png](https://i.imgur.com/vfTyuGV.jpeg){.calibre2}

![index-189_7.png](https://i.imgur.com/gen8Hd0.jpeg){.calibre2}

![index-189_8.png](https://i.imgur.com/cS6d95k.jpeg){.calibre2}

![index-189_9.png](https://i.imgur.com/5yV0AS4.jpeg){.calibre2}

![index-189_10.png](https://i.imgur.com/OTKDycb.jpeg){.calibre2}

１７８

for uint１６_tpulselen＝ ３００ pulselen ４５０ pulselen++

pwm敭

setPWM ４ ０ pulselen

pwm敭

setPWM ６ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ３２５ pulselen ４２５ pulselen++

pwm敭

setPWM ７ ０ pulselen

delay ５００

voidwalk

直行

for uint１６_tpulselen＝ ４５０ pulselen ３００ pulselen－－

pwm敭

setPWM ４ ０ pulselen

pwm敭

setPWM ６ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ３００ pulselen ４５０ pulselen++

pwm敭

setPWM ５ ０ pulselen

pwm敭

setPWM ７ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ３００ pulselen ４５０ pulselen++

pwm敭

setPWM ４ ０ pulselen

pwm敭

setPWM ６ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ４５０ pulselen ３００ pulselen－－

pwm敭

setPWM ５ ０ pulselen

pwm敭

setPWM ７ ０ pulselen

delay ５００

voidleft

左转

for uint１６_tpulselen＝ ４５０ pulselen ３００ pulselen－－

pwm敭

setPWM ４ ０ pulselen

pwm敭

setPWM ６ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ３２５ pulselen ４２５ pulselen++

pwm敭

setPWM ５ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ３００ pulselen ４５０ pulselen++

[]{#index_split_003.html#p190}![index-190_1.png](https://i.imgur.com/aLTmlIl.jpeg){.calibre2}

![index-190_2.png](https://i.imgur.com/7TRbJsR.jpeg){.calibre2}

![index-190_3.png](https://i.imgur.com/aY0QDPg.jpeg){.calibre2}

![index-190_4.png](https://i.imgur.com/e7WHbYN.jpeg){.calibre2}

![index-190_5.png](https://i.imgur.com/3PpNMFO.jpeg){.calibre2}

![index-190_6.png](https://i.imgur.com/hsFhV0M.jpeg){.calibre2}

![index-190_7.png](https://i.imgur.com/a8ATHqI.jpeg){.calibre2}

![index-190_8.png](https://i.imgur.com/tc86n0z.jpeg){.calibre2}

![index-190_9.png](https://i.imgur.com/6QNfYPu.jpeg){.calibre2}

１７９

pwm敭

setPWM ４ ０ pulselen

pwm敭

setPWM ６ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ４２５ pulselen ３２５ pulselen－－

pwm敭

setPWM ５ ０ pulselen

delay ５００

voidright

右转

for uint１６_tpulselen＝ ４５０ pulselen ３００ pulselen－－

pwm敭

setPWM ４ ０ pulselen

pwm敭

setPWM ６ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ３２５ pulselen ４２５ pulselen++

pwm敭

setPWM ７ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ３００ pulselen ４５０ pulselen++

pwm敭

setPWM ４ ０ pulselen

pwm敭

setPWM ６ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ４２５ pulselen ３２５ pulselen－－

pwm敭

setPWM ７ ０ pulselen

delay ５００

voiddance

跳舞

for uint１６_tpulselen＝ ０ pulselen ７５ pulselen++

pwm敭

setPWM ４ ０ SERVOBEGIN_４＋pulselen

pwm敭

setPWM ６ ０ SERVOBEGIN_６－pulselen

delay ５００

for uint１６_tpulselen＝ ０ pulselen ７５ pulselen++

pwm敭

setPWM ４ ０ SERVOBEGIN_４－pulselen

pwm敭

setPWM ６ ０ SERVOBEGIN_６＋pulselen

delay ５００

for uint１６_tpulselen＝ ３７５ pulselen ３００ pulselen－－

pwm敭

setPWM ４ ０ pulselen

pwm敭

setPWM ６ ０ pulselen

[]{#index_split_003.html#p191}![index-191_1.png](https://i.imgur.com/Wv7GUes.jpeg){.calibre2}

![index-191_2.png](https://i.imgur.com/iPjtw1A.jpeg){.calibre2}

![index-191_3.png](https://i.imgur.com/SfXomCO.jpeg){.calibre2}

![index-191_4.png](https://i.imgur.com/W7x4kHT.jpeg){.calibre2}

![index-191_5.png](https://i.imgur.com/A81A6tc.jpeg){.calibre2}

![index-191_6.png](https://i.imgur.com/RPbSHsA.jpeg){.calibre2}

![index-191_7.png](https://i.imgur.com/XdOdbXA.jpeg){.calibre2}

![index-191_8.png](https://i.imgur.com/6OqW3r6.jpeg){.calibre2}

１８０

delay ５００

for uint１６_tpulselen＝ ３００ pulselen ４５０ pulselen++

pwm敭

setPWM ５ ０ pulselen

pwm敭

setPWM ７ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ４５０ pulselen ３００ pulselen－－

pwm敭

setPWM ５ ０ pulselen

pwm敭

setPWM ７ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ３００ pulselen ３７５ pulselen++

pwm敭

setPWM ５ ０ pulselen

pwm敭

setPWM ７ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ３７５ pulselen ４５０ pulselen++

pwm敭

setPWM ４ ０ pulselen

pwm敭

setPWM ６ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ４５０ pulselen ３００ pulselen－－

pwm敭

setPWM ５ ０ pulselen

pwm敭

setPWM ７ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ３００ pulselen ４５０ pulselen++

pwm敭

setPWM ５ ０ pulselen

pwm敭

setPWM ７ ０ pulselen

delay ５００

for uint１６_tpulselen＝ ４５０ pulselen ３７５ pulselen－－

pwm敭

setPWM ５ ０ pulselen

pwm敭

setPWM ７ ０ pulselen

delay ５００

intp ＝ ０

intq ＝ ０

intf ＝ ０

voidloop

if f＝＝０

[]{#index_split_003.html#p192}![index-192_1.png](https://i.imgur.com/T8EAuBr.jpeg){.calibre2}

![index-192_2.png](https://i.imgur.com/0eCtXIX.jpeg){.calibre2}

![index-192_3.png](https://i.imgur.com/R737q3U.jpeg){.calibre2}

１８１

pwm敭setPWM ４ ０ SERVOBEGIN_０

pwm敭setPWM ５ ０ SERVOBEGIN_１

pwm敭setPWM ６ ０ SERVOBEGIN_２

pwm敭setPWM ７ ０ SERVOBEGIN_３

delay ５００

f＝１

if q ＝ ０ p＝ Serial敭read 当动作正在执行时 串口值赋为p 串口为空时 读取值为－１

Serial敭

println p

Serial敭println q

if p ０

if p＝＝ ４９

输入为１时 直行

walk

delay １５０

q＝ １

if p＝＝ ５０

输入为２时 左转

left

delay １５０

q＝ １

if p＝＝ ５１

输入为３时 右转

right

delay １５０

q＝ １

if p＝＝ ５２

输入为４时 后退

dwalk

delay １５０

q＝ １

if p＝＝ ５３

输入为５时 左后转

dleft

delay １５０

q＝ １

if p＝＝ ５４

输入为６时 右后转

dright

delay １５０

q＝ １

if p＝＝ ５５

输入为７时 跳舞

[]{#index_split_003.html#p193}![index-193_1.png](https://i.imgur.com/x9Rvmht.jpeg){.calibre2}

![index-193_2.png](https://i.imgur.com/b53KeJM.jpeg){.calibre2}

![index-193_3.png](https://i.imgur.com/buHxINn.jpeg){.calibre2}

![index-193_4.png](https://i.imgur.com/K2ziZZX.jpeg){.calibre2}

１８２

dance

delay １５０

q＝ １

if q＝＝ １

q＝ Serial敭read

if q ＝ ０

结束动作后复位舵机角度

pwm敭

setPWM ４ ０ SERVOBEGIN_４

pwm敭

setPWM ５ ０ SERVOBEGIN_５

pwm敭

setPWM ６ ０ SERVOBEGIN_６

pwm敭

setPWM ７ ０ SERVOBEGIN_７

delay ５００

５．

４　产品展示

手机蓝牙操作界面如图５Ｇ７所示,产品正面视角如图５Ｇ８所示,背部视角如图５Ｇ９所示.

图５Ｇ７　手机蓝牙操作界面

图５Ｇ８　正面外观图

[]{#index_split_003.html#p194}![index-194_1.png](https://i.imgur.com/XMtQPIM.jpeg){.calibre2}

![index-194_2.png](https://i.imgur.com/pNGDJth.jpeg){.calibre2}

１８３

图５Ｇ９　背部外观图

５．

５　故障及问题分析

问题１:无法通过蓝牙发送各项指令.

解决方案:最初认为接线出错.网上资料多为 Arduino开发板蓝牙接线,咨询后得知

ArduinoUNO 与 ArduinoMEGA 连线端口相同,于是排除接线问题.进一步分析出手机

软件问题,最初使用的蓝牙软件可以连接,但是发送指令有限制,只能为字母,而后使用蓝牙

串口 APP,可实现数字指令,并可以进行键盘编程.

问题２:舵机转动角度不准,机器人走路不稳定.

解决方案:由于购买的是较为便宜的国产舵机,每个舵机输入相同脉冲但转动的角度

不完全确定.于是,通过多次测试,对每个舵机进行独立的代码编程,使之能够协调运行,完

成相应动作.

问题３:在机器人主体放置四节电池和超声波模块后,头部变重,重心变高且偏向右,容

易导致向右倾翻.

解决方案:由于机器人走路时左右脚交替抬升,所以必须保证单脚可以支持整个主体.

于是,在左 右 脚 板 上 各 添 加 配 重,使 底 部 足 够 结 实,能 保 证 机 器 人 不 倾 翻. 给 Arduino MEGA 开发板供电的充电宝放到左脚,测试发现仍然不够稳定,又加上两块电池增加配重, 问题得以解决.

问题４:机器人收到指令后无法做出相应动作,且舵机偏转角度不够.

解决方案:开始以为是 国 产 舵 机 出 现 问 题,后 来 讨 论 分 析,认 为 是 电 池 电 压 变 低 导 致

的,于是更换电池,机器人恢复工作状态.但是,出现新的问题,其中一个舵机不再转动,拆

下后进行单独测试,发现舵机损坏,重新购置舵机后,问题得以解决.

问题５:超声波模块随着机器人行走而摇动,不断改动位置,导致探测的不完全是正前

方的距离.

[]{#index_split_003.html#p195}![index-195_1.png](https://i.imgur.com/xY2Ke63.jpeg){.calibre2}

１８４

解决方案:通过模拟机 器 人 行 走,希 望 找 到 一 个 比 较 稳 定 的 位 置 来 放 置 超 声 波 模 块.

但是,考虑到超 声 波 模 块 云 台 舵 机 能 顺 利 转 动,最 终 决 定 将 超 声 波 模 块 固 定 在 Arduino MEGA 开发板上,而不是机器人主体上.

问题６:超声波代码编译错误.

解决方案:通过编译器调试信息,发现没有配置相应的端口,配置后调试通过并成功上

传到 ArduinoMEGA 开发板.

５．

６　元件清单

完成本项目所用到的元件及数量如表５Ｇ３所示.

表５Ｇ３　蓝牙遥控四自由度可自动避障机器人元件清单

模　　块

元件/测试仪表

数量

导线

若干

杜邦线

若干

蓝牙模块

HCＧ０６

１个

ArduinoMEGA 开发板

１个

电源(充电宝)

１个

导线

若干

杜邦线

若干

超声波模块

HCＧSR０４

１个

ArduinoMEGA 开发板

１个

舵机

５个

杜邦线

若干

舵机控制模块

１６路 PWM 舵机控制板

１个

１．

５V 电池

４个

轴承

２个

L形件

２个

U 梁件

１个

主体构架部分

大脚板

２个

金属舵盘

４个

短 U 件

２个

螺丝、螺母

若干

[]{#index_split_003.html#p196}![index-196_1.png](https://i.imgur.com/YFAU2Hr.jpeg){.calibre2}

第６章

遥控智能四驱车项目设计

６．

１　项目背景

遥控车可以按照预先设定的模式在一定的范围内自动运作,不需要太多的人为调节,以

此达到预期或更高的目标.因此,本项目对传统的遥控车进行扩展,完成一款基于 Arduino 开发板且能用手机蓝牙遥控的智能四驱车.

６．

２　创新描述

用户可以基于最初的设定范围,通过蓝牙实现不同功能的选择及切换,例如避障、循迹、

遥控和调速等.在遥控时,可以自由组合已设定的基础遥控功能,使小车能够有不同的行进

轨迹.遥控时,小车遇到障碍物可自行后退.通过蓝牙传输,可任意改变小车车速及左右轮

速差,且在串口返回左右轮各自车速,即可实现调速功能.

６．

３　功能及总体设计

本 作 品 根 据 对 比 选 择 、模 块 独 立 、综 合 处 理 的 设 计 研 究 方 法 ,分 四 部 分 进 行 设 计 , 即 避 障 、循 迹 、遥 控 和 调 速 . 通 过 蓝 牙 实 现 遥 控 功 能 以 及 功 能 间 的 切 换 ,处 理 探 测 得 到

的 信 息 ,决 定 小 车 的 下 一 步 行 动 即 避 障 或 循 迹 ;人 为 遥 控 和 调 速 可 控 制 小 车 的 方 向 及

速 度 .

６．

３．

１　功能介绍

普通的智能小车一般只有简单的循迹或避障功能,本项目将多种功能集合到一起,并且

可通过手机蓝牙对小车实现遥控.能够由遥控实现各功能之间的切换,在遥控状态下,还可

本章根据王悦、毛彧叶项目设计整理而成.

[]{#index_split_003.html#p197}![index-197_1.png](https://i.imgur.com/BLxJQ2u.jpeg){.calibre2}

![index-197_2.png](https://i.imgur.com/D1aFBn6.jpeg){.calibre2}

１８６

以组合指令实现智能车的组合运动.

连接蓝牙后,选择小车功能:避障、循迹、遥控和调速.避障功能又可分为超声波探测

和小车行进两部分,由超声波探测并传回的数据控制小车的行进方向;循迹也可分为红外

探测与小车行进两部分,由多个红外探测传感器回传的探测信号来控制小车的转向、轮速和

进退;遥控功能主要由蓝牙遥控和直流电机两部分组成,蓝牙模块接收手机发送的指令后, 小车会有相应的运动;调速功能分为 蓝 牙 调 速 和 测 速 两 部 分,蓝 牙 模 块 收 到 信 息,写 入 速

度,再由测速模块测出轮速,并在串口显示.

６．

３．

２　总体设计

要实现上述功能需要 将 作 品 分 成 三 部 分 进 行 设 计:输 入 部 分、输 出 部 分 和 处 理 部 分.

输入部分包括超声波传感器、红外线探测传感器以及蓝牙模块;输出部分包括舵机、直流电

机驱动、测速模块和超声波模块;处理部分主要包括 ArduinoMEGA 开发板.

１．整体框架图

项目整体框架如图６Ｇ１所示.

图６Ｇ１　整体框架图

２．系统流程图

系统流程图如图６Ｇ２所示.

接通电源后,如果蓝牙接收到避障信号,则开始执行避障程序;若接收到循迹信号,则

执行循迹;若接收到遥控信号,则进入遥控模式;若接收到调速信号,则进入调速模式,并

将速度从串口返回;若接收到停止信号,则停止当前的运动.

[]{#index_split_003.html#p198}![index-198_1.png](https://i.imgur.com/RYluGBE.jpeg){.calibre2}

![index-198_2.png](https://i.imgur.com/4oIURuQ.jpeg){.calibre2}

１８７

图６Ｇ２　系统流程图

３．总电路图

系统总电路如图６Ｇ３所示.

图６Ｇ３中连线如下:

左前直流电机通过驱动接在数字引脚８、

９,使能端为数字引脚１１;右前直流电机通过驱

动接在数字引脚４、

５,使能端为数字引脚１０;左后直流电机通过驱动接在数字引脚２８、

２９,使

能端为数字引脚１３;右后直流电机通过驱动接在数字引脚２６、

２７,使能端为数字引脚１２.

为实现避障功能,舵机接在数字引脚６,超声波探测传感器接在模拟信号引脚 A４、A５;

[]{#index_split_003.html#p199}![index-199_1.png](https://i.imgur.com/jpXGv5U.jpeg){.calibre2}

![index-199_2.png](https://i.imgur.com/fsCTOEh.jpeg){.calibre2}

![index-199_3.png](https://i.imgur.com/Ztxq9Vm.jpeg){.calibre2}

![index-199_4.png](https://i.imgur.com/CreyNE0.jpeg){.calibre2}

１８８

图６Ｇ３　总电路图

为实现循迹功能,

５个红外循迹传感器 S１\~S５的接口为 A６、A２、A１、A０、A３;为实现遥控

功能,蓝牙模块的 TX 引脚接０,RX 引脚接１;为实现测速功能,左侧测速接数字引脚３,右

侧测速接数字引脚２.

６．

３．

３　模块介绍

本项目主要包括主程序模块、避障模块、循迹模块、遥控模块以及运动模块.下面分别

给出各模块的功能、元件、电路图和相关代码.

１．主程序模块

１)功能介绍

设置端口,检测 手 机 端 蓝 牙 输 入,以 启 动 另 外 三 个 模 块 进 行 小 车 的 驱 动. 元 件 包 括

ArduinoMEGA 开发板及扩展板、直流电机和电源.

２)相关代码

＃include Servo敭h

Servomyservo

[]{#index_split_003.html#p200}![index-200_1.png](https://i.imgur.com/vW1WhhM.jpeg){.calibre2}

１８９

intEcho ＝ A４ 　　　　　　　　 Echo回声脚

intTrig ＝A５

Trig 触发脚

intMotorRight１ ＝ ８

定义引脚 ８ 向MotorRight１ 输出

intMotorRight２ ＝ ９

定义引脚 ９ 向 MotorRight２输出

intMotorRight１１ ＝ ５

定义引脚５ 向 MotorRight１１ 输出

intMotorRight２１ ＝ ４

定义引脚 ４ 向MotorRight２１ 输出

intMotorLeft１ ＝ ２６

定义引脚 ２６ 向 MotorLeft１ 输出

intMotorLeft２ ＝ ２７

定义引脚 ２７ 向 MotorLeft２ 输出

intMotorLeft１１ ＝ ２８

定义引脚 ２８ 向MotorLeft１１ 输出

intMotorLeft２１ ＝ ２９

定义引脚 ２９ 向 MotorLeft２１输出

intMotorRPWM＝１０

PWM１０

intMotorLPWM＝１１

PWM１１

intMotorRPWM１＝１２

PWM１２

intMotorLPWM１＝１３

PWM１３

constintfinder１＝A３

定义 linefinderS１

constintfinder２＝A０

定义 linefinderS２

constintfinder３＝A１

定义 linefinderS３

constintfinder４＝A２

定义 linefinderS４

constintfinder５＝A６

定义 linefinderS５

intS１ S２ S３ S４ S５

intflag＝０

d＝０

m１＝０

m２＝０

charxy

chargetstr

intc＝０

intrightDistance ＝ ０

leftDistance ＝ ０ middleDistance ＝ ０

voidsetup

myservo敭

attach ６

Serial敭

begin ９６００

初始化各I O 模式为OUTPUT 输出模式

pinMode Echo INPUT

定义超声波输入引脚

pinMode Trig OUTPUT

定义超声波输出引脚

pinMode MotorRight１

OUTPUT

pinMode MotorRight２

OUTPUT

pinMode MotorLeft１

OUTPUT

pinMode MotorLeft２

OUTPUT

pinMode MotorRight１１

OUTPUT

pinMode MotorRight２１

OUTPUT

pinMode MotorLeft１１

OUTPUT

pinMode MotorLeft２１

OUTPUT

pinMode MotorLPWM OUTPUT

引脚 １０ PWM

pinMode MotorRPWM OUTPUT

引脚 １１ PWM

pinMode MotorLPWM１ OUTPUT

引脚 １２ PWM

[]{#index_split_003.html#p201}![index-201_1.png](https://i.imgur.com/BtUABlI.jpeg){.calibre2}

１９０

pinMode MotorRPWM１ OUTPUT

引脚 １３ PWM

pinMode finder１ INPUT

pinMode finder２ INPUT

pinMode finder３ INPUT

pinMode finder４ INPUT

pinMode finder５ INPUT

voidzonghe

if getstr＝＝ \'A\'

如果收到 \'A\' 则c＝１ 实现避障功能

c＝１

elseif getstr＝＝ \'C\'

如果收到 \'C\' 则c＝２ 实现遥控功能

c＝２

elseif getstr＝＝ \'D\'

如果收到 \'D\' 则c＝３ 实现循迹功能

c＝３

elseif getstr＝＝ \'E\'

如果收到 \'E\' 则c＝４ 实现调速功能

c＝４

elseif getstr＝＝ \'T\'

如果收到 \'T\' 则c＝０ 停止

c＝０

stop

while c＝＝１

c＝１ 实现避障功能

bizhang

getstr＝Serial敭

read

if getstr＝＝ \'T\'

c＝０

stop

while c＝＝２

c＝２ 实现遥控功能

yaokong

getstr＝Serial敭

read

if getstr＝＝ \'T\'

c＝０

[]{#index_split_003.html#p202}![index-202_1.png](https://i.imgur.com/36gCvwd.jpeg){.calibre2}

１９１

stop

while c＝＝３

c＝３ 实现循迹功能

xunji

getstr＝Serial敭

read

if getstr＝＝ \'T\'

c＝０

stop

while c＝＝４

c＝４ 实现调速功能

tiaosu

getstr＝Serial敭

read

if getstr＝＝ \'T\'

c＝０

stop

voidloop

getstr＝Serial敭

read

zonghe

２．避障模块

１)功能介绍

当超声波探测的距离低于设定值时,小车停下并再次探测左右距离,优先右转.若右侧

距离不够,则左转;若左右距离都不够,则后退.元件包括直流电机、直流电机驱动、舵机和

超声波距离传感器.

２)相关代码

intDistance_test

测出前方距离

digitalWrite Trig LOW

给触发引脚低电平

delayMicroseconds ２

digitalWrite Trig HIGH

给触发引脚高电平

delayMicroseconds ２０

digitalWrite Trig LOW

持续给触发引脚低电平

floatFdistance＝ pulseIn Echo HIGH 　　 读取高电平时间 单位 μs Fdistance＝ Fdistance ５８

为什么除以５８后单位为cm Y m ＝ X s ×３４４ ２

X s ＝ ２×Y m ３４４ X s ＝０敭

００５８×Y m 因此厘米 cm ＝微秒 μs ５８

return int Fdistance

voidqian

[]{#index_split_003.html#p203}![index-203_1.png](https://i.imgur.com/hRHPuxr.jpeg){.calibre2}

１９２

forward 向前

digitalWrite MotorRight１ HIGH

给高电平

digitalWrite MotorRight２ LOW

给低电平

analogWrite MotorRPWM

２５０

PWM２５０

digitalWrite MotorRight１１

HIGH

给高电平

digitalWrite MotorRight２１ LOW

给低电平

analogWrite MotorRPWM１

２５０

PWM２５０

digitalWrite MotorLeft１ HIGH

给高电平

digitalWrite MotorLeft２ LOW

给低电平

analogWrite MotorLPWM

２５０

PWM２５０

digitalWrite MotorLeft１１ HIGH

给高电平

digitalWrite MotorLeft２１ LOW

给低电平

analogWrite MotorLPWM１

２５０

PWM２５０

delay ８００

延时

voidstop

stop 停止

digitalWrite MotorRight１

LOW

digitalWrite MotorRight２

LOW

analogWrite MotorRPWM

０

０

digitalWrite MotorRight１１

LOW

digitalWrite MotorRight２１

LOW

analogWrite MotorRPWM１

０

０

digitalWrite MotorLeft１

LOW

digitalWrite MotorLeft２

LOW

analogWrite MotorLPWM

０

０

digitalWrite MotorLeft１１

LOW

digitalWrite MotorLeft２１

LOW

analogWrite MotorLPWM１

０

０

delay ５００

延时

voidback

digitalWrite MotorRight１

LOW

digitalWrite MotorRight２

HIGH

analogWrite MotorRPWM

２５０

２５０

digitalWrite MotorRight１１

LOW

digitalWrite MotorRight２１

HIGH

analogWrite MotorRPWM１

２５０

２５０

digitalWrite MotorLeft１

LOW

digitalWrite MotorLeft２

HIGH

analogWrite MotorLPWM

２５０

２５０

[]{#index_split_003.html#p204}![index-204_1.png](https://i.imgur.com/bVBI8j5.jpeg){.calibre2}

１９３

digitalWrite MotorLeft１１

LOW

digitalWrite MotorLeft２１

HIGH

analogWrite MotorLPWM１

２５０

２５０

delay ８００

voidturnleft

digitalWrite MotorRight１

HIGH

digitalWrite MotorRight２

LOW

analogWrite MotorRPWM

２５０

２５０

digitalWrite MotorRight１１

HIGH

digitalWrite MotorRight２１

LOW

analogWrite MotorRPWM１

２５０

２５０

digitalWrite MotorLeft１

HIGH

digitalWrite MotorLeft２

LOW

analogWrite MotorLPWM

０

０

digitalWrite MotorLeft１１

HIGH

digitalWrite MotorLeft２１

LOW

analogWrite MotorLPWM１

０

０

delay ８３０

voidturnright

digitalWrite MotorRight１

HIGH

digitalWrite MotorRight２

LOW

analogWrite MotorRPWM

０

０

digitalWrite MotorRight１１

HIGH

digitalWrite MotorRight２１

LOW

analogWrite MotorRPWM１

０

０

digitalWrite MotorLeft１

HIGH

digitalWrite MotorLeft２

LOW

analogWrite MotorLPWM

２５０

２５０

digitalWrite MotorLeft１１

HIGH

digitalWrite MotorLeft２１

LOW

analogWrite MotorLPWM１

２５０

２５０

delay ８３０

voidbizhang

myservo敭

write ９０

delay ２０

middleDistance ＝ Distance_test

[]{#index_split_003.html#p205}![index-205_1.png](https://i.imgur.com/MEiSvbM.jpeg){.calibre2}

![index-205_2.png](https://i.imgur.com/1H0SO87.jpeg){.calibre2}

![index-205_3.png](https://i.imgur.com/GePMBH0.jpeg){.calibre2}

![index-205_4.png](https://i.imgur.com/QPKLtJ4.jpeg){.calibre2}

１９４

＃ifdefsend

Serial敭

print ＂middleDistance＝＂

Serial敭

println middleDistance

＃endif

if middleDistance ＝５０

如果前方距离小于５０cm 则避障

stop

delay １０

myservo敭

write ５

delay ２５０

rightDistance ＝ Distance_test

＃ifdefsend

Serial敭

print ＂rightDistance＝＂

Serial敭

println rightDistance

＃endif

delay ２５０

myservo敭

write ９０

delay ２５０

myservo敭

write １７５

delay ２５０

leftDistance ＝ Distance_test

＃ifdefsend

Serial敭

print ＂leftDistance＝＂

Serial敭

println leftDistance

＃endif

delay ２５０

myservo敭

write ９０

delay ２５０

if rightDistance ＝５０

右边距离大于５０cm 则右转

turnright

delay ７５０

elseif leftDistance ＝５０

左边距离大于５０cm 则左转

turnleft

delay ７５０

else

前方及左右距离都不够 则后退

back

delay ２５０

[]{#index_split_003.html#p206}![index-206_1.png](https://i.imgur.com/TKqJWb9.jpeg){.calibre2}

１９５

else

qian

３．循迹模块

１)功能介绍

红外探测传感器发出红外光,黑线吸收红外光,无返回信号,白地产生漫反射返回信号.

小车根据传感器回传的不同信号,进行不同速度、不同方向的调整,使小车尽量保持以中路

方式沿黑线前进.元件包括红外循迹模块、直流电机和直流电机驱动.

２)相关代码

voidqianjin

digitalWrite MotorRight１

HIGH

IN１ 右直流电机高电平反转

digitalWrite MotorRight２

LOW

IN２ 右直流电机低电平正转

analogWrite MotorRPWM

１５０

１５０

digitalWrite MotorRight１１

HIGH

IN１ 右直流电机高电平反转

digitalWrite MotorRight２１

LOW

IN２ 右直流电机低电平正转

analogWrite MotorRPWM１

１５０

１５０

digitalWrite MotorLeft１ HIGH

IN３ 左直流电机高电平正转

digitalWrite MotorLeft２

LOW

IN４ 左直流电机低电平反转

analogWrite MotorLPWM

１５０

１５０

digitalWrite MotorLeft１１

HIGH

IN３ 左直流电机高电平正转

digitalWrite MotorLeft２１

LOW

IN４ 左直流电机低电平反转

analogWrite MotorLPWM１

１５０

１５０

delay １００

voidturnlgao

delay １

digitalWrite MotorRight１

HIGH

IN１ 右直流电机低电平反转

digitalWrite MotorRight２

LOW

IN２ 右直流电机高电平正转

analogWrite MotorRPWM

２５５

２５５

digitalWrite MotorRight１１

HIGH

IN１ 右直流电机低电平反转

digitalWrite MotorRight２１

LOW

IN２ 右直流电机高电平正转

analogWrite MotorRPWM１

２５５

２５５

digitalWrite MotorLeft１

HIGH

IN３ 左直流电机高电平正转

digitalWrite MotorLeft２

LOW

IN４ 左直流电机低电平反转

analogWrite MotorLPWM

０

０

digitalWrite MotorLeft１１

HIGH

IN３ 左直流电机高电平正转

digitalWrite MotorLeft２１

LOW

IN４ 左直流电机低电平反转

[]{#index_split_003.html#p207}![index-207_1.png](https://i.imgur.com/Loytt45.jpeg){.calibre2}

１９６

analogWrite MotorLPWM１

０

０

delay ２５０

voidturnldi

delay １

digitalWrite MotorRight１

HIGH

IN１ 右直流电机低电平反转

digitalWrite MotorRight２

LOW

IN２ 右直流电机高电平正转

analogWrite MotorRPWM

２００

２００

digitalWrite MotorRight１１

HIGH

IN１ 右直流电机低电平反转

digitalWrite MotorRight２１

LOW

IN２ 右直流电机高电平正转

analogWrite MotorRPWM１

２００

２００

digitalWrite MotorLeft１

HIGH

IN３ 左直流电机高电平正转

digitalWrite MotorLeft２

LOW

IN４ 左直流电机低电平反转

analogWrite MotorLPWM

５０

５０

digitalWrite MotorLeft１１

HIGH

IN３ 左直流电机高电平正转

digitalWrite MotorLeft２１

LOW

IN４ 左直流电机低电平反转

analogWrite MotorLPWM１

５０

５０

delay ２５０

voidturnrdi

delay １

digitalWrite MotorRight１

HIGH

IN１ 右直流电机低电平反转

digitalWrite MotorRight２

LOW

IN２ 右直流电机高电平正转

analogWrite MotorRPWM

５０

５０

digitalWrite MotorRight１１

HIGH

IN１ 右直流电机低电平反转

digitalWrite MotorRight２１

LOW

IN２ 右直流电机高电平正转

analogWrite MotorRPWM１

５０

５０

digitalWrite MotorLeft１

HIGH

IN３ 左直流电机高电平正转

digitalWrite MotorLeft２

LOW

IN４ 左直流电机低电平反转

analogWrite MotorLPWM

２００

２００

digitalWrite MotorLeft１１

HIGH

IN３ 左直流电机高电平正转

digitalWrite MotorLeft２１

LOW

IN４ 左直流电机低电平反转

analogWrite MotorLPWM１

２００

２００

delay ２５０

voidturnrgao

delay １０

digitalWrite MotorRight１

HIGH

IN１ 右直流电机高电平反转

digitalWrite MotorRight２

LOW

IN２ 右直流电机低电平正转

[]{#index_split_003.html#p208}![index-208_1.png](https://i.imgur.com/8zH7eYu.jpeg){.calibre2}

１９７

analogWrite MotorRPWM

０

０

digitalWrite MotorRight１１

HIGH

IN１ 右直流电机高电平反转

digitalWrite MotorRight２１

LOW

IN２ 右直流电机低电平正转

analogWrite MotorRPWM１

０

０

digitalWrite MotorLeft１

HIGH

IN３ 左直流电机高电平正转

digitalWrite MotorLeft２

LOW

IN４ 左直流电机低电平反转

analogWrite MotorLPWM

２５５

２５５

digitalWrite MotorLeft１１

HIGH

IN３ 左直流电机高电平正转

digitalWrite MotorLeft２１

LOW

IN４ 左直流电机低电平反转

analogWrite MotorLPWM１

２５５

２５５

delay ２５０

voidpanduan

R是右 right

L是左 left

if S５＝＝ HIGH

最右边探测到黑线 快速左转

turnlgao

右转 １

２

３

elseif S４＝＝ HIGH

右数第二个探测器探测到黑线 慢速左转

turnldi

elseif S１ ＝＝ LOW

最左边探测到黑线 快速右转

turnrgao

elseif S２＝＝HIGH

左数第二个探测器探测到黑线 慢速右转

turnrdi

elseif S３ ＝＝ HIGH

正中探测到黑线 直行

qianjin

else

qianjin

voidxunji

[]{#index_split_003.html#p209}![index-209_1.png](https://i.imgur.com/OFufSsD.jpeg){.calibre2}

１９８

S１＝ digitalRead finder１

S２＝ digitalRead finder２

S３＝ digitalRead finder３

S４＝ digitalRead finder４

S５＝ digitalRead finder５

panduan

４．遥控模块

１)功能介绍

将小车的蓝牙模块和手机相连,通过手机向小车发送指令.小车接收到指令后,调用并

实施相应的运动模块,实现手机对小车的蓝牙遥控;遇到障碍物时,小车可自行后退.元件

包括蓝牙模块、直流电机、直流电机驱动和避障模块.

２)相关代码

intDistance_test

测出前方距离

digitalWrite Trig LOW

给触发引脚低电平

delayMicroseconds ２

digitalWrite Trig HIGH

给触发引脚高电平

delayMicroseconds ２０

digitalWrite Trig LOW

持续给触发引脚低电平

floatFdistance＝ pulseIn Echo HIGH 读取高电平时间 单位 μs Fdistance＝ Fdistance ５８

return int Fdistance

voidqian

forward 向前转

digitalWrite MotorRight１ HIGH

给高电平

digitalWrite MotorRight２ LOW

给低电平

analogWrite MotorRPWM

２５０

２５０

digitalWrite MotorRight１１ HIGH

给高电平

digitalWrite MotorRight２１ LOW

给低电平

analogWrite MotorRPWM１

２５０

２５０

digitalWrite MotorLeft１ HIGH

给高电平

digitalWrite MotorLeft２ LOW

给低电平

analogWrite MotorLPWM

２５０

２５０

digitalWrite MotorLeft１１ HIGH

给高电平

digitalWrite MotorLeft２１ LOW

给低电平

analogWrite MotorLPWM１

２５０

２５０

delay ８００

延时

[]{#index_split_003.html#p210}![index-210_1.png](https://i.imgur.com/M1eweYp.jpeg){.calibre2}

１９９

voidstop

stop 停止

digitalWrite MotorRight１

LOW

digitalWrite MotorRight２

LOW

analogWrite MotorRPWM

０

０

digitalWrite MotorRight１１

LOW

digitalWrite MotorRight２１

LOW

analogWrite MotorRPWM１

０

０

digitalWrite MotorLeft１

LOW

digitalWrite MotorLeft２

LOW

analogWrite MotorLPWM

０

０

digitalWrite MotorLeft１１

LOW

digitalWrite MotorLeft２１

LOW

analogWrite MotorLPWM１

０

０

delay ５００

延时０敭

５s

voidback

digitalWrite MotorRight１

LOW

digitalWrite MotorRight２

HIGH

analogWrite MotorRPWM

２５０

２５０

digitalWrite MotorRight１１

LOW

digitalWrite MotorRight２１

HIGH

analogWrite MotorRPWM１

２５０

２５０

digitalWrite MotorLeft１

LOW

digitalWrite MotorLeft２

HIGH

analogWrite MotorLPWM

２５０

２５０

digitalWrite MotorLeft１１

LOW

digitalWrite MotorLeft２１

HIGH

analogWrite MotorLPWM１

２５０

２５０

delay ８００

voidturnleft

digitalWrite MotorRight１

HIGH

digitalWrite MotorRight２

LOW

analogWrite MotorRPWM

２５０

２５０

digitalWrite MotorRight１１

HIGH

digitalWrite MotorRight２１

LOW

analogWrite MotorRPWM１

２５０

２５０

digitalWrite MotorLeft１

HIGH

digitalWrite MotorLeft２

LOW

[]{#index_split_003.html#p211}![index-211_1.png](https://i.imgur.com/sqJUUna.jpeg){.calibre2}

![index-211_2.png](https://i.imgur.com/6Vcuthg.jpeg){.calibre2}

２００

analogWrite MotorLPWM

０

０

digitalWrite MotorLeft１１

HIGH

digitalWrite MotorLeft２１

LOW

analogWrite MotorLPWM１

０

０

delay ８３０

voidturnright

digitalWrite MotorRight１

HIGH

digitalWrite MotorRight２

LOW

analogWrite MotorRPWM

０

０

digitalWrite MotorRight１１

HIGH

digitalWrite MotorRight２１

LOW

analogWrite MotorRPWM１

０

０

digitalWrite MotorLeft１

HIGH

digitalWrite MotorLeft２

LOW

analogWrite MotorLPWM

２５０

２５０

digitalWrite MotorLeft１１

HIGH

digitalWrite MotorLeft２１

LOW

analogWrite MotorLPWM１

２５０ ０－－－１００－－２５０

delay ８３０

voidyaokong

myservo敭

write ９０

delay ２０

middleDistance ＝ Distance_test

if middleDistance ＝２０

前方距离小于２０cm 后退

back

elseif getstr＝＝ \'F\'

收到 \'F\' 前行

Serial敭

println ＂goforward

＂

qian

elseif getstr＝＝ \'S\'

收到 \'S\' 停止

Serial敭

println ＂stop

＂

stop

elseif getstr＝＝ \'B\'

收到 \'B\' 后退

Serial敭

println ＂goback

＂

back

[]{#index_split_003.html#p212}![index-212_1.png](https://i.imgur.com/fGXJmw5.jpeg){.calibre2}

２０１

elseif getstr＝＝ \'R\'

收到 \'R\' 右转

Serial敭

println ＂goright

＂

turnright

delay ７００

elseif getstr＝＝ \'L\'

收到 \'L\' 左转

Serial敭

println ＂goleft

＂

turnleft

delay ７００

else

stop

停止

５．调速模块

１)功能介绍

将小车的蓝牙模块和手机相连,通过手机向小车发送信息.小车接收到信息后,调用相

应函数,将速度写入,从而改变小车轮速,并且测速模块将小车左右轮速返回,显示在串口.

元件包括蓝牙模块、直流电机、直流电机驱动和测速模块.

２)相关代码

voidtiaosu

if flag＝＝０

收到的第一个数字为m１

m１＝Serial敭

parseInt

flag＝１

d＝０

elseif flag＝＝１

收到的第二个数字为m２

m２＝Serial敭parseInt

flag＝０

d＝１

if d＝＝１

m１为右轮速度

m２为左轮速度

digitalWrite MotorRight１

HIGH

IN１ 右直流电机高电平反转

digitalWrite MotorRight２

LOW

IN２ 右直流电机低电平正转

analogWrite MotorRPWM

m１

[]{#index_split_003.html#p213}![index-213_1.png](https://i.imgur.com/RBJHgbv.jpeg){.calibre2}

![index-213_2.png](https://i.imgur.com/qOykBJ1.jpeg){.calibre2}

![index-213_3.png](https://i.imgur.com/RZK2qUl.jpeg){.calibre2}

２０２

digitalWrite MotorRight１１

HIGH

IN１ 右直流电机高电平反转

digitalWrite MotorRight２１

LOW

IN２ 右直流电机低电平正转

analogWrite MotorRPWM１

m１

digitalWrite MotorLeft１ HIGH

IN３ 左直流电机高电平正转

digitalWrite MotorLeft２

LOW

IN４ 左直流电机低电平反转

analogWrite MotorLPWM

m２

digitalWrite MotorLeft１１

HIGH

IN３ 左直流电机高电平正转

digitalWrite MotorLeft２１

LOW

IN４ 左直流电机低电平反转

analogWrite MotorLPWM１

m２

delay １０００

以下代码用于调速并返回速度

＃include MsTimer２敭h

＃defineValue１９敭

８

计算周长的常量

intu_left ＝ ３

定义U形测速端口

intu_right ＝ ２

intMotorRight１ ＝ ８

定义引脚８ 向 input１ 输出

intMotorRight２ ＝ ９

定义引脚９ 向 input２ 输出

intMotorRight１１ ＝ ５

定义引脚５向 input３ 输出

intMotorRight２１ ＝ ４

定义引脚４ 向 input４ 输出

intMotorLeft１ ＝ ２６

定义引脚２６ 向 input１ 输出

intMotorLeft２ ＝ ２７

定义引脚２７ 向 input２ 输出

intMotorLeft１１ ＝ ２８

定义引脚２８ 向 input３ 输出

intMotorLeft２１ ＝ ２９

定义引脚２９ 向 input４ 输出

intMotorRPWM＝１０

PWM１０

intMotorLPWM＝１１

PWM１１

intMotorRPWM１＝１２

PWM１２

intMotorLPWM１＝１３

PWM１３

intr_wheel ＝ ０

记录U形测速模块的次数

intl_wheel ＝ ０

floatr_velocity＝０

速度

floatl_velocity＝０

intflag＝０

d＝０

m１＝０

m２＝０

charxy

voidLCount

l_wheel++

[]{#index_split_003.html#p214}![index-214_1.png](https://i.imgur.com/wH1Fnvp.jpeg){.calibre2}

２０３

voidRCount

r_wheel++

floatvelocity intn

路程

floatvel ＝Value∗ n ２０

returnvel

voidflash

返回速度

intr

l

r＝r_wheel

l＝l_wheel

r_velocity＝velocity r

l_velocity＝velocity l

Serial敭

print l_velocity

Serial敭

print ＂cm s L ＂

Serial敭

print ＂＂

Serial敭

print r_velocity

Serial敭

println ＂cm s R ＂

Serial敭

println \'\\n\'

r_wheel＝ ０

l_wheel＝ ０

voidsu intm１

intm２

digitalWrite MotorRight１

HIGH

digitalWrite MotorRight２

LOW

analogWrite MotorRPWM

m１

digitalWrite MotorRight１１

HIGH

digitalWrite MotorRight２１

LOW

analogWrite MotorRPWM１

m１

digitalWrite MotorLeft１

HIGH

digitalWrite MotorLeft２

LOW

analogWrite MotorLPWM

m２

digitalWrite MotorLeft１１

HIGH

[]{#index_split_003.html#p215}![index-215_1.png](https://i.imgur.com/GZKJWhA.jpeg){.calibre2}

２０４

digitalWrite MotorLeft２１

LOW

analogWrite MotorLPWM１

m２

delay １０００

voidsetup

Serial敭

begin ９６００

attachInterrupt ０

RCount FALLING

中断函数

attachInterrupt １

LCount FALLING

pinMode MotorRight１

OUTPUT

pinMode MotorRight２

OUTPUT

pinMode MotorLeft１

OUTPUT

pinMode MotorLeft２

OUTPUT

pinMode MotorRight１１

OUTPUT

pinMode MotorRight２１

OUTPUT

pinMode MotorLeft１１

OUTPUT

pinMode MotorLeft２１

OUTPUT

pinMode MotorLPWM OUTPUT

引脚 ６ PWM

pinMode MotorRPWM OUTPUT

引脚 ９ PWM

pinMode MotorLPWM１ OUTPUT

引脚 ６ PWM

pinMode MotorRPWM１ OUTPUT

引脚 ９ PWM

MsTimer２

set １０００ flash

中断设置函数 每 １s 进入一次中断

MsTimer２

start

voidloop

if flag＝＝０

m１＝Serial敭

parseInt

flag＝１

d＝０

elseif flag＝＝１

m２＝Serial敭parseInt

flag＝０

d＝１

[]{#index_split_003.html#p216}![index-216_1.png](https://i.imgur.com/lEyI1nz.jpeg){.calibre2}

![index-216_2.png](https://i.imgur.com/9xOA6Jj.jpeg){.calibre2}

![index-216_3.png](https://i.imgur.com/wfSzy92.jpeg){.calibre2}

２０５

if d＝＝１

su m１

m２

６．

４　产品展示

本产品的俯视图如图６Ｇ４所示;主视图如图６Ｇ５所示.

图６Ｇ４　产品俯视图

图６Ｇ５　产品主视图

６．

５　故障及问题分析

问题１:舵机只在程序运行的开始阶段转动一次,因此,小车的避障功能无法实现.由

于小车的预留孔型号不对,其他传感器的位置分布也出现问题.

解决方案:把小车与舵机的架子用胶水粘合,同时将舵机和超声波传感器粘合到一起, 避免出现传感器仅转动一次的情况.在小车和传感器二者都不能舍弃的情况下,决定采用

更加灵活的方式固定元件.

问题２:四轮小车的相关资料较少,参考两轮小车进行设计时出现了直流电机驱动及电

池动力不足的问题.

解决方案:选择用两个直流电机分别驱动前后轮,并且选用更高电压且可充电的电池.

另外,依次测试直流电机的正负极,将４个直流电机调整为共用正负极,问题得以解决.

问题３:小车在行进过程中左右轮会有差异,导致小车不能走直线.

解决方案:经排查发现,直流电机的焊接引脚不够稳定,用绝缘胶带将导线和直流电机

的引脚进行处理,保证了直流电机的转动.

问题４:无法使直流电机进行非全速的运转.

[]{#index_split_003.html#p217}![index-217_1.png](https://i.imgur.com/Qq4cODI.jpeg){.calibre2}

![index-217_2.png](https://i.imgur.com/vr80sDk.jpeg){.calibre2}

![index-217_3.png](https://i.imgur.com/tE78qad.jpeg){.calibre2}

２０６

解决方案:经检查,未接直流电机驱动的使能端,补接使能端后发现问题仍未解决.再

查资料发现直流电机的定义引脚不是 PWM 引脚.因此,不能接收模拟信号,只能接收数字

信号,再次改进以后,问题得以解决.

问题５:小车的循迹不稳定,摆动幅度较大.

解决方案:增加了一个传感器,减小了传感器之间的距离,亦减小了小车循迹过程中的

摆动幅度.

问题６:小车循线的转弯角度不合适.

解决方案:因黑线的弧度不一,较小较大的转弯弧度都会对小车循线产生影响,一时难

以增加更多的传感器,只能逐段测试速度差,调整不同传感器接收信号时的转弯弧度.

问题７:引脚不足.

解决方案:使用 ArduinoUNO 开发板,进行了前两个模块的设计与实验.但进入第三

部分时,因为本电路要求较多的 PWM 引脚,并且四轮小车的直流电机驱动所需引脚数较

多,ArduinoUNO 开发板的引脚数量明显不足,更换为 Arduino MEGA 开发板后,问题得

以解决.

问题８:ArduinoUNO 开发板的０、

１引脚不能同 TX、RX 引脚同时使用.

解决方案:因引脚不足,原本打算使用０、１引脚接入非使能端,但后来的实验中发现, 当 TX、RX 引脚接入蓝牙以后,０、１引脚的信号则不再被接收.这两部分引脚在扩展板上

是两个部分,但在原开发板上为相同的引脚,故不可同时使用,改用 Arduino MEGA 开发板

后,问题得以解决.

问题９:改用 ArduinoMEGA 开发板以后小车不动.

解决方案:因引脚问题改用了 ArduinoMEGA 开发板,但实验时发现小车不动.经检

查,发现 Arduino MEGA 开发板的引脚皆为 PWM 引脚,但依旧沿用了原代码使用数字写

入信号,故小车无法行进.

问题１０:与前两部分的代码融合后,发现小车仅接收一次功能指令,无法实现功能间的

切换.

解决方案:因融合了三个功能的代码,所以需要自由遥控选择功能.实验时,小车仅接

收开机后第一次的功能选择,后续不再接收.更改代码后,跳出思维循环,将原本利用函数

跳出循环改为通过更改数值,使其不符合 while循环的条件,从而跳出循环.

问题１１:缺少库文件.

解决方案:测速模块需要使用 MsTimer２．h 头文件,然而计算机显示缺少对应的库

文件,经仔细搜寻,从网上下载对应库文件并将其复制到相应的位置后问题得以解决.

问题１２:蓝牙传输char型字符,接收端无法收到数字.

解决方案:经查询资料后发现,可用 Serial．parseInt()函数识别数字.

问题１３:测速代码不能正确地被执行.

解决方案:利用中断函数,实现１s计时,测速模块的引脚只能接２、

３引脚.

[]{#index_split_003.html#p218}![index-218_1.png](https://i.imgur.com/YlGi1tM.jpeg){.calibre2}

２０７

６．

６　元件清单

完成本项目所用到的元件及数量如表６Ｇ１所示.

表６Ｇ１　智能遥控小车元件清单

模　　块

元件/测试仪表

数量

导线

若干

杜邦线

若干

直流电机驱动 L２９８N

２个

基础模块

直流电机

４个

３．

７V 可充电电池

２个

ArduinoMEGA 开发板

１个

两节电池电源盒

１个

超声波探测传感器

１个

红外线循迹

１个

舵机

１个

功能部分

扩展板

１个

四路循迹传感器

１个

蓝牙模块

１个

双路测速模块

１个

亚克力板

１个

外观部分

螺钉

６个

车轮

４个

[]{#index_split_003.html#p219}![index-219_1.png](https://i.imgur.com/VSTcVDP.jpeg){.calibre2}

第７章

电机合奏团项目设计

[]{#index_split_004.html}

７．

１　项目背景

２０世纪６０年代以来,随着电力电子技术的发展,半导体交流技术---------交流调速系统得

以实现.尤其是７０年代以来,大规模集成电路和计算机控制技术的发展,为交流电力拖动

的广泛应用创造了有利条件.例如交流电动机的串级调速、各种类型的变频调速、无换向器

电动机调速等,使得交流电力拖动逐步具备了调速范围宽、稳态精度高、动态响应快以及在

四象限做可逆运行等良好的技术性能,在调速性能方面完全可与直流电力拖动媲美.基于

此,本项目利用直流电机能够发声的功能,使声音可控,把不规则噪音变为可控的声音,从而

播放出一定音域范围的音乐.

７．

２　创新描述

将 MIDI类型的音乐文件转化为串口数据,经 Arduino开发板输出相应的调速脉冲,控

制步进电机以该音符的频率转动.对不同的音轨 Arduino芯片做不同处理,使得不同的步

进电机能够以不同音轨在同一时间合奏,形成更好的播放效果.

７．

３　功能及总体设计

本项目主要分为三部分进行设计:由计算机软件实现音乐信号的通道控制与播放到串

口部分,由 Arduino开发板实现串口数据的读取与处理部分和步进电机驱动器接收调速脉

冲控制直流电机转动部分.

本章根据张昊宸、郭聚川项目设计整理而成.

[]{#index_split_004.html#p220}![index-220_1.png](https://i.imgur.com/QC81U0r.jpeg){.calibre2}

![index-220_2.png](https://i.imgur.com/i6IcKlc.jpeg){.calibre2}

２０９

７．

３．

１　功能介绍

使用能够对不同音轨进行处理的音乐软件,设置好需要播放的通道进行播放,就能听到

步进电机传出具有机械质感的音乐声.

７．

３．

２　总体设计

要实现上述功能需要将作品分成三部分进行设计:计算机软件控制部分、处理部分和

输出部分.软件控制部分采用计算机上的音乐处理软件sonar以及 MIDI转串口系列的软

件,保证 MIDI信号正常输出到串口;处理部分用一个 FT２３２(USB转 TTL)元件使串口数

据输入４个 ArduinoProMini中;输出部分用四组步进电机驱动器分别按照接收到的信号

输出使电机转动.

１．整体框架图

项目整体框架如图７Ｇ１所示.

图７Ｇ１　整体框架图

２．系统流程图

系统流程图如图７Ｇ２所示.

本流程图仅显示对于单个接收数据的判断,即对于某一个接收到的十六进制数判断其

是否为音轨信号.若是,则先判断是否为本通道,通道判断之后,再根据音符接收态和播放

态先接收音符再播放音符.对于一首乐曲,音符播放完后整个流程重新开始,直到所有音符

播放完毕才结束.

[]{#index_split_004.html#p221}![index-221_1.png](https://i.imgur.com/Iyd1XO7.jpeg){.calibre2}

![index-221_2.png](https://i.imgur.com/H7284OY.jpeg){.calibre2}

２１０

图７Ｇ２　系统流程图

３．总电路图

系统总电路如图７Ｇ３所示;元件的连接如表７Ｇ１所示.

表７Ｇ１　各元件线路连接表

连 接 元 件

说　　明

VCC接 VCC

FT２３２ 与 Arduino Pro Mini的

RXI接 TXO

引脚连接

TXO 接 RXI

GND 接 GND

直 流 电 机 驱 动 与 Arduino Pro

输出引脚６与 PUL＋连接

Mini的连接

[]{#index_split_004.html#p222}![index-222_1.png](https://i.imgur.com/eAS1zBc.jpeg){.calibre2}

![index-222_2.png](https://i.imgur.com/GWMVYO5.jpeg){.calibre2}

２１１

续表

连 接 元 件

说　　明

A＋接 A,A－接 C

直流电机驱动与直流电机的连接

B＋接 B,B－接 D

ArduinoProMini开发板所有 RXI连在一起

ArduinoProMini开发板所有 VCC连在一起

其他连接

直流电机驱动 PUL－与电源负极相连

驱动板的 GND 连接电源负极

直流电机驱动 VCC端接电源正极

图７Ｇ３　总电路

７．

３．

３　模块介绍

本项目主要包括软件输入模块、数据传输处理模块和音频播放模块.其中,软件输入模

块采用计算机软件实现,不需要实际搭建电路.因此,本部分只介绍数据传输处理模块和音

频播放模块.

１．数据传输处理模块

数据传输处理模块的电路 连 接 如 图 ７Ｇ４所示.计算机通过右侧的 FT２３２接收串口数

据,导入 Arduino开发板,然后 Arduino开发板开始处理数据.引脚接法:４个 ArduinoPro Mini开发板的 RX 端、VCC引脚和 GND 引脚分别连接在一起(即同名引脚相互连接);最

外侧(即最右侧)VCC接 FT２３２VCC３．

３V 的输出,GND 相连,RX 接 TX,TX 接 RX,即所

[]{#index_split_004.html#p223}![index-223_1.png](https://i.imgur.com/V5th6pw.jpeg){.calibre2}

![index-223_2.png](https://i.imgur.com/OEFa3I1.jpeg){.calibre2}

![index-223_3.png](https://i.imgur.com/9YowwJ2.jpeg){.calibre2}

![index-223_4.png](https://i.imgur.com/pEbLrxk.jpeg){.calibre2}

![index-223_5.png](https://i.imgur.com/edxoaF0.jpeg){.calibre2}

２１２

有 VCC来自 FT２３２输出的３．

３V,所有 GND 最后引出共同接地,

４个 ArduinoProMini开

发板 RX 引脚全都接收来自 FT２３２TX 的信号.

图７Ｇ４　数据传输处理模块的电路连接

２．音频播放模块

１)功能介绍

音频播 放 模 块 电 路 如 图 ７Ｇ５ 所 示.４ 个 步 进 电 机 驱 动 器 的 PUL＋ 分 别 连 接 ４ 个

ArduinoProMini开发板的６号引脚;驱动器的 GND 和 PUL－共８个引脚相互连接并接

地;４个 VCC相互连接并外接９V 以上电源,

４个步进电机分别接４个驱动器的 A＋、A－、

B＋和 B－.

图７Ｇ５　音频播放模块

２)相关代码

ArduinoProMini１

＃include avr pgmspace敭h

定义引脚

＃definestatusLed１３

定义LED引脚为１３

＃definetonePin６

将输出引脚定义为６

为使步进电机播放单通道 将其定为假.若定为真则播放全通道

＃definerespondAllChannelsfalse

[]{#index_split_004.html#p224}![index-224_1.png](https://i.imgur.com/lwCA62w.jpeg){.calibre2}

２１３

MIDI代码的内部指令 定义播放中的不同状态

＃defineMIDI_CMD_NOTE_OFF０x８０

音符关闭指令 即停止播放

＃defineMIDI_CMD_NOTE_ON０x９０

音符打开指令 即开始播放或继续播放

＃defineMIDI_CMD_KEY_PRESSURE０xA０

按下指令或压力变化指令

＃defineMIDI_CMD_CONTROLLER_CHANGE０xB０ 控制变化信息

＃defineMIDI_CMD_PROGRAM_CHANGE０xC０

程序变化信息 音色改变

＃defineMIDI_CMD_CHANNEL_PRESSURE０xD０

通道压力信息 即音调变化

＃defineMIDI_CMD_PITCH_BEND０xE０

音调变化信息

＃defineMIDI_CMD_SYSEX０xF０

系统专用信息 防止所有通道被调用

定义空变量 代表希望忽略的或回到初始化的状态

＃defineMIDI_IGNORE０x００

MIDI接收态的定义.０x００为接收态１ 负责判断开关指令

０x０１为接收态２ 负责播放

＃defineMIDI_STATE_BYTE１０x００

＃defineMIDI_STATE_BYTE２０x０１

MIDI信号的音符对应频率的数组 实际上数组中的数值并不太准确 只保留到整数 但基本代表了

－１阶C到９阶G的１２８个音符

constuint１６_tfrequency １２８ PROGMEM＝ ８ ９ ９ １０ １０ １１ １２ １２ １３ １４ １５ １５ １６ １７

１８ １９ ２１ ２２ ２３ ２４ ２６ ２８ ２９ ３１ ３３ ３５ ３７ ３９ ４１ ４４ ４６ ４９ ５２ ５５ ５８ ６２ ６５ ６９

７３ ７８ ８２ ８７ ９２ ９８ １０４ １１０ １１７ １２３ １３１ １３９ １４７ １５６ １６５ １７５ １８５ １９６ ２０８ ２２０

２３３ ２４７ ２６２ ２７７ ２９４ ３１１ ３３０ ３４９ ３７０ ３９２ ４１５ ４４０ ４６６ ４９４ ５２３ ５５４ ５８７ ６２２ ６５９

６９８ ７４０ ７８４ ８３１ ８８０ ９３２ ９８８ １０４７ １１０９ １１７５ １２４５ １３１９ １３９７ １４８０ １５６８ １６６１

１７６０ １８６５ １９７６ ２０９３ ２２１７ ２３４９ ２４８９ ２６３７ ２７９４ ２９６０ ３１３６ ３３２２ ３５２０ ３７２９ ３９５１

４１８６ ４４３５ ４６９９ ４９７８ ５２７４ ５５８８ ５９２０ ５９２０ ６６４５ ７０４０ ７４５９ ７９０２ ８３７２ ８８７０ ９３９７

９９５６ １０５４８ １１１７５ １１８４０ １２５４４

setup 设置输出引脚和３８４００波特率

voidsetup

pinMode statusLed

OUTPUT

pinMode tonePin

OUTPUT

Serial敭

begin ３８４００

digitalWrite statusLed

HIGH

loop 正式程序 判断音符并使用tone函数播放相应频率

voidloop

staticbytenote

定义音符指令

staticbytelastCommand ＝ MIDI_IGNORE

初始化定义内部指令为空

staticbytestate

定义状态变量

staticbytelastByte

定义上一个音符指令

while Serial敭

available

读取收到的MIDI十六进制数代码

byteincomingByte ＝ Serial敭

read

条件判断

第一个条件判断是否为通道代码 若是 则判定通道是否为本芯片应该读取的通道

if incomingByte&０b１０００００００

判断是否是通道代码

[]{#index_split_004.html#p225}![index-225_1.png](https://i.imgur.com/p4an8tY.jpeg){.calibre2}

２１４

if respondAllChannels\|\| incomingByte&０x０F ＝＝ ０x００ 判断是否为本通道

lastCommand ＝ incomingByte&０xF０

更改指令准备接收信号

else

lastCommand ＝ MIDI_IGNORE

并非本通道则指令为空

state＝ MIDI_STATE_BYTE１

调整至接收态

第二个条件判断是否处于接收态１ 然后判断指令.指令为音符关则停止播放 若为音符开 则接收

音符等待调用至下一接收态播放

elseif state＝＝ MIDI_STATE_BYTE１

判断是否为接收态 若是 在判断后调整为播放态

if lastCommand＝＝MIDI_CMD_NOTE_OFF 若指令通道关 则停止播放

if note＝＝ incomingByte noTone tonePin state ＝ MIDI_STATE_BYTE２

elseif lastCommand＝＝ MIDI_CMD_NOTE_ON 若指令通道开 则将音符暂时存储

lastByte＝incomingByte

state ＝ MIDI_STATE_BYTE２

第三个条件判断是否处于接收态２.判断为音符开则使用tone函数输出对应音符的调速脉冲

else

if lastCommand＝＝ MIDI_CMD_NOTE_ON 若指令通道开且有有效音符则播放

if incomingByte

＝ ０

note ＝ lastByte

tone tonePin

unsignedint pgm_read_word &frequency note elseif note＝＝ lastByte

如果指令并非开 则停止播放

noTone tonePin

state＝ MIDI_STATE_BYTE１

再调回接收态

[]{#index_split_004.html#p226}![index-226_1.png](https://i.imgur.com/xBrrRNp.jpeg){.calibre2}

![index-226_2.png](https://i.imgur.com/xUoml5g.jpeg){.calibre2}

![index-226_3.png](https://i.imgur.com/aIvWxLX.jpeg){.calibre2}

２１５

ArduinoProMini２

＃include avr pgmspace敭h

定义引脚

＃definestatusLed１３

定义LED引脚为１３

＃definetonePin６

将输出引脚定义为６

为使步进电机播放单通道 将其定为假.若定为真则播放全通道

＃definerespondAllChannelsfalse

MIDI代码的内部指令 定义播放中的不同状态

＃defineMIDI_CMD_NOTE_OFF０x８０

音符关闭指令 即停止播放

＃defineMIDI_CMD_NOTE_ON０x９０

音符打开指令 即开始播放或继续播放

＃defineMIDI_CMD_KEY_PRESSURE０xA０

按下指令或压力变化指令

＃defineMIDI_CMD_CONTROLLER_CHANGE０xB０ 控制变化信息

＃defineMIDI_CMD_PROGRAM_CHANGE０xC０

程序变化信息 音色改变

＃defineMIDI_CMD_CHANNEL_PRESSURE０xD０

通道压力信息 即音调变化

＃defineMIDI_CMD_PITCH_BEND０xE０

音调变化信息

＃defineMIDI_CMD_SYSEX０xF０

系统专用信息 防止所有通道被调用

定义空变量 代表希望忽略的或回到初始化的状态

＃defineMIDI_IGNORE０x００

MIDI接收态的定义.０x００为接收态１ 负责判断开关指令

０x０１为接收态２ 负责播放

＃defineMIDI_STATE_BYTE１０x００

＃defineMIDI_STATE_BYTE２０x０１

MIDI信号的音符对应频率的数组 实际上数组中的数值并不太准确 只保留到整数 但基本代表了

－１阶C到９阶G的１２８个音符

constuint１６_tfrequency １２８ PROGMEM＝ ８ ９ ９ １０ １０ １１ １２ １２ １３ １４ １５ １５ １６ １７

１８ １９ ２１ ２２ ２３ ２４ ２６ ２８ ２９ ３１ ３３ ３５ ３７ ３９ ４１ ４４ ４６ ４９ ５２ ５５ ５８ ６２ ６５ ６９

７３ ７８ ８２ ８７ ９２ ９８ １０４ １１０ １１７ １２３ １３１ １３９ １４７ １５６ １６５ １７５ １８５ １９６ ２０８ ２２０

２３３ ２４７ ２６２ ２７７ ２９４ ３１１ ３３０ ３４９ ３７０ ３９２ ４１５ ４４０ ４６６ ４９４ ５２３ ５５４ ５８７ ６２２ ６５９

６９８ ７４０ ７８４ ８３１ ８８０ ９３２ ９８８ １０４７ １１０９ １１７５ １２４５ １３１９ １３９７ １４８０ １５６８ １６６１

１７６０ １８６５ １９７６ ２０９３ ２２１７ ２３４９ ２４８９ ２６３７ ２７９４ ２９６０ ３１３６ ３３２２ ３５２０ ３７２９ ３９５１

４１８６ ４４３５ ４６９９ ４９７８ ５２７４ ５５８８ ５９２０ ５９２０ ６６４５ ７０４０ ７４５９ ７９０２ ８３７２ ８８７０ ９３９７

９９５６ １０５４８ １１１７５ １１８４０ １２５４４

setup 设置输出引脚和３８４００波特率

voidsetup

pinMode statusLed

OUTPUT

pinMode tonePin

OUTPUT

Serial敭

begin ３８４００

digitalWrite statusLed

HIGH

loop 正式程序 判断音符并使用tone函数播放相应频率

voidloop

staticbytenote

定义音符指令

staticbytelastCommand ＝ MIDI_IGNORE

初始化定义内部指令为空

[]{#index_split_004.html#p227}![index-227_1.png](https://i.imgur.com/GqANeuB.jpeg){.calibre2}

２１６

staticbytestate

定义状态变量

staticbytelastByte

定义上一个音符指令

while Serial敭

available

读取收到的MIDI十六进制数代码

byteincomingByte ＝ Serial敭

read

条件判断

第一个条件判断是否为通道代码 若是则判定通道是否为本芯片应该读取的通道

if incomingByte&０b１０００００００

判断是否是通道代码

if respondAllChannels\|\| incomingByte&０x０F ＝＝０x０１ 　 判断是否为本通道

lastCommand ＝ incomingByte&０xF０

更改指令准备接收信号

else

lastCommand ＝ MIDI_IGNORE

并非本通道则指令为空

state＝ MIDI_STATE_BYTE１

调整至接收态

第二个条件判断是否处于接收态１ 然后判断指令.指令为音符关则停止播放 若为音符开 则接收

音符等待调用至下一接收态播放

elseif state＝＝ MIDI_STATE_BYTE１

判断是否为接收态 若是 在判断后调整为播放态

if lastCommand＝＝MIDI_CMD_NOTE_OFF 若指令通道关 则停止播放

if note＝＝ incomingByte noTone tonePin state ＝ MIDI_STATE_BYTE２

elseif lastCommand＝＝ MIDI_CMD_NOTE_ON 若指令通道开 则将音符暂时存储

lastByte＝incomingByte

state ＝ MIDI_STATE_BYTE２

第三个条件判断是否处于接收态２.判断为音符开则使用tone函数输出对应音符的调速脉冲

else

if lastCommand＝＝ MIDI_CMD_NOTE_ON 若指令通道开且有有效音符 则播放

if incomingByte

＝ ０

note ＝ lastByte

tone tonePin

unsignedint pgm_read_word &frequency note

[]{#index_split_004.html#p228}![index-228_1.png](https://i.imgur.com/RYKnuti.jpeg){.calibre2}

![index-228_2.png](https://i.imgur.com/dLFc3sw.jpeg){.calibre2}

２１７

elseif note＝＝ lastByte

如果指令并非开 则停止播放

noTone tonePin

state＝ MIDI_STATE_BYTE１

再调回接收态

ArduinoProMini开发板３和 ArduinoProMini开发板４的相关代码与以上类似,不

再列出.

７．

４　产品展示

产品整体外观如图７Ｇ６所示.图片左方是４个步进电机驱动器;中间是用面包板搭建

的 ArduinoProMini开发板的核心电路,上方的线是引出 FT２３２接口,便于对外连接;最

右侧是４个步进电机,负责发声.为了使电路简洁易于检查,步进电机驱动器和步进电机的

连线跨过面包板,步进电机不直接与面包板接线.

图７Ｇ６　整体外观图

[]{#index_split_004.html#p229}![index-229_1.png](https://i.imgur.com/o73xdze.jpeg){.calibre2}

２１８

７．

５　故障及问题分析

问题１:Arduino开发板无法直接控制直流电机.

解决方案:决定使用直流电机驱动,考虑直流电机可能振动过大,采用具有细分电流功

能的驱动器以减小其振动.经测试,与直流电机转动频率有关的驱动引线只有 PUL＋,最

终设置输出为一个引脚.

问题２:使用 ArduinoProMini开发板无法直接从计算机 USB接收数据.

解决方案:经查阅资料,使用 USB转串口工具---------FT２３２模块进行程序烧录和串口数

据接收.

问题３:使用一个开发板很难同时控制４个音轨对应的４个直流电机.

解决方案:使用４片 ArduinoPro Mini开发板分别控制直流电机,只要将 RX 引脚都

连接在一起,从一个 ArduinoProMini开发板的 RX 引脚接收数据而使４个开发板可同时

接收到,并通过内置不同开发板的代码进行不同音轨的分辨和操作.

问题４:最初发出的声音很嘈杂而且有延时.

解决方案:一开始考虑 MIDI代码的固定传输波特率为３１２５０,担心用其他波特率会造

成音节丢失,而 Arduino开发板以及使用串口工具的波特率都为某值的固定倍数,恰好没有

３１２５０.因此,开始使用不同的波特率进行通信毫无效果.后来,将代码中的波特率 改 为

３８４００使 MIDI以３８４００波特率传输,问题得以解决.

问题５:直流电机声音不优美,并且声音极小.

解决方案:采用纸箱盛装电路或者用一些共振好的材质,达到类似乐器共鸣的效果,提

高了音质与音量.

７．

６　元件清单

完成本项目所用到的元件及数量如表７Ｇ２所示.

表７Ｇ２　电机合奏团元件清单

模　　块

元件/测试仪表

数量

导线

若干

杜邦线

若干

步进电机驱动器

４个

两相四线步进电机

４个

音频播放模块　　

１２V 开关电源

１个

电源线

１个

绑带

若干

万用表

１个

[]{#index_split_004.html#p230}![index-230_1.png](https://i.imgur.com/7krVrwp.jpeg){.calibre2}

２１９

续表

模　　块

元件/测试仪表

数量

导线

若干

杜邦线

若干

ArduinoProMini开发板

４个

数据传输处理模块

面包板

１个

FT２３２

１个

排针

若干

外观部分　　　　

纸箱

１个

[]{#index_split_004.html#p231}![index-231_1.png](https://i.imgur.com/bFN1X8o.jpeg){.calibre2}

第８章

教学电子琴项目设计

８．

１　项目背景

本项目设计一款教学电子琴,根据指示灯亮灭触摸相应的按键并且发出音调,以达到教

学的目的.

８．

２　创新描述

教学电子琴不仅包括自由弹奏模式,还实现了音乐播放和教学的功能,能满足不同人群

的不同需求.本项目成本较低,仅使用 Arduino开发板、面包板、LED、杜邦线及若干导线就

完成了相应的功能,简单实用,并且不会出现某些硬件的灵敏性随时间降低的问题,理论上

使用期限较长.

８．

３　功能及总体设计

本作品主要分三部分进行设计:乐谱输入部分、指示灯亮灭部分和音调输出部分.乐

谱输入部分的主要功能是将一首歌曲转化为相应的数组;指示灯部分的主要功能是使 LED

按着相应的节奏和音调亮灭;音调输出部分即扬声器构成的发生器,其主要功能是根据使

用者触摸按键发出相应音调的声音.

８．

３．

１　功能介绍

本作品主要有三个功能:音乐播放,将歌曲对应的数组粘贴到代码内部,并将相应控制

引脚连接至高电平,复位后即可实现音乐播放的功能;自由弹奏,将相应的引脚连接至高电

平,复位后即可实现自由弹奏的功能;教学模式,将两个控制引脚都接至低电平,复位后即

本章根据黄静、张研项目设计整理而成.

[]{#index_split_004.html#p232}![index-232_1.png](https://i.imgur.com/O0ZEh2P.jpeg){.calibre2}

![index-232_2.png](https://i.imgur.com/SlDO8ve.jpeg){.calibre2}

![index-232_3.png](https://i.imgur.com/HdRsMeS.jpeg){.calibre2}

２２１

可根据 LED 的亮灭去触摸相应频率的按键.

８．

３．

２　总体设计

１．整体框架图

整体框架如图８Ｇ１所示.

图８Ｇ１　整体框架图

２．系统流程图

系统流程图如图８Ｇ２所示.

图８Ｇ２　系统流程图

３．总电路图

系统总电路如图８Ｇ３所示.

如图８Ｇ３所示,引脚１３连接扬声器正极;引脚２\~１２、引脚１４\~２２和引脚２４分别连接

２１个 LED 的正极;引脚３０\~５０由公共线接出并悬空,引脚２５和引脚２３分别连接５V 电

压和接地.

[]{#index_split_004.html#p233}![index-233_1.png](https://i.imgur.com/zXIS4zR.jpeg){.calibre2}

![index-233_2.png](https://i.imgur.com/w9XldLF.jpeg){.calibre2}

２２２

图８Ｇ３　总电路图

８．

３．

３　模块介绍

本项目主要包括乐谱输入模块、LED 点亮模块、音调输出模块和功能选择模块.下面

分别介绍各模块的功能、元件、电路图和相关代码.

１．乐谱输入模块

１)功能介绍

采用直接输入代码的办法实现音符的输入.根据简谱列出节拍和频率,并写成一个数

组,之后使用循环调用.

２)相关代码

定义一个数组tune 存储歌曲 月亮代表我的心 的乐谱音阶相应的频率值

inttune ＝

NTDL５

NTD１

NTD３

NTD５

NTD１

NTDL７

NTD３

NTD５ NTD５

NTD６

NTD７

NTDH１

NTD６

NTD６

NTD５

NTD５

NTD３

NTD２

NTD１

NTD１

NTD１

NTD３

NTD２

NTD１

NTD１

NTD１

NTD２

NTD３

NTD２

NTDL６

NTDL７

NTD１

NTD２

NTD１

NTD３

NTD５

NTD３

NTD２

NTD１

NTD５

NTDL７

NTDL６

NTDL７

NTDL６

NTDL７

NTDL６

NTDL５

NTD３

NTD５

NTD３

NTD２

NTD１

NTD５

NTDL７

NTDL６

NTDL７

NTD１

NTD１

NTD１

NTD２

NTD３

NTD２

NTDL５

NTD１

NTD３

NTD５

NTD１

NTDL７

NTD３

NTD５

NTD５

NTD６

NTD７

NTDH１

NTD６

NTD６

NTD５

NTD３

NTD２

NTD１

NTD１

NTD１

NTD３

NTD２

NTD１

NTD１

NTD１

NTD２

NTD３

NTD２

NTDL６

NTDL７

NTD１

NTD２

NTD１

[]{#index_split_004.html#p234}![index-234_1.png](https://i.imgur.com/g3tMC9K.jpeg){.calibre2}

![index-234_2.png](https://i.imgur.com/mrqD84X.jpeg){.calibre2}

２２３

定义一个数组durt 修改音阶相应的持续时间 即一拍、半拍

其中

１＋１＋１为三拍

１＋０敭

５为一拍半

floatdurt ＝

０敭

５

１＋０敭

５

０敭

５ １＋０敭

５

０敭

５ １＋０敭

５

０敭

５

１

０敭

５

０敭

５

１

１＋０敭

５

０敭

５

０敭

５

０敭

５

１＋１＋１

０敭

５

０敭

５

１＋０敭

５

０敭

５

１

０敭

５

０敭

５

１＋０敭

５

０敭

５

１

０敭

５

０敭

５

１＋０敭

５

０敭

５

１

０敭

５

０敭

５

１＋１＋１

０敭

５

０敭

５

１＋０敭

５

０敭

５

１

１

１＋１＋１

０敭

５

０敭

５

１＋０敭

５

０敭

５

１

１

１＋１＋１

１

１＋０敭

５

０敭

５

１

１

１＋１＋１

０敭

５

０敭

５

１＋０敭

５

０敭

５

１

０敭

５

０敭

５

１＋１＋１

０敭

５

１＋０敭

５

０敭

５

１＋０敭

５

０敭

５

１＋０敭

５

０敭

５

１＋０敭

５

０敭

５

１＋０敭

５

０敭

５

１＋０敭

５

０敭

５

０敭

５

０敭

５

０敭

５

０敭

５

１＋０敭

５

０敭

５

１

０敭

５

０敭

５

１＋０敭

５

０敭

５

１

０敭

５

０敭

５

１＋０敭

５

０敭

５

１

０敭

５

０敭

５

１＋１＋１

２．LED 点亮模块

１)功能介绍

LED 可根据音阶数组按相应的节奏和顺序亮灭.

２)相关代码

voidteach

教学函数

for intx＝０

x length

x++

if tune x ＝＝NTDL１

满足条件则让音阶对应的LED亮

ledp＝１２

digitalWrite ledp HIGH

delay wait

在延迟时间wait内去触摸按键 执行该发声函数

play

delay dura∗durt x

digitalWrite ledp LOW

elseif tune x ＝＝NTDL２

ledp＝１１

digitalWrite ledp HIGH

[]{#index_split_004.html#p235}![index-235_1.png](https://i.imgur.com/HGAVgz5.jpeg){.calibre2}

２２４

delay wait

play

delay dura∗durt x

digitalWrite ledp LOW

此处省略其他１８个elseif语句

elseif tune x ＝＝NTDH７

intledp＝２４

digitalWrite ledp HIGH

delay wait

play

delay dura∗durt x

digitalWrite ledp LOW

３．音调输出模块

１)功能介绍

实现触摸按键,发出该按键相应音调的声音.

２)相关代码

voidplay

弹奏函数 即发声函数

digitalWrite speaker

LOW

读这２１个引脚的电容值

capval１ ＝ readCapacitivePin ３０

capval２ ＝ readCapacitivePin ３１

capval３ ＝ readCapacitivePin ３２

capval４ ＝ readCapacitivePin ３３

capval５ ＝ readCapacitivePin ３４

capval６ ＝ readCapacitivePin ３５

capval７ ＝ readCapacitivePin ３６

capval８ ＝ readCapacitivePin ３７

capval９ ＝ readCapacitivePin ３８

capval１０ ＝ readCapacitivePin ３９

capval１１ ＝ readCapacitivePin ４０

capval１２ ＝ readCapacitivePin ４１

capval１４ ＝ readCapacitivePin ４２

capval１５ ＝ readCapacitivePin ４３

capval１６ ＝ readCapacitivePin ４４

capval１７ ＝ readCapacitivePin ４５

[]{#index_split_004.html#p236}![index-236_1.png](https://i.imgur.com/lSrAYyR.jpeg){.calibre2}

![index-236_2.png](https://i.imgur.com/7enaDK7.jpeg){.calibre2}

![index-236_3.png](https://i.imgur.com/uIfR04V.jpeg){.calibre2}

![index-236_4.png](https://i.imgur.com/ol89QjE.jpeg){.calibre2}

２２５

capval１８ ＝ readCapacitivePin ４６

capval１９ ＝ readCapacitivePin ４７

capval２０ ＝ readCapacitivePin ４８

capval２１ ＝ readCapacitivePin ４９

capval２２ ＝ readCapacitivePin ５０

当某引脚电容值大于２时 扬声器发出该引脚对应的音阶

if capval１ ２

tone speaker

２６２

dura_tone

if capval２ ２

tone speaker

２９４

dura_tone

此处省略其他１８个if语句

if capval２２ ２

tone speaker

１９７６

dura_tone

uint８_treadCapacitivePin intpinToMeasure 变量用于从ArduinoAVR转换到引脚

volatileuint８_t∗ port

将Arduino上的输入引脚号码转换为AVR、

PIN、

DDR

volatileuint８_t∗ ddr

volatileuint８_t∗ pin

bytebitmask

port ＝ portOutputRegister digitalPinToPort pinToMeasure ddr ＝ portModeRegister digitalPinToPort pinToMeasure bitmask ＝ digitalPinToBitMask pinToMeasure pin ＝ portInputRegister digitalPinToPort pinToMeasure 设置该引脚为低电平

∗port&＝ \~ bitmask

∗ddr\|＝ bitmask

delay １

使引脚作为内部上拉输入

∗ddr&＝ \~ bitmask

∗port\|＝ bitmask

减少每次读取引脚的周期数 提高灵敏度

uint８_tcycles ＝ １７

if ∗pin&bitmask cycles＝ ０

elseif ∗pin&bitmask cycles＝ １

elseif ∗pin&bitmask cycles＝ ２

此处省略１８个elseif语句

elseif ∗pin&bitmask cycles＝ １６

[]{#index_split_004.html#p237}![index-237_1.png](https://i.imgur.com/8oUEA6y.jpeg){.calibre2}

２２６

触摸传感器时 会在之间传递电荷 从而改变电容值

∗port&＝ \~ bitmask

∗ddr\|＝ bitmask

returncycles

４．功能选择模块

１)功能介绍

实现自由弹奏模式、播放音乐模式和教学模式的切换.

２)相关代码

voidloop

循环判定条件

intbuttonstateA＝digitalRead Abutton

intbuttonstateB＝digitalRead Bbutton

if buttonstateA＝＝HIGH

当buttonstateA为高电平 实现自动播放功能

broadcast

elseif buttonstateB＝＝HIGH

当buttonstateB为高电平 实现自由弹奏功能

dura_tone＝２０

play

Else

否则 实现教学功能

teach

５．主程序模块

intspeaker＝ １３

定义引脚１３为扬声器

定义２１个电容值

intcapval１

intcapval２

intcapval３

intcapval４

intcapval５

intcapval６

intcapval７

intcapval８

intcapval９

[]{#index_split_004.html#p238}![index-238_1.png](https://i.imgur.com/ogkva06.jpeg){.calibre2}

２２７

intcapval１０

intcapval１１

intcapval１２

intcapval１４

intcapval１５

intcapval１６

intcapval１７

intcapval１８

intcapval１９

intcapval２０

intcapval２１

intcapval２２

定义音调和相应的频率

＃defineNTD０ －１

＃defineNTD１２９４

＃defineNTD２３３０

＃defineNTD３３５０

＃defineNTD４３９３

＃defineNTD５４４１

＃defineNTD６４９５

＃defineNTD７５５６

＃defineNTDL１１４７

＃defineNTDL２１６５

＃defineNTDL３１７５

＃defineNTDL４１９６

＃defineNTDL５２２０

＃defineNTDL６２４７

＃defineNTDL７２６２

＃defineNTDH１５８９

＃defineNTDH２６６１

＃defineNTDH３７００

＃defineNTDH４７８６

＃defineNTDH５８８２

＃defineNTDH６９９０

＃defineNTDH７１１２０

＃defineWHOLE１

定义１为一拍

＃defineHALF０敭

５

定义０敭

５为半拍

＃defineQUARTER０敭

２５

定义０敭

２５为１ ４拍

＃defineEIGHTH０敭

２５

＃defineSIXTEENTH０敭

６２５

＃definedura６００

定义时间常量dura＝６００ms

＃definewait８００

定义灯亮后反应时间常量wait＝８００ms

[]{#index_split_004.html#p239}![index-239_1.png](https://i.imgur.com/BWU5Q76.jpeg){.calibre2}

２２８

定义一个数组tune 为歌曲 月亮代表我的心 的乐谱音阶相应的频率值

inttune ＝

NTDL５

NTD１

NTD３

NTD５

NTD１

NTDL７

NTD３

NTD５ NTD５

NTD６

NTD７

NTDH１

NTD６

NTD６

NTD５

NTD５

NTD３

NTD２

NTD１

NTD１

NTD１

NTD３

NTD２

NTD１

NTD１

NTD１

NTD２

NTD３

NTD２

NTDL６

NTDL７

NTD１

NTD２

NTD１

NTD３

NTD５

NTD３

NTD２

NTD１

NTD５

NTDL７

NTDL６

NTDL７

NTDL６

NTDL７

NTDL６

NTDL５

NTD３

NTD５

NTD３

NTD２

NTD１

NTD５

NTDL７

NTDL６

NTDL７

NTD１

NTD１

NTD１

NTD２

NTD３

NTD２

NTDL５

NTD１

NTD３

NTD５

NTD１

NTDL７

NTD３

NTD５

NTD５

NTD６

NTD７

NTDH１

NTD６

NTD６

NTD５

NTD３

NTD２

NTD１

NTD１

NTD１

NTD３

NTD２

NTD１

NTD１

NTD１

NTD２

NTD３

NTD２

NTDL６

NTDL７

NTD１

NTD２

NTD１

定义一个数组durt 修改音阶相应的持续时间 即一拍、半拍

其中

１＋１＋１为三拍

１＋０敭

５为一拍半

floatdurt ＝

０敭

５

１＋０敭

５

０敭

５ １＋０敭

５

０敭

５ １＋０敭

５

０敭

５

１

０敭

５

０敭

５

１

１＋０敭

５

０敭

５

０敭

５

０敭

５

１＋１＋１

０敭

５

０敭

５

１＋０敭

５

０敭

５

１

０敭

５

０敭

５

１＋０敭

５

０敭

５

１

０敭

５

０敭

５

１＋０敭

５

０敭

５

１

０敭

５

０敭

５

１＋１＋１

０敭

５

０敭

５

１＋０敭

５

０敭

５

１

１

１＋１＋１

０敭

５

０敭

５

１＋０敭

５

０敭

５

１

１

１＋１＋１

１

１＋０敭

５

０敭

５

１

１

１＋１＋１

０敭

５

０敭

５

１＋０敭

５

０敭

５

１

０敭

５

０敭

５

１＋１＋１

０敭

５

１＋０敭

５

０敭

５

１＋０敭

５

０敭

５

１＋０敭

５

０敭

５

１＋０敭

５

０敭

５

１＋０敭

５

０敭

５

１＋０敭

５

０敭

５

０敭

５

０敭

５

０敭

５

０敭

５

１＋０敭

５

０敭

５

１

０敭

５

０敭

５

１＋０敭

５

０敭

５

１

０敭

５

０敭

５

１＋０敭

５

０敭

５

１

０敭

５

０敭

５

１＋１＋１

intlength

定义数组长度

intledp

定义LED

intdura_tone＝１０００

定义时间常量dura_tone＝１０００ms

constintAbutton＝２３

定义引脚２３和引脚２５为两个功能选择引脚

constintBbutton＝２５

voidsetup

[]{#index_split_004.html#p240}![index-240_1.png](https://i.imgur.com/AV2DetL.jpeg){.calibre2}

２２９

pinMode ledp

OUTPUT

pinMode speaker OUTPUT

pinMode Abutton

INPUT

pinMode Bbutton

INPUT

length＝sizeof tune sizeof tune ０

voidloop

循环判定条件

intbuttonstateA＝digitalRead Abutton

intbuttonstateB＝digitalRead Bbutton

if buttonstateA＝＝HIGH

当buttonstateA为高电平 实现自动播放功能

broadcast

elseif buttonstateB＝＝HIGH

当buttonstateB为高电平 实现自由弹奏功能

dura_tone＝２０

play

Else

否则 实现教学功能

teach

voidplay

弹奏函数 即发声函数

digitalWrite speaker

LOW

读这２１个引脚的电容值

capval１ ＝ readCapacitivePin ３０

capval２ ＝ readCapacitivePin ３１

capval３ ＝ readCapacitivePin ３２

capval４ ＝ readCapacitivePin ３３

capval５ ＝ readCapacitivePin ３４

capval６ ＝ readCapacitivePin ３５

capval７ ＝ readCapacitivePin ３６

capval８ ＝ readCapacitivePin ３７

capval９ ＝ readCapacitivePin ３８

capval１０ ＝ readCapacitivePin ３９

capval１１ ＝ readCapacitivePin ４０

capval１２ ＝ readCapacitivePin ４１

capval１４ ＝ readCapacitivePin ４２

[]{#index_split_004.html#p241}![index-241_1.png](https://i.imgur.com/5RladrB.jpeg){.calibre2}

![index-241_2.png](https://i.imgur.com/pyAuJV2.jpeg){.calibre2}

![index-241_3.png](https://i.imgur.com/Jjqh0wv.jpeg){.calibre2}

![index-241_4.png](https://i.imgur.com/MZP6U0c.jpeg){.calibre2}

![index-241_5.png](https://i.imgur.com/xyB8bGn.jpeg){.calibre2}

![index-241_6.png](https://i.imgur.com/880FwQv.jpeg){.calibre2}

![index-241_7.png](https://i.imgur.com/ftrn7Mi.jpeg){.calibre2}

![index-241_8.png](https://i.imgur.com/SPQGnoD.jpeg){.calibre2}

![index-241_9.png](https://i.imgur.com/WTs0yOK.jpeg){.calibre2}

![index-241_10.png](https://i.imgur.com/DqS2BJ4.jpeg){.calibre2}

![index-241_11.png](https://i.imgur.com/4Q9IyM0.jpeg){.calibre2}

![index-241_12.png](https://i.imgur.com/Tb56al7.jpeg){.calibre2}

２３０

capval１５ ＝ readCapacitivePin ４３

capval１６ ＝ readCapacitivePin ４４

capval１７ ＝ readCapacitivePin ４５

capval１８ ＝ readCapacitivePin ４６

capval１９ ＝ readCapacitivePin ４７

capval２０ ＝ readCapacitivePin ４８

capval２１ ＝ readCapacitivePin ４９

capval２２ ＝ readCapacitivePin ５０

当某引脚电容值大于２时 扬声器发出该引脚对应的音阶

if capval１ ２

tone speaker

２６２

dura_tone

if capval２ ２

tone speaker

２９４

dura_tone

if capval３ ２

tone speaker

３３０

dura_tone

if capval４ ２

tone speaker

３５０

dura_tone

if capval５ ２

tone speaker

３９３

dura_tone

if capval６ ２

tone speaker

４４１

dura_tone

if capval７ ２

tone speaker

４９５

dura_tone

if capval８ ２

tone speaker

５２５

dura_tone

if capval９ ２

tone speaker

５８７

dura_tone

if capval１０ ２

tone speaker

６５９

dura_tone

if capval１１ ２

tone speaker

６９８

dura_tone

[]{#index_split_004.html#p242}![index-242_1.png](https://i.imgur.com/DvbxD3i.jpeg){.calibre2}

![index-242_2.png](https://i.imgur.com/X9dqg8F.jpeg){.calibre2}

![index-242_3.png](https://i.imgur.com/1esI1zz.jpeg){.calibre2}

![index-242_4.png](https://i.imgur.com/UKcIM5P.jpeg){.calibre2}

![index-242_5.png](https://i.imgur.com/NpKZKJo.jpeg){.calibre2}

![index-242_6.png](https://i.imgur.com/dVOTONW.jpeg){.calibre2}

![index-242_7.png](https://i.imgur.com/9PLsq0k.jpeg){.calibre2}

![index-242_8.png](https://i.imgur.com/pLqj9kG.jpeg){.calibre2}

![index-242_9.png](https://i.imgur.com/7rhgYOs.jpeg){.calibre2}

![index-242_10.png](https://i.imgur.com/26SAqct.jpeg){.calibre2}

![index-242_11.png](https://i.imgur.com/vXBrq29.jpeg){.calibre2}

２３１

if capval１２ ２

tone speaker

７８４

dura_tone

if capval１４ ２

tone speaker

８８０

dura_tone

if capval１５ ２

tone speaker

９８８

dura_tone

if capval１６ ２

tone speaker

１０４７

dura_tone

if capval１７ ２

tone speaker

１１７５

dura_tone

if capval１８ ２

tone speaker

１３１９

dura_tone

if capval１９ ２

tone speaker

１３９７

dura_tone

if capval２０ ２

tone speaker

１５６８

dura_tone

if capval２１ ２

tone speaker

１７６０

dura_tone

if capval２２ ２

tone speaker

１９７６

dura_tone

uint８_treadCapacitivePin intpinToMeasure volatileuint８_t∗ port

将Arduino开发板上的输入引脚号码转换为AVR、

PIN、

DDR

volatileuint８_t∗ ddr

volatileuint８_t∗ pin

bytebitmask

port ＝ portOutputRegister digitalPinToPort pinToMeasure ddr ＝ portModeRegister digitalPinToPort pinToMeasure bitmask ＝ digitalPinToBitMask pinToMeasure pin ＝ portInputRegister digitalPinToPort pinToMeasure 设置该引脚为低电平

[]{#index_split_004.html#p243}![index-243_1.png](https://i.imgur.com/KIw96kK.jpeg){.calibre2}

![index-243_2.png](https://i.imgur.com/NdwDcyi.jpeg){.calibre2}

２３２

∗port&＝ \~ bitmask

∗ddr\|＝ bitmask

delay １

使引脚作为内部上拉输入

∗ddr&＝ \~ bitmask

∗port\|＝ bitmask

减少每次读取引脚的周期数 提高灵敏度

uint８_tcycles ＝ １７

if ∗pin&bitmask cycles＝ ０

elseif ∗pin&bitmask cycles＝ １

elseif ∗pin&bitmask cycles＝ ２

elseif ∗pin&bitmask cycles＝ ３

elseif ∗pin&bitmask cycles＝ ４

elseif ∗pin&bitmask cycles＝ ５

elseif ∗pin&bitmask cycles＝ ６

elseif ∗pin&bitmask cycles＝ ７

elseif ∗pin&bitmask cycles＝ ８

elseif ∗pin&bitmask cycles＝ ９

elseif ∗pin&bitmask cycles＝ １０

elseif ∗pin&bitmask cycles＝ １１

elseif ∗pin&bitmask cycles＝ １２

elseif ∗pin&bitmask cycles＝ １３

elseif ∗pin&bitmask cycles＝ １４

elseif ∗pin&bitmask cycles＝ １５

elseif ∗pin&bitmask cycles＝ １６

触摸传感器时 会在之间传递电荷 从而改变电容值

∗port&＝ \~ bitmask

∗ddr\|＝ bitmask

returncycles

voidbroadcast

播放音乐的函数

for intx＝０ x length x++

循环音符的次数

tone speaker tune x

此函数依次播放tune序列里的数组 即每个音符

delay ４００∗durt x

每个音符持续的时间 即节拍duration ４００用于调整时间 该参数值越大 曲子速度越慢 越小曲

子速度越快

noTone speaker

停止当前音符 进入下一音符

delay ５０００

等待５s后 循环重新开始

[]{#index_split_004.html#p244}![index-244_1.png](https://i.imgur.com/PX2RHRO.jpeg){.calibre2}

![index-244_2.png](https://i.imgur.com/KLNPTq6.jpeg){.calibre2}

２３３

voidteach

教学函数

for intx＝０

x length

x++

if tune x ＝＝NTDL１

满足条件则让音阶对应的LED亮

ledp＝１２

digitalWrite ledp HIGH

delay wait

在延迟时间wait内去触摸按键 执行该发声函数

play

delay dura∗durt x

digitalWrite ledp LOW

elseif tune x ＝＝NTDL２

ledp＝１１

digitalWrite ledp HIGH

delay wait

play

delay dura∗durt x

digitalWrite ledp LOW

elseif tune x ＝＝NTDL３

intledp＝１０

digitalWrite ledp HIGH

delay wait

play

delay dura∗durt x

digitalWrite ledp LOW

elseif tune x ＝＝NTDL４

intledp＝９

digitalWrite ledp HIGH

delay wait

play

delay dura∗durt x

digitalWrite ledp LOW

elseif tune x ＝＝NTDL５

[]{#index_split_004.html#p245}![index-245_1.png](https://i.imgur.com/4hguOhs.jpeg){.calibre2}

２３４

intledp＝８

digitalWrite ledp HIGH

delay wait

play

delay dura∗durt x

digitalWrite ledp LOW

elseif tune x ＝＝NTDL６

intledp＝７

digitalWrite ledp HIGH

delay wait

play

delay dura∗durt x

digitalWrite ledp LOW

elseif tune x ＝＝NTDL７

intledp＝６

digitalWrite ledp HIGH

delay wait

play

delay dura∗durt x

digitalWrite ledp LOW

elseif tune x ＝＝NTD１

intledp＝５

digitalWrite ledp HIGH

delay wait

play

delay dura∗durt x

digitalWrite ledp LOW

elseif tune x ＝＝NTD２

intledp＝４

digitalWrite ledp HIGH

delay wait

play

delay dura∗durt x

digitalWrite ledp LOW

[]{#index_split_004.html#p246}![index-246_1.png](https://i.imgur.com/nZyPXCB.jpeg){.calibre2}

２３５

elseif tune x ＝＝NTD３

intledp＝３

digitalWrite ledp HIGH

delay wait

play

delay dura∗durt x

digitalWrite ledp LOW

elseif tune x ＝＝NTD４

intledp＝２

digitalWrite ledp HIGH

delay wait

play

delay dura∗durt x

digitalWrite ledp LOW

elseif tune x ＝＝NTD５

intledp＝１４

digitalWrite ledp HIGH

delay wait

play

delay dura∗durt x

digitalWrite ledp LOW

elseif tune x ＝＝NTD６

intledp＝１５

digitalWrite ledp HIGH

delay wait

play

delay dura∗durt x

digitalWrite ledp LOW

elseif tune x ＝＝NTD７

intledp＝１６

digitalWrite ledp HIGH

delay wait

play

[]{#index_split_004.html#p247}![index-247_1.png](https://i.imgur.com/v1Q6YAB.jpeg){.calibre2}

２３６

delay dura∗durt x

digitalWrite ledp LOW

elseif tune x ＝＝NTDH１

intledp＝１７

digitalWrite ledp HIGH

delay wait

play

delay dura∗durt x

digitalWrite ledp LOW

elseif tune x ＝＝NTDH２

intledp＝１８

digitalWrite ledp HIGH

delay wait

play

delay dura∗durt x

digitalWrite ledp LOW

elseif tune x ＝＝NTDH３

intledp＝１９

digitalWrite ledp HIGH

delay wait

play

delay dura∗durt x

digitalWrite ledp LOW

elseif tune x ＝＝NTDH４

intledp＝２０

digitalWrite ledp HIGH

delay wait

play

delay dura∗durt x

digitalWrite ledp LOW

elseif tune x ＝＝NTDH５

intledp＝２１

digitalWrite ledp HIGH

[]{#index_split_004.html#p248}![index-248_1.png](https://i.imgur.com/HmfRVnB.jpeg){.calibre2}

![index-248_2.png](https://i.imgur.com/avLPW7F.jpeg){.calibre2}

![index-248_3.png](https://i.imgur.com/LGme7Zh.jpeg){.calibre2}

２３７

delay wait

play

delay dura∗durt x

digitalWrite ledp LOW

elseif tune x ＝＝NTDH６

intledp＝２２

digitalWrite ledp HIGH

delay wait

play

delay dura∗durt x

digitalWrite ledp LOW

elseif tune x ＝＝NTDH７

intledp＝２４

digitalWrite ledp HIGH

delay wait

play

delay dura∗durt x

digitalWrite ledp LOW

８．

４　产品展示

产品整体的外观如图８Ｇ４所示;产品内部结构如图８Ｇ５所示;产品部分结构如图８Ｇ６所示.

图８Ｇ４　产品整体外观图

图８Ｇ５　产品内部结构图

[]{#index_split_004.html#p249}![index-249_1.png](https://i.imgur.com/ADD5REG.jpeg){.calibre2}

![index-249_2.png](https://i.imgur.com/cvqGN6f.jpeg){.calibre2}

２３８

图８Ｇ６　产品部分结构图

８．

５　故障及问题分析

问题１:指示灯功能与弹奏功能合为教学功能后无法正常弹奏,触摸琴键只会在每个指

示灯熄灭时发出短促的音调.

解决方案:出现这样的问题是因为在tone函数中设置的发出音调持续时间过短,所以

只能听到极其短促的音调,把持续时间设置大一点即可解决问题.

问题２:用按键开关控制播放、弹奏、教学功能的选择时,开关不起作用.

解决方案:舍弃按键开关,设置引脚直接连接电压或接地,通过检测引脚的电压状况选

择执行哪一个功能.若检测到引脚２３为高电平,则执行播放功能;否则,引脚２５为高电平

则执行弹奏功能;若二者都不满足,则执行教学功能.

问题３:弹奏功能实现不理想,触摸按键只能发出固定时长的音调,而不是期望的触摸

多久响多久.

解决方案:出现这样的问题是因为在设计教学功能时,把tone函数持续时间设定为一

个较大的值,所以只要触摸一下就会发出较长时间的声音,且在每次循环后有２０００ms的时

间延迟.后来,发现这个延迟的时间可以舍去,对各功能的执行影响不大,然后把tone函数

持续时间＃definedura_tone８００的定义方式改为intdura_tone ＝８００的定义方式,这样就

可以在不同 的 地 方 修 改 dura_tone为不同的值.所以,在 play()函数中把 dura_tone改为

２０即可正常弹奏.

问题４:扬声器的输出效果不是很好.

解决方案:扬声器的声音不是很清晰,输出效果差.最初的判断是扬声器没有正常工

作,扬声器没有 到 达 额 定 的 功 率.查 阅 功 率 放 大 器 资 料 发 现,功 率 放 大 器 的 输 出 功 率 在

２．

６W 左右,而项目中使用的一对扬声器的参数是(３W,８Ω),所以重新购买了０．５W 和１W

的功率放大器,经过调试选用了０．

５W 的功率放大器,问题得以解决.

问题５:扬声器输出带有一定的噪声.

解决方案:从理论上讲,由于功率放大器和来自外界的噪声,最后由扬声器输出的声音

带有一定程度的噪声.所以,决定从线路上进行改良.首先,更换优良的信号线作为信号传

[]{#index_split_004.html#p250}![index-250_1.png](https://i.imgur.com/F7L3LDH.jpeg){.calibre2}

２３９

输的线路.其次,将所有的信号线都经过了处理,将其每端的焊点进行排查,确保不是因为

焊接接触不良导致额外噪声.最后,确定所有信号线的走向与互相存在的干扰.总之,这是

一个很精细并且需要耐心的过程,因为能引起噪声的因素实在是太多,这里就不再赘述.

问题６:在教学功能测试过程中发现,由于代码按顺序执行,所以必须在指示灯闪烁之

前触摸对应琴键扬声器才能发声,否则会等到下一指示灯闪烁的时候才能发声.

解决方案:把弹奏功能的play函数写到if语句内部,指示灯亮后,使 play函数在灯亮

后执行.但是测试后发现,扬声器依然在下一指示灯亮起的时候才会发声,因为指示灯亮后

只有很短的时间能去触摸琴键,所以在当前指示灯亮时来不及启动弹奏功能.因此,在二者

之间增加适当的时间延迟即可,通过测试选择延迟８００ms.

８．

６　元件清单

完成本项目所用到的元件及数量如表８Ｇ１所示.

表８Ｇ１　教学电子琴元件清单

模　　块

元件/测试仪表

数量

导线

若干

杜邦线

若干

主体部分

ArduinoMEGA２５６０开发板

１个

面包板

１个

０．

５W 扬声器

１个

黑色卡纸

１个

外观部分

曲别针

若干

[]{#index_split_004.html#p251}![index-251_1.png](https://i.imgur.com/tHq4um6.jpeg){.calibre2}

第９章

微型激光雕刻机项目设计

９．

１　项目背景

激光是２０世纪最实用的发明之一,激光的应用已经遍及科技、经济、军事等社会发展的

许多领域.激光雕刻技术随着时代的发展日新月异,其应用的范围也十分广泛.目前,市场

上成型的激光雕刻机各式各样,应用的范围也相当广泛,但同时其造价也相对较高,对于那

些想接触激光技术与平面打印的普通 DIY 爱好者来说,无疑是一道门槛.

出于对激光雕刻的浓厚兴趣,本项目在相关设备供应商那里合理选择了制作器件,确定

了明确的制作思路,在有效降低项目成本的同时,对现今流行的激光雕刻技术及 Arduino可

编程模块进行学习,最终制作出一个可以完成日常生活中简单绘图要求的微型激光雕刻机.

９．

２　创新描述

传统的 DIY 激光雕刻机一般需要通过网上流行的 GRBL 绘图固件做核心操控程序帮

助完成简单的图像处 理 和 雕 刻,DIY 爱好者不需要深究其算法就可以完成简单的雕刻任

务.本项目在传统绘图功能的基础上,编写相关程序和算法,使得大家可以在学习激光雕刻

机的同时真正了解平面雕刻的一些核心功能算法.

创新点:算法升级.本项目在流行的操控程序上有所创新.例如,通过对程序的编写

掌握目前数控领域较为重要的直线插补和圆弧插补算法.该类算法采用简单的误差判断, 实现以折线逼近直线、以直线逼近圆弧的绘图功能.利用本项目编写的算法,可以自动画出

三角形、圆等类似的简单图形.

９．

３　功能及总体设计

本作品主要分为三部分进行设计:直流电机调试部分、插补功能实现部分和绘图功能

实现部分.直流电机调试部分的主要功能是在检测直流电机工作状态的同时,在平面内画

本章根据罗欣、顾晓阳项目设计整理而成.

[]{#index_split_004.html#p252}![index-252_1.png](https://i.imgur.com/wXbpkVr.jpeg){.calibre2}

![index-252_2.png](https://i.imgur.com/WiDvL7H.jpeg){.calibre2}

２４１

出一个四条边分别平行于 x轴、y轴的正方形,检测雕刻精度和激光雕刻质量;插补功能实

现部分的主要功能是实现平面内任意两点之间的连线雕刻和对圆弧图形的雕刻处理;绘图

功能实现部分的主要功能是实现将简单的图像文件转换为 G 代码文件,以操控雕刻机实现

雕刻功能.

９．

３．

１　功能介绍

算法升级,运用了逐点比较法,实现了简单的直线插补和圆弧插补.直线插补完成后通

过激光雕刻头的坐标返回功能实现简单的直角三角形雕刻.圆弧插补则需要逐象限区别对

待,设计不同的反馈函数完成各个象限的雕刻任务.

绘图功能实现,微型雕刻机接通外加电 源 并 与 计 算 机 相 连,通 过 向 开 发 板 植 入 GRBL

固件可以实现微型雕 刻 机 与 上 位 机 软 件 之 间 的 通 信,利 用 简 单 的 微 雕 软 件 可 以 实 现 如 下

功能:

(１)对简单的 G 代码编辑图片文件,可以直接按照 G 代码的命令运行画出想要的

图像;

(２)雕刻图片时,将图片进行必要的转换(不是所有图形都能转换成雕刻图形,"单笔

画"图片效果更理想),将一般的图片转换成雕刻机能雕刻的 G 代码文件,然后再进行雕刻

处理;

(３)对激光头的运行速度进行改变,以完成更好的雕刻效果.

９．

３．

２　总体设计

在做好硬件连线的基础上,可以采用两种路径分别实现上述功能.绘图功能可通过网

上流行的 GRBL 固件为核心操控完成,而本项目的插补算法不需要 GRBL 固件,将设计好

的算法植入开发板,输出器件即会做出相应的反应.

１．整体框架图

项目整体框架如图９Ｇ１所示.

图９Ｇ１　整体框架图

[]{#index_split_004.html#p253}![index-253_1.png](https://i.imgur.com/d5HcTb8.jpeg){.calibre2}

![index-253_2.png](https://i.imgur.com/3bYj07I.jpeg){.calibre2}

![index-253_3.png](https://i.imgur.com/YwGNgxv.jpeg){.calibre2}

２４２

２．系统流程图

系统流程图如图９Ｇ２所示.

图９Ｇ２　系统流程图

接通电源以后,如果输入预先编译的插补算法,则主程序开始工作,运行插补算法后,实

现简单的图形雕刻;如果使用绘图软件实现绘图功能,将固件下载到相应的软件操作界面, 就可以完成雕刻任务.断开电源,所有流程结束,系统停止运行.

３．总电路图

系统总电路如图９Ｇ３所示.

图９Ｇ３　总电路图

[]{#index_split_004.html#p254}![index-254_1.png](https://i.imgur.com/xews7YD.jpeg){.calibre2}

![index-254_2.png](https://i.imgur.com/OXIWQ7B.jpeg){.calibre2}

２４３

如图９Ｇ３所示,步进电机有４个引脚分别与驱动板相连,驱动板只需要通过２个引脚

(STEP、DIR)分别与开发板相连,即可实现对步进电机的简单控制操作.驱动板的具体参

数会在后文中详细介绍.该电路图相关引脚的分配如表９Ｇ１所示.

表９Ｇ１　电路相关引脚分配

模　　块

元 件 引 脚

Arduino开发板对应引脚及外部电源

A＋

２A

步进

步进

A－

１A

电机

---

电机

B＋

２B

驱动

B－

１B

STEP

x轴２,y轴３

步进电机及

DIR

x轴５,y轴６

其驱动模块

步进

VMOT

外部电源

电机

GND、MS１、MS２、MS３

GND

驱动

置位、复位

悬空

VDD

VCC

使能端

８

激光模块

激光输入端

１２

９．

３．

３　模块介绍

本项目主要包括硬件模块和主程序模块,下面分别介绍各模块的功能、元件、电路图和

相关代码.

１．硬件模块

１)设备介绍

激光雕刻机的硬件设备主要由４部分组成:铝材及亚

克力板支架、Arduino开发板控制模块、步进电机及其驱动

模块和激光设备.

如图９Ｇ４所示,步进电机一控制x 轴方向的转动,步进

电机背部通过亚克力板与激光模块相连,带动激光模块移

动.步进电机二、三 控 制y 轴方向转动,两步进电机轴部

相对,转动 时 互 为 反 向 转 动.Arduino开 发 板 接 Arduino LaserDriver扩展板,扩展板上有驱动片、电源转化模块、

图９Ｇ４　硬件设备

激光头和步进电机的接入端口.

２)驱动板介绍

A４９８８驱动板是一款完全的步进电机驱动器,带有内转置转换器,易于操作.A４９８８

包括一个固定关断时 间 电 流 稳 压 器,该稳压器可在慢或混合衰减模式下工作.只要在"步

进"中输入一个脉冲,即可驱动步进电机产生微步.

[]{#index_split_004.html#p255}![index-255_1.png](https://i.imgur.com/vt8XiQe.jpeg){.calibre2}

![index-255_2.png](https://i.imgur.com/flZpjEQ.jpeg){.calibre2}

![index-255_3.png](https://i.imgur.com/Ij5z6M4.jpeg){.calibre2}

![index-255_4.png](https://i.imgur.com/RVGZCMj.jpeg){.calibre2}

![index-255_5.png](https://i.imgur.com/4cG3oGD.jpeg){.calibre2}

２４４

使用 Arduino开发板直接控制电机,在微步运行时,A４９８８内的斩波控制可自动选择电

流衰减模式.在混合衰减模式下,该器件初始设置为在部分固定停机时间内快速衰减,然后

在余下的停机时间慢速衰减,用 Arduino开发板控制STEP和 DIR 就可以制动 A４９８８.

如图９Ｇ５所 示,是 一 个 简 单 的 步 进 电 机

驱动片和步进电机接线的原理图.引脚名依

次 为 VMOT、GND、２B、２A、１B、１A、VDD、

GND、使能端、MS１、MS２、MS３、复 位、置 位、

STEP、DIR.驱动板相关连线如下:

(１)VMOT 接外接电源正极;

(２)与 步 进 电 机 相 接 的 引 脚 为 ２B 蓝

(＋)、２A 红(＋)、１B绿(－)和１A 黑(－);

图９Ｇ５　驱动板相关连线

(３)STEP、DIR 分别接 Arduino开发板

的两个数字引脚;

(４)其余引脚均接地.

２．主程序模块

１)步进电机控制调试程序

＃include Stepper敭h

＃defineEN８

步进电机使能端 低电平有效

＃defineX_DIR５

x轴步进电机方向控制

＃defineY_DIR６

y轴步进电机方向控制

＃defineX_STP２

x轴步进控制

＃defineY_STP３

y轴步进控制

＃defineLASER１２

函数step功能 控制步进电机方向和步数

参数

dir方向控制

dirPin对应步进电机的DIR引脚

stepperPin对应步进电机的step引脚

steps为步进的步数

无返回值

voidstep booleandir bytedirPin bytestepperPin intsteps digitalWrite dirPin dir

delay ５０

for inti＝ ０ i steps i++

digitalWrite stepperPin HIGH

delayMicroseconds ８００

digitalWrite stepperPin LOW

delayMicroseconds ８００

[]{#index_split_004.html#p256}![index-256_1.png](https://i.imgur.com/Aeqdmv2.jpeg){.calibre2}

![index-256_2.png](https://i.imgur.com/jagtC4l.jpeg){.calibre2}

![index-256_3.png](https://i.imgur.com/Wr74V4L.jpeg){.calibre2}

![index-256_4.png](https://i.imgur.com/oSWstJF.jpeg){.calibre2}

２４５

voidsetup

将步进电机用到的I O引脚设置成输出

pinMode X_DIR OUTPUT pinMode X_STP OUTPUT

pinMode Y_DIR OUTPUT pinMode Y_STP OUTPUT

pinMode LASER OUTPUT

digitalWrite EN LOW

voidloop

digitalWrite LASER HIGH

step false X_DIR X_STP １００００

X轴电机反转１圈

２００步为一圈

step false Y_DIR Y_STP １００００

y轴电机反转１圈

２００步为一圈

delay １０００

step true X_DIR X_STP １００００

X轴电机正转１圈

２００步为一圈

step true Y_DIR Y_STP １００００

y轴电机正转１圈

２００步为一圈

delay １０００

该程序用于掌握步进电机工作原理及工作状态,实

验现象如图９Ｇ６所示.程序实现后可以在平面内画一个

标准的正方形,正方形的四条边分别平行于x 轴、

y轴.

２)逐点比较直线插补

直线插 补 算 法 是 数 控 领 域 比 较 重 要 的 一 类 算 法.

本项目设计了一个简单的逐点比较直线插补算法,该算

法可以由任意 两 点 的 连 线 用 激 光 雕 刻 机 实 现.具 体 程

图

序如下:

９Ｇ６　调试激光打印效果

＃include Stepper敭h

＃defineEN８

步进电机使能端 低电平有效

＃defineX_DIR５

x轴步进电机方向控制

＃defineY_DIR６

y轴步进电机方向控制

＃defineX_STP２

x轴步进控制

＃defineY_STP３

y轴步进控制

＃defineLASER１２

constintstepsPerRevolution ＝１００

步进电机每一转的步数

intN

总步数

intFM

偏差判断

起点坐标

intxm ＝ ０

intym ＝ ０

[]{#index_split_004.html#p257}![index-257_1.png](https://i.imgur.com/KsdvjRs.jpeg){.calibre2}

![index-257_2.png](https://i.imgur.com/Z7hRMt7.jpeg){.calibre2}

２４６

终点坐标

intxe ＝ ６０

intye ＝ ４０

intZF

坐标给进值

函数step功能 控制步进电机方向和步数

参数

dir用于方向控制 dirPin对应步进电机的DIR引脚

stepperPin对应步进电机的step引

脚 steps为步进的步数

无返回值

voidstep booleandir bytedirPin bytestepperPin intsteps digitalWrite dirPin dir

delay ５０

for inti＝ ０ i steps i++

digitalWrite stepperPin HIGH

delayMicroseconds ８００

digitalWrite stepperPin LOW

delayMicroseconds ８００

voidsetup

将步进电机用到的I O引脚设置成输出

pinMode X_DIR OUTPUT pinMode X_STP OUTPUT

pinMode Y_DIR OUTPUT pinMode Y_STP OUTPUT

pinMode EN OUTPUT

pinMode LASER

OUTPUT

digitalWrite EN LOW

Serial敭

begin １１５２００

初始化串口波特率为９６００

N＝abs xe－xm ＋abs ye－ym

计算坐标给进的总步数

FM＝０

置FM为 ０

voidcontrolplan１

digitalWrite LASER HIGH

ZF＝１

Serial敭

println ＂ ＋x＂

step true X_DIR X_STP stepsPerRevolution 在x轴步进

delay ５００

FM＝FM－abs ye－ym

N－－

[]{#index_split_004.html#p258}![index-258_1.png](https://i.imgur.com/IqDUsZA.jpeg){.calibre2}

![index-258_2.png](https://i.imgur.com/kRtZJHT.jpeg){.calibre2}

![index-258_3.png](https://i.imgur.com/aLhxBcH.jpeg){.calibre2}

![index-258_4.png](https://i.imgur.com/kvk2kSO.jpeg){.calibre2}

![index-258_5.png](https://i.imgur.com/GvxMvLi.jpeg){.calibre2}

![index-258_6.png](https://i.imgur.com/Kf8ilJ9.jpeg){.calibre2}

２４７

加工点偏差FM ０时的处理函数

voidcontrolplan２

digitalWrite LASER HIGH

ZF＝２

Serial敭

println ＂ ＋y＂

step true Y_DIR Y_STP stepsPerRevolution 在y轴步进

delay ５００

FM＝FM＋abs xe－xm

N－－

加工点偏差FM ０时的处理函数

voidloop

Serial敭

print ＂ZF＂

Serial敭

print ZF DEC

Serial敭

print ＂FM＂

Serial敭

print FM DEC

Serial敭

print ＂N＂

Serial敭

print N DEC

if N

＝０

if FM ＝０

controlplan１

else

controlplan２

else

Serial敭

print ＂\\n＂

for inti＝ xe－xm i ０ i－－

x轴回归

step false X_DIR X_STP stepsPerRevolution 在x轴步进

myStepper敭step －stepsPerRevolution

Serial敭

print i

DEC

Serial敭

println ＂ －x＂

delay １００

for inti＝ ye－ym i ０ i－－

y轴回归

step false Y_DIR Y_STP stepsPerRevolution myStepper１敭step －stepsPerRevolution

Serial敭

print i

DEC

[]{#index_split_004.html#p259}![index-259_1.png](https://i.imgur.com/x9xO8qc.jpeg){.calibre2}

![index-259_2.png](https://i.imgur.com/QGHcsKq.jpeg){.calibre2}

![index-259_3.png](https://i.imgur.com/olw49wv.jpeg){.calibre2}

![index-259_4.png](https://i.imgur.com/xUf1nr2.jpeg){.calibre2}

２４８

Serial敭

println ＂ －y＂

delay １００

while １

设置F 为反馈值,在不同路径下为F 设计不同的反馈表达式,程序的核心流程如图９Ｇ７和

图９Ｇ８所示.图９Ｇ７为直线插补算法实现流程图,图９Ｇ８为激光雕刻轨迹原理图,图９Ｇ９为

直线插补算法实验现象.

图９Ｇ７　直线插补算法实现流图

图９Ｇ８　激光实际运行轨迹原理图

图９Ｇ９　直线插补算法实验现象

[]{#index_split_004.html#p260}![index-260_1.png](https://i.imgur.com/xtWuoZS.jpeg){.calibre2}

![index-260_2.png](https://i.imgur.com/LyaqQxa.jpeg){.calibre2}

![index-260_3.png](https://i.imgur.com/7iXZofd.jpeg){.calibre2}

![index-260_4.png](https://i.imgur.com/QxygTPo.jpeg){.calibre2}

２４９

３)逐点比较圆弧插补算法

圆的插补算法与直线插补算法原理大致类似,其反馈函数较之有所不同,涉及４个象限

的循环判别语句,并且均有所不同,需要改变循环跳出语句.程序代码如下:

＃include Stepper敭h

＃defineEN８

步进电机使能端 低电平有效

＃defineX_DIR５

x轴步进电机方向控制

＃defineY_DIR６

y轴步进电机方向控制

＃defineX_STP２

x轴步进控制

＃defineY_STP３

y轴步进控制

＃defineLASER１２

z轴步进控制

constintstepsPerRevolution ＝１００

步进电机每一转的步数

intN＝１０００

总步数

intF

偏差

intXi Yi

intZF

坐标给进值

函数step 功能 控制步进电机方向和步数

参数

dir方向控制 dirPin对应步进电机的DIR引脚

stepperPin对应步进电机的step引脚

steps为步进的步数

无返回值

voidstep booleandir bytedirPin bytestepperPin intsteps digitalWrite dirPin dir

delay ５０

for inti＝ ０ i steps i++

digitalWrite stepperPin HIGH

delayMicroseconds ８００

digitalWrite stepperPin LOW

delayMicroseconds ８００

voidsetup

将步进电机用到的I O引脚设置成输出

pinMode X_DIR OUTPUT pinMode X_STP OUTPUT

pinMode Y_DIR OUTPUT pinMode Y_STP OUTPUT

pinMode EN OUTPUT

pinMode LASER OUTPUT

[]{#index_split_004.html#p261}![index-261_1.png](https://i.imgur.com/XfTZt69.jpeg){.calibre2}

![index-261_2.png](https://i.imgur.com/nBI8wEl.jpeg){.calibre2}

２５０

digitalWrite EN LOW

Serial敭

begin １１５２００

初始化串口波特率为９６００

voidloop

Serial敭

print ＂ZF＂

Serial敭

print ZF DEC

Serial敭

print ＂F＂

Serial敭

print F DEC

Serial敭

print ＂N＂

Serial敭

print N DEC

F＝ ０

Xi＝６０

Yi＝０

do

digitalWrite LASER HIGH

if F ＝０

ZF＝１

Serial敭

println ＂ －x＂

step true X_DIR X_STP stepsPerRevolution 在x轴步进

delay ５００

F＝F－２∗Xi＋１

Xi＝Xi－１

N－－

else

ZF＝２

Serial敭

println ＂ ＋y＂

step true Y_DIR Y_STP stepsPerRevolution 在y轴步进

delay ５００

F＝F＋２∗Yi＋１

Yi＝Yi＋１

N－－

[]{#index_split_004.html#p262}![index-262_1.png](https://i.imgur.com/xJ5a1Mf.jpeg){.calibre2}

![index-262_2.png](https://i.imgur.com/diYUcdb.jpeg){.calibre2}

![index-262_3.png](https://i.imgur.com/Z4AQsC1.jpeg){.calibre2}

![index-262_4.png](https://i.imgur.com/w7w6RB8.jpeg){.calibre2}

![index-262_5.png](https://i.imgur.com/neCjKrW.jpeg){.calibre2}

２５１

while Xi ＝０

第二象限１ ４圆弧

Xi＝０

Yi＝６０

do

digitalWrite LASER HIGH

if F ＝０

ZF＝２

Serial敭

println ＂ －y＂

step false Y_DIR Y_STP stepsPerRevolution 在y轴步进

delay ５００

F＝F－２∗Yi＋１

Yi＝Yi－１

N－－

else

ZF＝１

Serial敭

println ＂ －x＂

step true X_DIR X_STP stepsPerRevolution 在x轴步进

delay ５００

F＝F＋２∗abs Xi ＋１

Xi＝Xi－１

N－－

while Yi ＝０

第一象限１ ４圆弧

Xi＝－６０

Yi＝０

do

digitalWrite LASER HIGH

if F ＝０

ZF＝１

Serial敭

println ＂ ＋y＂

step false Y_DIR Y_STP stepsPerRevolution 在y轴步进

delay ５００

F＝F－２∗abs Yi ＋１

[]{#index_split_004.html#p263}![index-263_1.png](https://i.imgur.com/I30fSNU.jpeg){.calibre2}

![index-263_2.png](https://i.imgur.com/QhHczo8.jpeg){.calibre2}

![index-263_3.png](https://i.imgur.com/mzDmCiS.jpeg){.calibre2}

２５２

Yi＝Yi－１

N－－

else

ZF＝２

Serial敭

println ＂ ＋x＂

step false X_DIR X_STP stepsPerRevolution 在x轴步进

delay ５００

F＝F＋２∗abs Xi ＋１

Xi＝Xi＋１

N－－

while Xi ＝０

第四象限１ ４圆弧

Xi＝０

Yi＝－６０

do

digitalWrite LASER HIGH

if F ＝０

ZF＝１

Serial敭

println ＂ ＋x＂

step false X_DIR X_STP stepsPerRevolution 在x轴步进

delay ５００

F＝F－２∗abs Xi ＋１

Xi＝Xi＋１

N－－

else

ZF＝２

Serial敭

println ＂ －y＂

step true Y_DIR Y_STP stepsPerRevolution 在y轴步进

delay ５００

F＝F＋２∗abs Yi ＋１

Yi＝Yi＋１

N－－

[]{#index_split_004.html#p264}![index-264_1.png](https://i.imgur.com/4iFjyb4.jpeg){.calibre2}

![index-264_2.png](https://i.imgur.com/PSplvOZ.jpeg){.calibre2}

![index-264_3.png](https://i.imgur.com/M0FH13I.jpeg){.calibre2}

![index-264_4.png](https://i.imgur.com/PlG8ZDR.jpeg){.calibre2}

![index-264_5.png](https://i.imgur.com/dr83qtO.jpeg){.calibre2}

２５３

while Xi ＝６０

第三象限１ ４圆弧

第二象限的循环判别流程图如图９Ｇ１０所示,其他象限原理相似,只是反馈语句有所不

同.图９Ｇ１１为激光雕刻轨迹原理图,图９Ｇ１２为圆弧插补算法实验现象.

图９Ｇ１０　圆弧插补算法实现流图

图９Ｇ１１　激光实际运行轨迹原理图

图９Ｇ１２　圆弧插补算法实验现象

[]{#index_split_004.html#p265}![index-265_1.png](https://i.imgur.com/CvdAtOG.jpeg){.calibre2}

![index-265_2.png](https://i.imgur.com/ze9M7HY.jpeg){.calibre2}

２５４

３．绘图功能的实现

使用 ArduinoBuilder 并 选 择 好 串 口,调 整 合 适 的 波 特 率,即 可 将 固 件 文 件 植 入.

GRBL是上位机和下位机的组合.上下位机代码都可以从 Github上下载,但是需要编译.

GRBL固件是现在 DIY 绘图领域相当流行的编译工具(还可以用于实现３D 打印).从学习

深度上看,GRBL上下位机的学习应该是很难的,但是从应用角度上看,又是非常简单的.

学会运用 GRBL固件及掌握相关软件的操作,可以轻松地将 G 代码文件用雕刻机绘出来, 可以更加简单地实现绘图功能.操作步骤如下:

(１)不能使用普通的 ArduinoIDE下载 GRBL固件,需要利用 ArduinoBuilder下载; (２)下载完成后可以通过上位机控制电机.

本项目使用简单的微雕 软 件 控 制 实 现 绘 图 功 能,雕刻图片时,将图片进 行 必 要 的 转 换

(不是所有图形都能转换成没有的雕刻图形,主要对"单笔画"图片的转换效果更理想),将一

般的图片转换成雕刻机 G 代码文件,然后进行雕刻处理.图９Ｇ１３为将 GRBL 固件植入开

发板的操作界面;图９Ｇ１４为上位机程序的控制界面;图９Ｇ１５为绘图结果.

图９Ｇ１３　将 GRBL固件植入开发板的操作界面

[]{#index_split_004.html#p266}![index-266_1.png](https://i.imgur.com/35uDaCG.jpeg){.calibre2}

![index-266_2.png](https://i.imgur.com/hbQzGbp.jpeg){.calibre2}

![index-266_3.png](https://i.imgur.com/MejJ8y5.jpeg){.calibre2}

２５５

图９Ｇ１４　上位机程序的控制界面

图９Ｇ１５　绘图结果

９．

４　产品展示

产品整体外观如图９Ｇ１６所示;产品内部结构如图９Ｇ１７所示.

[]{#index_split_004.html#p267}![index-267_1.png](https://i.imgur.com/SnWiFyZ.jpeg){.calibre2}

![index-267_2.png](https://i.imgur.com/kHl07uZ.jpeg){.calibre2}

![index-267_3.png](https://i.imgur.com/EHmLsQl.jpeg){.calibre2}

２５６

图９Ｇ１６　整体外观图

图９Ｇ１７　内部结构图

９．

５　故障及问题分析

问题１:通过圆弧插补算法雕刻出的圆不规范.

解决方案:圆弧插补算法是在类比直线插补算法的基础上设计的,由于各个象限起始

点的要求不明确,加之差补算法逐点比较后本身就存在相应误差,所以需要在以后的时间内

对程序进行升级,使雕刻机工作更加精确.

问题２:图像灰度不一.

解决方案:雕刻图像的过程中,有时候会忘记对相关参数进行调整,画幅大小调整得不

合理会导致画出的图像形状发生变化.此外,雕刻机激光头移动的速度也会影响图片局部

的雕 刻 效 果,移动速度快会导致激光在移动较快区域作用时间较短,出现雕刻不到位的情

况.可以减小雕刻机运行的速度,也可以升级激光设备,换用更大概率的雕刻设备去弥补这

些误差.此外,电源转化模块工作不稳定,使得后期激光的输出功率不平均,也会使得雕刻

的图像灰度存在差异.

问题３:驱动板极易被烧坏.

解决方案:由于第一次接线时的疏忽大意,导致步进电机驱动模块接反,致使一通电驱

动板就被烧坏,遇到此类现象须立即更换驱动板,防止其他器件再次损坏.驱动板 容 易 发

[]{#index_split_004.html#p268}![index-268_1.png](https://i.imgur.com/byEkcF3.jpeg){.calibre2}

２５７

烫,也会影响其工作的安全性,在驱动板上增加散热模块可以减轻此类现象.

９．

６　元件清单

完成本项目所用到的元件及数量如表９Ｇ２所示.

表９Ｇ２　微型激光雕刻机元件清单

模　　块

元件/测试仪表

数量

ArduinoUNO 开发板

１个

ArduinoCNC/LaserDriver

１个

直流电机驱动板 A４９８８

２个

核心器件

电源模块

１个

激光头组件(蓝紫色２５０mW)

１个

２８步进电机

３个

铝片亚克力板构架

若干

外观部分

螺钉

若干

铝材

４个

[]{#index_split_004.html#p269}![index-269_1.png](https://i.imgur.com/BO3bTNj.jpeg){.calibre2}

第１０章

遥控吸尘器项目设计

１０．

１　项目背景

打扫卫生时,卫生死角既不好清理,又不容易收集里面的垃圾.同时,市场上的扫地机

器人价格比较高.基于以上考虑,本项目设计一款具有扫地机器人功能的简易吸尘器.功

能上虽然没有扫地机器人高级,但是能够满足普通家用要求.本项目设计的产品主要针对

灰尘、碎屑以及头发等比较轻小、扫帚难以清扫的垃圾.

１０．

２　创新描述

本产品采用可充电电池,不用担心吸尘器使用过程中供电不足的问题.充电电池比一

次性电池环保,既降低了成本,又有利于环境保护.同时,本项目设计的吸尘器与普通的吸

尘器相比,没有连线的束缚.吸尘时有两种选择:第一,可以自动避障来清理垃圾;第二, 设置了蓝牙串口,可以通过手机控制吸尘器.第二个功能类似于遥控车,既增加了乐趣,又

能完成一定的功能.既可以手动蓝牙控制,也可以通过红外避障功能自动控制.两种功能

之间可以自由转换,兼具便利性和娱乐性.同时,容纳箱的抽屉型结构设计,便于清理其中

吸入的垃圾.

１０．

３　功能及总体设计

本作品主要分为三部 分 进 行 设 计:直 流 电 机 驱 动 部 分、蓝 牙 遥 控 部 分 和 吸 尘 器 部 分.

直流电机驱动部分主要用来驱动小车,从而带动吸尘器;蓝牙遥控部分,主要用来遥控小车

的行进方向;吸尘器部分利用机箱风扇完成吸尘.可通过手机蓝牙 APP等方式远程控制

吸尘器的运动方式,吸尘器具有８个运动方向;可以通过手机 APP上的按键切换自由避障

本章根据杨希、周天宇项目设计整理而成.

[]{#index_split_004.html#p270}![index-270_1.png](https://i.imgur.com/4tv9Qlc.jpeg){.calibre2}

![index-270_2.png](https://i.imgur.com/MYSEkYh.jpeg){.calibre2}

２５９

运动和手动控制两种模式.

吸尘器经过的地方,灰尘、纸屑等将被吸入木箱内.像拉抽屉一样把里层的木箱抽出, 就可以倒掉里面的垃圾.另外,在不给控制模块供电的情况下,单独给风扇供电,就可以把

它当作电风扇使用.

１０．

３．

１　功能介绍

吸尘器的主要功能是吸尘,吸尘器针对的主要对象是头发、灰尘、轻小碎屑等.本项目

设计的吸尘器区别于普通吸尘器,可以人为地通过蓝牙控制方向来吸尘,也可以采用自动避

障的方式吸尘.与普通的吸尘器相比,没有了连线的束缚,更自由,更方便.同时,与扫地机

器人相比,本项目设计的吸尘器在成本方面大大降低,虽然灵活性与实用性不如扫地机器

人,但是对于家居场所,功能已经足够.

１０．

３．

２　总体设计

要实现上述功能需要将作品分成三部分进行设计:直流电机驱动部分、蓝牙遥控部分

和吸尘器部分.使用６节五号电池组给 Arduino电机驱动扩展板和 Arduino开发板供电, Arduino开发板的数字引脚控制 L２９８N 的电平信号输入,L２９８N 的输出端控制直流电机运转.

HCＧ０５蓝牙模块接收来自移动端的数据并发送给 Arduino开发板,从而控制 Arduino 开发板的各引脚输出所需的电平.直流电机转动方向的不同组合(前转、后转、不转)使底盘

具有９种运动状态,红外避障传感器用于实现自动控制.吸尘器放置在底盘上,达到蓝牙控

制吸尘器移动的目的.

１．整体框架图

项目整体框架如图１０Ｇ１所示.

图１０Ｇ１　整体框架图

２．系统流程图

系统流程如图１０Ｇ２所示.

接通电源后,可以选择自动避障模式来自动清理垃圾,或者选择人为清理垃圾.自动避

障模式下可以发出红外线,当遇到障碍物时,输入低电平,可以避开障碍,自动清理垃圾.对

于手动清理垃圾,需要事先连接好蓝牙设备,就像操控遥控车一样,操控吸尘器实现吸尘功

能,直至垃圾清理完毕.

[]{#index_split_005.html}

[]{#index_split_005.html#p271}![index-271_1.png](https://i.imgur.com/b8SAHar.jpeg){.calibre2}

![index-271_2.png](https://i.imgur.com/Ws5kFNK.jpeg){.calibre2}

![index-271_3.png](https://i.imgur.com/PK6FKWb.jpeg){.calibre2}

２６０

图１０Ｇ２　系统流程图

３．总电路图

系统总电路如图１０Ｇ３所示;原理图如图１０Ｇ４所示;引脚连接如表１０Ｇ１所示.

图１０Ｇ３　总电路图

[]{#index_split_005.html#p272}![index-272_1.png](https://i.imgur.com/GYd4z7k.jpeg){.calibre2}

![index-272_2.png](https://i.imgur.com/rA2Ip7F.jpeg){.calibre2}

２６１

图１０Ｇ４　原理图

表１０Ｇ１　引脚连接

元　　件

元件引脚

Arduino开发板对应引脚

IN１

８

IN２

９

L２９８N

IN３

１０

IN４

１１

VCC

VCC

GND

GND

HCＧ０５蓝牙模块

TXD

RXD

RXD

TXD

VCC

VCC

红外避障传感器(左)

GND

GND

OUT１

５

VCC

VCC

红外避障传感器(右)

GND

GND

OUT２

６

１０．

３．

３　模块介绍

本项目主要包括直流电机驱动模块、蓝牙遥控模块和自动避障模块.下面分别给出各

模块的功能、元件、电路图和相关代码.

[]{#index_split_005.html#p273}![index-273_1.png](https://i.imgur.com/ohLMw90.jpeg){.calibre2}

![index-273_2.png](https://i.imgur.com/1SnQlGV.jpeg){.calibre2}

![index-273_3.png](https://i.imgur.com/rb7SkRE.jpeg){.calibre2}

２６２

１．电机驱动模块

１)功能介绍

由于 ArduinoUNO 开发板本身供电接口不足,所以需要通过扩展板转接蓝牙模块和

电机驱动板,图１０Ｇ５为 ArduinoUNO 扩展板.

L２９８N 直流电机驱动板具有４个数字逻辑输入引脚、２个使能引脚、３个供电引脚以及

４个输出引脚.其中,

IN１、

IN２引脚控制 OUT１、OUT２的输出;IN３、

IN４引脚控制 OUT３、

OUT４的输出;使能引脚 ENA、ENB为模拟输入引脚,必须与 Arduino开发板的 PWM 引

脚连接,通过调节输出电平的占空比,用于调节直流电机的转速.将 Arduino开发板的数字

引脚接入 L２９８N 的逻辑输入引脚,通过输入信号电平差的高低即可实现对直流电机的控

制,图１０Ｇ６为 L２９８N 的引脚图.

图１０Ｇ５　ArduinoUNO 扩展板

图１０Ｇ６ 　L２９８N 引脚

２)相关代码

chargetstr

定义蓝牙串口接收的字符串变量

intLeft_motor_go＝８

IN１

intLeft_motor_back＝９

IN２

intRight_motor_go＝１０

IN３

intRight_motor_back＝１１

IN４

intLED＝７

避障指示灯

constintSensorRight_２ ＝ ５

右传感器信号输入为５引脚

constintSensorLeft_２ ＝ ６

左传感器信号输入为６引脚

intSR_２

右侧红外避障传感器

intSL_２

左侧红外避障传感器

voidsetup

Serial敭

begin ９６００

波特率为９６００ 与蓝牙模块HC－０５默认的波特率一致

pinMode Left_motor_go

OUTPUT

引脚８

pinMode Left_motor_back

OUTPUT

引脚９

pinMode Right_motor_go

OUTPUT

引脚１０

[]{#index_split_005.html#p274}![index-274_1.png](https://i.imgur.com/aWMPER1.jpeg){.calibre2}

２６３

pinMode Right_motor_back

OUTPUT

引脚１１

pinMode LED

OUTPUT

LED避障指示灯的信号控制端

pinMode SensorLeft_２ INPUT

pinMode SensorRight_２ INPUT

voidforward

前进

digitalWrite Right_motor_go

HIGH

digitalWrite Right_motor_back

LOW

analogWrite Right_motor_go

１５０ PWM调速 ０\~２５５

analogWrite Right_motor_back

０

digitalWrite Left_motor_go

LOW

digitalWrite Left_motor_back

HIGH

analogWrite Left_motor_go

０

analogWrite Left_motor_back

１５０

delay time∗ １００

voidforward１

避障前进

digitalWrite Right_motor_go

HIGH

digitalWrite Right_motor_back

LOW

analogWrite Right_motor_go

１５０

analogWrite Right_motor_back

０

digitalWrite Left_motor_go

LOW

digitalWrite Left_motor_back

HIGH

getstr＝Serial敭

read

analogWrite Left_motor_go

０

analogWrite Left_motor_back

０

delay time∗ １００

voidbrake

刹车

digitalWrite Right_motor_go

LOW

digitalWrite Right_motor_back

LOW

digitalWrite Left_motor_go

LOW

digitalWrite Left_motor_back

LOW

voidbrake１

避障刹车

digitalWrite Right_motor_go

LOW

digitalWrite Right_motor_back

LOW

analogWrite Right_motor_go

１５０

[]{#index_split_005.html#p275}![index-275_1.png](https://i.imgur.com/CbXFmJt.jpeg){.calibre2}

２６４

analogWrite Right_motor_back

０

digitalWrite Left_motor_go

LOW

digitalWrite Left_motor_back

LOW

getstr＝Serial敭

read

analogWrite Left_motor_go

０

analogWrite Left_motor_back

０

delay time∗ １００

voidleft

左前

digitalWrite Right_motor_go

HIGH

digitalWrite Right_motor_back

LOW

analogWrite Right_motor_go

１５０

analogWrite Right_motor_back

０

digitalWrite Left_motor_go

LOW

digitalWrite Left_motor_back

LOW

analogWrite Left_motor_go

０

analogWrite Left_motor_back

０

delay time∗ １００

voidleft１

避障左前

digitalWrite Right_motor_go

HIGH

digitalWrite Right_motor_back

LOW

analogWrite Right_motor_go

１５０

analogWrite Right_motor_back

０

digitalWrite Left_motor_go

LOW

digitalWrite Left_motor_back

LOW

getstr＝Serial敭

read

analogWrite Left_motor_go

０

analogWrite Left_motor_back

０

delay time∗ １００

voidback_left

左后

digitalWrite Right_motor_go

LOW

digitalWrite Right_motor_back

HIGH

analogWrite Right_motor_go

１５０

analogWrite Right_motor_back

０

digitalWrite Left_motor_go

LOW

digitalWrite Left_motor_back

LOW

analogWrite Left_motor_go

０

[]{#index_split_005.html#p276}![index-276_1.png](https://i.imgur.com/TsGpq7D.jpeg){.calibre2}

２６５

analogWrite Left_motor_back

０

delay time∗ １００

voidspin_left

左转

digitalWrite Right_motor_go

HIGH

digitalWrite Right_motor_back

LOW

analogWrite Right_motor_go

２００

analogWrite Right_motor_back

０

digitalWrite Left_motor_go

HIGH

digitalWrite Left_motor_back

LOW

analogWrite Left_motor_go

２００

analogWrite Left_motor_back

０

delay time∗ １００

voidright

右前

digitalWrite Right_motor_go

LOW

digitalWrite Right_motor_back

LOW

analogWrite Right_motor_go

０

analogWrite Right_motor_back

０

digitalWrite Left_motor_go

LOW

digitalWrite Left_motor_back

HIGH

analogWrite Left_motor_go

０

analogWrite Left_motor_back

１５０

delay time∗ １００

voidright１

避障右前

digitalWrite Right_motor_go

LOW

digitalWrite Right_motor_back

LOW

analogWrite Right_motor_go

１５０

analogWrite Right_motor_back

０

digitalWrite Left_motor_go

LOW

digitalWrite Left_motor_back

HIGH

getstr＝Serial敭

read

analogWrite Left_motor_go

０

analogWrite Left_motor_back

０

delay time∗ １００

voidback_right

右后

[]{#index_split_005.html#p277}![index-277_1.png](https://i.imgur.com/fYoiVxT.jpeg){.calibre2}

２６６

digitalWrite Right_motor_go

LOW

digitalWrite Right_motor_back

LOW

analogWrite Right_motor_go

０

analogWrite Right_motor_back

０

digitalWrite Left_motor_go

HIGH

digitalWrite Left_motor_back

LOW

analogWrite Left_motor_go

０

analogWrite Left_motor_back

１５０

delay time ∗ １００

voidspin_right

右转

digitalWrite Right_motor_go

LOW

digitalWrite Right_motor_back

HIGH

analogWrite Right_motor_go

０

analogWrite Right_motor_back

２００

digitalWrite Left_motor_go

LOW

digitalWrite Left_motor_back

HIGH

analogWrite Left_motor_go

０

analogWrite Left_motor_back

２００

delay time∗ １００

voidback

后退

digitalWrite Right_motor_go

LOW

digitalWrite Right_motor_back

HIGH

analogWrite Right_motor_go

０

analogWrite Right_motor_back

１５０

digitalWrite Left_motor_go

HIGH

digitalWrite Left_motor_back

LOW

analogWrite Left_motor_go

１５０

analogWrite Left_motor_back

０

delay time∗ １００

voidback１

避障后退

digitalWrite Right_motor_go

LOW

digitalWrite Right_motor_back

HIGH

analogWrite Right_motor_go

１５０

analogWrite Right_motor_back

０

digitalWrite Left_motor_go

HIGH

digitalWrite Left_motor_back

LOW

[]{#index_split_005.html#p278}![index-278_1.png](https://i.imgur.com/NGFBM0t.jpeg){.calibre2}

２６７

getstr＝Serial敭

read

analogWrite Left_motor_go

０

analogWrite Left_motor_back

０

delay time∗ １００

voidautoavoid

避障模式

while getstr＝＝ \'０\'

检测接收的字符是否为０

SR_２ ＝ digitalRead SensorRight_２

读取右传感器对应的引脚电平

SL_２ ＝ digitalRead SensorLeft_２

读取左传感器对应的引脚电平

if SL_２ ＝＝ HIGH&&SR_２＝＝HIGH

如果左右传感器都没有检测到障碍

forward１

Serial敭

println ＂forward１＂

elseif SL_２ ＝＝ HIGH&&SR_２ ＝＝ LOW 只有右侧传感器检测到障碍

left１

Serial敭

println ＂left１＂

elseif SR_２ ＝＝ HIGH&&SL_２ ＝＝ LOW 如果只有左侧传感器检测到障碍

right１

Serial敭

println ＂right１＂

else

左右两边都有障碍物 则先刹车 再后退 接着改变方向前进

digitalWrite LED

HIGH

brake１

delay ３００

back１

delay ４００

left１

delay ５００

voidloop

getstr＝Serial敭

read

根据接收到的字符指令进行动作

if getstr＝＝ \'０\'

[]{#index_split_005.html#p279}![index-279_1.png](https://i.imgur.com/jb7lmJd.jpeg){.calibre2}

２６８

Serial敭

println ＂autoavoid＂

autoavoid

elseif getstr＝＝ \'８\'

Serial敭

println ＂forward＂

forward

elseif getstr＝＝ \'２\'

Serial敭

println ＂back＂

back

elseif getstr＝＝ \'５\'

Serial敭

println ＂brake＂

brake

elseif getstr＝＝ \'７\'

Serial敭

println ＂left＂

left

elseif getstr＝＝ \'９\'

Serial敭

println ＂right＂

right

elseif getstr＝＝ \'４\'

Serial敭

println ＂spin_left＂

spin_left

elseif getstr＝＝ \'６\'

Serial敭

println ＂spin_right＂

spin_right

elseif getstr＝＝ \'１\'

Serial敭

println ＂back_left＂

[]{#index_split_005.html#p280}![index-280_1.png](https://i.imgur.com/hn6g16x.jpeg){.calibre2}

![index-280_2.png](https://i.imgur.com/5mKKwJS.jpeg){.calibre2}

２６９

back_left

elseif getstr＝＝ \'３\'

Serial敭

println ＂back_right＂

back_right

２．蓝牙遥控模块

１)功能介绍

蓝牙模块 HCＧ０５采用 CSR 主流蓝牙芯片,采用蓝牙

V２．

０协议标准,使用 TTL 接口与单片机通信,默认波特

率为９６００.输入电压应为３．６\~６V.使用前可使用 USB

转 TTL模块和蓝牙串口调试助手进行配置(调整波特率、

配对名称和密码等).

配对成功后,蓝牙手机或 Arduino自带串口监视器发

送字符串后,HCＧ０５通过 TXD、RXD 接口将字符串以十六

进制形 式 传 输 给 ArduinoUNO 开发板,其根据接收到的

图１０Ｇ７　蓝牙遥控模块 HCＧ０５

字符串执行与之相应的函数.例如,发送数字８,则会执行

函数forward().蓝牙遥控模块实物如图１０Ｇ７所示.

２)相关代码

Serial敭begin ９６００

打开串口

HC－０５默认波特率为９６００

voidloop

getstr＝Serial敭

read

根据接收到的字符指令进行动作

if getstr＝＝ \'０\'

Serial敭

println ＂autoavoid＂

autoavoid

elseif getstr＝＝ \'８\'

Serial敭

println ＂forward＂

forward

elseif getstr＝＝ \'２\'

Serial敭

println ＂back＂

back

[]{#index_split_005.html#p281}![index-281_1.png](https://i.imgur.com/ZN7tBeU.jpeg){.calibre2}

２７０

elseif getstr＝＝ \'５\'

Serial敭

println ＂brake＂

brake

elseif getstr＝＝ \'７\'

Serial敭

println ＂left＂

left

elseif getstr＝＝ \'９\'

Serial敭

println ＂right＂

right

elseif getstr＝＝ \'４\'

Serial敭

println ＂spin_left＂

spin_left

elseif getstr＝＝ \'６\'

Serial敭

println ＂spin_right＂

spin_right

elseif getstr＝＝ \'１\'

Serial敭

println ＂back_left＂

back_left

elseif getstr＝＝ \'３\'

Serial敭

println ＂back_right＂

back_right

代码功能:蓝牙串口接收到数字１\~９时,将按照１\~９这９个数字在九宫格上的分布

来执行相应方向的运动控制函数,例如数字８对应前方,数字９对应右前方;接收到数字０

时,将执行自动控制模式,当红外避障传感器检测到前方障碍物时刹车,后退一段距离,然后

更换前进方向;检测到左边或右边的障碍物时,仅改变前进方向以避开障碍.

[]{#index_split_005.html#p282}![index-282_1.png](https://i.imgur.com/HaXo3Bw.jpeg){.calibre2}

![index-282_2.png](https://i.imgur.com/ngzwL31.jpeg){.calibre2}

２７１

３．自动避障模块

１)功能介绍

红外避障传感 器 利 用 物 体 反 射 波 的 性 质.在 一 定 距

离范围内,如果没有障碍物,则发射出去的红外线 强 度 将

会随着传播距离增长而衰减,传感器输出高电平信号;如

果有障碍物,红外线将被反射到传感器接收头,传 感 器 检

测到该信号 后 就 能 确 认 有 障 碍 物,并 输 出 低 电 平 信 号 给

图１０Ｇ８　红外避障传感器

Arduino开发板.通过 Arduino开 发 板 程 序 判 定 障 碍 物

处于左边、右边还是前方,旋转传感器中间的旋钮可以调节传感器的灵敏度(即确认有障碍

物并输出电平的最大距离),图１０Ｇ８为红外避障传感器.

２)相关代码

voidautoavoid

避障模式

while getstr＝＝ \'０\'

检测接收的字符是否为０

SR_２ ＝ digitalRead SensorRight_２

读取右传感器对应的引脚电平

SL_２ ＝ digitalRead SensorLeft_２

读取左传感器对应的引脚电平

if SL_２ ＝＝ HIGH&&SR_２＝＝HIGH

如果左右传感器都没有检测到障碍

forward１

Serial敭

println ＂forward１＂

elseif SL_２ ＝＝ HIGH&&SR_２ ＝＝ LOW 只有右侧传感器检测到障碍

left１

Serial敭

println ＂left１＂

elseif SR_２ ＝＝ HIGH&&SL_２ ＝＝ LOW 如果只有左侧传感器检测到障碍

right１

Serial敭

println ＂right１＂

else

左右两边都有障碍物 则先刹车 再后退 接着改变方向前进

digitalWrite LED

HIGH

brake１

delay ３００

[]{#index_split_005.html#p283}![index-283_1.png](https://i.imgur.com/EWSSfK8.jpeg){.calibre2}

![index-283_2.png](https://i.imgur.com/szplBo9.jpeg){.calibre2}

![index-283_3.png](https://i.imgur.com/D4oYtaR.jpeg){.calibre2}

２７２

back１

delay ４００

left１

delay ５００

１０．

４　产品展示

产品的整体外观如图１０Ｇ９所示.主体是一个吸尘器风箱和小车,小车搭载着吸尘器工

作.小车为两层结构,中间放总体电路,把控制小车的电路放于小车两层结构之中,这样,既

有空间存放电路,又可使整体较为美观.图１０Ｇ１０所示为小车内部电路.

图１０Ｇ９　小车整体外部结构

图１０Ｇ１０　内部结构

１０．

５　故障及问题分析

问题１:L２９８N 在调试过程中无法正常工作.

解决方案:L２９８N 有５V、

１２V、GND 三个供电引脚,由于不了解L２９８N 的运作机理,将

５V 和１２V 口同时供电,导致驱动板无法正常工作,输出电平为０.在查阅资料后得知,由于

L２９８N 自带稳压模块,可将１２V 降至５V 给驱动板供电,如果有电压较高(例如９\~１２V)的

[]{#index_split_005.html#p284}![index-284_1.png](https://i.imgur.com/vRimE1N.jpeg){.calibre2}

２７３

电源,接１２V 引脚和 GND 即可,

５V 引脚不必接.此时,不但直流电机驱动板正常工作,并

且与使用５V 电压供电时相比,输出电平更高,直流电机运转更快速.

问题２:在没有障碍物时,红外避障传感器显示灯亮.

解决方案:红外避障传感器在使用前没有调节灵敏度,灵敏度过高,导致无论附近有无

障碍物,输出指示灯都亮着,并且输出低电平.查阅资料后得知,通过调节传感器中间的旋

钮即可调节灵敏度,以输出指示灯亮灭交界时障碍物与传感器的距离作为依据,设定应该在

什么距离下开始执行避障动作.

问题３:在所有导线都连接好的情况下出现电压值异常.

解决方案:线路在面包板上并接后出现电压值异常,无法工作.排查后发现是导线连

接松动导致的,在导线与直流电机铜片接触处需要热熔胶固定来保证接触稳定.

问题４:匹配不到蓝牙遥控模块.

解决方案:Arduino开发板程序打开的蓝牙串口波特率与 HCＧ０５默认波特率不匹配导

致无法通信.使用语句 Serial．begin(９６００)初始化串口通信,并将波特率设为９６００,问题得

以解决.

问题５:Arduino开发板程序下载出现错误.

解决方案:Arduino开发板程序下载时出现错误.经检查发现,在设备管理器的通信

端口一栏中查看 Arduino开发板所接的通信端口,并在 Arduino开发板的工具栏中设置开

发板类型和通信端口,如有不一致也会导致程序无法下载.

问题６:吸尘器的风力不够.

解决方案:通过对吸尘器进行通电测试,发现吸尘器的封装性不够强.由于吸尘器的

箱子是自制的,密封性不是很好.在购买风扇时,特别关注了风扇的功率,在２０W 左右,所

以正常情况下,风力是足够的,于是用胶带对于封闭性不强的地方做了处理.另外,发现用

于吸尘的塑料软管在箱子中的长度过长,严重阻碍了吸力的大小,当减小了软管在箱子内的

长度后,吸力大大提升.

问题７:吸尘器的垃圾处理问题.

解决方案:由于箱子是 自 制 的,最 开 始 只 考 虑 往 里 吸 尘,并 没 有 考 虑 往 外 倒 垃 圾 的 问

题,最后决定将箱子做成抽屉,方便垃圾的外倒.

问题８:蓝牙模块无法配对.

由于iPhone的蓝牙模块中载有加密芯片,需认证才能与其他蓝牙设备对接,所以暂时

只能使用安卓或其他系统的手机进行配对.使用蓝牙串口 APP 时需注意串口发送的字符

要与程序中设置的字符一致.

[]{#index_split_005.html#p285}![index-285_1.png](https://i.imgur.com/4FTlQze.jpeg){.calibre2}

２７４

１０．

６　元件清单

完成本项目所用到的元件及数量如表１０Ｇ２所示.

表１０Ｇ２　遥控吸尘器元件清单

模　　块

元件/测试仪表

数量

ArduinoUNO 开发板

１个

Arduino直流电机驱动扩展板

１个

L２９８N 直流电机驱动板

１个

红外避障传感器

２个

蓝牙模块 HCＧ０５

１个

控制模块　

面包板

１个

南孚聚能环５号电池

６节

１８６５０充电锂电池组

１个

导线

若干

杜邦线

若干

椴木板

２个

１２V 风扇

１个

吸尘器模块

塑料软管

１个

纱布

２个

底盘

２个

车轮

２个

底盘部分　

万向轮

１个

螺丝

若干

铜柱

若干

[]{#index_split_005.html#p286}![index-286_1.png](https://i.imgur.com/1Ro2Dol.jpeg){.calibre2}

第１１章

写字报时机器人项目设计

１１．

１　项目背景

随着科学技术的发展,人们希望繁杂的工作可以由机器人代替完成.近年来,出现了能

够画画的机器人,根据像素点来控制作画.但是,由于像素点的处理太过复杂,环境基础设

施和自身条件限制了其推广应用.本项目基于 Arduino平台开发了一款可以写数字报时计

算的写字机器人.考虑利用智能车的行进轨迹来书写文字时,持笔书写的稳定性不够,本项

目决定使用机械臂并且固定写字板来实现文字的书写.

１１．

２　创新描述

写字机器人通过机械臂持笔在固定好的白板上书写时间达到报时的目的.它写下当前时

间,擦掉,再写新的时间.因为有时钟模块,即使断电后再通电,仍然可以书写最新的时间.

机器人将写字和报时功能结合起来,不仅可以人为控制书写内容,还可以通过时钟模块

获取当前时间后,自动调用函数书写当前时间.由于时钟模块配备了电池,就算机器人断电

后再通电,仍然可以书写当前时间.后期又添加了计算器功能,通过手机蓝牙串口向机器人

输入四则运算式,机器人能够计算并写出结果.

１１．

３　功能及总体设计

本作品主要分为三部分进行设计:写字部分、时钟部分和蓝牙输入计算器部分.写字

部分的主要功能是在白板上的任意位置写出数字０\~９;时钟部分的主要功能是获取当前时

间;蓝牙输入计算器部分的主要功能是通过手机蓝牙串口向蓝牙模块输入算式,计算出所

输入的算式结果.

本章根据刘若琪、赵晶蕊项目设计整理而成.

[]{#index_split_005.html#p287}![index-287_1.png](https://i.imgur.com/L10LSne.jpeg){.calibre2}

![index-287_2.png](https://i.imgur.com/ELClSCx.jpeg){.calibre2}

２７６

１１．

３．

１　功能介绍

根据机械臂转动的角度关系,编写了在白板的任意位置书写数字的函数(由若干个函数

共同组成).从时钟模块获取当前时间后调用写字函数,书写出当前时间.计算器程序计算

算式结果后也调用写字函数书写结果.

只要机器人通电即可实现书写时间功能,当手机通过蓝牙输入算式时,机器人执行计算

器功能;当手机不输入数据时,机器人执行报时功能并书写时间.

１１．

３．

２　总体设计

要实现上述功能需要 将 作 品 分 成 三 部 分 进 行 设 计:输 入 部 分、输 出 部 分 和 处 理 部 分.

输入部分选用了蓝牙模块和时钟模块;输出部分使用舵机驱动机械臂在亚克力板上进行书

写;处理部分使用 ArduinoUNO 开发板.

１．整体框架图

项目的整体框架如图１１Ｇ１所示.

图１１Ｇ１　整体框架图

２．系统流程图

系统流程图如图１１Ｇ２所示.

接通电源后,主程序开始工作.如果时钟模块有初始化数据,则对其进行初始化,然后

读取其数据,否则直接读取时钟模块当前数据,机器人开始调用写字函数写出时间;如果手

机通过蓝牙发送四则运算式,则在擦掉当前时间后,机器人调用计算器函数计算出答案后, 调用写字函数写出答案.断开电源,所有流程结束,系统停止运行.

３．总电路图

系统总电路如图１１Ｇ３所示.

如图１１Ｇ３所示,由于接线端并不繁杂,所以并没有使用功能扩展板,只加了一块面包

板,用于将每个模块的电源端和地线接在一起.

[]{#index_split_005.html#p288}![index-288_1.png](https://i.imgur.com/HB7c0bK.jpeg){.calibre2}

![index-288_2.png](https://i.imgur.com/wv84Yeh.jpeg){.calibre2}

![index-288_3.png](https://i.imgur.com/o5fxqKq.jpeg){.calibre2}

２７７

图１１Ｇ２　系统流程图

图１１Ｇ３　总电路图

[]{#index_split_005.html#p289}![index-289_1.png](https://i.imgur.com/j2o4go9.jpeg){.calibre2}

![index-289_2.png](https://i.imgur.com/eoKQN8X.jpeg){.calibre2}

![index-289_3.png](https://i.imgur.com/maUnsWf.jpeg){.calibre2}

![index-289_4.png](https://i.imgur.com/u18pOxS.jpeg){.calibre2}

![index-289_5.png](https://i.imgur.com/QsaNbw6.jpeg){.calibre2}

![index-289_6.png](https://i.imgur.com/uAe02MB.jpeg){.calibre2}

![index-289_7.png](https://i.imgur.com/Qcar1JI.jpeg){.calibre2}

![index-289_8.png](https://i.imgur.com/JGKscj7.jpeg){.calibre2}

![index-289_9.png](https://i.imgur.com/bRb5u2y.jpeg){.calibre2}

![index-289_10.png](https://i.imgur.com/xf33OeH.jpeg){.calibre2}

![index-289_11.png](https://i.imgur.com/cXvuQom.jpeg){.calibre2}

![index-289_12.png](https://i.imgur.com/nMte229.jpeg){.calibre2}

![index-289_13.png](https://i.imgur.com/LMmRDof.jpeg){.calibre2}

![index-289_14.png](https://i.imgur.com/EeWRNjK.jpeg){.calibre2}

![index-289_15.png](https://i.imgur.com/QQNCoRf.jpeg){.calibre2}

２７８

图中有三个舵机lift、

left和right,分别控制抬笔、落笔和左右机械臂的转动,将它们的

控制端分别接于数字I/O 引脚的２、

３、

４;时钟模块 DS１３０２的 RST 复位引脚接于数字I/O

引脚５,DAT 引脚接于数字I/O 引脚６,时钟输入引脚SCLK 接于数字I/O 引脚７;蓝牙模

块 HCＧ０５的 TX 引脚接数字I/O 引脚１０,RX 引脚接数字I/O 引脚１１;将所有模块的 VCC

引脚并联接于５V 电压,地线接在一起,接于同一接地引脚,从而实现了整个电路的完整连

接.时钟模块和蓝牙模块作为输入,舵机作为输出,进而通过获取时间和蓝牙指令控制机械

臂的运动以达到书写时间的目的.

１１．

３．

３　模块介绍

本项目主要包括主程序模块、写字模块和计算器模块.下面分别给出各模块的功能、元

件、电路图和相关代码.

１．主程序模块

１)功能介绍

确定舵机０°、

９０°和１８０°时的 PWM,设定舵机初始位置;创建 DS１３０２对象,开启计算

机串口以及蓝牙串口与 Arduino开发板的通信.当蓝牙串口没有向 Arduino开发板发送信

息时,判断计算机串口有无发送重置时间信息,若无则获取当前时间调用写字函数书写;当

蓝牙串口向 Arduino开发板发送了计算信息,则调用计算器函数.

２)相关代码

＃include stdio敭h

＃include String敭h

＃include DS１３０２敭h

时钟模块的类库

＃include stdlib敭h

＃include Servo敭h

控制舵机的类库

＃include Wire敭h

＃include SoftwareSerial敭h

定义软串口的类库

SoftwareSerialmySerial １０ １１

引脚１０为RX 引脚１１为TX

左右悬臂舵机的９０°位置

＃defineSERVOFAKTORLEFT６１０

＃defineSERVOFAKTORRIGHT５８０

左右悬臂舵机的 ０°或１８０°位置

＃defineSERVOLEFTNULL１９００

＃defineSERVORIGHTNULL１１００

三个舵机的接口

＃defineSERVOPINLIFT２

＃defineSERVOPINLEFT３

＃defineSERVOPINRIGHT４

升举舵机的三个角度

＃defineLIFT０１５８０

接触写字板

[]{#index_split_005.html#p290}![index-290_1.png](https://i.imgur.com/Dt9aq1o.jpeg){.calibre2}

２７９

＃defineLIFT１１３００

在数字间移动

＃defineLIFT２１１００

插入笔擦

速度

＃defineLIFTSPEED１５００

悬臂的长度 以毫米为单位

＃defineL１３５

＃defineL２５７敭

２

＃defineL３１４敭

２

左右舵机轴心的坐标位置

＃defineO１X２２

＃defineO１Y－２５

＃defineO２X４７

＃defineO２Y－２５

时钟模块的三个接口

uint８_tRST_PIN ＝ ５

uint８_tDAT_PIN ＝ ６

uint８_tCLK_PIN ＝ ７

日期变量缓存

charbuf ５０

charday １０

计算机串口数据缓存

Stringcomdata＝ ＂＂

intnumdata ７ ＝ ０ j＝ ０ mark＝ ０

蓝牙串口数据缓存

Stringcomdata２ ＝ ＂＂

charflag

intnumdata２ ２ ＝ ０

创建 DS１３０２ 对象

DS１３０２rtc RST_PIN DAT_PIN CLK_PIN

intservoLift ＝ １５００

Servoservo１

Servoservo２

Servoservo３

volatiledoublelastX ＝ ７０

volatiledoublelastY ＝ ４２

intlast_min ＝ ０

voidsetup

Serial敭

begin ９６００

mySerial敭

begin ９６００

rtc敭

write_protect false

rtc敭

halt false

[]{#index_split_005.html#p291}![index-291_1.png](https://i.imgur.com/y7Vbuk4.jpeg){.calibre2}

![index-291_2.png](https://i.imgur.com/EXvRJ16.jpeg){.calibre2}

![index-291_3.png](https://i.imgur.com/m2FYkTp.jpeg){.calibre2}

![index-291_4.png](https://i.imgur.com/PLG2fOQ.jpeg){.calibre2}

２８０

lift ２

drawTo ７０ ４２

servo１敭

attach SERVOPINLIFT

升降舵机

servo２敭

attach SERVOPINLEFT

左舵机

servo３敭

attach SERVOPINRIGHT

右舵机

delay １０００

voidloop

if mySerial敭available

如果蓝牙串口收到计算公式

while mySerial敭

available ０

comdata２＋＝ char mySerial敭

read

delay ２

if

servo１敭

attached servo１敭

attach SERVOPINLIFT

if

servo２敭

attached servo２敭

attach SERVOPINLEFT

if

servo３敭

attached servo３敭

attach SERVOPINRIGHT

calculator

调用计算器函数

comdata２ ＝ String ＂＂

清空comdata２以便下次使用

else

如果蓝牙串口没有收到计算公式

while Serial敭available ０

如果计算机串口收到重置时钟模块的信息

comdata ＋＝ char Serial敭

read

delay ２

mark ＝ １

以逗号分隔分解comdata的字符串 分解结果转换成数字保存到numdata 数组

if mark＝＝ １

Serial敭

print ＂Youinputed ＂

Serial敭

println comdata

for inti＝ ０ i comdata敭

length i++

if comdata i ＝＝ \' \'\|\|comdata i ＝＝ ０x１０\|\|comdata i ＝＝ ０x１３

j++

else

[]{#index_split_005.html#p292}![index-292_1.png](https://i.imgur.com/2ypsd7k.jpeg){.calibre2}

![index-292_2.png](https://i.imgur.com/pCv1e1P.jpeg){.calibre2}

![index-292_3.png](https://i.imgur.com/2gRHx4x.jpeg){.calibre2}

![index-292_4.png](https://i.imgur.com/XUuHtve.jpeg){.calibre2}

２８１

numdata j ＝ numdata j ∗ １０ ＋ comdata i － \'０\'

将转换好的numdata转换成时间格式 写入DS１３０２

Timet numdata ０ numdata １ numdata ２ numdata ３ numdata ４ numdata ５

numdata ６

rtc敭

time t

mark ＝ ０

j＝０

清空comdata变量 以便等待下次输入

comdata ＝ String ＂＂

清空numdata变量

for inti＝ ０ i ７ i++ numdata i ＝０

在计算机串口打印当前时间

print_time

Timehm ＝ rtc敭

time

从时钟模块获取时间

inti ＝ ０

if １\|\|last_min

＝ hm敭

min

去掉１则每分钟书写一次

if

servo１敭

attached servo１敭

attach SERVOPINLIFT

if

servo２敭

attached servo２敭

attach SERVOPINLEFT

if

servo３敭

attached servo３敭

attach SERVOPINRIGHT

while i＋１ ∗１０ ＝ hm敭hr

i++

写小时

number ５ １８ i

１敭

１

number １９ １８ hm敭

hr－i∗１０

１敭

１

写冒号

number ２８ １８ １１

１敭

２

i＝０

while i＋１ ∗１０ ＝ hm敭min

i++

写分钟

number ３４ １８ i １敭

１

测试获得第一个字合适的中点为 ３４

１８

number ４８ １８ hm敭

min－i∗１０ １敭

１

测试获得第一个字合适的中点为 ４８

１８

lift ２

[]{#index_split_005.html#p293}![index-293_1.png](https://i.imgur.com/OqjWBVB.jpeg){.calibre2}

![index-293_2.png](https://i.imgur.com/WLOy89O.jpeg){.calibre2}

２８２

drawTo ７３ ４５

笔擦

delay １０００

lift １

擦掉白板上的字体

number ３ ３ １１１ １敭

７

last_min ＝ hm敭

min

servo１敭

detach

servo２敭

detach

servo３敭

detach

２．写字模块

１)功能介绍

可以在白板上的任意位置书写数字.

２)算法设计及相关代码

(１)机械臂的几何关系

首先,以白板左下角为原点,向上为y 轴,向右为x 轴建立直角坐标系.先求左舵机转

动角度 和 坐 标 位 置 的 关 系,设 笔 的 位 置 为 (

x,y),左 右 舵 机 的 位 置 分 别 为 (x０１,y０１),

(x０２,y０２),L１、L２、L３ 以及角度如图１１Ｇ４所示.

图１１Ｇ４　左舵机几何原理图

其中,

α１ ＝cos－１L２１ ＋x２ ＋y２ －L２２

２L１ x２ ＋y２

α２ ＝tan－１y－y０１

x－x０１

对于右舵机,笔的位置与右臂连接点的位置不确定,所以对右臂假设了一个类似左臂的

关系,找到一个辅助点 C,这个辅助点和连接点的位置是不变的,恒为 L２－L３.所以,角度

[]{#index_split_005.html#p294}![index-294_1.png](https://i.imgur.com/D4AvtFp.jpeg){.calibre2}

![index-294_2.png](https://i.imgur.com/0PLcvXn.jpeg){.calibre2}

２８３

关系如图１１Ｇ５所示.

图１１Ｇ５　右舵机几何原理图

其中,

x′ ＝x＋L３cos(

α１ －α２ ＋０．６２１＋π)

y′ ＝x＋L３sin(

α１ －α２ ＋０．６２１＋π)

α１ ＝tan－１y′－y０２

x′－x０２

C ＝ 　 x

( ′－x０２ )２ ＋ y

( ′－y０２ )２

２

α

＋C２ － L

( ２ －L３ )２

２ ＝c

os－１L１

２L１C

(２)相关代码

doublereturn_angle doublea doubleb doublec 计算夹角的余弦公式

returnacos a∗ a＋ c∗ c－ b∗ b ２ ∗ a∗ c voidset_XY doubleTx doubleTy

delay １

doubledx dy c a１ a２ Hx Hy

计算与左舵机 x０１ y０１ 的坐标差

dx ＝ Tx － O１X

dy ＝ Ty － O１Y

计算C的长度以及两个夹角的大小

c ＝ sqrt dx∗ dx＋ dy∗ dy

a１ ＝ atan２ dy dx

a２ ＝ return_angle L１ L２ c

servo２敭

writeMicroseconds floor a２ ＋ a１ － M_PI ∗ SERVOFAKTORLEFT ＋ SERVOLEFTNULL

[]{#index_split_005.html#p295}![index-295_1.png](https://i.imgur.com/8VEsB1T.jpeg){.calibre2}

![index-295_2.png](https://i.imgur.com/KI8JiwK.jpeg){.calibre2}

![index-295_3.png](https://i.imgur.com/aXhPpZJ.jpeg){.calibre2}

２８４

左臂转动

计算右臂的角度关系

a２ ＝ return_angle L２ L１ c

０敭

６２１为３６敭

５°转化为弧度的值 非精确测量 在程序中微调所得

Hx ＝ Tx ＋ L３ ∗ cos a１ － a２ ＋ ０敭

６２１ ＋ M_PI

Hy ＝ Ty ＋ L３ ∗ sin a１ － a２ ＋ ０敭

６２１ ＋ M_PI

dx ＝ Hx － O２X

dy ＝ Hy － O２Y

c ＝ sqrt dx∗ dx＋ dy∗ dy

a１ ＝ atan２ dy dx

a２ ＝ return_angle L１ L２ － L３ c

servo３敭

writeMicroseconds floor a１ － a２ ∗ SERVOFAKTORRIGHT ＋ SERVORIGHTNULL

右臂转动

上面的函数确定了坐标点位置 需要一个函数控制连接点

drawTo实现了这个功能

voiddrawTo doublepX doublepY

doubledx dy c

inti

下一个点与当前点距离的差值

dx ＝ pX － lastX

dy ＝ pY － lastY

乘以４的功能是使得点与点之间的连接更平滑 每一步走得更短

c ＝ floor ４ ∗ sqrt dx∗ dx＋ dy∗ dy

if c １ c＝ １

for i＝ ０ i ＝ c i++

把点和点连接起来

set_XY lastX＋ i∗ dx c lastY＋ i∗ dy c lastX ＝ pX

将当前点设置为过去点

lastY ＝ pY

∗考虑大多数数字有圆的部分 这种数字用坐标点写出来显得太方正 所以增加了两个顺时针画圆

和逆时针画圆的函数∗

顺时针画圆

voidbogenUZS floatbx floatby floatradius intstart intende floatsqee

∗ bx by 为圆心坐标 radius为半径 start和end为起始和结束角度 sqee用于调节圆的大小∗

floatinkr ＝ －０敭

０５

一次转动的角度大小

floatcount ＝ ０

do

drawTo sqee∗ radius∗ cos start＋ count ＋ bx

[]{#index_split_005.html#p296}![index-296_1.png](https://i.imgur.com/cjFyx0p.jpeg){.calibre2}

![index-296_2.png](https://i.imgur.com/qnWxodN.jpeg){.calibre2}

![index-296_3.png](https://i.imgur.com/schPUeo.jpeg){.calibre2}

２８５

radius ∗ sin start＋ count ＋ by

count ＋＝ inkr

while start＋ count ende

逆时针画圆

voidbogenGZS floatbx floatby floatradius intstart intende floatsqee floatinkr ＝ ０敭

０５

floatcount ＝ ０

do

drawTo sqee∗ radius∗ cos start＋ count ＋ bx radius ∗ sin start＋ count ＋ by

count ＋＝ inkr

while start＋ count ＝ ende

在以上函数的基础上 实现写字函数

voidnumber floatbx floatby intnum floatscale bx

by 为落笔的坐标点

scale为字体的大小

switch num

case０

drawTo bx＋ １２ ∗ scale by＋ ６ ∗ scale

lift ０

bogenGZS bx＋ ７ ∗ scale by＋ １０ ∗ scale １０ ∗ scale －０敭

８ ６敭

７ ０敭

５

lift １

break

case１

drawTo bx＋ ３ ∗ scale by＋ １５ ∗ scale

lift ０

drawTo bx＋ １０ ∗ scale by＋ ２０ ∗ scale

drawTo bx＋ １０ ∗ scale by＋ ０ ∗ scale

lift １

break

case２

drawTo bx＋ ２ ∗ scale by＋ １２ ∗ scale

lift ０

bogenUZS bx＋ ８ ∗ scale by＋ １４ ∗ scale ６ ∗ scale ３ －０敭

８ １

drawTo bx＋ １ ∗ scale by＋ ０ ∗ scale

drawTo bx＋ １２ ∗ scale by＋ ０ ∗ scale

lift １

[]{#index_split_005.html#p297}![index-297_1.png](https://i.imgur.com/AVOCCuz.jpeg){.calibre2}

２８６

break

case３

drawTo bx＋ ２ ∗ scale by＋ １７ ∗ scale

lift ０

bogenUZS bx＋ ５ ∗ scale by＋ １５ ∗ scale ５ ∗ scale ３ －２ １

bogenUZS bx＋ ５ ∗ scale by＋ ５ ∗ scale ５ ∗ scale １敭

５７ －３ １

lift １

break

case４

drawTo bx＋ １０ ∗ scale by＋ ０ ∗ scale

lift ０

drawTo bx＋ １０ ∗ scale by＋ ２０ ∗ scale

drawTo bx＋ ２ ∗ scale by＋ ６ ∗ scale

drawTo bx＋ １２ ∗ scale by＋ ６ ∗ scale

lift １

break

case５

drawTo bx＋ ２ ∗ scale by＋ ５ ∗ scale

lift ０

bogenGZS bx＋ ５ ∗ scale by＋ ６ ∗ scale ６ ∗ scale －２敭

５ ２ １

drawTo bx＋ ５ ∗ scale by＋ ２０ ∗ scale

drawTo bx＋ １２ ∗ scale by＋ ２０ ∗ scale

lift １

break

case６

drawTo bx＋ ２ ∗ scale by＋ １０ ∗ scale

lift ０

bogenUZS bx＋ ７ ∗ scale by＋ ６ ∗ scale ６ ∗ scale ２ －４敭

４ １

drawTo bx＋ １１ ∗ scale by＋ ２０ ∗ scale

lift １

break

case７

drawTo bx＋ ２ ∗ scale by＋ ２０ ∗ scale

lift ０

drawTo bx＋ １２ ∗ scale by＋ ２０ ∗ scale

drawTo bx＋ ２ ∗ scale by＋ ０

lift １

break

case８

drawTo bx＋ ５ ∗ scale by＋ １０ ∗ scale

lift ０

bogenUZS bx＋ ５ ∗ scale by＋ １５ ∗ scale ５ ∗ scale ４敭

７ －１敭

６ １

[]{#index_split_005.html#p298}![index-298_1.png](https://i.imgur.com/O4GSXfe.jpeg){.calibre2}

２８７

bogenGZS bx＋ ５ ∗ scale by＋ ５ ∗ scale ５ ∗ scale －４敭

７ ２ １

lift １

break

case９

drawTo bx＋ ９ ∗ scale by＋ １１ ∗ scale

lift ０

bogenUZS bx＋ ７ ∗ scale by＋ １５ ∗ scale ５ ∗ scale ４ －０敭

５ １

drawTo bx＋ ５ ∗ scale by＋ ０

lift １

break

case１１１

擦白板

lift ０

drawTo ７０ ４２

drawTo ６５ ４２

drawTo ６５ ４５

drawTo ５ ４５

drawTo ５ ４５

drawTo ６０ ４５

drawTo ６０ ４０

drawTo ５ ４０

drawTo ５ ３５

drawTo ６０ ３５

drawTo ６０ ３０

drawTo ５ ３０

drawTo ５ ２５

drawTo ６０ ２５

drawTo ６０ ２０

drawTo ５ ２０

drawTo ６０ ４２

drawTo ７７ ４２

lift ２

break

case１１

时间中间的冒号

drawTo bx＋ ５ ∗ scale by＋ １５ ∗ scale

lift ０

bogenGZS bx＋ ５ ∗ scale by＋ １５ ∗ scale ０敭

１ ∗ scale １ －１ １

lift １

drawTo bx＋ ５ ∗ scale by＋ ５ ∗ scale

lift ０

bogenGZS bx＋ ５ ∗ scale by＋ ５ ∗ scale ０敭

１ ∗ scale １ －１ １

lift １

break

[]{#index_split_005.html#p299}![index-299_1.png](https://i.imgur.com/4KoJMiM.jpeg){.calibre2}

![index-299_2.png](https://i.imgur.com/V0A2Ru7.jpeg){.calibre2}

![index-299_3.png](https://i.imgur.com/YqUmW8C.jpeg){.calibre2}

![index-299_4.png](https://i.imgur.com/4dpTPSR.jpeg){.calibre2}

![index-299_5.png](https://i.imgur.com/W5l9l31.jpeg){.calibre2}

![index-299_6.png](https://i.imgur.com/qpm5I6f.jpeg){.calibre2}

![index-299_7.png](https://i.imgur.com/KDjdBjR.jpeg){.calibre2}

![index-299_8.png](https://i.imgur.com/WLH7zjx.jpeg){.calibre2}

![index-299_9.png](https://i.imgur.com/vmJ7Zgw.jpeg){.calibre2}

２８８

白板下方的lift舵机控制机械臂的抬起和放下 实现起笔、落笔和插入笔擦的功能

直接使舵机转动到相应角度对舵机有一定损害 所以采用缓慢转动的方式

voidlift intlift

switch lift

case０

接触写字板

if servoLift ＝ LIFT０

while servoLift ＝ LIFT０

servoLift－－

servo１敭

writeMicroseconds servoLift

delayMicroseconds LIFTSPEED

else

while servoLift ＝ LIFT０

servoLift++

servo１敭

writeMicroseconds servoLift

delayMicroseconds LIFTSPEED

break

case１

书写不同数字之间的抬起

if servoLift ＝ LIFT１

while servoLift ＝ LIFT１

servoLift－－

servo１敭

writeMicroseconds servoLift

delayMicroseconds LIFTSPEED

else

while servoLift ＝ LIFT１

servoLift++

servo１敭

writeMicroseconds servoLift

delayMicroseconds LIFTSPEED

break

case２

插入笔擦

if servoLift ＝ LIFT２

while servoLift ＝ LIFT２

[]{#index_split_005.html#p300}![index-300_1.png](https://i.imgur.com/nCTBRW5.jpeg){.calibre2}

![index-300_2.png](https://i.imgur.com/4IyxbBO.jpeg){.calibre2}

![index-300_3.png](https://i.imgur.com/cy8MqIO.jpeg){.calibre2}

２８９

servoLift－－

servo１敭

writeMicroseconds servoLift

delayMicroseconds LIFTSPEED

else

while servoLift ＝ LIFT２

servoLift++

servo１敭

writeMicroseconds servoLift

delayMicroseconds LIFTSPEED

break

３．计算器模块

１)功能介绍

从蓝牙收到计算式并进行计算,将计算结果书写出来(和蓝牙的通信在主程序模块中实

现),电路如图１１Ｇ６所示.

图１１Ｇ６　电路原理图

蓝牙模块 HCＧ０５的 TX 引脚接数字I/O 引脚１０,RX 引脚接数字I/O 引脚１１;电源接

５V,地线接在 Arduino开发板的 GND 引脚.

２)相关代码

voidcalculator

intj＝０

intd＝０

[]{#index_split_005.html#p301}![index-301_1.png](https://i.imgur.com/K1DGREB.jpeg){.calibre2}

![index-301_2.png](https://i.imgur.com/JKv9Rhl.jpeg){.calibre2}

![index-301_3.png](https://i.imgur.com/9TaxAcT.jpeg){.calibre2}

![index-301_4.png](https://i.imgur.com/PDv83kV.jpeg){.calibre2}

２９０

for inti＝ ０ i comdata２敭

length i++

if comdata２ i ＝＝ \'＋ \'\|\|comdata２ i ＝＝ \'－ \'\|\|comdata２ i ＝＝ \'∗ \'\|\|comdata２ i ＝＝ \' \'

flag＝comdata２ i

j++

else

如果没有运算符号 则将读到的数字乘以１０并加上以前读入的数字

comdata２ i － \'０\' 就是将字符 \'０\'的ASCII码转换成数字０

第一次循环numdata２ ０ ＝ ０∗１０＋１ ＝ １

第二次numdata２ ０ 等于１ 循环是numdata２ ０ ＝ １∗１０＋２ ＝ １２

第三次numdata２ ０ 等于１２ 循环是numdata２ ０ ＝ １２∗１０＋３ ＝ １２３

numdata２ j ＝ numdata２ j ∗ １０ ＋ comdata２ i － \'０\'

switch flag

case \'＋ \'

d＝ numdata２ ０ ＋numdata２ １

break

case \'－ \'

d＝ numdata２ ０ －numdata２ １

break

case \'∗ \'

d＝ numdata２ ０ ∗numdata２ １

break

case \' \'

d＝ numdata２ ０ numdata２ １

break

default

mySerial敭

println ＂Error

Pleaseinputequationagain敭

＂

mySerial敭

println d

蓝牙串口打印结果

numdata２ ２ ＝ ０

重置数组便于下次使用

∗以下程序将结果的每个数字分开便于书写

目前的程序能够计算一万以内的数字∗

if d ＝９

number ５ １８ d

１敭

１

调用写字函数书写时间

elseif d ＝９９

[]{#index_split_005.html#p302}![index-302_1.png](https://i.imgur.com/S7eSK7M.jpeg){.calibre2}

![index-302_2.png](https://i.imgur.com/xXfPCjq.jpeg){.calibre2}

![index-302_3.png](https://i.imgur.com/BvkFB2x.jpeg){.calibre2}

![index-302_4.png](https://i.imgur.com/BdG6wqI.jpeg){.calibre2}

![index-302_5.png](https://i.imgur.com/K11hWWP.jpeg){.calibre2}

![index-302_6.png](https://i.imgur.com/JypiWU1.jpeg){.calibre2}

![index-302_7.png](https://i.imgur.com/KEzUX07.jpeg){.calibre2}

![index-302_8.png](https://i.imgur.com/jtQ2Kb4.jpeg){.calibre2}

２９１

ints＝０

while s＋１ ∗１０ ＝ d

s++

number ５ １８

s

１敭

１

number １９

１８

d－s∗１０

１敭

１

elseif d ＝９９９

intb＝０

ints＝０

while b＋１ ∗１００ ＝ d

b++

while s＋１ ∗１０ ＝ d－b∗１００

s++

number ５ １８ b

１敭

１

number １９ １８ s

１敭

１

number ３４ １８ d－b∗１００－s∗１０ １敭

１

else

intq＝０

intb＝０

ints＝０

while q＋１ ∗１０００ ＝ d

q++

while b＋１ ∗１００ ＝ d－q∗１０００

b++

while s＋１ ∗１０ ＝ d－q∗１０００－b∗１００

s++

number ５ １８ q

１敭

１

[]{#index_split_005.html#p303}![index-303_1.png](https://i.imgur.com/9lvMHIg.jpeg){.calibre2}

![index-303_2.png](https://i.imgur.com/WNu46Nx.jpeg){.calibre2}

![index-303_3.png](https://i.imgur.com/6K9DN6f.jpeg){.calibre2}

![index-303_4.png](https://i.imgur.com/OWGUEfJ.jpeg){.calibre2}

２９２

number １９ １８ b

１敭

１

number ３４ １８ s １敭

１

number ４８ １８

d－q∗１０００－b∗１００－s∗１０ １敭

１

１１．

４　产品展示

产品整体外观如图１１Ｇ７所示.左上方是 Arduino开发板和面包板,上面连接时钟模块

和蓝牙模块,用于获取时间和接收指令数据;右上方是一套亚克力板,接有三个舵机,舵机

控制引脚接于 Arduino开发板相关引脚,舵机连接机械臂,将笔固定于机械臂前端,从而可

在白板上书写时间数字.

图１１Ｇ７　整体外观

蓝牙模块如图１１Ｇ８所示;时钟模块如图１１Ｇ９所示;舵机模块如图１１Ｇ１０和图１１Ｇ１１所

示;亚克力机械臂如图１１Ｇ１２所示.

图１１Ｇ８　蓝牙模块 HCＧ０５

图１１Ｇ９　时钟模块 DS１３０２

[]{#index_split_005.html#p304}![index-304_1.png](https://i.imgur.com/f8V5GAr.jpeg){.calibre2}

![index-304_2.png](https://i.imgur.com/wUHMZXS.jpeg){.calibre2}

![index-304_3.png](https://i.imgur.com/Q6kucr4.jpeg){.calibre2}

![index-304_4.png](https://i.imgur.com/zT0u71r.jpeg){.calibre2}

２９３

图１１Ｇ１０　舵机 Lift

图１１Ｇ１１　舵机 Left、Right

图１１Ｇ１２　亚克力机械臂和白板

１１．

５　故障及问题分析

问题１:没有充分了解舵机的工作原理就直接组装了机械臂,导致机械臂持笔无法触碰

到白板的每一个点.

解决方 案:先 测 试 舵 机,使 其 ９０°时,机 械 臂 垂 直 于 白 板,则 可 以 触 碰 到 白 板 的 每 一

个点.

问题２:舵机的角度不准确,令舵机由０°旋转到１８０°时,舵机旋转了２００°左右,获取舵

机参数较难实现.

解决方案:由于舵机到达每个位置的角度与理论值相差较大,无法直接构造写字路径, 于是在白板上均匀地设置６×８＝４８个点,编写程序测试出笔落在每个点时舵机所旋转的角

度,即 PWM 值,由此逐点规划字体路径.

问题３:通过蓝牙输入指令得不到正确的反馈,通过计算机输入指令时却可以得到正确

的反馈.

[]{#index_split_005.html#p305}![index-305_1.png](https://i.imgur.com/f0HRnEP.jpeg){.calibre2}

２９４

解决方案:根据函数反馈得知,蓝牙模块无法正确读出所输入指令,开始以为是手机的

加减乘除４个符号的格式,无法被 Arduino开发板识别(因为是以 ASCII码方式发送的).

而后发现,蓝牙串口根本没有收到信息,并且蓝牙串口一旦向窗口打印信息就会中断蓝牙连

接.经查资料得知,串口波特率设置不恰当,修改后问题得以解决.

问题４:使用时钟模块时,DS１３０２库文件在 ArduinoIDE中存在问题,并且无法调用库

文件里面的函数.

解决方案:下载的 DS１３０２库文件版本低,这个库文件里面包含一个改名库文件,所以

导致 DS１３０２ 库文件无法编译成功,后查询到该改名库文件的新名字,进行置换后编译成

功,DS１３０２库文件可以正常使用.

问题５:由于考虑不够严密,编写的计算器函数并不能获取多位整数,只能获取个位int 型数字,使计算器功能无法按预期实现.

解决方案:整合代码时发现问题并修改算法,使其能够获取多位整数,从而实现了计算

器这一功能.

问题６:更换新的算法后,由于舵机的精确度不高,而三角函数又属于理论计算,写出的

直线不够整齐.

解决方案:不采用类似数码管显示的字体,依靠圆的轨迹,可以较为漂亮地写出大多数

数字,字的大小也可调,但是某些数字的书写还是不甚美观.不再使用之前的servo．write() 函数,而是采用servo．writeMicroseconds(),控制更为精确.

１１．

６　元件清单

完成本项目所用到的元件及数量如表１１Ｇ１所示.

表１１Ｇ１　报时写字机器人元件清单

元件/测试仪表

数量

杜邦线

若干

S９GO 舵机

３个

HCＧ０５蓝牙模块

１个

DS１３０２时钟模块

１个

ArduinoUNO 开发板

１个

面包板

１个

亚克力板

１个

螺钉、螺母

若干

白板笔

１个

[]{#index_split_005.html#p306}![index-306_1.png](https://i.imgur.com/lbs6Snn.jpeg){.calibre2}

第１２章

棋盘小游戏之守护

绿色项目设计

１２．

１　项目背景

项目的灵感来源于风靡微信的一款小游戏«围住神经猫».这是一款非常益智的小游

戏,以简单的规则、丰富的玩法成了人们打发闲暇时间的热门选择.玩法为:人们用棋子去

围堵猫,不让猫到达边界,若 围 堵 失 败,则 玩 家 输;若 围 堵 成 功,猫 不 能 再 移 动,则 玩 家 赢.

但是,由于这是一款在手机上玩的游戏,长时间玩对眼睛有很大伤害,特别是青少年.因此, 本项目将这款游戏开发成实体版的棋盘小游戏,既益智,又护眼.

１２．

２　创新描述

首先,本项目在游戏«围住神经猫»的基础上开发了实体版,即用棋子在５×７的棋盘上

围堵代表猫的绿灯,绿灯有前后左右４个移动方向.并且,本项目设计了输赢结果的显示效

果,若玩家赢,则棋盘上用绿灯显示"W",并闪烁;若玩家输,则用绿灯显示"F",并闪烁.本

项目还设计了闯关模式,玩家可以根据说明书上的关卡摆放棋子,也可以自己设计关卡,事

先摆放棋子设置障碍,有多种玩法.

１２．

３　功能及总体设计

本作品主要分为绿灯显示设计部分和棋子(小磁铁)感应部分.绿灯显示设计部分:游

戏时,用绿灯显示猫的位置和移动路线,并在游戏结束后显示输赢结果,用３５个 LED 绿色

小灯 实 现;棋 子 (小 磁 铁)感 应 部 分:游 戏 时 得 到 棋 子 和 预 先 设 置 障 碍 的 位 置,并 传 到

Arduino开发板中,使用３５个干簧管模块和小磁铁来实现;当小磁铁放到对应干簧管的上

方,干簧管输出低电平;若无棋子,则干簧管输出高电平,以此来确定棋子位置.

本章根据李婷、袁贞项目设计整理而成.

[]{#index_split_005.html#p307}![index-307_1.png](https://i.imgur.com/83p2EPW.jpeg){.calibre2}

![index-307_2.png](https://i.imgur.com/l1a2c5I.jpeg){.calibre2}

２９６

１２．

３．

１　功能介绍

本作品的主要功能为享受休闲益智小游戏乐趣的同时不伤害眼睛.作品的主体为一个

５×７的棋盘和棋子.玩家事先在棋盘上摆放好棋子作为障碍,然后接通电源,看到棋盘中

间的小绿灯亮起,表示游戏开始.接下来玩家需要用棋子围堵小绿灯,避免让它到达边界.

每落一个棋子,小绿灯会移动一次位置,直至围住或顺利到达边界.由于使用实物棋盘和棋

子,比起手机游戏,极大地减少了对人体特别是眼睛的辐射和伤害,减少了眼睛的疲劳,保护

眼睛健康.除此之外,本作品还可以让玩家自己设计关卡,除说明书所给出的几个 关 卡 类

型,玩家可以自 己 摆 放 棋 子 作 为 新 的 关 卡 进 行 游 戏.因 此,本 产 品 给 予 玩 家 无 限 创 造 的

可能.

１２．

３．

２　总体设计

要实现上述功能需要 将 作 品 分 成 三 部 分 进 行 设 计:输 入 部 分、输 出 部 分 和 处 理 部 分.

输入部分主要由小磁铁和干簧管模块组成,其中干簧管模块被排列整齐地固定在万能电路

板上,小磁铁和干簧管模块配合使用,用于获取棋子的位置;输出部分由绿色 LED 组成,用

于在 游 戏 中 表 示 绿 灯 位 置、移 动 方 向 和 游 戏 结 束 时 的 显 示 效 果;处 理 部 分 由 Arduino MEGA２５６０开发板组成,用于处理游戏中绿灯的显示位置,判断游戏是否结束并在结束时

控制绿灯显示相应的效果,以及对所下棋子的位置进行分析计算,给出下一步小绿灯最合适

的位置.

１．整体框架图

项目整体框架如图１２Ｇ１所示.

图１２Ｇ１　整体框架图

[]{#index_split_005.html#p308}![index-308_1.png](https://i.imgur.com/FMBr2HE.jpeg){.calibre2}

![index-308_2.png](https://i.imgur.com/afgKqBz.jpeg){.calibre2}

２９７

２．系统流程图

系统流程图如图１２Ｇ２所示.

图１２Ｇ２　系统流程图

接通电源后,主程序开始工作.游戏过程中每落下一枚棋子,绿灯移动一个位置.直至

游戏结束,显示游戏结果,按下复位键,游戏重新开始.断开电源,所有流程结束,系统停止

运行.

３．总电路图

系统总电路如图１２Ｇ３所示.如图１２Ｇ３所示,本电路连线较为复杂,主要分为干簧管模

块连接部分和小灯泡模块连接部分.

干簧管模块连接主要为三种连线:电源线、接地线和开关线.其中,开关线用于感应磁

场变化并输出高低电平.在该电路图中,每个干簧管的开关线都分别引出连接.电源线和

接地线在实际电路中被焊在了排母上进行连接,在该电路图中用导线相连来表示.每个干

簧管模块的开关线按顺序连接到 Arduino开发板的数字I/O 的０\~３４引脚,由于干簧管模

块按５行７列排列,连线时相同行的开关连接线用同一种颜色表示;每个干簧管模块的接

[]{#index_split_005.html#p309}![index-309_1.png](https://i.imgur.com/QO7DrvL.jpeg){.calibre2}

![index-309_2.png](https://i.imgur.com/lR46cIK.jpeg){.calibre2}

２９８

图１２Ｇ３　系统总电路图

地线都引出并连接在一起,连接起来的线引出一 根 接 在 Arduino开发板的 GND 引脚;每

个干簧管模块的 电 源 线 连 接 在 一 起,连 接 起 来 的 线 引 出 一 根 接 在 Arduino开 发 板 的 ５V

引脚.

小灯泡模块连接部分主要是正极的连线和负极的连线.每个小灯泡的正极连线分别引

出连接在 Arduino开发板数字I/O 引脚的３５\~５３引脚和模拟I/O 的 A１\~A１５引脚;负极

的连线则在实际电路中同样被焊在排母上并连接在一起,在该电路图中用导线相连来表示, 连接起来的线引出一根连接在 Arduino开发板的 GND 引脚.

１２．

３．

３　模块介绍

本项目主要包括棋子位置输入模块、绿灯显示模块、游戏计算模块和游戏执行模块.下

面分别给出各模块的功能、元件、电路图和相关代码.

１．棋子位置输入模块

１)功能介绍

干簧管模块感应上方位置是否有磁铁,若有磁铁,输出数字信号０,否则输出数字信号

[]{#index_split_005.html#p310}![index-310_1.png](https://i.imgur.com/aiV5m18.jpeg){.calibre2}

![index-310_2.png](https://i.imgur.com/tqMxYxH.jpeg){.calibre2}

２９９

１.图１２Ｇ４为模块的电路图,棋盘一共用了３５块.元件包括３５个干簧管模块和 Arduino MEGA２５６０开发板.

图１２Ｇ４　棋子位置输入模块

２)相关代码

constintL１１ ＝ ０

constintL１２ ＝ １

constintL１３ ＝ ２

constintL１４ ＝ ３

constintL１５ ＝ ４

constintL１６ ＝ ５

constintL１７ ＝ ６

constintL２１ ＝ ７

[]{#index_split_005.html#p311}![index-311_1.png](https://i.imgur.com/lENMqWn.jpeg){.calibre2}

３００

constintL２２ ＝ ８

constintL２３ ＝ ９

constintL２４ ＝ １０

constintL２５ ＝ １１

constintL２６ ＝ １２

constintL２７ ＝ １３

constintL３１ ＝ １４

constintL３２ ＝ １５

constintL３３ ＝ １６

constintL３４ ＝ １７

constintL３５ ＝ １８

constintL３６ ＝ １９

constintL３７ ＝ ２０

constintL４１ ＝ ２１

constintL４２ ＝ ２２

constintL４３ ＝ ２３

constintL４４ ＝ ２４

constintL４５ ＝ ２５

constintL４６ ＝ ２６

constintL４７ ＝ ２７

constintL５１ ＝ ２８

constintL５２ ＝ ２９

constintL５３ ＝ ３０

constintL５４ ＝ ３１

constintL５５ ＝ ３２

constintL５６ ＝ ３３

constintL５７ ＝ ３４

voidsetup

pinMode D１１ OUTPUT

定义I O引脚

pinMode D１２ OUTPUT

pinMode D１３ OUTPUT

pinMode D１４ OUTPUT

pinMode D１５ OUTPUT

pinMode D１６ OUTPUT

pinMode D１７ OUTPUT

pinMode D２１ OUTPUT

pinMode D２２ OUTPUT

pinMode D２３ OUTPUT

pinMode D２４ OUTPUT

pinMode D２５ OUTPUT

pinMode D２６ OUTPUT

[]{#index_split_005.html#p312}![index-312_1.png](https://i.imgur.com/ALz4GQA.jpeg){.calibre2}

３０１

pinMode D２７ OUTPUT

pinMode D３１ OUTPUT

pinMode D３２ OUTPUT

pinMode D３３ OUTPUT

pinMode D３４ OUTPUT

pinMode D３５ OUTPUT

pinMode D３６ OUTPUT

pinMode D３７ OUTPUT

pinMode D４１ OUTPUT

pinMode D４２ OUTPUT

pinMode D４３ OUTPUT

pinMode D４４ OUTPUT

pinMode D４５ OUTPUT

pinMode D４６ OUTPUT

pinMode D４７ OUTPUT

pinMode D５１ OUTPUT

pinMode D５２ OUTPUT

pinMode D５３ OUTPUT

pinMode D５４ OUTPUT

pinMode D５５ OUTPUT

pinMode D５６ OUTPUT

pinMode D５７ OUTPUT

pinMode L１１ INPUT

pinMode L１２ INPUT

pinMode L１３ INPUT

pinMode L１４ INPUT

pinMode L１５ INPUT

pinMode L１６ INPUT

pinMode L１７ INPUT

pinMode L２１ INPUT

pinMode L２２ INPUT

pinMode L２３ INPUT

pinMode L２４ INPUT

pinMode L２５ INPUT

pinMode L２６ INPUT

pinMode L２７ INPUT

pinMode L３１ INPUT

pinMode L３２ INPUT

pinMode L３３ INPUT

pinMode L３４ INPUT

pinMode L３５ INPUT

pinMode L３６ INPUT

[]{#index_split_005.html#p313}![index-313_1.png](https://i.imgur.com/OSxPiJa.jpeg){.calibre2}

３０２

pinMode L３７ INPUT

pinMode L４１ INPUT

pinMode L４２ INPUT

pinMode L４３ INPUT

pinMode L４４ INPUT

pinMode L４５ INPUT

pinMode L４６ INPUT

pinMode L４７ INPUT

pinMode L５１ INPUT

pinMode L５２ INPUT

pinMode L５３ INPUT

pinMode L５４ INPUT

pinMode L５５ INPUT

pinMode L５６ INPUT

pinMode L５７ INPUT

voidinputAllPoints

intC１１ ＝ digitalRead L１１

定义３５个常量存储读取的电平

intC１２ ＝ digitalRead L１２

intC１３ ＝ digitalRead L１３

intC１４ ＝ digitalRead L１４

intC１５ ＝ digitalRead L１５

intC１６ ＝ digitalRead L１６

intC１７ ＝ digitalRead L１７

intC２１ ＝ digitalRead L２１

intC２２ ＝ digitalRead L２２

intC２３ ＝ digitalRead L２３

intC２４ ＝ digitalRead L２４

intC２５ ＝ digitalRead L２５

intC２６ ＝ digitalRead L２６

intC２７ ＝ digitalRead L２７

intC３１ ＝ digitalRead L３１

intC３２ ＝ digitalRead L３２

intC３３ ＝ digitalRead L３３

intC３４ ＝ digitalRead L３４

intC３５ ＝ digitalRead L３５

intC３６ ＝ digitalRead L３６

intC３７ ＝ digitalRead L３７

intC４１ ＝ digitalRead L４１

intC４２ ＝ digitalRead L４２

intC４３ ＝ digitalRead L４３

[]{#index_split_005.html#p314}![index-314_1.png](https://i.imgur.com/FC5tDvk.jpeg){.calibre2}

３０３

intC４４ ＝ digitalRead L４４

intC４５ ＝ digitalRead L４５

intC４６ ＝ digitalRead L４６

intC４７ ＝ digitalRead L４７

intC５１ ＝ digitalRead L５１

intC５２ ＝ digitalRead L５２

intC５３ ＝ digitalRead L５３

intC５４ ＝ digitalRead L５４

intC５５ ＝ digitalRead L５５

intC５６ ＝ digitalRead L５６

intC５７ ＝ digitalRead L５７

if C１１ ＝＝ ０

根据读取的电平值 初始化allPoint和mapl矩阵

allPoint ０ ０ 敭

type ＝ WallType mapl ０ ０ ＝ １

elseallPoint ０ ０ 敭

type ＝ FreeType mapl ０ ０ ＝ ０

if C１２ ＝＝ ０

allPoint ０ １ 敭

type ＝ WallType mapl ０ １ ＝ １

elseallPoint ０ １ 敭

type ＝ FreeType mapl ０ １ ＝ ０

if C１３ ＝＝ ０

allPoint ０ ２ 敭

type ＝ WallType mapl ０ ２ ＝ １

elseallPoint ０ ２ 敭

type ＝ FreeType mapl ０ ２ ＝ ０

if C１４ ＝＝ ０

allPoint ０ ３ 敭

type ＝ WallType mapl ０ ３ ＝ １

elseallPoint ０ ３ 敭

type ＝ FreeType mapl ０ ３ ＝ ０

if C１５ ＝＝ ０

allPoint ０ ４ 敭

type ＝ WallType mapl ０ ４ ＝ １

elseallPoint ０ ４ 敭

type ＝ FreeType mapl ０ ４ ＝ ０

if C１６ ＝＝ ０

allPoint ０ ５ 敭

type ＝ WallType mapl ０ ５ ＝ １

elseallPoint ０ ５ 敭

type ＝ FreeType mapl ０ ５ ＝ ０

if C１７ ＝＝ ０

[]{#index_split_005.html#p315}![index-315_1.png](https://i.imgur.com/1PE1eDp.jpeg){.calibre2}

３０４

allPoint ０ ６ 敭

type ＝ WallType mapl ０ ６ ＝ １

elseallPoint ０ ６ 敭

type ＝ FreeType mapl ０ ６ ＝ ０

if C２１ ＝＝ ０

allPoint １ ０ 敭

type ＝ WallType mapl １ ０ ＝ １

elseallPoint １ ０ 敭

type ＝ FreeType mapl １ ０ ＝ ０

if C２２ ＝＝ ０

allPoint １ １ 敭

type ＝ WallType mapl １ １ ＝ １

elseallPoint １ １ 敭

type ＝ FreeType mapl １ １ ＝ ０

if C２３ ＝＝ ０

allPoint １ ２ 敭

type ＝ WallType mapl １ ２ ＝ １

elseallPoint １ ２ 敭

type ＝ FreeType mapl １ ２ ＝ ０

if C２４ ＝＝ ０

allPoint １ ３ 敭

type ＝ WallType mapl １ ３ ＝ １

elseallPoint １ ３ 敭

type ＝ FreeType mapl １ ３ ＝ ０

if C２５ ＝＝ ０

allPoint １ ４ 敭

type ＝ WallType mapl １ ４ ＝ １

elseallPoint １ ４ 敭

type ＝ FreeType mapl １ ４ ＝ ０

if C２６ ＝＝ ０

allPoint １ ５ 敭

type ＝ WallType mapl １ ５ ＝ １

elseallPoint １ ５ 敭

type ＝ FreeType mapl １ ５ ＝ ０

if C２７ ＝＝ ０

allPoint １ ６ 敭

type ＝ WallType mapl １ ６ ＝ １

elseallPoint １ ６ 敭

type ＝ FreeType mapl １ ６ ＝ ０

if C３１ ＝＝ ０

allPoint ２ ０ 敭

type ＝ WallType mapl ２ ０ ＝ １

[]{#index_split_005.html#p316}![index-316_1.png](https://i.imgur.com/KNj3l45.jpeg){.calibre2}

３０５

elseallPoint ２ ０ 敭

type ＝ FreeType mapl ２ ０ ＝ ０

if C３２ ＝＝ ０

allPoint ２ １ 敭

type ＝ WallType mapl ２ １ ＝ １

elseallPoint ２ １ 敭

type ＝ FreeType mapl ２ １ ＝ ０

if C３３ ＝＝ ０

allPoint ２ ２ 敭

type ＝ WallType mapl ２ ２ ＝ １

elseallPoint ２ ２ 敭

type ＝ FreeType mapl ２ ２ ＝ ０

if C３４ ＝＝ ０

allPoint ２ ３ 敭

type ＝ WallType mapl ２ ３ ＝ １

elseallPoint ２ ３ 敭

type ＝ FreeType mapl ２ ３ ＝ ０

if C３５ ＝＝ ０

allPoint ２ ４ 敭

type ＝ WallType mapl ２ ４ ＝ １

elseallPoint ２ ４ 敭

type ＝ FreeType mapl ２ ４ ＝ ０

if C３６ ＝＝ ０

allPoint ２ ５ 敭

type ＝ WallType mapl ２ ５ ＝ １

elseallPoint ２ ５ 敭

type ＝ FreeType mapl ２ ５ ＝ ０

if C３７ ＝＝ ０

allPoint ２ ６ 敭

type ＝ WallType mapl ２ ６ ＝ １

elseallPoint ２ ６ 敭

type ＝ FreeType mapl ２ ６ ＝ ０

if C４１ ＝＝ ０

allPoint ３ ０ 敭

type ＝ WallType mapl ３ ０ ＝ １

elseallPoint ３ ０ 敭

type ＝ FreeType mapl ３ ０ ＝ ０

if C４２ ＝＝ ０

allPoint ３ １ 敭

type ＝ WallType mapl ３ １ ＝ １

elseallPoint ３ １ 敭

type ＝ FreeType mapl ３ １ ＝ ０

[]{#index_split_005.html#p317}![index-317_1.png](https://i.imgur.com/vXYtgsi.jpeg){.calibre2}

３０６

if C４３ ＝＝ ０

allPoint ３ ２ 敭

type ＝ WallType mapl ３ ２ ＝ １

elseallPoint ３ ２ 敭

type ＝ FreeType mapl ３ ２ ＝ ０

if C４４ ＝＝ ０

allPoint ３ ３ 敭

type ＝ WallType mapl ３ ３ ＝ １

elseallPoint ３ ３ 敭

type ＝ FreeType mapl ３ ３ ＝ ０

if C４５ ＝＝ ０

allPoint ３ ４ 敭

type ＝ WallType mapl ３ ４ ＝ １

elseallPoint ３ ４ 敭

type ＝ FreeType mapl ３ ４ ＝ ０

if C４６ ＝＝ ０

allPoint ３ ５ 敭

type ＝ WallType mapl ３ ５ ＝ １

elseallPoint ３ ５ 敭

type ＝ FreeType mapl ３ ５ ＝ ０

if C４７ ＝＝ ０

allPoint ３ ６ 敭

type ＝ WallType mapl ３ ６ ＝ １

elseallPoint ３ ６ 敭

type ＝ FreeType mapl ３ ６ ＝ ０

if C５１ ＝＝ ０

allPoint ４ ０ 敭

type ＝ WallType mapl ４ ０ ＝ １

elseallPoint ４ ０ 敭

type ＝ FreeType mapl ４ ０ ＝ ０

if C５２ ＝＝ ０

allPoint ４ １ 敭

type ＝ WallType mapl ４ １ ＝ １

elseallPoint ４ １ 敭

type ＝ FreeType mapl ４ １ ＝ ０

if C５３ ＝＝ ０

allPoint ４ ２ 敭

type ＝ WallType mapl ４ ２ ＝ １

elseallPoint ４ ２ 敭

type ＝ FreeType mapl ４ ２ ＝ ０

if C５４ ＝＝ ０

[]{#index_split_005.html#p318}![index-318_1.png](https://i.imgur.com/E1LsJEv.jpeg){.calibre2}

![index-318_2.png](https://i.imgur.com/igtMFuO.jpeg){.calibre2}

![index-318_3.png](https://i.imgur.com/vQiFqSv.jpeg){.calibre2}

![index-318_4.png](https://i.imgur.com/nuYQjH1.jpeg){.calibre2}

３０７

allPoint ４ ３ 敭

type ＝ WallType mapl ４ ３ ＝ １

elseallPoint ４ ３ 敭

type ＝ FreeType mapl ４ ３ ＝ ０

if C５５ ＝＝ ０

allPoint ４ ４ 敭

type ＝ WallType mapl ４ ４ ＝ １

elseallPoint ４ ４ 敭

type ＝ FreeType mapl ４ ４ ＝ ０

if C５６ ＝＝ ０

allPoint ４ ５ 敭

type ＝ WallType mapl ４ ５ ＝ １

elseallPoint ４ ５ 敭

type ＝ FreeType mapl ４ ５ ＝ ０

if C５７ ＝＝ ０

allPoint ４ ６ 敭

type ＝ WallType mapl ４ ６ ＝ １

elseallPoint ４ ６ 敭

type ＝ FreeType mapl ４ ６ ＝ ０

structLocation ∗ getLocation

返回落棋位置

structLocation∗p＝ NULL

structLocation∗s＝ NULL

inta ５ ７

intb＝ ０

inputAllPoints

读取落棋前棋盘上的棋子状态

for inti＝ ０ i ５ i++

for intj＝ ０ j ７ j++

a i j ＝ mapl i j

if mapl i j ＝＝ １ b++

digitalWrite D５７ HIGH

提示落棋

delay ２０００

digitalWrite D５７ LOW

delay ６０００

inputAllPoints

读取落棋后棋盘上的棋子状态

digitalWrite D４７ HIGH

delay ２０００

digitalWrite D４７ LOW

intc＝ ０

intd＝ ０

for inti＝ ０ i ５ i++

[]{#index_split_005.html#p319}![index-319_1.png](https://i.imgur.com/5cusgjW.jpeg){.calibre2}

![index-319_2.png](https://i.imgur.com/cCBpNk8.jpeg){.calibre2}

![index-319_3.png](https://i.imgur.com/wcZGkF3.jpeg){.calibre2}

![index-319_4.png](https://i.imgur.com/6QcKLFp.jpeg){.calibre2}

![index-319_5.png](https://i.imgur.com/q0spykF.jpeg){.calibre2}

３０８

for intj＝ ０ j ７ j++

if a i j

＝ mapl i j

p－ row＝ i

p－ col＝ j

if mapl i j ＝＝ １ c++

if b

＝ c

returnp

else

returns

２．绿灯显示模块

１)功能介绍

根据游戏结果显示不同 的 效 果.当 围 困 成 功 时,显 示 "W"图案;当围困失败时,显示

"F"图案,图案均先闪烁两次后维持其形状.元件包括３５个绿色 LED 和 Arduino MEGA ２５６０开发板,如图１２Ｇ５所示.

图１２Ｇ５　绿灯显示模块

[]{#index_split_005.html#p320}![index-320_1.png](https://i.imgur.com/4mgjMEC.jpeg){.calibre2}

３０９

２)相关代码

constintD１１ ＝ ３５ 　　　　　 定义３５个输出接口

constintD１２ ＝ ３６

constintD１３ ＝ ３７

constintD１４ ＝ ３８

constintD１５ ＝ ３９

constintD１６ ＝ ４０

constintD１７ ＝ ４１

constintD２１ ＝ ４２

constintD２２ ＝ ４３

constintD２３ ＝ ４４

constintD２４ ＝ ４５

constintD２５ ＝ ４６

constintD２６ ＝ ４７

constintD２７ ＝ ４８

constintD３１ ＝ ４９

constintD３２ ＝ ５０

constintD３３ ＝ ５１

constintD３４ ＝ ５２

constintD３５ ＝ ５３

constintD３６ ＝ ５４

constintD３７ ＝ ５５

constintD４１ ＝ ５６

constintD４２ ＝ ５７

constintD４３ ＝ ５８

constintD４４ ＝ ５９

constintD４５ ＝ ６０

constintD４６ ＝ ６１

constintD４７ ＝ ６２

constintD５１ ＝ ６３

constintD５２ ＝ ６４

constintD５３ ＝ ６５

constintD５４ ＝ ６６

constintD５５ ＝ ６７

constintD５６ ＝ ６８

constintD５７ ＝ ６９

voiddisplaywin

显示"

W"图案并闪烁２次

digitalWrite D１１ HIGH

digitalWrite D１７ HIGH

digitalWrite D２１ HIGH

[]{#index_split_005.html#p321}![index-321_1.png](https://i.imgur.com/Qof4XVI.jpeg){.calibre2}

３１０

digitalWrite D２４ HIGH

digitalWrite D２７ HIGH

digitalWrite D３２ HIGH

digitalWrite D３４ HIGH

digitalWrite D３６ HIGH

digitalWrite D４２ HIGH

digitalWrite D４４ HIGH

digitalWrite D４６ HIGH

digitalWrite D５３ HIGH

digitalWrite D５５ HIGH

delay ５００

digitalWrite D１１ LOW

digitalWrite D１７ LOW

digitalWrite D２１ LOW

digitalWrite D２４ LOW

digitalWrite D２７ LOW

digitalWrite D３２ LOW

digitalWrite D３４ LOW

digitalWrite D３６ LOW

digitalWrite D４２ LOW

digitalWrite D４４ LOW

digitalWrite D４６ LOW

digitalWrite D５３ LOW

digitalWrite D５５ LOW

delay ５００

digitalWrite D１１ HIGH

digitalWrite D１７ HIGH

digitalWrite D２１ HIGH

digitalWrite D２４ HIGH

digitalWrite D２７ HIGH

digitalWrite D３２ HIGH

digitalWrite D３４ HIGH

digitalWrite D３６ HIGH

digitalWrite D４２ HIGH

digitalWrite D４４ HIGH

digitalWrite D４６ HIGH

digitalWrite D５３ HIGH

digitalWrite D５５ HIGH

delay ５００

digitalWrite D１１ LOW

digitalWrite D１７ LOW

digitalWrite D２１ LOW

[]{#index_split_005.html#p322}![index-322_1.png](https://i.imgur.com/v7ov98H.jpeg){.calibre2}

３１１

digitalWrite D２４ LOW

digitalWrite D２７ LOW

digitalWrite D３２ LOW

digitalWrite D３４ LOW

digitalWrite D３６ LOW

digitalWrite D４２ LOW

digitalWrite D４４ LOW

digitalWrite D４６ LOW

digitalWrite D５３ LOW

digitalWrite D５５ LOW

delay ５００

digitalWrite D１１ HIGH

digitalWrite D１７ HIGH

digitalWrite D２１ HIGH

digitalWrite D２４ HIGH

digitalWrite D２７ HIGH

digitalWrite D３２ HIGH

digitalWrite D３４ HIGH

digitalWrite D３６ HIGH

digitalWrite D４２ HIGH

digitalWrite D４４ HIGH

digitalWrite D４６ HIGH

digitalWrite D５３ HIGH

digitalWrite D５５ HIGH

delay ５００

voiddisplayfail

显示"

F"图案并闪烁２次

digitalWrite D１３ HIGH

digitalWrite D１４ HIGH

digitalWrite D１５ HIGH

digitalWrite D２３ HIGH

digitalWrite D３３ HIGH

digitalWrite D３４ HIGH

digitalWrite D３５ HIGH

digitalWrite D４３ HIGH

digitalWrite D５３ HIGH

delay ５００

digitalWrite D１３ LOW

digitalWrite D１４ LOW

digitalWrite D１５ LOW

digitalWrite D２３ LOW

[]{#index_split_005.html#p323}![index-323_1.png](https://i.imgur.com/tNGCf8g.jpeg){.calibre2}

３１２

digitalWrite D３３ LOW

digitalWrite D３４ LOW

digitalWrite D３５ LOW

digitalWrite D４３ LOW

digitalWrite D５３ LOW

delay ５００

digitalWrite D１３ HIGH

digitalWrite D１４ HIGH

digitalWrite D１５ HIGH

digitalWrite D２３ HIGH

digitalWrite D３３ HIGH

digitalWrite D３４ HIGH

digitalWrite D３５ HIGH

digitalWrite D４３ HIGH

digitalWrite D５３ HIGH

delay ５００

digitalWrite D１３ LOW

digitalWrite D１４ LOW

digitalWrite D１５ LOW

digitalWrite D２３ LOW

digitalWrite D３３ LOW

digitalWrite D３４ LOW

digitalWrite D３５ LOW

digitalWrite D４３ LOW

digitalWrite D５３ LOW

delay ５００

digitalWrite D１３ HIGH

digitalWrite D１４ HIGH

digitalWrite D１５ HIGH

digitalWrite D２３ HIGH

digitalWrite D３３ HIGH

digitalWrite D３４ HIGH

digitalWrite D３５ HIGH

digitalWrite D４３ HIGH

digitalWrite D５３ HIGH

delay ５００

voiddisplaycat

显示猫的位置

if allPoint ０ ０ 敭

type ＝＝ CatType

digitalWrite D１１ HIGH

delay ２０００

[]{#index_split_005.html#p324}![index-324_1.png](https://i.imgur.com/SYi38t1.jpeg){.calibre2}

３１３

elsedigitalWrite D１１ LOW

if allPoint ０ １ 敭

type ＝＝ CatType

digitalWrite D１２ HIGH

delay ２０００

elsedigitalWrite D１２ LOW

if allPoint ０ ２ 敭

type ＝＝ CatType

digitalWrite D１３ HIGH

delay ２０００

elsedigitalWrite D１３ LOW

if allPoint ０ ３ 敭

type ＝＝ CatType

digitalWrite D１４ HIGH

delay ２０００

elsedigitalWrite D１４ LOW

if allPoint ０ ４ 敭

type ＝＝ CatType

digitalWrite D１５ HIGH

delay ２０００

elsedigitalWrite D１５ LOW

if allPoint ０ ５ 敭

type ＝＝ CatType

digitalWrite D１６ HIGH

delay ２０００

elsedigitalWrite D１６ LOW

if allPoint ０ ６ 敭

type ＝＝ CatType

digitalWrite D１７ HIGH

delay ２０００

elsedigitalWrite D１７ LOW

if allPoint １ ０ 敭

type ＝＝ CatType

digitalWrite D２１ HIGH

delay ２０００

elsedigitalWrite D２１ LOW

if allPoint １ １ 敭

type ＝＝ CatType

digitalWrite D２２ HIGH

delay ２０００

elsedigitalWrite D２２ LOW

[]{#index_split_005.html#p325}![index-325_1.png](https://i.imgur.com/9k213YE.jpeg){.calibre2}

３１４

if allPoint １ ２ 敭

type ＝＝ CatType

digitalWrite D２３ HIGH

delay ２０００

elsedigitalWrite D２３ LOW

if allPoint １ ３ 敭

type ＝＝ CatType

digitalWrite D２４ HIGH

delay ２０００

elsedigitalWrite D２４ LOW

if allPoint １ ４ 敭

type ＝＝ CatType

digitalWrite D２５ HIGH

delay ２０００

elsedigitalWrite D２５ LOW

if allPoint １ ５ 敭

type ＝＝ CatType

digitalWrite D２６ HIGH

delay ２０００

elsedigitalWrite D２６ LOW

if allPoint １ ６ 敭

type ＝＝ CatType

digitalWrite D２７ HIGH

delay ２０００

elsedigitalWrite D２７ LOW

if allPoint ２ ０ 敭

type ＝＝ CatType

digitalWrite D３１ HIGH

delay ２０００

elsedigitalWrite D３１ LOW

if allPoint ２ １ 敭

type ＝＝ CatType

digitalWrite D３２ HIGH

delay ２０００

elsedigitalWrite D３２ LOW

if allPoint ２ ２ 敭

type ＝＝ CatType

digitalWrite D３３ HIGH

delay ２０００

elsedigitalWrite D３３ LOW

if allPoint ２ ３ 敭

type ＝＝ CatType

digitalWrite D３４ HIGH

[]{#index_split_005.html#p326}![index-326_1.png](https://i.imgur.com/nuEr29b.jpeg){.calibre2}

３１５

delay ２０００

elsedigitalWrite D３４ LOW

if allPoint ２ ４ 敭

type ＝＝ CatType

digitalWrite D３５ HIGH

delay ２０００

elsedigitalWrite D３５ LOW

if allPoint ２ ５ 敭

type ＝＝ CatType

digitalWrite D３６ HIGH

delay ２０００

elsedigitalWrite D３６ LOW

if allPoint ２ ６ 敭

type ＝＝ CatType

digitalWrite D３７ HIGH

delay ２０００

elsedigitalWrite D３７ LOW

if allPoint ３ ０ 敭

type ＝ CatType

digitalWrite D４１ HIGH

delay ２０００

[]{#index_split_006.html}

elsedigitalWrite D４１ LOW

if allPoint ３ １ 敭

type ＝＝ CatType

digitalWrite D４２ HIGH

delay ２０００

elsedigitalWrite D４２ LOW

if allPoint ３ ２ 敭

type ＝＝ CatType

digitalWrite D４３ HIGH

delay ２０００

elsedigitalWrite D４３ LOW

if allPoint ３ ３ 敭

type ＝＝ CatType

digitalWrite D４４ HIGH

delay ２０００

elsedigitalWrite D４４ LOW

if allPoint ３ ４ 敭

type ＝＝ CatType

digitalWrite D４５ HIGH

delay ２０００

[]{#index_split_006.html#p327}![index-327_1.png](https://i.imgur.com/n0dncA7.jpeg){.calibre2}

３１６

elsedigitalWrite D４５ LOW

if allPoint ３ ５ 敭

type ＝＝ CatType

digitalWrite D４６ HIGH

delay ２０００

elsedigitalWrite D４６ LOW

if allPoint ３ ６ 敭

type ＝＝ CatType

digitalWrite D４７ HIGH

delay ２０００

elsedigitalWrite D４７ LOW

if allPoint ４ ０ 敭

type ＝＝ CatType

digitalWrite D５１ HIGH

delay ２０００

elsedigitalWrite D５１ LOW

if allPoint ４ １ 敭

type ＝＝ CatType

digitalWrite D５２ HIGH

delay ２０００

elsedigitalWrite D５２ LOW

if allPoint ４ ２ 敭

type ＝＝ CatType

digitalWrite D５３ HIGH

delay ２０００

elsedigitalWrite D５３ LOW

if allPoint ４ ３ 敭

type ＝＝ CatType

digitalWrite D５４ HIGH

delay ２０００

elsedigitalWrite D５４ LOW

if allPoint ４ ４ 敭

type ＝＝ CatType

digitalWrite D５５ HIGH

delay ２０００

elsedigitalWrite D５５ LOW

if allPoint ４ ５ 敭

type ＝＝ CatType

digitalWrite D５６ HIGH

delay ２０００

elsedigitalWrite D５６ LOW

if allPoint ４ ６ 敭

type ＝＝ CatType

[]{#index_split_006.html#p328}![index-328_1.png](https://i.imgur.com/i9acwPL.jpeg){.calibre2}

![index-328_2.png](https://i.imgur.com/D4QrfaZ.jpeg){.calibre2}

![index-328_3.png](https://i.imgur.com/Li56GR4.jpeg){.calibre2}

３１７

digitalWrite D５７ HIGH

delay ２０００

elsedigitalWrite D５７ LOW

３．游戏计算模块

１)功能介绍

利用输入模块获得的位置信息,计算猫逃跑的最短路径,并返回猫的下一位置.

２)相关代码

enumPointType CatType WallType FreeType structLocation

introw

存每个点的行

intcol

存每个点的列

enumPointTypetype

存每个点的类型

intcost

存每个点的连接数

intpath

存每个点的最短路径数

structLocationallPoint ５ ７

structLocationcat

intmapl ５ ７

inthasCircle ＝ ０

voidinitAllPoints

初始化allPoint矩阵

for inti＝ ０ i ５ i++

for intj＝ ０ j ７ j++

allPoint i j 敭

row ＝ i ＋ １

allPoint i j 敭

col ＝ j ＋ １

allPoint i j 敭

type ＝ FreeType

allPoint i j 敭

cost ＝ ０

allPoint i j 敭

path ＝ －１００

mapl i j ＝ ０

cat敭

row ＝ allPoint ２ ３ 敭

row

cat敭

col ＝ allPoint ２ ３ 敭

col

cat敭

type ＝ CatType

allPoint ２ ３ 敭

type ＝ CatType

mapl ２ ３ ＝ １

cat敭

path ＝ ８８８

displaycat

显示猫的位置

[]{#index_split_006.html#p329}![index-329_1.png](https://i.imgur.com/SEbXbJI.jpeg){.calibre2}

![index-329_2.png](https://i.imgur.com/qh50DD1.jpeg){.calibre2}

![index-329_3.png](https://i.imgur.com/wBmBUt4.jpeg){.calibre2}

![index-329_4.png](https://i.imgur.com/64wK71D.jpeg){.calibre2}

![index-329_5.png](https://i.imgur.com/ZI6jv4F.jpeg){.calibre2}

![index-329_6.png](https://i.imgur.com/YSjHkaH.jpeg){.calibre2}

![index-329_7.png](https://i.imgur.com/eM0v5At.jpeg){.calibre2}

![index-329_8.png](https://i.imgur.com/STmuNNw.jpeg){.calibre2}

![index-329_9.png](https://i.imgur.com/F0YNrSt.jpeg){.calibre2}

![index-329_10.png](https://i.imgur.com/vEX9K3Y.jpeg){.calibre2}

![index-329_11.png](https://i.imgur.com/YUEP4uM.jpeg){.calibre2}

![index-329_12.png](https://i.imgur.com/W6vTG1G.jpeg){.calibre2}

![index-329_13.png](https://i.imgur.com/tMIRA0T.jpeg){.calibre2}

３１８

delay ２０００

inputAllPoints

读取wall的位置

voidcalAllCost

计算连接数与最短路径数

每次计算时先清除以前所有的信息

clearAllCost

按照左、右、上、下四个方向进行搜索

for inti＝ ０ i ５ i++

for intj＝ ０ j ７ j++

calPath &allPoint i j

for inti＝ ０ i ５ i++

for intj＝ ０ j ７ j++

calPath &allPoint ４ － i ７ － j

for inti＝ ０ i ５ i++

for intj＝ ０ j ７ j++

calPath &allPoint ４ － i j

for inti＝ ０ i ５ i++

for intj＝ ０ j ７ j++

calPath &allPoint i ７ － j

for inti＝ ０ i ５ i++

for intj＝ ０ j ７ j++

calCost &allPoint i j

for inti＝ ０ i ５ i++

for intj＝ ０ j ７ j++

calCost &allPoint i j

hasCircle ＝ isInCircle &cat

判断猫是否在一个圈中

voidclearAllCost

清除所有点的信息

[]{#index_split_006.html#p330}![index-330_1.png](https://i.imgur.com/vBzlZzy.jpeg){.calibre2}

![index-330_2.png](https://i.imgur.com/hxqrceb.jpeg){.calibre2}

![index-330_3.png](https://i.imgur.com/HiWxuaj.jpeg){.calibre2}

![index-330_4.png](https://i.imgur.com/QOzF58R.jpeg){.calibre2}

![index-330_5.png](https://i.imgur.com/8XyBpgh.jpeg){.calibre2}

３１９

for inti＝ ０ i ５ i++

for intj＝ ０ j ７ j++

allPoint i j 敭

cost ＝ －１００

allPoint i j 敭

path ＝ －１００

intcatAutoGo

猫移动

structLocation ∗best＝ getBestLocation if best

＝ NULL

inti ＝ getMapRow &cat

intj ＝ getMapCol &cat

mapl i j ＝ ０

allPoint i j 敭

type ＝ FreeType

cat敭

row ＝ best－ row

cat敭

col ＝ best－ col

i ＝ getMapRow &cat

j ＝ getMapCol &cat

mapl i j ＝ １

allPoint i j 敭

type ＝ CatType

cat敭

path ＝ ８８８

displaycat

delay ２０００

if i＝＝ ０\|\|i＝＝ ４\|\|j＝＝ ０\|\|j＝＝ ６

return－１

游戏结束

else

return１

只有一个点了

return０

structLocation ∗ getBestLocation

获取最佳位置

structLocation ∗best＝ NULL

if best

＝ NULL

returnbest

elseif hasCircle＝＝ １

returnbest

[]{#index_split_006.html#p331}![index-331_1.png](https://i.imgur.com/lscPJst.jpeg){.calibre2}

![index-331_2.png](https://i.imgur.com/D9X5pqj.jpeg){.calibre2}

![index-331_3.png](https://i.imgur.com/FRdP43q.jpeg){.calibre2}

![index-331_4.png](https://i.imgur.com/kTAz4zv.jpeg){.calibre2}

![index-331_5.png](https://i.imgur.com/gApEa4z.jpeg){.calibre2}

![index-331_6.png](https://i.imgur.com/u18cUIq.jpeg){.calibre2}

３２０

structLocation ∗locationSet ４

inti ＝ getMapRow &cat

intj ＝ getMapCol &cat

structLocationp ＝ allPoint i j

locationSet ０ ＝ getLeft &p

locationSet １ ＝ getRight &p

locationSet ２ ＝ getUp &p

locationSet ３ ＝ getDown &p

for i＝ ０ i ４ i++

if isValid locationSet i ＝＝ １

best ＝ locationSet i

break

for intj＝ i＋ １ j ４ j++

if isValid locationSet j ＝＝ １&&isLessThan locationSet j best ＝＝ １

best ＝ locationSet j

returnbest

intgetMapRow structLocation∗p

得到行信息

returnp－ row － １

intgetMapCol structLocation∗p

得到列信息

returnp－ col － １

structLocation ∗ getLeft structLocation∗p 得到左边的点

structLocation ∗ newp＝ NULL

gettherowandcol

introw ＝ getMapRow p

intcol ＝ getMapCol p

左边的点

if col ０

newp ＝ &allPoint row col－ １

returnnewp

structLocation ∗ getRight structLocation∗p 得到右边的点

[]{#index_split_006.html#p332}![index-332_1.png](https://i.imgur.com/Th5skCl.jpeg){.calibre2}

![index-332_2.png](https://i.imgur.com/ZJsVdiP.jpeg){.calibre2}

![index-332_3.png](https://i.imgur.com/q9FZNLC.jpeg){.calibre2}

![index-332_4.png](https://i.imgur.com/9lgljZ5.jpeg){.calibre2}

３２１

structLocation ∗newp＝ NULL

得到行列

introw ＝ getMapRow p

intcol ＝ getMapCol p

右边的点

if col ６

newp ＝ &allPoint row col＋ １

returnnewp

structLocation ∗ getUp structLocation∗p 得到上边的点

structLocation ∗newp＝ NULL

得到行列

introw ＝ getMapRow p

intcol ＝ getMapCol p

上面的点

if row ０

newp ＝ &allPoint row－ １ col

returnnewp

structLocation ∗ getDown structLocation∗p 得到下边的点

structLocation ∗newp＝ NULL

gettherowandcol

introw ＝ getMapRow p

intcol ＝ getMapCol p

下边的点

if row ４

newp ＝ &allPoint row＋ １ col

returnnewp

intisValid structLocation∗p

判断点是否合理

introw ＝ getMapRow p

intcol ＝ getMapCol p

if p

＝ NULL&&mapl row col ＝＝ ０

return１

else

[]{#index_split_006.html#p333}![index-333_1.png](https://i.imgur.com/TzaCwjC.jpeg){.calibre2}

![index-333_2.png](https://i.imgur.com/B5qctks.jpeg){.calibre2}

![index-333_3.png](https://i.imgur.com/lQKoXj4.jpeg){.calibre2}

![index-333_4.png](https://i.imgur.com/7Nhq7WR.jpeg){.calibre2}

![index-333_5.png](https://i.imgur.com/eAymDDQ.jpeg){.calibre2}

![index-333_6.png](https://i.imgur.com/QRR1bfl.jpeg){.calibre2}

![index-333_7.png](https://i.imgur.com/FROtCJw.jpeg){.calibre2}

３２２

return０

intcalCost structLocation∗p

计算该点的连接数

intcost ＝ ０

得到行列

introw ＝ getMapRow p

intcol ＝ getMapCol p

if mapl row col ＝＝ １

p－ cost ＝ １００

returnp－ cost

if row＝＝ ０\|\|col＝＝ ０\|\|row＝＝ ４\|\|col＝＝ ６

p－ cost ＝ ０

returnp－ cost

structLocation ∗leftP＝ getLeft p

if isValid leftP ＝＝ １

cost++

structLocation ∗rightP＝ getRight p

if isValid rightP ＝＝ １

cost++

structLocation ∗upP＝ getUp p

if isValid upP ＝＝ １

cost++

structLocation ∗downP＝ getDown p

if isValid downP ＝＝ １

cost++

p－ cost ＝ cost

returnp－ cost

intcalPath structLocation∗p

计算该点的最短路径数

intcost ＝ ０

得到行列

introw ＝ getMapRow p

intcol ＝ getMapCol p

if mapl row col ＝＝ １

[]{#index_split_006.html#p334}![index-334_1.png](https://i.imgur.com/0y8mifR.jpeg){.calibre2}

![index-334_2.png](https://i.imgur.com/FAmxRML.jpeg){.calibre2}

![index-334_3.png](https://i.imgur.com/XOxiLTg.jpeg){.calibre2}

![index-334_4.png](https://i.imgur.com/QyuLl0q.jpeg){.calibre2}

![index-334_5.png](https://i.imgur.com/QDMnski.jpeg){.calibre2}

![index-334_6.png](https://i.imgur.com/62G9RXv.jpeg){.calibre2}

![index-334_7.png](https://i.imgur.com/0kgzl3O.jpeg){.calibre2}

![index-334_8.png](https://i.imgur.com/j6uYkLt.jpeg){.calibre2}

![index-334_9.png](https://i.imgur.com/2kJLd0u.jpeg){.calibre2}

![index-334_10.png](https://i.imgur.com/HsmBKD4.jpeg){.calibre2}

![index-334_11.png](https://i.imgur.com/0q6ejd4.jpeg){.calibre2}

![index-334_12.png](https://i.imgur.com/Lqs9GfG.jpeg){.calibre2}

![index-334_13.png](https://i.imgur.com/vM4NwhM.jpeg){.calibre2}

![index-334_14.png](https://i.imgur.com/xP7ZIY4.jpeg){.calibre2}

３２３

p－ path ＝ １００

returnp－ path

if row＝＝ ０\|\|col＝＝ ０\|\|row＝＝ ４\|\|col＝＝ ６

p－ path ＝ ０

returnp－ path

structLocation ∗validSet ４

structLocation ∗leftP＝ getLeft p

validSet cost ＝ leftP

cost++

structLocation ∗rightP＝ getRight p

validSet cost ＝ rightP

cost++

structLocation ∗upP＝ getUp p

validSet cost ＝ upP

cost++

structLocation ∗downP＝ getDown p

validSet cost ＝ downP

cost++

遍历周围的点 如果已经有值就用来更新这个节点的path

如果还有点没有值 那需要等以后来计算它们的值

intmin ＝ １００

for inti＝ ０ i cost i++

if validSet i － path ＝ ０

inttmp ＝ validSet i － path

if min tmp

min ＝ tmp

if min １００

p－ path ＝ min ＋ １

else

p－ path ＋＝ １

returnp－ path

intisInCircle structLocation∗p

判断是否已经围成一个圈

intcost ＝ ０

[]{#index_split_006.html#p335}![index-335_1.png](https://i.imgur.com/qrFnGRg.jpeg){.calibre2}

![index-335_2.png](https://i.imgur.com/yWFSpOd.jpeg){.calibre2}

![index-335_3.png](https://i.imgur.com/GjwD66i.jpeg){.calibre2}

![index-335_4.png](https://i.imgur.com/xtBcvw0.jpeg){.calibre2}

![index-335_5.png](https://i.imgur.com/TVwi9cs.jpeg){.calibre2}

![index-335_6.png](https://i.imgur.com/iD2HLZD.jpeg){.calibre2}

![index-335_7.png](https://i.imgur.com/4Nt7HhJ.jpeg){.calibre2}

![index-335_8.png](https://i.imgur.com/vpVMemC.jpeg){.calibre2}

![index-335_9.png](https://i.imgur.com/DEfePyU.jpeg){.calibre2}

![index-335_10.png](https://i.imgur.com/b9P528P.jpeg){.calibre2}

![index-335_11.png](https://i.imgur.com/ZCLNEc8.jpeg){.calibre2}

![index-335_12.png](https://i.imgur.com/DkogPlM.jpeg){.calibre2}

![index-335_13.png](https://i.imgur.com/zKNe6T0.jpeg){.calibre2}

![index-335_14.png](https://i.imgur.com/FC5FsoD.jpeg){.calibre2}

![index-335_15.png](https://i.imgur.com/zqKcYQk.jpeg){.calibre2}

![index-335_16.png](https://i.imgur.com/5xHaE6T.jpeg){.calibre2}

![index-335_17.png](https://i.imgur.com/naIam22.jpeg){.calibre2}

![index-335_18.png](https://i.imgur.com/DbITLLA.jpeg){.calibre2}

![index-335_19.png](https://i.imgur.com/LFCEBnO.jpeg){.calibre2}

３２４

structLocation ∗validSet ４

structLocation ∗leftP＝ getLeft p

validSet cost ＝ leftP

cost++

structLocation ∗rightP＝ getRight p

validSet cost ＝ rightP

cost++

structLocation ∗upP＝ getUp p

validSet cost ＝ upP

cost++

structLocation ∗downP＝ getDown p

validSet cost ＝ downP

cost++

遍历周围的点 判断它们是墙还是墙内的点 墙内的点的值为负数 但大于－１００

intnum ＝ ０

for inti＝ ０ i cost i++

if validSet i － path １００\|\| validSet i － path －１００&&validSet i － path ０ \|\|

validSet i － path＝＝ １００

它是猫或墙内的点或墙

num++

if num＝＝ ４

return１

else

return０

intisLessThan structLocation∗p１ structLocation∗p２

比较p１和p２两个点的最短路径数

if p１－ path ＝ ０&&p２－ path ＝ ０

if p１－ path p２－ path

return１

else

return０

elseif hasCircle＝＝ １

if p１－ cost p２－ cost

[]{#index_split_006.html#p336}![index-336_1.png](https://i.imgur.com/Zj56I7G.jpeg){.calibre2}

![index-336_2.png](https://i.imgur.com/ZIlWttH.jpeg){.calibre2}

![index-336_3.png](https://i.imgur.com/Uf3OjJ8.jpeg){.calibre2}

![index-336_4.png](https://i.imgur.com/r6tQRma.jpeg){.calibre2}

![index-336_5.png](https://i.imgur.com/vZyeYd7.jpeg){.calibre2}

３２５

return１

else

return０

else

intm１ ＝ －p１－ path

intm２ ＝ －p２－ path

if m１ m２

return１

else

return０

voidupdateCost introw intcol

更新这个点

structLocation ∗loc＝ &allPoint row col loc－ type ＝ WallType

mapl row col ＝ １

clearAllCost

calAllCost

intisEqualToCat introw intcol

等同于猫

intcatRow ＝ getMapRow &cat

intcatCol ＝ getMapCol &cat

if catRow＝＝ row－ １&&catCol＝＝ col－ １

return１

return０

４．游戏执行模块

１)功能介绍

在loop中调用各函数,将各部分功能按一定的时序与逻辑组织起来,形成程序进程.

２)相关代码

voidloop

initAllPoints

初始化所有点

displaycat

显示猫的位置

delay ２０００

[]{#index_split_006.html#p337}![index-337_1.png](https://i.imgur.com/WEH3FCc.jpeg){.calibre2}

![index-337_2.png](https://i.imgur.com/Y5gNweA.jpeg){.calibre2}

![index-337_3.png](https://i.imgur.com/gEk2Yex.jpeg){.calibre2}

３２６

calAllCost

计算path和cost

delay １００

intisGameOver ＝ ０

while １

introw col

structLocation ∗p＝ getLocation

intm ＝ １

while m

structLocation ∗p＝ getLocation

if Location∗p＝ NULL m＝ １

else

row ＝ p－ row

col ＝ p－ col

break

updateCost ２ ４

displaycat

显示猫的位置

delay ２０００

intres ＝ isEqualToCat row col

if isGameOver＝＝ １&&res＝＝ ０

continue

只有一个点了 没被选中 什么都不做

elseif isGameOver＝＝ １

break

最后一个点被选中 游戏结束

isGameOver ＝ catAutoGo

displaycat

delay ２０００

if isGameOver＝＝ －１

break

到边界了 游戏结束

displaycat

显示猫的位置

delay ２０００

calAllCost

if isGameOver＝＝ －１

displayfail

while １

[]{#index_split_006.html#p338}![index-338_1.png](https://i.imgur.com/cPmy9fV.jpeg){.calibre2}

![index-338_2.png](https://i.imgur.com/9HAzCoh.jpeg){.calibre2}

![index-338_3.png](https://i.imgur.com/JOf152v.jpeg){.calibre2}

３２７

delay ２００００

到边界了 游戏结束

elseif isGameOver＝＝ １

displaywin

while １

delay ２００００

１２．

４　产品展示

产品整 体 外 观 如 图 １２Ｇ６ 所 示;内 部 结 构 如 图 １２Ｇ７ 所 示. 图 １２Ｇ６ 上 方 是 Arduino MEGA２５６０开发 板;下 方 是 一 个 ５×７ 的 棋 盘.棋 盘 上 有 ３５ 个 干 簧 管 块 和 ３５ 个 绿 色

LED,棋子(小磁铁)落在干簧管正上方,LED 显示猫逃跑的路径与游戏结果.

图１２Ｇ６　整体外观图

图１２Ｇ７　内部结构图

[]{#index_split_006.html#p339}![index-339_1.png](https://i.imgur.com/uYpzSxl.jpeg){.calibre2}

３２８

１２．

５　故障及问题分析

问题１:万能电路板上的孔太小,和干簧管模块自带的孔径不一致,无法固定.

解决方案:为了解决孔径不一致的问题,决定在万能电路板上适当的位置钻孔,使孔径

扩大以匹配干簧管的孔径.首先,将３５个干簧管模块在万能电路板上排列整齐,在调整好

位置后,用笔在万能电路板上每个干簧管模块的位置做好标记.然后找专业人士帮忙钻孔, 最终解决了这个问题,成功固定干簧管模块.

问题２:需要把绿色 LED固定在万能电路板上,并且留出一定长度的引脚用于与 Arduino 开发板的连接,但是万能电路板上的孔对于 LED的引脚来说太大,不能直接固定.

解决方案:根据电子电路实验的经验,决定用锡焊的方式固定引脚,把 LED 的引脚和

万能电路板焊在一起.首先,将一个 LED 插入万能电路板中,看留出多少长度的引脚合适.

在确定了合适的长度后,对３５个灯进行了锡焊,使它们固定.

问题３:３５个干簧管模块的电源线和接地线需要连接到 Arduino开发板,但是引脚数

目明显不够用.

解决方案:为了解决这个问题,特意购买了排母,用排母将每个干簧管模块的电源线连

接在一起,长度不够的需要用杜邦线来连接排母和电源线.与此类似,用排母将每个干簧管

模块的接地线也连接在一起,长度不够则用杜邦线连接.这样,使所有的干簧管模块的电源

线都串联在一起,接地线也都串联在一起.然后,再引出一根线连到 Arduino开发板的电源

引脚,另一根线引出连到 Arduino开发板的接地引脚,即可解决引脚不够用的问题.在固定

排母时,同样通过锡焊将它们焊在万能电路板上,使它们固定,同时起到串联的作用.

问题４:由于干簧管模块感应磁力的范围是１．５cm 以内,在万能电路板上焊了两排排

母,又在排母上连接了杜邦线,高度太高,如果在上面放上亚克力板做棋盘,会使干簧管模块

感应不到小磁铁的磁力.

解决方案:先将杜邦线按顺序连接在排母上,将它们焊在一起,起到连接的作用,然后

再将杜邦线向水平方向弯折,从而使高度大大降低,放上亚克力板后,干簧管模块也能感受

到小磁铁的磁力,问题得以解决.

问题５:小磁铁是强磁体,磁性太强,当把它们摆放在亚克力板上时,相邻的两个小磁铁

要么会立刻吸在一起,要么会相互排斥,无法摆放在预设的位置.并且,当只有一个小磁铁

放在上面时,会使周围的几个干簧管模块同时感应到磁力.

解决方案:利用加热的方法使小磁铁磁力减弱.用打火机将小磁铁灼烧大约１min,就

可以达到想要的效果.

问题６:编写计算最短路径数的代码时,由于棋盘不是正方形规格,网络上给出的计算

方法不管用,无法计算准确的最短路径数.

解决方案:改变计算方法,并在 VS２０１５中单步运行,逐渐完善算法,直至准确无误.

[]{#index_split_006.html#p340}![index-340_1.png](https://i.imgur.com/L4PJWBl.jpeg){.calibre2}

３２９

１２．

６　元件清单

完成本项目所用到的元件及数量如表１２Ｇ１所示.

表１２Ｇ１　棋盘小游戏之守护绿色元件清单

模　　块

元件/测试仪表

数量

导线

若干

绿灯 控 制 模 块 与 位 置 处

杜邦线

若干

理模块

排母

１４个

ArduinoMEGA２５６０开发板

１个

导线

若干

杜邦线

若干

绿灯显示模块

绿色发光二极管

３５个

万能电路板

１个

干簧管模块

３５块

位置输入部分

小磁铁

３５个

亚克力板

１个

外观部分

螺钉

４个

螺母

若干

[]{#index_split_006.html#p341}![index-341_1.png](https://i.imgur.com/JJIBOOd.jpeg){.calibre2}

第１３章

炮弹发射车项目设计

１３．

１　项目背景

项目设计的灵感来自于各式各样的玩具,例如小时候常玩的遥控车、玩具枪、坦克军事

装备等.项目旨在设计一款属于自己的玩具---------炮弹发射车,能够遥控发射车的前进方向、

控制炮台的旋转并发射"炮弹".

１３．

２　创新描述

市面上的遥控小车种类 繁 多,除了能够通过遥控控制移动外,还有一些 其 他 的 拓 展 功

能,例如寻迹、避障等.但是,类似于炮弹发射车的玩具产品却很少见.从原理上来说,本项

目设计的炮弹发射车相当于普通的蓝牙遥控小车和机械臂的结合.

１３．

３　功能及总体设计

通过两部手机的两个 APP分别控制小车部分和炮台部分,其中一个 APP 可以控制发

射车的移动方向(前进、后退、左转、右转、左后转、右后转、原地左转、原地右转、停止);另一

个 APP可以控制炮台的旋转并且扣动扳机.

１３．

３．

１　功能介绍

本项目通过智能遥控车模拟炮弹携带车辆,通过机械臂完成对炮台的控制,初步实现简

易的炮弹发射车.

本章根据常浩然、肖汝迪项目设计整理而成.

[]{#index_split_006.html#p342}![index-342_1.png](https://i.imgur.com/qKcBZ5V.jpeg){.calibre2}

![index-342_2.png](https://i.imgur.com/GgYVZbr.jpeg){.calibre2}

３３１

１３．

３．

２　总体设计

本产品主要分为小车部分和炮台部分.小车部分由两个直流电机控制两个轮子实现小

车的驱动,两个直流电机连接到直流电机驱动模块上,电机驱动模块和蓝牙模块都连接到

ArduinoMEGA２５６０开发板上,实现蓝牙控制小车;炮台部分由两个舵机分别驱动底座旋

转和机械臂,机械臂扣动扳机,两个舵机和蓝牙模块都连接到舵机扩展板上,扩展板连接到

ArduinoUNO 开发板上,实现对炮台的所有控制.

１．整体框架图

项目整体框架如图１３Ｇ１所示.

图１３Ｇ１　整体框架图

２．系统流程图

系统流程图如图１３Ｇ２所示.

３．总电路图

总电路图如图１３Ｇ３所示.

[]{#index_split_006.html#p343}![index-343_1.png](https://i.imgur.com/WufkNoU.jpeg){.calibre2}

![index-343_2.png](https://i.imgur.com/u9e9EC6.jpeg){.calibre2}

３３２

图１３Ｇ２　系统流程图

总电路图中,将炮台部分与小车部分的电源合在一起,利用分压为舵机提供６V 的电

压,为直流电机提供１２V 的电压.直流电机１、

２的４根导线连接到直流电机扩展板 L２９８N

的 OUT１\~OUT４引脚;直流电机扩展板的１２V 电源引脚与 GND 分别连接到电源的正极

与负极;扩展板的５V 引脚利用面包板与 Arduino开发板和蓝牙模块的５V 引脚连接到一

起.扩展板的IN１\~IN４引脚连接到 Arduino开发板的４\~７引脚(

１\~１３引脚均可使用,本

次实验使用４\~７引脚).Arduino开发板与蓝牙模块的 GND 引脚连接到电源负极.蓝牙

模块的 TX 引脚连接到 Arduino开发板的 RX 引脚(本次实验不需要小车返回信息给手机, 所以没有使用蓝牙模块的 RX 引脚).使用１２V 电源给驱动模块供电,与炮台部分一样,依

[]{#index_split_006.html#p344}![index-344_1.png](https://i.imgur.com/1xM1yZl.jpeg){.calibre2}

![index-344_2.png](https://i.imgur.com/NEinhbk.jpeg){.calibre2}

３３３

图１３Ｇ３　总电路图

旧使用移动电源为 Arduino开发板供电.舵机扩展板 ArduinoSensorShieldv．

５的各引脚

依次与 ArduinoUNO 开发板相连.两个舵机的三个引脚连接至舵机扩展板的５引脚与９

引脚,其中５引脚与９引脚的 G、V、S分别与舵机的 G、V、S相连.蓝牙模块的 VCC、GND、

TXD、RXD 分别连接扩展板蓝牙部分的 V、G、R、T.最后,使用６V 电池为舵机扩展板供

电,使用移动电源(电路图中用电池表示)代替电源为 Arduino开发板供电.

１３．

３．

３　模块介绍

１．小车部分

１)功能介绍

小车部分的电路 如 图 １３Ｇ４ 所示.直 流 电 机 １、２ 的 ４ 个 导 线 连 接 到 直 流 电 机 扩 展 板

[]{#index_split_006.html#p345}![index-345_1.png](https://i.imgur.com/D0fOH9h.jpeg){.calibre2}

![index-345_2.png](https://i.imgur.com/Hd7aljJ.jpeg){.calibre2}

３３４

L２９８N 的 OUT１\~OUT４引脚,直流电机扩展板的１２V 与 GND 分别连接到电源的正极与

负极,扩展板的５V 引脚利用面包板与 Arduino开发板和蓝牙模块的５V 引脚连接到一起.

扩展板的IN１\~IN４引脚连接到 Arduino开发板的４\~７引脚.Arduino开发板与蓝牙模块

的 GND 引脚连接到电源负极.蓝牙模块的 TX 引脚连接到 Arduino开发板的 RX 引脚.

使用１２V 电源为驱动模块供电,与炮台部分一样,依旧使用移动电源(电路图１３Ｇ４中用电池

表示)为 Arduino开发板供电.

图１３Ｇ４　小车模块电路

２)相关代码

＃defineIN１４

＃defineIN２５

定义IN１接Arduino开发板的４引脚

IN２接５引脚

＃defineIN３６

＃defineIN４７

定义IN３接Arduino开发板的６引脚

IN４接７引脚

voidforward

voidback

voidturnLeft

voidturnRight

voidturnbackLeft

voidturnbackRight

voidturnLeftOrigin

voidturnRightOrigin

void_stop

把需要使用的函数都声明一遍

voidsetup

pinMode IN１

OUTPUT

[]{#index_split_006.html#p346}![index-346_1.png](https://i.imgur.com/Wpl92Zv.jpeg){.calibre2}

３３５

pinMode IN２

OUTPUT

pinMode IN３

OUTPUT

pinMode IN４

OUTPUT

Serial敭

begin ９６００

inti

voidloop

if Serial敭

available

i＝Serial敭

read

switch i

case\'１\'

turnLeft break

case\'２\'

forward break

case\'３\'

turnRight break

case\'４\'

turnLeftOrigin break

case\'５\'

\_stop break

case\'６\'

turnRightOrigin break

case\'７\'

turnbackLeft break

case\'８\'

back break

case\'９\'

turnbackRight break

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

函数功能 控制车前进

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

voidforward

digitalWrite IN１

HIGH

digitalWrite IN２

LOW

左轮前进

digitalWrite IN３

HIGH

digitalWrite IN４

LOW

右轮前进

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

[]{#index_split_006.html#p347}![index-347_1.png](https://i.imgur.com/phjLPqK.jpeg){.calibre2}

３３６

函数功能 控制车后退

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

voidback

digitalWrite IN１

LOW

digitalWrite IN２

HIGH

左轮后退

digitalWrite IN３

LOW

digitalWrite IN４

HIGH

右轮后退

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

函数功能 控制车左转

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

voidturnLeft

digitalWrite IN１

LOW

digitalWrite IN２

LOW

左轮静止不动

digitalWrite IN３

HIGH

digitalWrite IN４

LOW

右轮前进

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

函数功能 控制车左后转弯

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

voidturnbackLeft

digitalWrite IN１

LOW

digitalWrite IN２

LOW

左轮静止不动

digitalWrite IN３

LOW

digitalWrite IN４

HIGH

右轮后退

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

函数功能 控制车右后转弯

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

voidturnRight

digitalWrite IN１

HIGH

digitalWrite IN２

LOW

左轮前进

digitalWrite IN３

LOW

digitalWrite IN４

LOW

右轮静止不动

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

函数功能 控制车右转

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

voidturnbackRight

digitalWrite IN１

LOW

[]{#index_split_006.html#p348}![index-348_1.png](https://i.imgur.com/pmzuCnv.jpeg){.calibre2}

３３７

digitalWrite IN２

HIGH

左轮后退

digitalWrite IN３

LOW

digitalWrite IN４

LOW

右轮静止不动

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

函数功能 控制车原地左转

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

voidturnLeftOrigin

digitalWrite IN１

LOW

digitalWrite IN２

HIGH

左轮后退

digitalWrite IN３

HIGH

digitalWrite IN４

LOW

右轮前进

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

函数功能 控制车原地右转

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

voidturnRightOrigin

digitalWrite IN１

HIGH

digitalWrite IN２

LOW

左轮前进

digitalWrite IN３

LOW

digitalWrite IN４

HIGH

右轮后退

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

函数功能 控制车停止

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

void_stop

digitalWrite IN１

LOW

digitalWrite IN２

LOW

左轮静止不动

digitalWrite IN３

LOW

digitalWrite IN４

LOW

右轮静止不动

２．炮台部分

１)功能介绍

炮台部分的电路如图１３Ｇ５所示.舵机扩展板 ArduinoSensorShieldv．５的各引脚依

次与 ArduinoUNO 开发板相连.两个舵机的３个引脚连接至舵机扩展板的５引脚与９引

脚,其中５引脚与９引脚的 G、V、S分别与舵机的 G、V、S相连.蓝牙模块的 VCC、GND、

TXD、RXD 分别连接扩展板蓝牙部分的 V、G、R、T.最后,使用６V 电池为舵机扩展板供

电,使用移动电源(电路图１３Ｇ５中用电池表示)代替电源为 Arduino开发板供电.

[]{#index_split_006.html#p349}![index-349_1.png](https://i.imgur.com/WxUbcJq.jpeg){.calibre2}

![index-349_2.png](https://i.imgur.com/Ky6Vpys.jpeg){.calibre2}

![index-349_3.png](https://i.imgur.com/MRddx68.jpeg){.calibre2}

![index-349_4.png](https://i.imgur.com/GGbJFGw.jpeg){.calibre2}

![index-349_5.png](https://i.imgur.com/pjbVyVl.jpeg){.calibre2}

３３８

图１３Ｇ５　炮台模块电路

２)相关代码

＃include Servo敭h

ServoPrj文件

＃include＂CommProtocolData敭h＂

CommProtocolData敭

cpp文件

BYTEbuf_len ＝ ０

定义长度为０

BYTEbuffer １０

voidPrintChar BYTEc

字符输出函数

Serial敭

print c

voidcopyBuf BYTE∗data

将buffer数组的值复制给输入数组

for inti＝０

i buf_len

i++

data i ＝ buffer i

Serial敭write data buf_len

voidInitComm intBaud

Serial敭

begin Baud

初始化串口通信波特率

BYTEGetBuffer BYTE∗data

串口读取数据 赋值到buffer数组 返回buffer数组长度

while Serial敭

available

[]{#index_split_006.html#p350}![index-350_1.png](https://i.imgur.com/w5qs9cl.jpeg){.calibre2}

![index-350_2.png](https://i.imgur.com/mbWJwnr.jpeg){.calibre2}

![index-350_3.png](https://i.imgur.com/r9bPJFr.jpeg){.calibre2}

３３９

buffer buf_len ＝ Serial敭

read

Serial敭print buffer buf_len

Serial敭write buffer buf_len

buf_len ++

Serial敭write buf_len

returnbuf_len

BYTEGetFrameDataPart BYTE∗data 把串口的值赋值到buffer中 并把值再赋给data Serial敭write GetBuffer data

GetBuffer data

Serial敭

write data

buf_len

if buf_len ＝ ８ && buffer buf_len－１ ＝＝０X０A copyBuf data

Serial敭write data buf_len

for inti＝６

i buf_len

i++

if data i ＝＝０X０D

data ９ ＝ i Serial敭write buf_len 　 用data ９ 记录data的长度

break

data １ －＝ \'０\'

把数组中存储的字符型数据转换为整数型

data ２ －＝ \'０\'

data ３ －＝ \'０\'

data ４ －＝ \'０\'

data ５ －＝ \'０\'

if data ９ ＝＝７

data ６ －＝ \'０\'

Serial敭write data data ９

buf_len ＝ ０

return１

else

Serial敭write buf_len

return０

[]{#index_split_006.html#p351}![index-351_1.png](https://i.imgur.com/LxQMoqF.jpeg){.calibre2}

![index-351_2.png](https://i.imgur.com/qSOBA0V.jpeg){.calibre2}

![index-351_3.png](https://i.imgur.com/XTZyiw9.jpeg){.calibre2}

![index-351_4.png](https://i.imgur.com/VojFSJy.jpeg){.calibre2}

![index-351_5.png](https://i.imgur.com/1W3oUUV.jpeg){.calibre2}

![index-351_6.png](https://i.imgur.com/q8SKDyx.jpeg){.calibre2}

３４０

voidClearBuffer

把buffer数组长度变量初始化为０

buf_len ＝ ０

∗CommProtocolData敭h文件∗

＃include＂def敭h＂

＃ifndefCOMMPROTOCOLDATA_H\_

＃defineCOMMPROTOCOLDATA_H\_

voidInitComm intBaud

BYTEGetBuffer BYTE∗data

BYTEGetFrameDataPart BYTE∗data

voidClearBuffer

＃endif

∗Mem敭c文件∗

＃include＂Mem敭h＂

∗Mem敭h文件∗

＃include＂def敭h＂

＃include avr eeprom敭h

＃ifndefMEM_H\_

＃defineMEM_H\_

＃defineMEM_LEN５１２

＃defineMEM_START０x１０

＃defineMEM_ENDMEM_LEN

BYTEWrite_section uint１６_taddr

BYTE ∗buf BYTElen

BYTERead_section uint１６_taddr

BYTE ∗buf BYTElen

BYTESave_toE２PROM Servo_info∗ pInfo

BYTERead_fromE２PROM Servo_info∗ pInfo BYTEWrite_section uint１６_taddr

BYTE ∗buf BYTElen

uint１６_ti ＝ ０

for

i len

i++

if i ＝ MEM_END

returni

eeprom_write_byte uint８_t∗ addr＋ i buf i 　　　 将addr、buf写入存储器中

return０

BYTERead_section uint１６_taddr

BYTE ∗buf BYTElen

将存储器的值赋值给buffer

uint１６_ti ＝ ０

for

i len

i++

[]{#index_split_006.html#p352}![index-352_1.png](https://i.imgur.com/jZvCHgW.jpeg){.calibre2}

![index-352_2.png](https://i.imgur.com/2u2U6tC.jpeg){.calibre2}

![index-352_3.png](https://i.imgur.com/xRI7Gzh.jpeg){.calibre2}

![index-352_4.png](https://i.imgur.com/rW8XqRC.jpeg){.calibre2}

![index-352_5.png](https://i.imgur.com/BjrCCbg.jpeg){.calibre2}

３４１

if i＋len ＝ MEM_END

returni

buf i ＝ eeprom_read_byte uint８_t∗ addr＋ i return０

BYTESave_toE２PROM Servo_info∗ pInfo

判断并存储Servo_info∗ pInfo

uint１６_tlen ＝ pInfo－ section_num ∗ sizeof SECTION_INFO ＋ ８

BYTE ∗p＝ BYTE∗ pInfo

uint１６_twrite_len ＝ ８

constBYTEsave_step ＝ sizeof SECTION_INFO

Write_section ０

p

８

p＋＝ ８

while write_len len－８

Write_section write_len

p

save_step

write_len ＋＝ save_step

p ＋＝ save_step

returnwrite_len

BYTERead_fromE２PROM Servo_info∗ pInfo 判断并改变Servo_info∗ pInfo的值

BYTEbHasData ＝ eeprom_read_byte uint８_t∗ ０x０１

if bHasData

＝ HAS_DATA

uint１６_tlen ＝ eeprom_read_byte uint８_t∗ ０x０１ ＋ １

len ＝ len∗sizeof SECTION_INFO

BYTE ∗p＝ BYTE∗ pInfo

uint１６_tread_len ＝ ８

constBYTEread_step ＝ sizeof SECTION_INFO

Read_section ０

p

８

p＋＝８

while read_len len－１

Read_section read_len

p

read_step

read_len ＋＝ read_step

p＋＝ read_step

[]{#index_split_006.html#p353}![index-353_1.png](https://i.imgur.com/GZnEgrA.jpeg){.calibre2}

![index-353_2.png](https://i.imgur.com/w95YLRU.jpeg){.calibre2}

![index-353_3.png](https://i.imgur.com/9IzUXOD.jpeg){.calibre2}

![index-353_4.png](https://i.imgur.com/IjafqZm.jpeg){.calibre2}

３４２

returnread_len

＃endif

＃include＂ServoDriver敭h＂ ServoDriver敭cpp文件

typedefstructservo_info

定义舵机的结构

BYTEcurr_pos

初始位置

BYTEdest_pos

最终位置

BYTEmove_spe

移动速度

BYTEis_moving

舵机目前状态

SERVO_INFO

SERVO_INFOservo_info SERVO_NUM

建立一个结构组

Servoservo SERVO_NUM

BYTEis_anyservo_moving ＝ false

voidInitServoPort

定义引脚并初始化各舵机

pinMode ５

OUTPUT

pinMode ９

OUTPUT

servo ０ 敭

attach ５

servo １ 敭

attach ９

for inti＝ ０

i SERVO_NUM

i++

servo_info i 敭

curr_pos ＝ ９０

servo_info i 敭

dest_pos ＝ ９０

servo_info i 敭

move_spe ＝ １

servo_info i 敭

is_moving ＝ false

BYTESetServoMoveto BYTEservo_num

BYTEdestpos

BYTEspe

设置各舵机要移动的角度和最终的位置

if servo_num SERVO_NUM

return１

servo_info servo_num 敭

dest_pos ＝ destpos

servo_info servo_num 敭

move_spe ＝ spe

return０

BYTEMoveAllServoToDest

将舵机分别按照参数进行移动

BYTEservo_cnt ＝ ０

is_anyservo_moving ＝ false

for

servo_cnt SERVO_NUM

servo_cnt ++

[]{#index_split_006.html#p354}![index-354_1.png](https://i.imgur.com/VicQA1l.jpeg){.calibre2}

![index-354_2.png](https://i.imgur.com/brIB2x0.jpeg){.calibre2}

![index-354_3.png](https://i.imgur.com/88fvPdY.jpeg){.calibre2}

![index-354_4.png](https://i.imgur.com/PgcihoK.jpeg){.calibre2}

![index-354_5.png](https://i.imgur.com/O5RONIQ.jpeg){.calibre2}

![index-354_6.png](https://i.imgur.com/S0QRERp.jpeg){.calibre2}

![index-354_7.png](https://i.imgur.com/WxXJIsf.jpeg){.calibre2}

３４３

if servo_info servo_cnt 敭

curr_pos servo_info servo_cnt 敭

dest_pos

判断该舵机当前位置是否与输入位置相等

is_anyservo_moving ＝ true

if servo_info servo_cnt 敭

curr_pos ＋ servo_info servo_cnt 敭

move_spe servo_info servo\_

cnt 敭

dest_pos

servo_info servo_cnt 敭

curr_pos ＋＝ servo_info servo_cnt 敭

move_spe

servo servo_cnt 敭

write servo_info servo_cnt 敭

curr_pos

else

servo_info servo_cnt 敭

curr_pos ＝ servo_info servo_cnt 敭

dest_pos

servo servo_cnt 敭

write servo_info servo_cnt 敭

dest_pos

elseif servo_info servo_cnt 敭

curr_pos servo_info servo_cnt 敭

dest_pos

is_anyservo_moving ＝ true

if servo_info servo_cnt 敭

curr_pos － servo_info servo_cnt 敭

move_spe servo_info servo\_

cnt 敭

dest_pos

servo_info servo_cnt 敭

curr_pos －＝ servo_info servo_cnt 敭

move_spe

servo servo_cnt 敭

write servo_info servo_cnt 敭

curr_pos

else

servo_info servo_cnt 敭

curr_pos ＝ servo_info servo_cnt 敭

dest_pos

servo servo_cnt 敭

write servo_info servo_cnt 敭

dest_pos

returnis_anyservo_moving

ServoDriver敭

h文件

＃include＂def敭h＂

＃include Servo敭h

＃ifndefSERVODRIVER_H\_

＃defineSERVODRIVER_H\_

＃defineMIN_POS１１００

定义舵机旋转角度的范围和舵机数量

＃defineMAX_POS２０００

＃defineSERVO_NUM２

voidInitServoPort

[]{#index_split_006.html#p355}![index-355_1.png](https://i.imgur.com/k5W9uIi.jpeg){.calibre2}

３４４

BYTESetServoMoveto BYTEservo_num

BYTEdestpos

BYTEspe

BYTEMoveAllServoToDest

＃endif

∗ServoMain敭cpp文件∗

＃include＂Mem敭h＂

＃include＂ServoMain敭h＂

＃include＂ServoDriver敭h＂

＃include＂CommProtocolData敭h＂

BYTEdata ６４ ＝ ０x５A

１

０x５A

１

０x５A

１

０x５A

１

０x５A

１

１

定义data数组及其初值

BYTEflag ＝ ０

BYTEbIsPrintDown ＝ ０

BYTEd １０ ＝ ０x３１

０x３２

０x３３

０x３４

０x３５

０x３６

０x３７

０x３８

０x３９

０x４０

BYTEaddr ＝ ０xF０

BYTElen ＝ １０

BYTERUN_CMD ＝ CMD_DEBUG

Servo_infomem_info

BYTEbIsLoadE２PROM ＝ ０

BYTERunDebug

运行

intrundata

rdi＝７

BYTErdata

ClearBuffer

while １

if GetFrameDataPart data

if data ０

＝ ０x２３

Serial敭

write data

data ９

return０

if data data ９ ＋１

＝ ０X０A

return０

if data ９ ＝＝６

rundata ＝ data ３ ∗１００＋data ４ ∗１０＋data ５

计算要旋转的角度

elseif data ９ ＝＝７

rundata ＝ data ３ ∗１０００＋data ４ ∗１００＋data ５ ∗１０＋data ６

[]{#index_split_006.html#p356}![index-356_1.png](https://i.imgur.com/NppdY23.jpeg){.calibre2}

３４５

rdata ＝ rundata－５００ ∗９ １００

SetServoMoveto data １ －１

rdata

ServoSpeedResolution

根据串口的数据计算并设置旋转的角度

MoveAllServoToDest

根据计算的数据进行旋转

voidsetup

Serial敭

begin ９６００

InitServoPort

mem_info敭

section_hasData ＝ HAS_DATA

无限循环

voidloop

RunDebug

∗ServoMain敭h文件∗

＃include＂Arduino敭h＂

＃defineServoSpeedResolution５

∗def敭h文件∗

＃ifndefDEF_H\_

＃defineDEF_H\_

＃include＂Arduino敭h＂

＃defineATmega_１６８

＃defineHAS_DATA０x５５

enum CMD_DEBUG＝ ０xF０

CMD_AUTO

CMD_LOAD

CMD_PRG

CMD_UPLOAD

＃defineBYTEunsignedchar

＃defineTRUE１

＃defineFALSE０

typedefstruct

speed结构

BYTEspe_l

４

BYTEspe_h

４

SPEED

typedefstruct

section_info结构

BYTEservo１_pos

BYTEservo２_pos

SPEEDspe１_２

SPEEDspe３_４

SPEEDspe５_６

BYTEdelay_s

SECTION_INFO

[]{#index_split_006.html#p357}![index-357_1.png](https://i.imgur.com/AnKi3DG.jpeg){.calibre2}

![index-357_2.png](https://i.imgur.com/SVzOLsm.jpeg){.calibre2}

![index-357_3.png](https://i.imgur.com/48PbPGN.jpeg){.calibre2}

３４６

typedefstruct

servo_info结构

BYTEsection_hasData

BYTEsection_num

BYTEndef ６

SECTION_INFOinfo １００

Servo_info

＃endif

３．蓝牙模块

如图１３Ｇ６所示,通过蓝牙串口的 APP来控制小车的移动,８个按键分别控制炮弹发射

车的８种移动方式(前进、后退、左转、右转、左后转、右后转、原地左转、原地右转),通过在函

数中定义IN１\~IN４分别和 Arduino开发板的４\~７引脚连接来实现.例如,按"前进"键

时,蓝牙向 Arduino开发板发送数字２,使之运行forward函数.两个直流电机两端一个是

高电压,另一个是低电压,实现两个舵机的正向旋转,使炮弹发射车向前移动.实现函数时, 通过对直流电机两端电压的调控来实现旋转与否,进而实现各种移动方式.

如图１３Ｇ７所示,通过名为 ServoControl的 APP实现对炮台部分舵机的控制.舵机蓝

牙控制模块原理与小车的蓝牙控制模块类似,不同点在于舵机的蓝牙模块通过对滑块的滑

动来实现对舵机转动角度的调节,并且预先对发送的数据进行一系列判断与运算,然后再执

行相应动作.

图１３Ｇ６　蓝牙控制模块

图１３Ｇ７　舵机控制 APP界面

[]{#index_split_006.html#p358}![index-358_1.png](https://i.imgur.com/BbkQ1Zw.jpeg){.calibre2}

![index-358_2.png](https://i.imgur.com/BIXDOGb.jpeg){.calibre2}

![index-358_3.png](https://i.imgur.com/ZkD1GRP.jpeg){.calibre2}

![index-358_4.png](https://i.imgur.com/L2LZld0.jpeg){.calibre2}

３４７

１３．

４　产品展示

产品展示如图１３Ｇ８\~图１３Ｇ１１所示;整体外观如图１３Ｇ１２所示.小车的两个夹板之间

放置了 ArduinoMEGA２５６０开发板和直流电机驱动模块;小车上方靠后和炮台的底座粘

连,炮台上面是两个舵机和发射装置;小车中间是一个面包板,用来连接各种线;小车前面

是电池组和 Arduino开发板电源.

图１３Ｇ８　产品展示１

图１３Ｇ９　产品展示２

图１３Ｇ１０　产品展示３

[]{#index_split_006.html#p359}![index-359_1.png](https://i.imgur.com/ns0XY4x.jpeg){.calibre2}

![index-359_2.png](https://i.imgur.com/U1knbrM.jpeg){.calibre2}

![index-359_3.png](https://i.imgur.com/AEnbuPl.jpeg){.calibre2}

３４８

图１３Ｇ１１　产品展示４

图１３Ｇ１２　整体外观

１３．

５　问题及故障分析

问题１:炮弹发射车整体重量较大,小车的轮胎摩擦系数不高,开始时经常会空转或者

不转,无法完成指定移动.

解决方案:在直流电机允许范围内,增加电池数量,加大电压,从而增大直流电机扭矩, 使之能够在较重状态下完成移动.

问题２:舵机的力度不够,不能扣动扳机.

解决方案:因为电压已经接近最大,所以不能通过增加电压的方法增大舵机的力度,决

定在外部加两根皮筋起到助力的作用.

问题３:代码无法正常导入 Arduino开发板中.

解决方案:查询计算机设备管理器的通信端口,将其设定为正确通信端口,再次烧录就

可以成功.

问题４:组装小车和炮台(机械臂)时,零件缺失或不匹配.

解决方案:自己动手修改零件,利用螺丝刀、

５０２胶水等工具自行改装,对部分零件的

大小进行自主修改、切割.

问题５:炮弹发射装置角度不够好,不能以正常角度发射炮弹.

解决方案:从炮台底座 延 伸 出 一 个 支 撑 架,固 定 发 射 装 置,调 整 小 车 前 方 的 万 向 轮 位

置,调整好炮台的角度.

问题６:由于舵机只能旋转１８０°,所以直接拼装炮台时舵机中心与炮台轴心不重合,无

法实现左右都能够旋转９０°.

解决方案:重新拼装,多次测量,保证舵机９０°位置与炮台轴心基本重合.

问题７:舵机所要求的最高电压为６V,为了能够使炮弹发射车正常移动,直流电机所需

要的最大电压为１２V,分别供电则所用电池太多,炮弹发射车的总体重量会过大.

解决方案:用８节１．５V 电压提供１２V 电压,通过面包板将１２V 电压分压出６V 给舵

机供电.

[]{#index_split_006.html#p360}![index-360_1.png](https://i.imgur.com/rxjcZbX.jpeg){.calibre2}

３４９

１３．

６　元件清单

完成本项目所用到的元件及数量如表１３Ｇ１所示.

表１３Ｇ１　炮弹发射车元件清单

模　　块

元件/测试仪表

数量

导线

若干

杜邦线

若干

直流电机

２个

蓝牙模块

１个

小车部分

L２９８N 直流电机驱动模块

１个

ArduinoMEGA２５６０开发板

１个

小车组装配套所需零件

若干

１２V 电源(８节电池)

１个

电池盒

２个

导线

若干

杜邦线

若干

ArduinoUNO 开发板

１个

ArduinoSensorShieldv５．

０

１个

蓝牙模块

１个

炮台部分

玩具手枪

１个

亚克力板

若干

皮筋

２个

６V 电源(４节电池)

１个

电池盒

１个

亚克力板

若干

螺钉和螺丝

若干

外观部分

纸板

若干

移动电源

１个

[]{#index_split_006.html#p361}![index-361_1.png](https://i.imgur.com/ni9VU0R.jpeg){.calibre2}

第１４章

球形机器人项目设计

１４．

１　项目背景

机器人是当今最热的研究领域之一.机器人能够完美地替代工厂里辛劳的工人进行正

常工作.能够抵达遥远的月球,还能进入那灼热的火山里来帮助人们解锁大自然 的 秘 密.

在复杂的水下环境,它可以替代工作潜到水里甚至是深水里进行水下作业.地震、山洪等灾

害过后的灾区,经常有人因得不到救援而丧失生命,在这种情况下,机器人能够帮助进行伤

员搜寻、物资运送等紧急救灾工作.现在各大城市,机器人餐厅也相继涌现,机器人服务员

能为客人端茶送水、点菜下单.在农田里,机器人的出现提高了农作物的生产率和质量,解

放了劳动力,让农民避免了来自农药的危害.当然,机器人也可以成为代步工具,例如自驾

模式的汽车、载人平衡车等.

球形运动机器人是一种以球形或近似球形为外壳的独立运动体,它在运动方式上,以滚

动运动为主.由于这种运动方式和外壳的特殊性,使球形机器人与以往人们熟知的轮式或

轨道式机器人有很大不同.该类机器人在转向时具有独特的优势,比其他运动方式能更灵

活地转向;当发生高空坠落等危险情况时,球形装置可迅速调整运行状态,进行连续工作; 在探测过程中,当与障碍物或其他运动机构发生碰撞时,球形结构具有很强的恢复能力.另

外,由于球体滚动的阻力比滑动或轮式运动的阻力小很多,所以球形机器人具有运动效率

高、能量损耗小的特点.针对以上优势,球形机器人可以应用于危险环境的探测、管道内部

的焊缝检测、监控侦察等方面.目前,国内外越来越多的专家和学者开始重视这一类机器人

的研究与开发.

AarneHalme等人在１９９６年研制出了第一台真正意义上的球形运动机构.该机构通

过内部驱动单元(

InsideDriveUnit,

IDU)的运动来打破球体的平衡,但由于单轮驱动固有

的局限性,它无法实现球形机器人的全向滚动.IDU 是一个与直流电机固联的驱动轮,通

过轮的转动控制运动方向的改变.球体的球壳是由有机玻璃或其他相似的材料制成的,以

保证球体内部构件能够与外部控制部分进行无线电通信,如图１４Ｇ１所示.

本章根据柴霖、朱梦菲项目设计整理而成.

[]{#index_split_006.html#p362}![index-362_1.png](https://i.imgur.com/DQ2iVs9.jpeg){.calibre2}

![index-362_2.png](https://i.imgur.com/BNXNO6o.jpeg){.calibre2}

３５１

图１４Ｇ１　第一台球形运动机构

哈尔滨工业大学机器人技术与系统国家重点实验室的赵勃等人,对传统的偏心质量块

驱动方式进行了改进,研制了一种双偏心质量块驱动的球形机器人.双偏心质量块驱动的

球形机器人具有更快的移动速度和更灵活的转向能力,但将机器人的横滚角度限制在了一

定的范围,机器人不具有全方位滚动能力.

１９９７年,AntonioBicchi推出了自行设计的球形机器人 Sphericle.这种机器人在结构

上较为简单,是将一个小车放置在球体的内部,小车的每个车轮各装有一个驱动电机,在车

轮的前后用弹性支撑轮进行支撑.两轮小车携带有动力源、传感器、蓄电池和控制系统,所

有这些设备构成较重的质量块.这样,小车在自身重力的作用下,将车轮与球壳之间的滑动

减少到最小.

Roball代表了一类用于娱乐和家庭服务功能的球形机器人.当 Roball遇到４种不同

的情况时会采取相应的滚动速度和运动方向,这４种情况依次是突发事件、旋转、直行和巡

航.在遇到不同的情况时,通过语音系统可以发出各种声音或者播放不同的音乐,以增加和

孩子的交流能力.

SonyRobot机器人在结构上采用４个均布的电磁体和１个铁球的主体机构,通过电磁

体对铁球的不同吸附顺序和方式,机器人可以实现地面上的滚动、水平和垂直方向上的跳

动.同时,在跳起的过程中,它还可以进行重新定位.

北京邮电大学研制了一种球形机器人,如图１４Ｇ２所示.该球形机器人通过调整和改变

重心位置而产生的驱动力矩来实现机器人的滚动.其运动的具体实现是通过２个直流电机

分别驱动 ２组齿轮传动机构,从而带动相应的配重块向期望的方向偏转,以改变其重心位

置,最终使得整个球体向期望的方向移动.同时,通过调节其重心向两边偏斜,可以产生实

现机器人转向功能时所需要的力矩.

[]{#index_split_006.html#p363}![index-363_1.png](https://i.imgur.com/5DT9PLJ.jpeg){.calibre2}

![index-363_2.png](https://i.imgur.com/qWUHJDF.jpeg){.calibre2}

３５２

图１４Ｇ２　球形机器人实物

北京航空航天大学机器人研究所设计了一种新型月球探测车运动机构---------球型智能运

动单元(

SphericalSmartMovingUnit),该单元将机构、直流电机、驱动器和控制器集成密

封在一个球形的壳体内.它采用内部驱动的方式来控制球体的运动,依靠陀螺力获得它的

动态稳定性.球型智能运动单元可以通过无线或有线的通信方式接收外部的运动指令,也

可以做自主运动,它具有前进、后退、左转或右转等运动功能.

１４．

２　创新描述

１．硬件方面

(１)相对于球型机器人的各类实现结构,本项目选择现阶段最易实现的二轮小车摩

擦驱动结构,将二轮小车 放 入 硬 质 亚 克 力 球 中,通 过 橡 胶 轮 胎 的 摩 擦 力 驱 使 小 球 实 现 滚

动前进,通过 Arduino开发板编码控制左右轮的转动,从而实现前进、后退、左转、后 转 的

功能.

(２)为了使小球的底盘更加稳定,在两轮小车的底座创意性地加入两个牛眼轮,一方面

更加贴合球的表面,滚动效果更好,另一方面还可以作为配重使地盘更加稳定,相较于市面

上更为普遍的万向轮,牛眼轮的占用空间更小且转动半径更小.

(３)为了使小车在球的滚动过程中,两个塑胶底轮(驱动轮)始终贴合球的表面,创意性

地加入顶部支柱(其上安装万向轮),实现小车在球中的稳定滚动.

２．软件方面

关于软件部分,最初的思路是:在txt文档中输入一个图形(矩阵),通过代码转化为蓝

牙模块能识别的序列;在此基础上,加入绘图功能(优化 UI界面),即能通过在exe中的绘

图,识别出矩阵地图,通过双线程主函数分别控制地图输入和屏幕输出.利用自动模式不断

转化当前小车在轨道中的状态,实现小车在轨道中的暂停与行走,再将蓝牙能识别的运动序

列传到文档中.

加入地图循迹部分的 C++ 代码,具体实现过程为:

[]{#index_split_006.html#p364}![index-364_1.png](https://i.imgur.com/OTu0o4x.jpeg){.calibre2}

![index-364_2.png](https://i.imgur.com/FPDfb3z.jpeg){.calibre2}

３５３

(１)通过代码控制地图的绘制(只允许直角图形,形成收尾闭合的小球滚动轨道),全部

用二维数组(矩阵形式)来实现.

(２)将地图上的点阵形式转化为坐标,实现坐标的计算(枚举出直行、后退、左转、右转

的所有情 况 并 转 化 为 蓝 牙 可 以 识 别 的 控 制 指 令 );将 相 应 的 小 车 行 走 路 线 传 给 文 件

opreator,将opreator的序列输入蓝牙串口 APP中,实现对小车行走路线的控制.

(３)UI界面控制输出点阵,实现地图的可视化.

１４．

３　功能及总体设计

本项目期望达到的效果是实现实物导航系统.球形是一种灵活性更强、摩擦损耗相对

较小且结构封闭、不易受到外界影响而导致损坏的模型,球形机器人很适合应用于地形较为

复杂或人流密集的地区.本项目通过相应软件系统对导航系统或输入的信息进行处理,并

将信息通过蓝牙或其他方式传递到球形机器人的信息处理系统,最终实现球形机器人的导

航等功能.

１４．

３．

１　功能介绍

软件部分实现通过键盘 的 输 入,模拟绘制地图(地图通过相应软件可在相应文 件 中 可

见,地图可实现动态效果).与此同时,可将地图信息通过一定的处理,以字符串的 形 式 输

出,并下一步输入 Arduino开发板处理实现.

蓝牙模块基础功能:通过市场上的蓝牙串口软件,将手机上的信息通过手机蓝牙发送

到蓝牙模块,蓝牙模块接收信息后传递到 Arduino主板进行信息处理.

Arduino开发板部分:通过蓝牙输入数字或字符串,实现小车的基础行走、小车走出预

设图形、小车根据地图信息行走、小车自动寻人等功能.

１４．

３．

２　总体设计

１．整体框架图

项目整体框架如图１４Ｇ３所示.

图１４Ｇ３　整体框架图

[]{#index_split_006.html#p365}![index-365_1.png](https://i.imgur.com/BLUbBjq.jpeg){.calibre2}

![index-365_2.png](https://i.imgur.com/iYZhZeA.jpeg){.calibre2}

３５４

２．系统流程图

系统流程图如图１４Ｇ４所示.

图１４Ｇ４　系统流程图

用户可选择是否使用地图信息处理软件,对于通过蓝牙输入 Arduino开发板的信息,先

通过输入字符串的第一位数字判断此时应用哪一种功能,再根据程序相应的设置实现相应

的功能.由于系统中的自动寻人功能按照设计要求应在行走过程中始终运行,故优先级高

于其他功能,在程序功能选择之前即运行.

３．总电路图

系统总电路及 ArduinoUNO 开发板引脚如图１４Ｇ５所示,引脚连接如表１４Ｇ１所示.

表１４Ｇ１　电路连线

起始引脚(部件名/引脚)

连接引脚(部件名/引脚)

Arduino/RX

蓝牙 HCＧ０５/TX

Arduino/TX

蓝牙 HCＧ０５/RX

Arduino/３引脚

无源蜂鸣器I/O 输入引脚

Arduino/４引脚

直流电机板 L２９８N/IN３引脚

Arduino/５引脚

直流电机板 L２９８N/IN４引脚

Arduino/６引脚

直流电机板 L２９８N/IN１引脚

Arduino/７引脚

直流电机板 L２９８N/IN２引脚

Arduino/９引脚

人体红外传感器/OUT 引脚

Arduino/１０引脚

直流电机板 L２９８N/FNA 引脚

Arduino/１１引脚

直流电机板 L２９８N/FNB引脚

[]{#index_split_006.html#p366}![index-366_1.png](https://i.imgur.com/GlTrKjp.jpeg){.calibre2}

![index-366_2.png](https://i.imgur.com/98QOy21.jpeg){.calibre2}

３５５

续表

起始引脚(部件名/引脚)

连接引脚(部件名/引脚)

Arduino/(DIGITALPMW 侧)GND

直流电机板 L２９８N/GND 引脚

Arduino/(POWER 侧)GND１

无源蜂鸣器/GND 引脚

Arduino/(POWER 侧)GND２

蓝牙 HCＧ０５/GND 引脚

Arduino/(POWER 侧)５V１

蓝牙 HCＧ０５/VCC引脚

Arduino/(POWER 侧)３．

３V

无源蜂鸣器/VCC引脚

Arduino/(POWER 侧)５V２

人体红外传感器/VCC引脚

电机板 L２９８N/GND 引脚

人体红外传感器/GND 引脚

７．

４V 电池组/正极

直流电机板 L２９８N/＋１２V 引脚

７．

４V 电池组/负极

直流电机板 L２９８N/GND 引脚

直流电机１/１引脚

直流电机板 L２９８N/OUT２Ｇ１引脚

直流电机１/２引脚

直流电机板 L２９８N/OUT２Ｇ２引脚

直流电机２/１引脚

直流电机板 L２９８N/OUT３Ｇ１引脚

直流电机２/２引脚

直流电机板 L２９８N/OUT３Ｇ２引脚

９V 方形电池/接口

Arduino/供电引脚

图１４Ｇ５　总电路图

对于本系统,由于两轮小车在球中行进,行进过程中难免有部件撞击球内壁,故基于系

统稳定性的考虑,本设计中连线的可靠性极为重要.作为球形体,置于球内部的小车在立体

结构的重量分配上必须尽量平衡,以保证小车在行进过程中尽量减少轮子与内壁不必要的

[]{#index_split_006.html#p367}![index-367_1.png](https://i.imgur.com/RwDqbqS.jpeg){.calibre2}

３５６

滑动摩擦.以上提及的问题在连线图中无法体现,故在此总结陈述.综上,虽然系统结构较

为简单,但在实际连接过程中需要注意很多问题.

１４．

３．

３　模块介绍

本项目主要包括 Arduino开发板行进模块、人体红外感应模块、无源蜂鸣器模块、硬件

设计模块、地图编辑模块和 Arduino开发板主程序模块.下面分别给出各模块的功能、元

件、电路图和相关代码.

１．Arduino开发板行进模块

１)功能介绍

蓝牙模块负责接收手机传来的信息,Arduino开发板通过相应代码处理输入信息,再将

处理过的信息输 入 直 流 电 机 板 L２９８N 模块来控制左右两个直流电机转 动.电 路 连 线 见

表１４Ｇ１,相关功能实现如表１４Ｇ２所示.

表１４Ｇ２　相关功能

输入字符

模式

实 现 功 能

１

模式一

可根据输入地图信息行走

可实现基本的行 走 功 能:０ 停 止;１ 前 进;２ 后 退;３ 左

２

模式二

转;４右转

第二位为７则走正方形;第二位为８则走三角形;第二

３

模式三

位为９则走圆形

２)相关代码

走地图模式 此程序可单独运行

Stringcomdata ＝ ＂＂

charnumdata １０ ＝ \'６\' \'６\' \'６\' \'６\' \'６\' \'６\' \'６\' \'６\' \'６\' \'６\'

intmark ＝ ０

＃defineIN１６

７和６为右轮

＃defineIN２７

＃defineIN３４

５和４为左轮

＃defineIN４５

＃definerP１０

右轮配速

＃definelP１１

左轮配速

voidsetup

pinMode IN１

OUTPUT

pinMode IN２

OUTPUT

pinMode IN３

OUTPUT

pinMode IN４

OUTPUT

pinMode rP

OUTPUT

pinMode lP

OUTPUT

Serial敭

begin ９６００

[]{#index_split_006.html#p368}![index-368_1.png](https://i.imgur.com/GEdxONq.jpeg){.calibre2}

![index-368_2.png](https://i.imgur.com/bXZnZKG.jpeg){.calibre2}

![index-368_3.png](https://i.imgur.com/i8Aa8A9.jpeg){.calibre2}

３５７

voidloop

intj ＝ ０

while Serial敭available ０

此模块为识别输入的字符串

comdata＋＝ char Serial敭read

先将输入导入一个字符串中

delay ５

mark＝ １

标记有信息输入

if mark＝＝ １

有信息输入时执行以下操作

Serial敭println comdata

返回收到的字符串

Serial敭

println comdata敭

length

for inti＝ ０ i comdata敭

length i++

if comdata i ＝＝ \' \'

输入以＂

＂为识别符区分每个变量

j++

else

numdata j ＝comdata i

将字符串导入数组 去除＂

＂

comdata ＝ String ＂＂

初始化以备下次使用

mark ＝ ０

Serial敭

println numdata

for inti＝ ０ numdata i

＝ \'６\' i++

地图行走

if numdata i ＝＝ \'１\'

识别向前、左转直角、右转直角

numdata i ＝ \'６\'

gostraight

elseif numdata i ＝＝ \'３\'

numdata i ＝ \'６\'

初始化以备下次使用

goleft

elseif numdata i ＝＝ \'４\'

numdata i ＝ \'６\'

goright

analogWrite lP ８０

analogWrite rP １００

[]{#index_split_006.html#p369}![index-369_1.png](https://i.imgur.com/25sYKQH.jpeg){.calibre2}

３５８

digitalWrite IN１

LOW

digitalWrite IN２

LOW

地图结束 小车停止

digitalWrite IN３

LOW

digitalWrite IN４

LOW

delay ３０００

voidgostraight

模式一函数

analogWrite lP ８０

analogWrite rP １００

digitalWrite IN１

HIGH

digitalWrite IN２

LOW

右轮前进

digitalWrite IN３

HIGH

digitalWrite IN４

LOW

左轮前进

delay ３０００

voidgoleft

analogWrite lP ８０

analogWrite rP １００

digitalWrite IN１

LOW

digitalWrite IN２

LOW

右轮前进

digitalWrite IN３

HIGH

digitalWrite IN４

LOW

左轮前进

delay ３０００

voidgoright

analogWrite lP ８０

analogWrite rP １００

digitalWrite IN１

HIGH

digitalWrite IN２

LOW

右轮前进

digitalWrite IN３

LOW

digitalWrite IN４

LOW

左轮前进

delay ３０００

２．人体红外感应模块

１)功能介绍

如图１４Ｇ６所示,人体感应模块可以将感应值输入 Arduino开发板以控制直流电机的转

动,带动球体先旋转４５°再直行一小段距离,以实现系统的自动寻人功能.需要注意的是, 人体红外感应部件在感应到人体之后会有３\~５s的锁死,期间模块不能感应,这是传感器制

作工艺问题,锁死解除后可进行下一次感应.

[]{#index_split_006.html#p370}![index-370_1.png](https://i.imgur.com/bgDs5PG.jpeg){.calibre2}

![index-370_2.png](https://i.imgur.com/SuGbHSI.jpeg){.calibre2}

３５９

图１４Ｇ６　自动寻人功能示意图

２)相关代码

＃defineIN１６

７和６为右轮

＃defineIN２７

＃defineIN３４

５和４为左轮

＃defineIN４５

＃definerP１０

右轮配速

＃definelP１１

左轮配速

intPIR ＝９

定义DIGITAL９为PIR 红外热释电传感器

intled ＝１３

定义DIGITAL８为LED 发光模块

inti＝０

voidsetup

pinMode IN１

OUTPUT

pinMode IN２

OUTPUT

pinMode IN３

OUTPUT

pinMode IN４

OUTPUT

pinMode rP

OUTPUT

pinMode lP

OUTPUT

pinMode led

OUTPUT

设置LED为数字输出

pinMode PIR

INPUT

设置PIR为数字输入

voidloop

if digitalRead PIR

如果有人通过人体红外感应模块

digitalWrite led

HIGH

发光模块点亮

digitalWrite IN１

LOW

digitalWrite IN２

LOW

右轮不动

digitalWrite IN３

LOW

digitalWrite IN４

LOW

elseif i＝＝０

[]{#index_split_006.html#p371}![index-371_1.png](https://i.imgur.com/sCICpXu.jpeg){.calibre2}

![index-371_2.png](https://i.imgur.com/Antp4aP.jpeg){.calibre2}

３６０

digitalWrite led LOW

发光模块熄灭

analogWrite lP ８０

analogWrite rP １００

digitalWrite IN１

LOW

digitalWrite IN２

LOW

右轮不动 左轮转动 右转

digitalWrite IN３

HIGH

digitalWrite IN４

LOW

i++

elseif i＝＝１

digitalWrite led

LOW

发光模块熄灭

analogWrite lP ８０

analogWrite rP １００

digitalWrite IN１

LOW

digitalWrite IN２

LOW

左轮不动 右轮转动 左转

digitalWrite IN３

HIGH

digitalWrite IN４

LOW

i－－

３．无源蜂鸣器模块

１)功能介绍

无源蜂鸣器接在 Arduino开发板上,在实现行走功能时可以播放歌曲«小星星»,可以增

加趣味性.

２)相关代码

音乐播放和画圆同步

＃defineIN１６

７和６为右轮

＃defineIN２７

＃defineIN３４

５和４为左轮

＃defineIN４５

＃definerP１０

右轮配速

＃definelP１１

左轮配速

intspeakerPin ＝ ３

intlength ＝ １５

charnotes ＝ ＂ccggaagffeeddc＂

intbeats ＝ １ １ １ １ １ １ ２ １ １ １ １ １ １ ２ ４

inttempo ＝ ３００

voidplayTone inttone intduration

for longi＝ ０ i duration∗ １０００L i＋＝ tone∗ ２

[]{#index_split_006.html#p372}![index-372_1.png](https://i.imgur.com/VV3Eq0t.jpeg){.calibre2}

![index-372_2.png](https://i.imgur.com/VFFw8D8.jpeg){.calibre2}

![index-372_3.png](https://i.imgur.com/iNfZl6i.jpeg){.calibre2}

３６１

digitalWrite speakerPin HIGH

delayMicroseconds tone

digitalWrite speakerPin LOW

analogWrite lP ８０

analogWrite rP １００

digitalWrite IN１

HIGH

digitalWrite IN２

LOW

左轮不动 右轮转动 左转

digitalWrite IN３

LOW

digitalWrite IN４

LOW

delayMicroseconds tone

analogWrite lP

８０

analogWrite rP １００

digitalWrite IN１

LOW

digitalWrite IN２

LOW

右轮不动 左轮转动 右转

digitalWrite IN３

HIGH

digitalWrite IN４

LOW

delayMicroseconds tone

voidplayNote charnote intduration

charnames ＝ \'c\' \'d\' \'e\' \'f\' \'g\' \'a\' \'b\' \'C\'

inttones ＝ １９１５ １７００ １５１９ １４３２ １２７５ １１３６ １０１４ ９５６

播放音乐

for inti＝ ０ i ８ i++

if names i ＝＝ note

playTone tones i duration

voidsetup

pinMode speakerPin OUTPUT

pinMode IN１

OUTPUT

pinMode IN２

OUTPUT

pinMode IN３

OUTPUT

pinMode IN４

OUTPUT

pinMode rP

OUTPUT

pinMode lP

OUTPUT

voidloop

for inti＝ ０ i length i++

if notes i ＝＝ \' \'

[]{#index_split_006.html#p373}![index-373_1.png](https://i.imgur.com/1PP500j.jpeg){.calibre2}

![index-373_2.png](https://i.imgur.com/Vhi4f2w.jpeg){.calibre2}

![index-373_3.png](https://i.imgur.com/jsut0KI.jpeg){.calibre2}

３６２

analogWrite lP ８０

analogWrite rP １００

digitalWrite IN１

LOW

digitalWrite IN２

LOW

直行

digitalWrite IN３

LOW

digitalWrite IN４

LOW

delay beats i ∗ tempo

停顿

else

playNote notes i beats i ∗ tempo

停顿

delay tempo ２

４．硬件设计模块

由于本项目设计的特殊性,硬件部件的摆放位置及结构设计尤为重要.为实现球体能

够按照既定的程序行进,要求小车在球内始终占据球的下半部分,同时要使小车与球的滑动

摩擦达到最小而使滚动摩擦达到最大,如图１４Ｇ７所示.

图１４Ｇ７　球内部小车结构简图

图１４Ｇ８　球内部小车牛眼轮位置及贴合示意图

根据所购买的小车底板上的孔洞设计,多次调整牛眼轮的放置位置,使牛眼轮可以贴合

球壳,从而使小车在球中更加稳固,如图１４Ｇ８所示.

另外,因为主轮仍为较大的小车车轮,为减少小车在行进过程中倒向一边而导致空转的

可能,需要根据小车底板上的孔洞设计,反复试验调整小车上各个部件的位置,以使小车在

两主轮作为支撑时其自身左右部分更加平衡,如图１４Ｇ９所示.

同时,需要一个支柱来抵住小车,以防止小车在行进过程中在球中倒置,导致小车空转, 不能自行恢复至正常行进状态.因此,使用不同长度的铜柱叠加构成了支柱并将万向轮置

于其上,如图１４Ｇ１０所示.

[]{#index_split_006.html#p374}![index-374_1.png](https://i.imgur.com/PqN8HZF.jpeg){.calibre2}

![index-374_2.png](https://i.imgur.com/7IrOysD.jpeg){.calibre2}

![index-374_3.png](https://i.imgur.com/IS5elGL.jpeg){.calibre2}

![index-374_4.png](https://i.imgur.com/EzWbLXi.jpeg){.calibre2}

![index-374_5.png](https://i.imgur.com/vIaxLeL.jpeg){.calibre2}

![index-374_6.png](https://i.imgur.com/HTk6pMS.jpeg){.calibre2}

![index-374_7.png](https://i.imgur.com/pwBM4T8.jpeg){.calibre2}

![index-374_8.png](https://i.imgur.com/FZB7Grd.jpeg){.calibre2}

![index-374_9.png](https://i.imgur.com/C173oFj.jpeg){.calibre2}

![index-374_10.png](https://i.imgur.com/dt3e6R6.jpeg){.calibre2}

![index-374_11.png](https://i.imgur.com/iposb1w.jpeg){.calibre2}

３６３

图１４Ｇ９　球内部小车各部件位置

图１４Ｇ１０　球内部小车支柱与万向轮位置

５．地图编辑模块

１)功能介绍

地图编辑软件基于 C++ 语言设计,可以实现通过键盘的输入模拟绘制地图的过程(地图

通过相应软件可在相应文件中可见,地图可实现动态效果,也可以txt文件可见).同时,可

将地图信息通过一定的 处 理,以字符串的形式输出,用于输入 Arduino开发板进行下一步

处理.

２)相关代码

地图编辑器

＃include stdio敭h

＃include stdlib敭h

＃include conio敭h

＃include Windows敭h

＃definem１６

＃definen２５

intx＝１

y＝１

fx

fy

state＝０

number＝１

end＝０

FILE∗ fileptr

voidoperate

inttrack m n ＝ ０

轨道数组

inttrain m n ＝ ０

屏幕输出数组

intscreen m n ＝ ０

当前位置数组

voidsign int

int

int

voidsetcolor int

voidprintscreen

voidwriterecord

[]{#index_split_006.html#p375}![index-375_1.png](https://i.imgur.com/7F7C1uT.jpeg){.calibre2}

３６４

voidmain

fileptr＝fopen ＂map敭txt＂

＂w＂

intorder

printscreen

进行打印屏幕操作 为了让小车有运动中动画效果

不断进行清屏和重新打印的操作

while １

operate

if end＝＝１

break

system ＂cls＂

执行DOS命令 清屏

printscreen

writerecord

voidoperate

此处使用枚举法 判断不同状态 每个状态里输入不

同的order

intorder i j

order＝getch

order是指键盘上的w键或a键或s键或d键 所以

必须调用系统库函数

cohic敭

h读取char型字符

if order＝＝１３

回车的ASCII码是１３

end＝１

return

if state＝＝０

如果当前状态是０ 通过移动光标判断order 进一

步判断二维数组中的进位

if order＝＝ \'a\'&& x

＝fx\|\|y

＝fy 输入＂a＂且不碰到边界 向左一格

y－－

elseif order＝＝ \'s\'

输入＂s＂且不碰到边界 向下一格

x++

elseif order＝＝＂d＂

输入＂d＂且不碰到边界 向右一格

y++

elseif order＝＝ \'w\'

输入＂w＂且不碰到边界 向上一格

x－－

if x＝＝m－１

碰到边界的情况

x＝m－２

if x＝＝０

x＝１

if y＝＝n－１

[]{#index_split_006.html#p376}![index-376_1.png](https://i.imgur.com/4Yu5xKy.jpeg){.calibre2}

![index-376_2.png](https://i.imgur.com/GS3dtsY.jpeg){.calibre2}

![index-376_3.png](https://i.imgur.com/XLFPqBH.jpeg){.calibre2}

![index-376_4.png](https://i.imgur.com/uMQIglD.jpeg){.calibre2}

![index-376_5.png](https://i.imgur.com/ig0j5J9.jpeg){.calibre2}

３６５

y＝n－２

if y＝＝０

y＝１

if order＝＝ \' \'&& x

＝fx\|\|y

＝fy 如果order为空 确认 在屏幕上进行显示

sign x y number

fx＝x

fy＝y

state＝１

如果按了空格 跳转到状态一

return

if state＝＝１

状态一

if x＝＝fx&&order＝＝ \'a\'

y－－

elseif y＝＝fy&&order＝＝ \'s\'

x++

elseif x＝＝fx&&order＝＝ \'d\'

y++

elseif y＝＝fy&&order＝＝ \'w\'

x－－

if x＝＝m－１

x＝m－２

if x＝＝０

x＝１

if y＝＝n－１

y＝n－２

if y＝＝０

y＝１

if order＝＝ \' \'&& x

＝fx\|\|y

＝fy

if track x y

＝number

sign x y number

for i＝x i ＝fx i++

sign i y number

for i＝fx i ＝x i++

sign i y number

for i＝y i ＝fy i++

sign x i number

for i＝fy i ＝y i++

sign x i number

[]{#index_split_006.html#p377}![index-377_1.png](https://i.imgur.com/PjL0I4E.jpeg){.calibre2}

![index-377_2.png](https://i.imgur.com/PRtMG6L.jpeg){.calibre2}

![index-377_3.png](https://i.imgur.com/zrZ6x8p.jpeg){.calibre2}

![index-377_4.png](https://i.imgur.com/1XDthre.jpeg){.calibre2}

![index-377_5.png](https://i.imgur.com/PpdXJud.jpeg){.calibre2}

３６６

fx＝x

fy＝y

state＝１

return

if track x y ＝＝number

sign x y number

for i＝x i ＝fx i++

sign i y number

for i＝fx i ＝x i++

sign i y number

for i＝y i ＝fy i++

sign x i number

for i＝fy i ＝y i++

sign x i number

fx＝x

fy＝y

state＝２

return

if state＝＝２

if track x y－１ ＝＝number&&order＝＝ \'a\'

y－－

elseif track x＋１ y ＝＝number&&order＝＝ \'s\'

x++

elseif track x y＋１ ＝＝number&&order＝＝ \'d\'

y++

elseif track x－１ y ＝＝number&&order＝＝ \'w\'

x－－

if x＝＝m－１

x＝m－２

if x＝＝０

x＝１

if y＝＝n－１

y＝n－２

if y＝＝０

y＝１

if order＝＝ \' \'

[]{#index_split_006.html#p378}![index-378_1.png](https://i.imgur.com/6LyouCx.jpeg){.calibre2}

![index-378_2.png](https://i.imgur.com/j9vK8fV.jpeg){.calibre2}

![index-378_3.png](https://i.imgur.com/FJVlKeQ.jpeg){.calibre2}

３６７

train x y ＝number＋６４

fx＝x

fy＝y

state＝３

return

if state＝＝３

if track x y－１ ＝＝number&&order＝＝ \'a\'

y－－

elseif track x＋１ y ＝＝number&&order＝＝ \'s\'

x++

elseif track x y＋１ ＝＝number&&order＝＝ \'d\'

y++

elseif track x－１ y ＝＝number&&order＝＝ \'w\'

x－－

if x＝＝m－１

x＝m－２

if x＝＝０

x＝１

if y＝＝n－１

y＝n－２

if y＝＝０

y＝１

if order＝＝ \' \'&& y＝＝fy&& x＝＝fx＋１\|\|x＝＝fx－１ \|\| x＝＝fx&& y＝＝fy＋１\|\|y＝＝

fy－１

train x y ＝number＋９６

fx＝x

fy＝y

state＝０

number++

return

voidsign intx

inty

intnumber

画轨道函数

if track x y ＝＝０

track x y ＝number

if track x y ＝１&&track x y ＝６&&track x y

＝number

track x y ＝９

[]{#index_split_006.html#p379}![index-379_1.png](https://i.imgur.com/a12CiP6.jpeg){.calibre2}

![index-379_2.png](https://i.imgur.com/Y54i6Br.jpeg){.calibre2}

![index-379_3.png](https://i.imgur.com/wrKjdgF.jpeg){.calibre2}

![index-379_4.png](https://i.imgur.com/XRPjCix.jpeg){.calibre2}

![index-379_5.png](https://i.imgur.com/fUDze6h.jpeg){.calibre2}

![index-379_6.png](https://i.imgur.com/ez5lubV.jpeg){.calibre2}

![index-379_7.png](https://i.imgur.com/mFhNDN8.jpeg){.calibre2}

![index-379_8.png](https://i.imgur.com/2bFYpON.jpeg){.calibre2}

![index-379_9.png](https://i.imgur.com/OYJqCBs.jpeg){.calibre2}

３６８

voidsetcolor intcolor

设置颜色

switch color

case０

白 色 　 　 　SetConsoleTextAttribute GetStdHandle STD_OUTPUT_HANDLE

FOREGROUND_INTENSITY\|FOREGROUND_RED\|FOREGROUND_GREEN\|FOREGROUND_BLUE

break

case１

红 色 　 　 　SetConsoleTextAttribute GetStdHandle STD_OUTPUT_HANDLE

FOREGROUND_INTENSITY\|FOREGROUND_RED

break

case２

绿 色 　 　 　SetConsoleTextAttribute GetStdHandle STD_OUTPUT_HANDLE

FOREGROUND_INTENSITY\|FOREGROUND_GREEN

break

case３

蓝 色 　 　 　SetConsoleTextAttribute GetStdHandle STD_OUTPUT_HANDLE

FOREGROUND_INTENSITY\|FOREGROUND_BLUE

break

case４

紫 色 　 　 　SetConsoleTextAttribute GetStdHandle STD_OUTPUT_HANDLE

FOREGROUND_INTENSITY\|FOREGROUND_RED\|FOREGROUND_BLUE

break

case５

[]{#index_split_007.html}

蓝 色 　 　 　SetConsoleTextAttribute GetStdHandle STD_OUTPUT_HANDLE

FOREGROUND_INTENSITY\|FOREGROUND_GREEN\|FOREGROUND_BLUE

break

case６

黄 色 　 　 　SetConsoleTextAttribute GetStdHandle STD_OUTPUT_HANDLE

FOREGROUND_INTENSITY\|FOREGROUND_RED\|FOREGROUND_GREEN

break

default

break

voidprintscreen

inti j

for i＝０ i m i++

for j＝０ j n j++

screen i j ＝track i j

for i＝０ i m i++

for j＝０ j n j++

if train i j ＝ \'A\'&&train i j ＝ \'Z\'

screen i j ＝ \'T\'

if train i j ＝ \'a\'&&train i j ＝ \'z\'

screen i j ＝ \'t\'

[]{#index_split_007.html#p380}![index-380_1.png](https://i.imgur.com/XAKBpvq.jpeg){.calibre2}

![index-380_2.png](https://i.imgur.com/7OaCj37.jpeg){.calibre2}

![index-380_3.png](https://i.imgur.com/um5tV33.jpeg){.calibre2}

![index-380_4.png](https://i.imgur.com/Hc65n9e.jpeg){.calibre2}

![index-380_5.png](https://i.imgur.com/rALUBfo.jpeg){.calibre2}

![index-380_6.png](https://i.imgur.com/HS2SFdi.jpeg){.calibre2}

![index-380_7.png](https://i.imgur.com/qHcLWYq.jpeg){.calibre2}

![index-380_8.png](https://i.imgur.com/JddQ1zN.jpeg){.calibre2}

![index-380_9.png](https://i.imgur.com/MybZQ0N.jpeg){.calibre2}

３６９

for i＝０ i m i++

F是边界设定

screen i ０ ＝ \'F\'

for i＝０ i m i++

screen i n－１ ＝ \'F\'

for i＝０ i n i++

screen ０ i ＝ \'F\'

for i＝０ i n i++

screen m－１ i ＝ \'F\'

screen x y ＝ \'p\'

for i＝０ i m i++

for j＝０ j n j++

if screen i j ＝＝０

printf ＂＂

if screen i j ＝１&&screen i j ＝２０

setcolor ０

printf ＂□＂

if screen i j ＝＝ \'T\'

setcolor train i j －６４

printf ＂◆＂

if screen i j ＝＝ \'t\'

setcolor train i j －９６

printf ＂█＂

if screen i j ＝＝ \'F\'

setcolor ０

printf ＂▓＂

if screen i j ＝＝ \'p\'

setcolor number

switch state

case０ printf ＂□＂ break

case１ printf ＂□＂ break

[]{#index_split_007.html#p381}![index-381_1.png](https://i.imgur.com/rsd1Yvk.jpeg){.calibre2}

![index-381_2.png](https://i.imgur.com/VKRM3IP.jpeg){.calibre2}

![index-381_3.png](https://i.imgur.com/Y1cRsCY.jpeg){.calibre2}

![index-381_4.png](https://i.imgur.com/xvVae3Q.jpeg){.calibre2}

![index-381_5.png](https://i.imgur.com/Fo02s7a.jpeg){.calibre2}

![index-381_6.png](https://i.imgur.com/XGOCZTg.jpeg){.calibre2}

![index-381_7.png](https://i.imgur.com/7n8SueF.jpeg){.calibre2}

![index-381_8.png](https://i.imgur.com/vfGjZH1.jpeg){.calibre2}

３７０

case２ printf ＂◆＂ break

case３ printf ＂█＂ break

default break

printf ＂\\n＂

voidwriterecord

inti j

for i＝０ i m i++

for j＝０ j n j++

if track i j

＝０

track i j ＝track i j ＋４８

if train i j

＝０

track i j ＝train i j

for i＝０ i m i++

for j＝０ j n j++

if track i j

＝０

putc track i j fileptr

if track i j ＝＝０

putc \' \' fileptr

if j n－１

putc \' \' fileptr

putc \'\\n\' fileptr

∗

system ＂cls＂

for i＝０ i m i++

for j＝０ j n j++

printf ＂％c＂ track i j

printf ＂\\n＂

∗

地图绘制结果如图１４Ｇ１１所示;记事本显示如图１４Ｇ１２所示.

[]{#index_split_007.html#p382}![index-382_1.png](https://i.imgur.com/iAlXafB.jpeg){.calibre2}

![index-382_2.png](https://i.imgur.com/ypZtLbw.jpeg){.calibre2}

![index-382_3.png](https://i.imgur.com/9sJxeGG.jpeg){.calibre2}

![index-382_4.png](https://i.imgur.com/Kn7PmND.jpeg){.calibre2}

![index-382_5.png](https://i.imgur.com/EzJKfpO.jpeg){.calibre2}

![index-382_6.png](https://i.imgur.com/g8px4mN.jpeg){.calibre2}

![index-382_7.png](https://i.imgur.com/BnelR4I.jpeg){.calibre2}

![index-382_8.png](https://i.imgur.com/gGxyf7k.jpeg){.calibre2}

![index-382_9.png](https://i.imgur.com/epfpIds.jpeg){.calibre2}

![index-382_10.png](https://i.imgur.com/QHkCcfF.jpeg){.calibre2}

![index-382_11.png](https://i.imgur.com/9WIz6Yv.jpeg){.calibre2}

３７１

图１４Ｇ１１　地图绘制结果

图１４Ｇ１２　记事本显示

第二部分 UI界面 让机器人动起来

＃include stdio敭h

＃include Windows敭h

＃include stdlib敭h

＃include conio敭h

＃definem１６

边界

＃definen２５

边界

[]{#index_split_007.html#p383}![index-383_1.png](https://i.imgur.com/4Z4MMsi.jpeg){.calibre2}

３７２

inttrack m n ＝ ０

轨道数组

intscreen m n ＝ ０

屏幕输出数组

intposition m n ＝ ０

当前位置数组

intforeposition m n ＝ ０

历史位置 扫描历史位置周围的８个点

intstate m n ＝ ０

intorder ８ ＝ １

１

１

１

１

１

１

１

inttime＝０

num

intdir

fdir＝０

FILE∗ recordptr

FILE∗ opreatorptr

voidputinthetrack

从文件中读取轨道

voidputinthepositon

从文件中读取车头和车尾的位置

voidprintscreen

打印屏幕

voidrun

voidautomatamachine int

int

int

int

int

自动机模式

intjudgestate int

int

int

int

int

判断轨道状态

intchecksaretrack int

int

int

int

voidstay int

int

int

int

int

voidmove int

int

int

int

int

voidputintheforepositon

voidsetcolor int

voidwriterecord

intgetnum

voidlittle_main

voidinput

intmain

执行双线程 输入和印屏使用两个线程

opreatorptr＝fopen ＂opreator敭txt＂

＂a＂

DWORDThreadID１ ＝ １

HANDLEhRead１ ＝ CreateThread NULL ０ LPTHREAD_START_ROUTINE little_main NULL ０

&ThreadID１

运行little_main

DWORDThreadID２ ＝ ２

HANDLE hRead２ ＝ CreateThread NULL ０ LPTHREAD_START\_ ROUTINE input NULL ０

&ThreadID２

运行input

while １

Sleep １００

每休息１００ms进行清屏

system ＂PAUSE＂

fclose opreatorptr

return０

[]{#index_split_007.html#p384}![index-384_1.png](https://i.imgur.com/HzamEyV.jpeg){.calibre2}

![index-384_2.png](https://i.imgur.com/gq2dmBc.jpeg){.calibre2}

![index-384_3.png](https://i.imgur.com/Ue4jFk3.jpeg){.calibre2}

![index-384_4.png](https://i.imgur.com/ppButzT.jpeg){.calibre2}

![index-384_5.png](https://i.imgur.com/DG6gSGF.jpeg){.calibre2}

![index-384_6.png](https://i.imgur.com/K4Vbtgq.jpeg){.calibre2}

![index-384_7.png](https://i.imgur.com/wIBsKyx.jpeg){.calibre2}

３７３

voidinput

intch

while １

ch＝getch

if ch ＝ \'１\'&&ch ＝ \'８\'

该库函数读到的字符型变量 必须进行ASCII码转换

order ch－４８ ＝－order ch－４８

voidlittle_main

双线程的输入部分

putinthetrack

putinthepositon

putintheforepositon

分别运行三个读取函数 得到轨道、当前位置和下

一位置的信息

num＝getnum

recordptr＝fopen ＂trainrecord敭

txt＂

＂w＂ 记录小车当前的状态

for time＝０

１

time++

run

system ＂cls＂

printscreen

writerecord

Sleep １５０

每隔１５０ms进行清屏

voidputinthetrack

打开map敭

txt 将已有数据读入track二维数组

inti j

FILE∗ fileptr

fileptr＝fopen ＂map敭txt＂

＂r＂

打开并准备写入map敭

txt

for i＝０ i m i++

for j＝０ j n j++

track i j ＝getc fileptr 文件中读取轨道位置

getc fileptr

for i＝０ i m i++

for j＝０ j n j++

注意此处需要进行ASCII码的转换

if track i j ＝＝ \' \'

空格即没有轨道

[]{#index_split_007.html#p385}![index-385_1.png](https://i.imgur.com/pCHEPl8.jpeg){.calibre2}

![index-385_2.png](https://i.imgur.com/kjMR28y.jpeg){.calibre2}

![index-385_3.png](https://i.imgur.com/0rIeiaF.jpeg){.calibre2}

![index-385_4.png](https://i.imgur.com/EET1Gba.jpeg){.calibre2}

![index-385_5.png](https://i.imgur.com/7LxYFCh.jpeg){.calibre2}

![index-385_6.png](https://i.imgur.com/8OZEe4B.jpeg){.calibre2}

![index-385_7.png](https://i.imgur.com/8rWtcCR.jpeg){.calibre2}

![index-385_8.png](https://i.imgur.com/Vzg7xmK.jpeg){.calibre2}

![index-385_9.png](https://i.imgur.com/3SbDeAY.jpeg){.calibre2}

![index-385_10.png](https://i.imgur.com/pmu4OPV.jpeg){.calibre2}

![index-385_11.png](https://i.imgur.com/WSTaTIA.jpeg){.calibre2}

![index-385_12.png](https://i.imgur.com/tAF6HTD.jpeg){.calibre2}

![index-385_13.png](https://i.imgur.com/Jy01nxx.jpeg){.calibre2}

![index-385_14.png](https://i.imgur.com/FO58Ict.jpeg){.calibre2}

![index-385_15.png](https://i.imgur.com/PrT5Ixj.jpeg){.calibre2}

３７４

track i j ＝０

if track i j ＝ \'１\'&&track i j ＝ \'９\'

track i j －＝４８

if track i j ＝ \'A\'&&track i j

＝ \'

Z\'

大写字母代表车头

track i j －＝６４

if track i j ＝ \'a\'&&track i j ＝ \'z\' 小写字母代表车尾

track i j －＝９６

fclose fileptr

voidputinthepositon

打开map文件 读取车头的位置

inti j

FILE∗ fileptr

fileptr＝fopen ＂map敭txt＂

＂r＂

for i＝０ i m i++

for j＝０ j n j++

position i j ＝getc fileptr

getc fileptr

for i＝０ i m i++

for j＝０ j n j++

if position i j ＝ \'A\'&&position i j ＝ \'Z\'

大写字母车头的位置

position i j －＝６４

else

position i j ＝０

fclose fileptr

voidputintheforepositon

打开map 读取当前位置的前一个位置

inti j

FILE∗ fileptr

fileptr＝fopen ＂map敭txt＂

＂r＂

for i＝０ i m i++

for j＝０ j n j++

foreposition i j ＝getc fileptr

找到小车当前所在位置

getc fileptr

[]{#index_split_007.html#p386}![index-386_1.png](https://i.imgur.com/LcIl8s0.jpeg){.calibre2}

![index-386_2.png](https://i.imgur.com/j8lFp2V.jpeg){.calibre2}

![index-386_3.png](https://i.imgur.com/9lPphq9.jpeg){.calibre2}

![index-386_4.png](https://i.imgur.com/FnM5QQ4.jpeg){.calibre2}

![index-386_5.png](https://i.imgur.com/kbaUwcg.jpeg){.calibre2}

![index-386_6.png](https://i.imgur.com/tbwGLZW.jpeg){.calibre2}

![index-386_7.png](https://i.imgur.com/Vji5mo0.jpeg){.calibre2}

![index-386_8.png](https://i.imgur.com/GPKfr9D.jpeg){.calibre2}

![index-386_9.png](https://i.imgur.com/ZcndFNT.jpeg){.calibre2}

３７５

for i＝０ i m i++

for j＝０ j n j++

if foreposition i j ＝ \'a\'&&foreposition i j ＝ \'z\'

判断小车车身所在位置并进行ASCII码转换

foreposition i j －＝９６

else

foreposition i j ＝０

fclose fileptr

voidrun

inti j k

intx １０ ＝ ０ y １０ ＝ ０ fx １０ ＝ ０ fy １０ ＝ ０

读入所有车的位置信息与历史位置信息并存储在４个数组中

for i＝０ i m i++

for j＝０ j n j++

if position i j

＝０

x position i j ＝i

y position i j ＝j

for i＝０ i m i++

for j＝０ j n j++

if foreposition i j

＝０

fx foreposition i j ＝i

将现有的forposition二维数组转化为所需要的坐标点位置

fy foreposition i j ＝j

for k＝１ x k

＝０

k++

顺序逐个执行自动机

automatamachine x k y k fx k fy k k 需要的参数就是转换出来的二维x、

y坐标点

voidautomatamachine intx

inty

intfx

intfy

intnumber 自动机装置

intstate

注意 为了得到蓝牙能识别的数组 需要进行坐标转化为蓝牙命令的枚举判断

state＝judgestate x y fx fy number

根据judgestate函数判定状态

if state＝＝０

stay x y fx fy number

执行停动作

if state＝＝１

[]{#index_split_007.html#p387}![index-387_1.png](https://i.imgur.com/q5qw43u.jpeg){.calibre2}

３７６

move x y fx fy number

执行走动作

if １

识别前进、后退、左转、右转并将识别出的数字保存在opreator中

charcommand

if state＝＝ ０

command＝ ０

else

command＝ １

intdx＝ x－fx

intdy＝ y－fy

if dx＝＝０&&dy＝＝１

dir＝１

直行

elseif dx＝＝０&&dy＝＝－１

dir＝２

后退

elseif dx＝＝１&&dy＝＝０

dir＝３

左转

elseif dx＝＝－１&&dy＝＝０

dir＝４

右转

if fdir＝＝ １&&dir＝＝ ４

对dir和fdir进行枚举并转换为蓝牙指令 共８种情况

command＝ ３

if fdir＝＝ １&&dir＝＝ ３

command＝ ４

if fdir＝＝ ２&&dir＝＝ ４

command＝ ４

if fdir＝＝ ２&&dir＝＝ ４

command＝ ３

if fdir＝＝ ３&&dir＝＝ １

command＝ ３

if fdir＝＝ ３&&dir＝＝ ２

command＝ ４

if fdir＝＝ ４&&dir＝＝ １

command＝ ４

if fdir＝＝ ４&&dir＝＝ ２

command＝ ３

fdir＝ dir

putc command＋ ４８ opreatorptr

将蓝牙转换结果保存到opreator敭

txt文件中 注意 需要进行ASCII码的转换

intjudgestate intx

inty

intfx

intfy

intnumber

[]{#index_split_007.html#p388}![index-388_1.png](https://i.imgur.com/06KBvnH.jpeg){.calibre2}

![index-388_2.png](https://i.imgur.com/pLZ51Hg.jpeg){.calibre2}

![index-388_3.png](https://i.imgur.com/pDXtgrZ.jpeg){.calibre2}

![index-388_4.png](https://i.imgur.com/FAaWw8R.jpeg){.calibre2}

![index-388_5.png](https://i.imgur.com/2Vszzkg.jpeg){.calibre2}

３７７

inti j owntrack＝０ sharetrack＝０ available＝０

if order number ＝＝－１

return０

for i＝x－１ i ＝x＋１ i++

for j＝y－１ j ＝y＋１ j++

if i

＝x\|\|j

＝y && x＝＝i\|\|y＝＝j && i

＝fx\|\|j

＝fy

if track i j ＝＝number\|\|track i j ＝＝track x y owntrack＝１

可以走自己的轨道

if track i j ＝＝９

sharetrack＝１

需要走上公共轨道

available＝checksaretrack i

j

i

j 判断公共轨道是否被其他车占用

if owntrack＝＝１

return１

走

if sharetrack＝＝１

if available＝＝１

return１

未被占用则能走

else

return０

被占用则不能走

return０

出现了未考虑的其他情况则先不走

intchecksaretrack intx

inty

intfx

intfy

深度优先搜索 检查轨道上是否有车

inti j

if position x y

＝０

return０

for i＝x－１ i ＝x＋１ i++

for j＝y－１ j ＝y＋１ j++

if i

＝x\|\|j

＝y && x＝＝i\|\|y＝＝j && i

＝fx\|\|j

＝fy

if track i j ＝＝９

returnchecksaretrack i j x y

return１

voidmove intx

inty

intfx

intfy

intnumber

搜索周围８个点的位置 有轨道的只有两个位置 除去foreposition 就是下一位置

[]{#index_split_007.html#p389}![index-389_1.png](https://i.imgur.com/o8WTmvP.jpeg){.calibre2}

![index-389_2.png](https://i.imgur.com/88bQIYG.jpeg){.calibre2}

![index-389_3.png](https://i.imgur.com/LYWa51R.jpeg){.calibre2}

![index-389_4.png](https://i.imgur.com/9NSMDjw.jpeg){.calibre2}

![index-389_5.png](https://i.imgur.com/2xOiJy9.jpeg){.calibre2}

![index-389_6.png](https://i.imgur.com/verjqDW.jpeg){.calibre2}

![index-389_7.png](https://i.imgur.com/JZ7PiQj.jpeg){.calibre2}

![index-389_8.png](https://i.imgur.com/63IoXDg.jpeg){.calibre2}

![index-389_9.png](https://i.imgur.com/zThzFbp.jpeg){.calibre2}

![index-389_10.png](https://i.imgur.com/YHLDOOK.jpeg){.calibre2}

![index-389_11.png](https://i.imgur.com/exlkV7w.jpeg){.calibre2}

![index-389_12.png](https://i.imgur.com/aU7Opl8.jpeg){.calibre2}

![index-389_13.png](https://i.imgur.com/89GgZMK.jpeg){.calibre2}

３７８

inti j

for i＝x－１ i ＝x＋１ i++

for j＝y－１ j ＝y＋１ j++

if i

＝x\|\|j

＝y && x＝＝i\|\|y＝＝j &&foreposition i j ＝＝０&&position i j ＝＝０

if track i j ＝＝number\|\|track i j ＝＝track x y \|\|track i j ＝＝９

foreposition fx fy ＝０

foreposition x y ＝number

position i j ＝number

position x y ＝０

state x y ＝０

state i j ＝１

return

voidstay intx

inty

intfx

intfy

intnumber

尚未实现车站功能

state x y ＝－１

return

voidprintscreen

同地图编辑器 实现UI界面的具体函数

inti j

for i＝０ i m i++

for j＝０ j n j++

screen i j ＝track i j

for i＝０ i m i++

for j＝０ j n j++

if position i j

＝０

screen i j ＝ \'T\'

车头

for i＝０ i m i++

for j＝０ j n j++

if foreposition i j

＝０

screen i j ＝ \'t\'

车尾

for i＝０ i m i++

for j＝０ j n j++

if screen i j ＝＝０

没有轨道 输出空格

printf ＂＂

if screen i j ＝１&&screen i j ＝２０

[]{#index_split_007.html#p390}![index-390_1.png](https://i.imgur.com/1ddFQE3.jpeg){.calibre2}

![index-390_2.png](https://i.imgur.com/RUj6M4z.jpeg){.calibre2}

３７９

setcolor ０

printf ＂□＂

if screen i j ＝＝ \'T\'

车头

setcolor position i j

printf ＂◆＂

if screen i j ＝＝ \'t\'

车尾

setcolor foreposition i j

printf ＂＂

printf ＂\\n＂

for i＝１ i ＝num i++

setcolor i

printf ＂％d \\t＂ i

voidsetcolor intcolor

设置颜色

switch color

case０

白色

SetConsoleTextAttribute GetStdHandle STD_OUTPUT_HANDLE FOREGROUND_INTENSITY\|

FOREGROUND_RED\|FOREGROUND_GREEN\|FOREGROUND_BLUE

break

case１

红色

SetConsoleTextAttribute GetStdHandle STD_OUTPUT_HANDLE FOREGROUND_INTENSITY\|

FOREGROUND_RED

break

case２

绿色

SetConsoleTextAttribute GetStdHandle STD_OUTPUT_HANDLE FOREGROUND_INTENSITY\|

FOREGROUND_GREEN

break

case３

蓝色

SetConsoleTextAttribute GetStdHandle STD_OUTPUT_HANDLE FOREGROUND_INTENSITY\|

FOREGROUND_BLUE

[]{#index_split_007.html#p391}![index-391_1.png](https://i.imgur.com/asiWH3h.jpeg){.calibre2}

![index-391_2.png](https://i.imgur.com/6cmd8Wb.jpeg){.calibre2}

![index-391_3.png](https://i.imgur.com/AfYU4o0.jpeg){.calibre2}

![index-391_4.png](https://i.imgur.com/kOZT29y.jpeg){.calibre2}

![index-391_5.png](https://i.imgur.com/T0JOZkc.jpeg){.calibre2}

![index-391_6.png](https://i.imgur.com/F2s1xLr.jpeg){.calibre2}

![index-391_7.png](https://i.imgur.com/GYLVsR5.jpeg){.calibre2}

３８０

break

case４

紫色

SetConsoleTextAttribute GetStdHandle STD_OUTPUT_HANDLE FOREGROUND_INTENSITY\|

FOREGROUND_RED\|FOREGROUND_BLUE

break

case５

蓝色

SetConsoleTextAttribute GetStdHandle STD_OUTPUT_HANDLE FOREGROUND_INTENSITY\|

FOREGROUND_GREEN\|FOREGROUND_BLUE

break

case６

黄色

SetConsoleTextAttribute GetStdHandle STD_OUTPUT_HANDLE FOREGROUND_INTENSITY\|

FOREGROUND_RED\|FOREGROUND_GREEN

break

default

break

intgetnum

inti j num＝１

for i＝０ i m i++

for j＝０ j n j++

if position i j ＝num

num＝position i j

returnnum

voidwriterecord

inti j k

setcolor ０

fprintf recordptr

＂time＝％d\\n＂

time

printf ＂\\ntime＝％d\\tstrategy＝快车优先策略\\n＂ time for k＝１ k ＝num k++

for i＝０ i m i++

for j＝０ j n j++

if position i j ＝＝k

if state i j ＝＝１&&track i j ＝＝９

fprintf recordptr

＂train％d

\\n\\tx＝％d\\ty＝％d\\tstate＝movingon

thepublictrack\\n＂ k i j

printf ＂train％d \\tx＝％d\\ty＝％d\\tstate＝movingonthepublic

[]{#index_split_007.html#p392}![index-392_1.png](https://i.imgur.com/hNLtRUq.jpeg){.calibre2}

![index-392_2.png](https://i.imgur.com/mZ9GmgX.jpeg){.calibre2}

![index-392_3.png](https://i.imgur.com/CAEpAdX.jpeg){.calibre2}

３８１

track\\n＂ k i j

elseif state i j ＝＝１&&track i j

＝９

fprintf recordptr

＂train％d

\\n\\tx＝％d\\ty＝％d\\tstate＝movingon

theprivatetrack\\n＂ k i j

printf ＂train％d \\tx＝％d\\ty＝％d\\tstate＝movingontheprivate track\\n＂ k i j

else

fprintf recordptr

＂train％d

\\n\\tx＝％d\\ty＝％d\\tstate＝waiting

attheforkroad\\n＂ k i j

printf ＂train％d

\\tx＝％d\\ty＝％d\\tstate＝waitingattheforkroad

\\n＂ k i j

fprintf recordptr

＂\\n＂

time

setcolor ０

本部分的程序运行结果及记事本的输出如图１４Ｇ１３和图１４Ｇ１４所示.

图１４Ｇ１３　程序运行结果

图１４Ｇ１４　记事本输出

[]{#index_split_007.html#p393}![index-393_1.png](https://i.imgur.com/WiexGkp.jpeg){.calibre2}

３８２

６．Arduino主程序模块

１)功能介绍

本部分综合前几个模块的功能,将实现 Arduino开发板控制的功能,从系统结构的角度

进行总体的代码说明.

２)相关代码

Stringcomdata＝ ＂＂

charnumdata １０ ＝ \'６\' \'６\' \'６\' \'６\' \'６\' \'６\' \'６\' \'６\' \'６\' \'６\'

intmark ＝ ０

＃defineIN１６

７和６为右轮

＃defineIN２７

＃defineIN３４

５和４为左轮

＃defineIN４５

＃definerP１０

右轮配速

＃definelP１１

左轮配速

STOP \'０\' 停止编码

GO \'１ 前进编码

BACK \'２\' 后退编码

LEFT \'３\' 左转编码

RIGHT \'４\' 右转编码

SQUARE \'７\'

TRI\'８\'

ROUND \'９\'

＃definePIR９

定义引脚９为PIR 红外热释电传感器

＃defineled１３

定义引脚１３为LED 发光模块

intspeakerPin ＝ ３

intlength ＝ １５

charnotes ＝ ＂ccggaagffeeddc＂

intbeats ＝ １ １ １ １ １ １ ２ １ １ １ １ １ １ ２ ４

inttempo ＝ ３００

voidsetup

pinMode IN１

OUTPUT

pinMode IN２

OUTPUT

pinMode IN３

OUTPUT

pinMode IN４

OUTPUT

pinMode rP

OUTPUT

pinMode lP

OUTPUT

pinMode led

OUTPUT

设置LED为数字输出

pinMode PIR

INPUT

设置PIR为数字输入

pinMode speakerPin OUTPUT

[]{#index_split_007.html#p394}![index-394_1.png](https://i.imgur.com/ibhv3ne.jpeg){.calibre2}

![index-394_2.png](https://i.imgur.com/BWbEcMu.jpeg){.calibre2}

![index-394_3.png](https://i.imgur.com/eimNWsT.jpeg){.calibre2}

３８３

Serial敭

begin ９６００

voidloop

∗ if digitalRead PIR

如果有人通过人体红外感应模块

digitalWrite led

HIGH

发光模块点亮

digitalWrite IN１

LOW

digitalWrite IN２

LOW

右轮不动

digitalWrite IN３

LOW

digitalWrite IN４

LOW

else

digitalWrite led

LOW

发光模块熄灭

analogWrite lP ８０

analogWrite rP １００

digitalWrite IN１

LOW

digitalWrite IN２

LOW

右轮不动 左轮转动 右转

digitalWrite IN３

HIGH

digitalWrite IN４

LOW

∗

intj ＝ ０

j是分拆之后数字数组的位置记数

while Serial敭

available ０

comdata ＋＝ char Serial敭

read

delay ５

mark ＝ １

if mark＝＝ １

Serial敭

println comdata

Serial敭

println comdata敭

length

for inti＝ ０ i comdata敭

length i++

if comdata i ＝＝ \' \'

j++

else

numdata j ＝comdata i

[]{#index_split_007.html#p395}![index-395_1.png](https://i.imgur.com/qaMyN27.jpeg){.calibre2}

３８４

comdata ＝ String ＂＂

mark ＝ ０

if numdata ０ ＝＝ \'１\'

基本行走

numdata ０ ＝ \'６\'

if numdata １ ＝＝ \'１\'

numdata １ ＝ \'６\'

go

前进

elseif numdata １ ＝＝ \'２\'

numdata １ ＝ \'６\'

back

后退

elseif numdata １ ＝＝ \'３\'

numdata １ ＝ \'６\'

左转

turnLeft

elseif numdata １ ＝＝ \'４\'

numdata １ ＝ \'６\'

右转

turnRight

elseif numdata １ ＝＝ \'０\'

numdata １ ＝ \'６\'

停车

stopCar

elseif numdata ０ ＝＝ \'２\'

识别地图模式

for inti＝ ０ numdata i

＝ \'６\' i++

地图行走

if numdata i ＝＝ \'１\'

numdata i ＝ \'６\'

gostraight

elseif numdata i ＝＝ \'３\'

[]{#index_split_007.html#p396}![index-396_1.png](https://i.imgur.com/XNjydsj.jpeg){.calibre2}

３８５

numdata i ＝ \'６\'

goleft

elseif numdata i ＝＝ \'４\'

numdata i ＝ \'６\'

goright

analogWrite lP ８０

analogWrite rP １００

digitalWrite IN１

LOW

digitalWrite IN２

LOW

右轮前进

digitalWrite IN３

LOW

digitalWrite IN４

LOW

左轮前进

elseif numdata ０ ＝＝ \'３\'

走图形模式

numdata ０ ＝＝ \'６\'

if numdata １ ＝＝ \'７\'

numdata １ ＝＝ \'６\'

square

elseif numdata １ ＝＝ \'８\'

numdata １ ＝＝ \'６\'

tri

elseif numdata １ ＝＝ \'９\'

numdata １ ＝＝ \'６\'

roundd

模式一函数

voidgostraight

analogWrite lP ８０

[]{#index_split_007.html#p397}![index-397_1.png](https://i.imgur.com/e3Uu51b.jpeg){.calibre2}

３８６

analogWrite rP １００

digitalWrite IN１

HIGH

digitalWrite IN２

LOW

右轮前进

digitalWrite IN３

HIGH

digitalWrite IN４

LOW

左轮前进

delay ３０００

voidgoleft

analogWrite lP ８０

analogWrite rP １００

digitalWrite IN１

LOW

digitalWrite IN２

LOW

右轮前进

digitalWrite IN３

HIGH

digitalWrite IN４

LOW

左轮前进

delay ３０００

voidgoright

analogWrite lP ８０

analogWrite rP １００

digitalWrite IN１

HIGH

digitalWrite IN２

LOW

右轮前进

digitalWrite IN３

LOW

digitalWrite IN４

LOW

左轮前进

delay ３０００

模式二函数

voidinitCar

默认全是低电平 停止状态

analogWrite lP ８０

analogWrite rP １００

digitalWrite IN１

LOW

digitalWrite IN２

LOW

digitalWrite IN３

LOW

digitalWrite IN４

LOW

voidturnLeft

∗ 左转∗

analogWrite lP ８０

analogWrite rP １００

digitalWrite IN１

HIGH

digitalWrite IN２

LOW

右轮前进

[]{#index_split_007.html#p398}![index-398_1.png](https://i.imgur.com/oqBcjI4.jpeg){.calibre2}

３８７

digitalWrite IN３

LOW

digitalWrite IN４

LOW

左轮不动

voidturnRight

∗右转∗

analogWrite lP ８０

analogWrite rP １００

digitalWrite IN１

LOW

digitalWrite IN２

LOW

右轮不动

digitalWrite IN３

HIGH

digitalWrite IN４

LOW

左轮前进

voidgo

∗ 前进∗

analogWrite lP ８０

analogWrite rP １００

digitalWrite IN１

HIGH

digitalWrite IN２

LOW

右轮前进

digitalWrite IN３

HIGH

digitalWrite IN４

LOW

左轮前进

voidback

∗ 倒车∗

analogWrite lP

８０

analogWrite rP １００

digitalWrite IN１

LOW

digitalWrite IN２

HIGH

右轮后退

digitalWrite IN３

LOW

digitalWrite IN４

HIGH

左轮后退

voidstopCar

∗ 停车∗

initCar

voidsquare

正方形

gostraight

goleft

gostraight

goleft

gostraight

goleft

gostraight

goleft

initCar

[]{#index_split_007.html#p399}![index-399_1.png](https://i.imgur.com/pvxbrE5.jpeg){.calibre2}

![index-399_2.png](https://i.imgur.com/MkKwRQ8.jpeg){.calibre2}

３８８

voidtri

三角形

gostraight

analogWrite lP ８０

analogWrite rP １００

digitalWrite IN１

HIGH

digitalWrite IN２

LOW

右轮前进 左转

digitalWrite IN３

LOW

digitalWrite IN４

LOW

左轮停止

delay ４０００

gostraight

analogWrite lP ８０

analogWrite rP １００

digitalWrite IN１

HIGH

digitalWrite IN２

LOW

右轮前进 左转

digitalWrite IN３

LOW

digitalWrite IN４

LOW

左轮停止

delay ４０００

gostraight

analogWrite lP １００

analogWrite rP １００

digitalWrite IN１

HIGH

digitalWrite IN２

LOW

右轮前进 左转

digitalWrite IN３

LOW

digitalWrite IN４

LOW

左轮停止

delay ４０００

initCar

voidplayTone inttone intduration

for longi＝ ０ i duration∗ １０００L i＋＝ tone∗ ２

digitalWrite speakerPin HIGH

delayMicroseconds tone

digitalWrite speakerPin LOW

analogWrite lP ８０

analogWrite rP １００

digitalWrite IN１

HIGH

digitalWrite IN２

LOW

直行

digitalWrite IN３

LOW

digitalWrite IN４

LOW

delayMicroseconds tone

analogWrite lP ８０

analogWrite rP １００

digitalWrite IN１

LOW

[]{#index_split_007.html#p400}![index-400_1.png](https://i.imgur.com/1UKSlR3.jpeg){.calibre2}

![index-400_2.png](https://i.imgur.com/dwTS1Wk.jpeg){.calibre2}

![index-400_3.png](https://i.imgur.com/46I7t3o.jpeg){.calibre2}

３８９

digitalWrite IN２

LOW

右轮不动 左轮转动 右转

digitalWrite IN３

HIGH

digitalWrite IN４

LOW

delayMicroseconds tone

voidplayNote charnote intduration

charnames ＝ \'c\' \'d\' \'e\' \'f\' \'g\' \'a\' \'b\' \'C\'

inttones ＝ １９１５ １７００ １５１９ １４３２ １２７５ １１３６ １０１４ ９５６

播放音乐

for inti＝ ０ i ８ i++

if names i ＝＝ note

playTone tones i duration

voidroundd

音乐播放和画圆

for inti＝ ０ i length i++

if notes i ＝＝ \' \'

analogWrite lP ８０

analogWrite rP １００

digitalWrite IN１

LOW

无音乐时停止

digitalWrite IN２

LOW

digitalWrite IN３

LOW

digitalWrite IN４

LOW

delay beats i ∗ tempo

停顿

else

playNote notes i beats i ∗ tempo

停顿

delay tempo ２

１４．

４　产品展示

产品整体外观如图 １４Ｇ１５所示,内部结构如图１４Ｇ１６所示.为了使小车能在球中稳定

滚动并做到配重均匀,所有驱动元件及传感器元件均固定在小车上.

小车上层摆放的是 Arduino开发板、蜂鸣器、人体红外感应模块以及蓝牙传输模块.小

车下层摆放电池盒、电极板和蓄电池电池盒.对于小车外部,上部铜柱支撑的万向轮可以保

持小车在球的滚动过程中不会产生倒置;底部的牛眼轮可以使小车和球面底部更加贴合,

[]{#index_split_007.html#p401}![index-401_1.png](https://i.imgur.com/7FxzBAR.jpeg){.calibre2}

![index-401_2.png](https://i.imgur.com/EqzyA3y.jpeg){.calibre2}

![index-401_3.png](https://i.imgur.com/vtX85Mq.jpeg){.calibre2}

３９０

使球的滚动更加顺畅.

图１４Ｇ１５　整体外观

图１４Ｇ１６　内部结构

１４．

５　故障及问题分析

问题１:由于不了解电极板的供电电压和功率,导致蓄电池放电过快,产生过放电现象

而损坏.另外,电机板 L２９８N 模块正常运转时所需要的电压为５\~３５V,而用于 Arduino开

发板的单节５号电池电压为３．

７V,用２节或４节此类电池串联使用,则增加了小车的重量,

并且电池组不仅要为 L２９８N 供电,同时也要为 Arduino开发板供电.查询资料后发现,使

用同一电源同时为 Arduino开发板和电机板供电极易使得电机板分得的电压不足从而影响

运转.由于还使用了无源蜂鸣器模块,当供给 Arduino开发板的电池电量不足时,无源蜂鸣

器在接到 Arduino开发板上后会发出噪声,从而干扰蓝牙通信.

解决方案:首先了解到,由于购入的３．

７V５号电池没有电池过流保护片(简称 PTC),

所以一旦电池过度放电,很容易报废且会影响其他电池的正常工作.为此,在使用过程中需

要密切关注直流电机的运转情况,一旦发现直流电机运转速度变慢,则应该立即为电池充电

以防报废.其次,使用９V 方块电池为 Arduino开发板供电,并使用５号电池组为电极板供

电.这样,电池的重量分散,有利于平衡小车的重量.并且,

９V 方块电池容量更大,续航时

间也更长,无源蜂鸣器也不会发出噪声干扰通信.

问题２:小车进入球壳后,一旦开始运动会产生翻滚与空转问题,并且不能根据指令来

运动.

解决方案:针对两轮小车不能完美贴合球面、容易翻转的问题,希望在小车底面再添加

两个辅助小轮使小车在球壳底部更稳固地"站立".起初决定使用常见的辅助万向轮,但万

向轮不仅状态不稳定,运转起来旋转一周所占的空间也较大.经过查阅资料,发现了在小车

上较少使用的牛眼轮.牛眼轮是由一个铁珠与镶嵌铁珠的"口"组成,形状酷似牛眼,故名牛

眼轮.牛眼轮可理解为一个万向滚珠,故占地面积更少,也更稳固.由于很难用尺子测量小

车底板到球底的距离,同时也受限于小车底板的螺丝孔位置,多次实验选定了最佳铜柱组合

长度,能够使得两个牛眼轮贴合球壳,辅助小车运动.

[]{#index_split_007.html#p402}![index-402_1.png](https://i.imgur.com/38rQf1G.jpeg){.calibre2}

![index-402_2.png](https://i.imgur.com/nIQOEbn.jpeg){.calibre2}

３９１

针 对 小 车 在 球 中 倒 翻 的 问 题 ,选 择 在 小 车 上 架 一 个 铜 柱 进 行 支 撑,铜 柱 顶 端 安 装 万

向 轮 ,顶到球壳的顶端,防 止 其 在 运 动 过 程 中 翻 滚. 同 样,配 合 小 车 车 板 的 螺 丝 孔 位 置, 多 次 实 验 铜 柱 组 合 长 度 ,使 得 万 向 轮 能 够 不 阻 碍 小 车 的 运 动,同 时 也 能 起 到 不 让 小 车 倒

翻 的 作 用 .

与此同时,由于购入的球壳非定制,原作为扭蛋生产出的

球壳两侧重量不 同 且 不 圆.球壳内部因为是亚 克 力 材 料,摩

擦力小,不足以支撑小车通过摩擦带动球的转 动.根 据 设 计

原理,希望球内部滚动摩擦力达到最小而滑动摩擦力达 到 最

大.因此,在较轻一面的球壳上,贴上电 工 绝 缘 胶 带,并 用 剪

刀在胶带上划出许多划痕,人工制造大摩擦力环境,增加摩擦

力.在较轻的半边球壳里贴上更多的胶带也可 平 衡 重 量,此

举亦对重量问题有所助力,如图１４Ｇ１７所示.

问题３:Arduino开发板代码问题.需要通过蓝牙输入

一个数组来选择小车模式并在其后输入相关指令.在模式三

图１４Ｇ１７　平衡重量示意图

的走圆形功能中要 同 时 播 放 音 乐 «小星星»,行走过程中的延

时要与音乐中的延时相对应才能正确执行功能.

解决方案:由于 Arduino开发板与 C++ 代码风格十分相似却又有很多不同之处,最初

在编程过程中,代码中的字符串和字符数组遇到很多问题.例如,在 C++ 中可以使用char c２\[\]＝＂Iamhappy＂;的语句来初始化字符数组,但在 Arduino开发板中却只能用charc１\[\]＝

{\'I\',\' \',\'a\',\'m\',\' \',\'h\',\'a\',\'p\',\'p\',\'y\'};的语句来初始化数组.经过对比蓝牙返

回值并多次调试,确定了最终的代码.

对于模式三的走圆形功能,由于在行走过程中需要使用延时函 数 delay()控制行走时

间,在delay()函数运行所有其他程序相当于被中断,传感器也不再起作用.所以,要使音乐

播放和车轮在同一时间都能正常运行,需将直流电机运行代码插入音乐的代码中(音乐延时

更短更频繁).选择插入到控制音频持续时间的函数 playTone()中,最终效果如前文函数

所示.

问题４:C++ 代码问题.计划读取 word文档中由空格、大小写字母书写的轨道和小车

信息,发现这种方法虽然看起来很直观,但是绘制过程十分烦琐且易出错,所以希望通过一

个 UI图形界面来实现控制.

解决方案:运用 C++ 代码编写数据编辑器,通过键盘输入"w""a""s""d"４个字符来控

制光标的移动(光标移动映射为坐标点的移动),在输入过程中打印屏幕上的字符,利用自动

机模型进行情况跳转,实现根据输入的 order不同,在屏幕上绘制边界、轨道、车头、车尾等

信息,输入回车时完成自动机模型,跳转并在屏幕输出图形.

问题５:如何实现 UI界面让小车产生动起来的效果.

解决方案:在打印小车相关信息尤其是进行轨道输入的过程中,使用的方法是打印轨

道信息,间隔１００ms进行屏幕清屏,然后重新打印所读取的轨道和小车信息.在这种情况

[]{#index_split_007.html#p403}![index-403_1.png](https://i.imgur.com/tkeT0IF.jpeg){.calibre2}

![index-403_2.png](https://i.imgur.com/2My6FSy.jpeg){.calibre2}

３９２

下,发现打印屏幕的过程中出现输入与输出严重不对称

情况,查阅了许多资料,创新性地使用了双线程的 C++

编程方法,解决了键盘输入与屏幕输出的问题.

值得注意 的 是,为 了 让 小 车 产 生 动 起 来 的 动 画 效

果,运用了自动机模型,读取小车当前位置,扫描周围的

８个点所在位置,判断只有两个点有轨道,排除之前所

走的 那 个 点,得到下一位置,通过上述清屏和重新打印

图

的操作

１４Ｇ１８　小车车轮悬空示意图

,实现让小车动起来的动画效果.小车车轮悬空

如图１４Ｇ１８所示.

１４．

６　元件清单

完成本项目所用到的元件及数量如表１４Ｇ３所示.

表１４Ｇ３　球形机器人元件清单

模　　块

元件/测试仪表

数量

导线

若干

杜邦线

若干

HCＧ０５蓝牙模块

１个

蓝牙输入模块

ArduinoUNOR３开发板

１个

无源蜂鸣器

１个

人体红外感应模块(热释电传感器)

１个

杜邦线

若干

直流电机驱动板 L２９８N

１个

驱动部分　　

电池盒

１个

９V 电源

１个

３．

７V 蓄电池

２个

螺钉、螺母、铜柱

若干

球壳

１个

亚克力板

１个

外观部分　　

牛眼轮

２个

万向轮

１个

橡胶驱动轮

２个

[]{#index_split_007.html#p404}![index-404_1.png](https://i.imgur.com/ih4RDXX.jpeg){.calibre2}

第１５章

多功能蓝牙小车项目设计

１５．

１　项目背景

现今社会,人们的生活节奏越来越快,都希望尽可能高效率地利用时间,在最短的时间

做最多的事情.而随着移动终端和互联网的发展,社会进入了信息爆炸的时代,人们都希望

尽可能多地接收信息.因此,本项目基于 Arduino开发板制作一款多功能蓝牙小车为生活

提供方便.

１５．

２　创新描述

通过超声波模块及红外感应模块,辅助车主在倒车入库时测量小车到各障碍物的距离; 借助人体红外感应模块,实现感应警报;借助蓝牙模块,实现遥控行驶等功能.

创新点:使用红外测距模块感应小车底盘距离地面的高度,当距离低于警戒线时,亮灯

报警,以使小车底盘免于障碍物的破坏.

１５．

３　功能及总体设计

本作品主要分为小车遥控部分和辅助功能部分.小车遥控部分的主要功能是通过蓝牙

模块实现对小车的遥控;辅助功能部分的主要功能是通过超声波模块、红外感应模块和光

敏传感器等模块创造一系列方便生活用车的辅助功能.

１５．

３．

１　功能介绍

在代码中分别设定了超声波测距、红外测距、人体红外警报以及光敏感应亮灯等多种模

式,通过蓝牙遥控方式控制小车,操作者还可以通过手机 APP控制小车的行驶,实现多种辅

本章根据阙笑语、孙扬项目设计整理而成.

[]{#index_split_007.html#p405}![index-405_1.png](https://i.imgur.com/ST9EVnd.jpeg){.calibre2}

![index-405_2.png](https://i.imgur.com/ZGQinEF.jpeg){.calibre2}

![index-405_3.png](https://i.imgur.com/v9oLLxH.jpeg){.calibre2}

![index-405_4.png](https://i.imgur.com/MW8OkLV.jpeg){.calibre2}

３９４

助功能.

１５．

３．

２　总体设计

要实现上述功能需要 将 作 品 分 成 三 部 分 进 行 设 计:输 入 部 分、输 出 部 分 和 处 理 部 分.

输入部分选择蓝牙模块、超声波模块、人体感应模块、红外测距模块和光敏传感器作为输入; 输出部分采用 LCD１６０２显示屏和彩色 LED 作为输出;处理部分使用 ArduinoUNO 开发

板和 ArduinoMEGA２５６０开发板进行处理.

１．整体框架图

项目整体框架如图１５Ｇ１\~图１５Ｇ３所示.图１５Ｇ１为遥控部分,图１５Ｇ２为辅助功能部分, 图１５Ｇ３为整体框架.

图１５Ｇ１　遥控部分

图１５Ｇ２　辅助功能部分

图１５Ｇ３　整体框架

[]{#index_split_007.html#p406}![index-406_1.png](https://i.imgur.com/KHlhZG8.jpeg){.calibre2}

![index-406_2.png](https://i.imgur.com/RLbOHSZ.jpeg){.calibre2}

![index-406_3.png](https://i.imgur.com/5veEqow.jpeg){.calibre2}

３９５

２．系统流程

系统的蓝牙控制流程如图１５Ｇ４所示;系统辅助功能如图１５Ｇ５所示.

图１５Ｇ４　蓝牙控制流程

图１５Ｇ５　系统辅助功能

３．电路图

系统辅助 功 能 电 路 图 如 图 １５Ｇ６ 所 示,小 车 主 板 如 图 １５Ｇ７ 所 示,引 脚 分 配 如 表 １５Ｇ１

所示.

[]{#index_split_007.html#p407}![index-407_1.png](https://i.imgur.com/XEuTEqa.jpeg){.calibre2}

![index-407_2.png](https://i.imgur.com/azk7yIN.jpeg){.calibre2}

![index-407_3.png](https://i.imgur.com/egmplOF.jpeg){.calibre2}

３９６

图１５Ｇ６　辅助功能电路

图１５Ｇ７　小车主板

[]{#index_split_007.html#p408}![index-408_1.png](https://i.imgur.com/eo44Bah.jpeg){.calibre2}

３９７

表１５Ｇ１　引脚分配

Arduino

Arduino

Arduino

元件引脚

元件引脚

元件引脚

开发板引脚

开发板引脚

开发板引脚

超声波１ECHO

３０

超声波３TRIG

４２

红外感应１OUT

５１

超声波１TRIG

４０

超声波３VCC

VCC

红外感应２GND

GND

超声波１VCC

VCC

超声波３GND

GND

红外感应３VCC

VCC

超声波１GND

GND

LCDSCL

SCL

－

－

超声波２ECHO

３１

LCDSDA

SDA

－

－

超声波２TRIG

４１

LCD VCC

VCC

－

－

超声波２VCC

VCC

LCDGND

GND

－

－

超声波２GND

GND

光敏１

５０

－

－

超声波３ECHO

３２

光敏２

GND

－

－

１５．

３．

３　模块介绍

本项目主要包括蓝牙控制模块、超声波测距模块、红外模块和光敏传感器模块.下面分

别给出各模块的功能和相关代码.

１．蓝牙控制模块

１)功能介绍

通过底盘、主控板、ArduinoUNO 开发板以及蓝牙模块的连接,配合开源手机 APP,实

现蓝牙遥控.

２)相关代码

∗前进 按下发出ONA 松开发出ONF

后退 按下发出ONB 松开发出ONF

左转 按下发出ONC 松开发出ONF

右转 按下发出OND 松开发出ONF

停止 按下发出ONE 松开发出ONF敭

蓝牙程序的功能是按下对应的按键则执行操作 松开按键则停止执行操作

∗

chargetstr

intLeft_motor_go＝８

左直流电机前进 IN１

intLeft_motor_back＝９

左直流电机后退 IN２

intRight_motor_go＝１０

右直流电机前进 IN３

intRight_motor_back＝１１

右直流电机后退 IN４

voidsetup

初始化直流电机驱动I O为输出方式

Serial敭

begin ９６００

pinMode Left_motor_go

OUTPUT

８ 无PWM

[]{#index_split_007.html#p409}![index-409_1.png](https://i.imgur.com/dOb3uLD.jpeg){.calibre2}

３９８

pinMode Left_motor_back

OUTPUT

９ PWM

pinMode Right_motor_go

OUTPUT

引脚１０ PWM

pinMode Right_motor_back

OUTPUT

引脚１１ PWM

voidrun

digitalWrite Right_motor_go

HIGH

右直流电机前进

digitalWrite Right_motor_back

LOW

analogWrite Right_motor_go

１５０

PWM比例为０\~２５５ 用于调速 左右轮差异略增减

analogWrite Right_motor_back

０

digitalWrite Left_motor_go

LOW

左直流电机前进

digitalWrite Left_motor_back

HIGH

analogWrite Left_motor_go

０

PWM比例为０\~２５５ 用于调速 左右轮差异略增减

analogWrite Left_motor_back

１５０

delay time ∗ １００

执行时间 可以调整

voidbrake

刹车 停车

digitalWrite Right_motor_go

LOW

digitalWrite Right_motor_back

LOW

digitalWrite Left_motor_go

LOW

digitalWrite Left_motor_back

LOW

voidleft

digitalWrite Right_motor_go

HIGH

右直流电机前进

digitalWrite Right_motor_back

LOW

analogWrite Right_motor_go

１５０

analogWrite Right_motor_back

０

PWM比例为０\~２５５ 用于调速

digitalWrite Left_motor_go

LOW

左轮后退

digitalWrite Left_motor_back

LOW

analogWrite Left_motor_go

０

analogWrite Left_motor_back

０

PWM比例为０\~２５５ 用于调速

delay time ∗ １００

执行时间 可以调整

voidspin_left inttime

左转 左轮后退 右轮前进

digitalWrite Right_motor_go

HIGH

右直流电机前进

digitalWrite Right_motor_back

LOW

analogWrite Right_motor_go

２００

analogWrite Right_motor_back

０

PWM比例为０\~２５５ 用于调速

digitalWrite Left_motor_go

HIGH

左轮后退

[]{#index_split_007.html#p410}![index-410_1.png](https://i.imgur.com/vQz7Lgc.jpeg){.calibre2}

３９９

digitalWrite Left_motor_back

LOW

analogWrite Left_motor_go

２００

analogWrite Left_motor_back

０

PWM比例为０\~２５５ 用于调速

delay time ∗ １００

执行时间 可以调整

voidright

digitalWrite Right_motor_go

LOW

右直流电机后退

digitalWrite Right_motor_back

LOW

analogWrite Right_motor_go

０

analogWrite Right_motor_back

０

PWM比例为０\~２５５ 用于调速

digitalWrite Left_motor_go

LOW

左直流电机前进

digitalWrite Left_motor_back

HIGH

analogWrite Left_motor_go

０

analogWrite Left_motor_back

１５０

PWM比例为０\~２５５ 用于调速

delay time ∗ １００

执行时间 可以调整

voidspin_right inttime

右转 右轮后退 左轮前进

digitalWrite Right_motor_go

LOW

右直流电机后退

digitalWrite Right_motor_back

HIGH

analogWrite Right_motor_go

０

analogWrite Right_motor_back

２００

PWM比例为０\~２５５ 用于调速

digitalWrite Left_motor_go

LOW

左直流电机前进

digitalWrite Left_motor_back

HIGH

analogWrite Left_motor_go

０

analogWrite Left_motor_back

２００

PWM比例为０\~２５５ 用于调速

delay time ∗ １００

执行时间 可以调整

voidback

digitalWrite Right_motor_go

LOW

右轮后退

digitalWrite Right_motor_back

HIGH

analogWrite Right_motor_go

０

analogWrite Right_motor_back

１５０

PWM比例为０\~２５５ 用于调速

digitalWrite Left_motor_go

HIGH

左轮后退

digitalWrite Left_motor_back

LOW

analogWrite Left_motor_go

１５０

analogWrite Left_motor_back

０

PWM比例为０\~２５５ 用于调速

delay time ∗ １００

执行时间 可以调整

voidloop

[]{#index_split_007.html#p411}![index-411_1.png](https://i.imgur.com/uywLBOU.jpeg){.calibre2}

![index-411_2.png](https://i.imgur.com/9CUcias.jpeg){.calibre2}

![index-411_3.png](https://i.imgur.com/nCPrlKI.jpeg){.calibre2}

![index-411_4.png](https://i.imgur.com/jsD88Gz.jpeg){.calibre2}

![index-411_5.png](https://i.imgur.com/2Vz6CJ2.jpeg){.calibre2}

４００

getstr＝Serial敭

read

if getstr＝＝ \'A\'

Serial敭

println ＂goforward

＂

run

elseif getstr＝＝ \'B\'

Serial敭

println ＂goback

＂

back

elseif getstr＝＝ \'C\'

Serial敭

println ＂goleft

＂

left

elseif getstr＝＝ \'D\'

Serial敭

println ＂goright

＂

right

elseif getstr＝＝ \'F\'

Serial敭

println ＂Stop

＂

brake

elseif getstr＝＝ \'E\'

Serial敭

println ＂Stop

＂

brake

２．辅助模块

１)功能介绍

通过 ArduinoMEGA２５６０开发板和元件的连接实现多种辅助功能,如超声波测距、光

敏感应和人体红外感应等.

２)相关代码

＃include LiquidCrystal_I２C敭h

＃include Wire敭h

＃defineAD５A５

定义模拟引脚A５

＃defineLED５０

定义数字引脚５０

LiquidCrystal_I２Clcd ０x２７

１６

２

intinputPin１＝３０

intoutputPin１＝４０

[]{#index_split_007.html#p412}![index-412_1.png](https://i.imgur.com/lTE88hM.jpeg){.calibre2}

![index-412_2.png](https://i.imgur.com/QKwjq4k.jpeg){.calibre2}

４０１

intinputPin２＝３１

intoutputPin２＝４１

intinputPin３＝３２

intoutputPin３＝４２

intIntensity ＝ ０

光照度数值

voidsetup

Serial敭

begin ９６００

pinMode inputPin１ INPUT

pinMode inputPin２ INPUT

pinMode inputPin３ INPUT

pinMode outputPin１ OUTPUT

pinMode outputPin２ OUTPUT

pinMode outputPin３ OUTPUT

pinMode LED

OUTPUT

设置LED为输出模式

voidloop

Intensity ＝ analogRead AD５

读取模拟引脚AD５的值 存入Intensity变量

Serial敭

print ＂Intensity ＝ ＂

串口输出＂Intensity＝ ＂

Serial敭

println Intensity

串口输出Intensity变量的值 并换行

if Intensity ＝１６ digitalWrite LED

LOW

else digitalWrite LED

HIGH

delay ５００

延时５００ms

lcd敭

init

digitalWrite outputPin１ LOW

delayMicroseconds ２

digitalWrite outputPin１ HIGH

１０μs脉冲触发超声波检测

delayMicroseconds １０

digitalWrite outputPin１ LOW

intdistance１ ＝ pulseIn inputPin１ HIGH 读取接收脉冲的时间

distance１＝ distance１ ５８

脉冲时间转换为距离

Serial敭

print distance１

输出距离

Serial敭

println ＂cm＂

lcd敭

backlight

lcd敭

print ＂L＂

lcd敭

print distance１

在LCD上输出距离信息

lcd敭

print ＂＂

delay ５００

digitalWrite outputPin３ LOW

delayMicroseconds ２

digitalWrite outputPin３ HIGH

１０μs脉冲触发超声波检测

delayMicroseconds １０

[]{#index_split_007.html#p413}![index-413_1.png](https://i.imgur.com/twSApmw.jpeg){.calibre2}

４０２

digitalWrite outputPin３ LOW

intdistance３ ＝ pulseIn inputPin３ HIGH 读取接收脉冲的时间

distance３＝ distance３ ５８

将时间转换为距离

Serial敭

print distance３

输出距离

Serial敭

println ＂cm＂

lcd敭

backlight

lcd敭

print ＂B＂

lcd敭

print distance３

在LCD上输出距离信息

lcd敭

print ＂＂

delay ５００

digitalWrite outputPin２ LOW

delayMicroseconds ２

digitalWrite outputPin２ HIGH

１０μs脉冲触发超声波检测

delayMicroseconds １０

digitalWrite outputPin２ LOW

intdistance２ ＝ pulseIn inputPin２ HIGH 读取接收脉冲的时间

distance２＝ distance２ ５８

将时间转换为距离

Serial敭

print distance２

输出距离

Serial敭

println ＂cm＂

lcd敭

backlight

lcd敭

print ＂R＂

lcd敭

print distance２

lcd敭

print ＂＂

在LCD上输出距离信息

delay ５００

人体红外感应

intSensor＝ ５２

＃defineLED１４９

定义数字引脚４９

voidsetup

Serial敭

begin ９６００

pinMode Sensor INPUT

pinMode LED１

OUTPUT

设置LED为输出模式

voidloop

intSensorState ＝ digitalRead Sensor

Serial敭

println SensorState

if SensorState＝＝１ digitalWrite LED１

HIGH

else digitalWrite LED１

LOW

delay １００

光敏

＃defineAD５A５

定义模拟引脚A５

＃defineLED１３

定义数字引脚１３

[]{#index_split_007.html#p414}![index-414_1.png](https://i.imgur.com/99T6jL6.jpeg){.calibre2}

![index-414_2.png](https://i.imgur.com/fszFvbv.jpeg){.calibre2}

![index-414_3.png](https://i.imgur.com/DJZV0da.jpeg){.calibre2}

![index-414_4.png](https://i.imgur.com/apfh899.jpeg){.calibre2}

![index-414_5.png](https://i.imgur.com/w4NLHjf.jpeg){.calibre2}

４０３

intIntensity ＝ ０

光照度数值

voidsetup

程序初始化

pinMode LED

OUTPUT

设置LED为输出模式

Serial敭

begin ９６００

设置波特率为９６００

LCD显示

voidloop

程序主体循环

Intensity ＝ analogRead AD５

读取模拟引脚AD５的值 存入Intensity变量

Serial敭

print ＂Intensity ＝ ＂

串口输出＂Intensity＝ ＂

Serial敭

println Intensity

串口输出Intensity变量的值 并换行

delay ５００

延时５００ms

＃include LiquidCrystal_I２C敭h

＃include Wire敭h

LiquidCrystal_I２Clcd ０x２７

１６

２ 设置I２C驱动板的地址 否则不会在LCD上显示信息

intinputPin＝３０

定义第一个超声波信号的接收引脚

intinputPin１＝３１

定义第二个超声波信号的接收引脚

intoutputPin＝４０

定义第一个超声波信号的发出引脚

intoutputPin１＝４１

定义第二个超声波信号的发出引脚

intledpin＝１３

voidsetup

Serial敭

begin ９６００

pinMode ledpin

OUTPUT

pinMode inputPin INPUT

pinMode inputPin１ INPUT

pinMode outputPin OUTPUT

pinMode outputPin１ OUTPUT

voidloop

lcd敭

init

digitalWrite outputPin LOW

使发出超声波信号的引脚输出２ms低电平

digitalWrite outputPin１ LOW

使发出超声波信号的引脚输出２ms低电平

delayMicroseconds ２

digitalWrite outputPin HIGH

使发出超声波信号的引脚输出１０ms高电平 至少为１０μs

digitalWrite outputPin１ HIGH

使发出超声波信号的引脚输出１０ms高电平 至少为１０μs

delayMicroseconds １０

digitalWrite outputPin LOW

保持发出超声波信号的引脚为低电平

digitalWrite outputPin LOW

保持发出超声波信号的引脚为低电平

[]{#index_split_007.html#p415}![index-415_1.png](https://i.imgur.com/5lGEYTJ.jpeg){.calibre2}

![index-415_2.png](https://i.imgur.com/xZA8W7V.jpeg){.calibre2}

![index-415_3.png](https://i.imgur.com/wOQoasW.jpeg){.calibre2}

![index-415_4.png](https://i.imgur.com/9NnD6bY.jpeg){.calibre2}

![index-415_5.png](https://i.imgur.com/GKqFep3.jpeg){.calibre2}

４０４

intdistance ＝ pulseIn inputPin HIGH

读取脉冲时间

intdistance１ ＝ pulseIn inputPin１ HIGH

读取脉冲时间

distance＝ distance ５８

将脉冲时间转化为距离 单位

cm

distance１＝ distance１ ５８

Serial敭

print distance

Serial敭

println ＂cm＂

向串口监视器输出距离信息

Serial敭

print distance１

Serial敭

println ＂cm＂

lcd敭

backlight

lcd敭

print distance

lcd敭

println ＂cm＂

在LCD上输出距离信息

lcd敭

print distance１

lcd敭

println ＂cm＂

delay ５００

刷新时间为５００ms 即０敭

５s

３．LCD 模块

１)功能介绍

本项目采用 LCD 库文件代码 LiquidCrystal_I２C,从而简化 LCD 的连接应用.

２)相关代码

＃ifndefLiquidCrystal_I２C_h

＃defineLiquidCrystal_I２C_h

＃include inttypes敭h

＃include＂Print敭h＂

＃include Wire敭h

以下为预定义

＃defineLCD_CLEARDISPLAY０x０１

清除LCD屏幕上的内容 并将光标置于左上角

＃defineLCD_RETURNHOME０x０２

将光标定位在屏幕左上角

＃defineLCD_ENTRYMODESET０x０４

模式选择

＃defineLCD_DISPLAYCONTROL０x０８

光标左右移动

＃defineLCD_CURSORSHIFT０x１０

显示光标

＃defineLCD_FUNCTIONSET０x２０

功能定义

＃defineLCD_SETCGRAMADDR０x４０

＃defineLCD_SETDDRAMADDR０x８０

命令语句

下面是具体实现

模式选择

＃defineLCD_ENTRYRIGHT０x００

＃defineLCD_ENTRYLEFT０x０２

＃defineLCD_ENTRYSHIFTINCREMENT０x０１

＃defineLCD_ENTRYSHIFTDECREMENT０x００

显示设置

[]{#index_split_007.html#p416}![index-416_1.png](https://i.imgur.com/awLVgcC.jpeg){.calibre2}

４０５

＃defineLCD_DISPLAYON０x０４

＃defineLCD_DISPLAYOFF０x００

＃defineLCD_CURSORON０x０２

＃defineLCD_CURSOROFF０x００

＃defineLCD_BLINKON０x０１

＃defineLCD_BLINKOFF０x００

光标操纵

＃defineLCD_DISPLAYMOVE０x０８

＃defineLCD_CURSORMOVE０x００

＃defineLCD_MOVERIGHT０x０４

＃defineLCD_MOVELEFT０x００

功能设置

＃defineLCD_８BITMODE０x１０

４字节

＃defineLCD_４BITMODE０x００

８字节

＃defineLCD_２LINE０x０８

显示屏第一行

＃defineLCD_１LINE０x００

显示屏第二行

＃defineLCD_５x１０DOTS０x０４

小数点控制

＃defineLCD_５x８DOTS０x００

＃defineLCD_BACKLIGHT０x０８

背光亮度设置

＃defineLCD_NOBACKLIGHT０x００

＃defineEnB０００００１００

＃defineRwB００００００１０

读写字节

＃defineRsB０００００００１

Registerselectbit

classLiquidCrystal_I２C publicPrint

public

LiquidCrystal_I２C uint８_tlcd_Addr uint８_tlcd_cols uint８_tlcd_rows voidbegin uint８_tcols uint８_trows uint８_tcharsize＝ LCD_５x８DOTS

voidclear

清除显示

voidhome

返回设置

voidnoDisplay

不显示设置

voiddisplay

显示设置

voidnoBlink

映射

voidblink

未映射

voidnoCursor

去掉光标

voidcursor

光标

voidscrollDisplayLeft

光标左移

voidscrollDisplayRight

光标右移

voidprintLeft

靠左输出

voidprintRight

靠右输出

voidleftToRight

从左向右

voidrightToLeft

从右向左

voidshiftIncrement

递增

[]{#index_split_007.html#p417}![index-417_1.png](https://i.imgur.com/hyXr0yd.jpeg){.calibre2}

![index-417_2.png](https://i.imgur.com/OqgPy8o.jpeg){.calibre2}

![index-417_3.png](https://i.imgur.com/PUbdosH.jpeg){.calibre2}

![index-417_4.png](https://i.imgur.com/VL3Fqxp.jpeg){.calibre2}

![index-417_5.png](https://i.imgur.com/xpmsE1a.jpeg){.calibre2}

４０６

voidshiftDecrement

递减

voidnoBacklight

取消背景光

voidbacklight

建立背景光

voidautoscroll

自动控制光标

voidnoAutoscroll

手动控制光标

voidcreateChar uint８_t uint８_t

建立字表

voidsetCursor uint８_t uint８_t

建立光标

＃ifdefined ARDUINO &&ARDUINO ＝ １００

virtualsize_twrite uint８_t

＃else

virtualvoidwrite uint８_t

＃endif

voidcommand uint８_t

voidinit

voidblink_on

voidblink_off

voidcursor_on

voidcursor_off

voidsetBacklight uint８_tnew_val

voidload_custom_character uint８_tchar_num uint８_t∗rows voidprintstr constchar

LiquidCrystal_I２C

∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗

＃include＂LiquidCrystal_I２C敭h＂

包含以上所写的头文件

＃include inttypes敭h

＃ifdefined ARDUINO &&ARDUINO ＝ １００

＃include＂Arduino敭h＂

＃defineprintIIC args Wire敭write args

inlinesize_tLiquidCrystal_I２C

write uint８_tvalue

send value Rs

return１

＃else

＃include＂WProgram敭h＂

＃defineprintIIC args Wire敭send args

inlinevoidLiquidCrystal_I２C

write uint８_tvalue

send value Rs

＃endif

＃include＂Wire敭h＂

当LCD通电时执行以下步骤

１敭清除显示屏

[]{#index_split_007.html#p418}![index-418_1.png](https://i.imgur.com/ezQ0QGu.jpeg){.calibre2}

![index-418_2.png](https://i.imgur.com/5ejQaBZ.jpeg){.calibre2}

![index-418_3.png](https://i.imgur.com/Zqb9AOg.jpeg){.calibre2}

![index-418_4.png](https://i.imgur.com/bx4YDxC.jpeg){.calibre2}

４０７

２敭设定功能

DL ＝ １

N ＝ ０

F ＝ ０

３敭显示控制界面

D ＝ ０

C ＝ ０

B ＝ ０

４敭模式选择

I D ＝ １

S ＝ ０

LiquidCrystal_I２C

LiquidCrystal_I２C uint８_tlcd_Addr

uint８_tlcd_cols

uint８_tlcd_rows

构造函数

\_Addr＝ lcd_Addr

\_cols＝ lcd_cols

\_rows＝ lcd_rows

\_backlightval＝ LCD_NOBACKLIGHT

voidLiquidCrystal_I２C

init

构造函数

init_priv

voidLiquidCrystal_I２C

init_priv

构造函数

Wire敭begin

\_displayfunction＝ LCD_４BITMODE\|LCD_１LINE\|LCD_５x８DOTS

begin \_cols \_rows

voidLiquidCrystal_I２C

begin uint８_tcols uint８_tlines uint８_tdotsize if lines １

构造函数

\_displayfunction\|＝ LCD_２LINE

\_numlines＝ lines

if dotsize

＝ ０ && lines＝＝ １

\_displayfunction\|＝ LCD_５x１０DOTS

delay ５０

延迟

expanderWrite \_backlightval

开始执行

delay １０００

write４bits ０x０３ ４

设置４字节模式

delayMicroseconds ４５００

重新尝试

[]{#index_split_007.html#p419}![index-419_1.png](https://i.imgur.com/zN7IXdy.jpeg){.calibre2}

![index-419_2.png](https://i.imgur.com/GG9UiVW.jpeg){.calibre2}

![index-419_3.png](https://i.imgur.com/z1pFu0J.jpeg){.calibre2}

![index-419_4.png](https://i.imgur.com/AgM0q35.jpeg){.calibre2}

![index-419_5.png](https://i.imgur.com/iFyuJIB.jpeg){.calibre2}

![index-419_6.png](https://i.imgur.com/JvNKb3g.jpeg){.calibre2}

![index-419_7.png](https://i.imgur.com/3l9xRTN.jpeg){.calibre2}

![index-419_8.png](https://i.imgur.com/1S7AeL9.jpeg){.calibre2}

４０８

write４bits ０x０３ ４

delayMicroseconds ４５００

再次尝试

write４bits ０x０３ ４

delayMicroseconds １５０

最后一次尝试

write４bits ０x０２ ４

设置 lines、

fontsize等

command LCD_FUNCTIONSET\| \_displayfunction 改变显示模式

\_displaycontrol＝ LCD_DISPLAYON\|LCD_CURSOROFF\|LCD_BLINKOFF

display

clear

清除

\_displaymode＝ LCD_ENTRYLEFT\|LCD_ENTRYSHIFTDECREMENT

command LCD_ENTRYMODESET\| \_displaymode 设置进入模式

home

voidLiquidCrystal_I２C

clear

清除模式设置

command LCD_CLEARDISPLAY

清除显示 光标置零

delayMicroseconds ２０００

延迟较长时间

voidLiquidCrystal_I２C

home

command LCD_RETURNHOME

设置光标位置为零

delayMicroseconds ２０００

延迟时间

voidLiquidCrystal_I２C

setCursor uint８_tcol uint８_trow

introw_offsets ＝ ０x００ ０x４０ ０x１４ ０x５４

if row \_numlines

row＝ \_numlines－１

wecountrowsstartingw ０

command LCD_SETDDRAMADDR\| col＋ row_offsets row voidLiquidCrystal_I２C

noDisplay

打开 关闭显示器

\_displaycontrol&＝ \~LCD_DISPLAYON

command LCD_DISPLAYCONTROL\| \_displaycontrol voidLiquidCrystal_I２C

display

\_displaycontrol\|＝ LCD_DISPLAYON

command LCD_DISPLAYCONTROL\| \_displaycontrol voidLiquidCrystal_I２C

noCursor

打开 关闭下画线光标

\_displaycontrol&＝ \~LCD_CURSORON

command LCD_DISPLAYCONTROL\| \_displaycontrol voidLiquidCrystal_I２C

cursor

\_displaycontrol\|＝ LCD_CURSORON

[]{#index_split_007.html#p420}![index-420_1.png](https://i.imgur.com/qN7JB2D.jpeg){.calibre2}

![index-420_2.png](https://i.imgur.com/jvmxlGp.jpeg){.calibre2}

![index-420_3.png](https://i.imgur.com/w2IRFyM.jpeg){.calibre2}

![index-420_4.png](https://i.imgur.com/YgasuPx.jpeg){.calibre2}

４０９

command LCD_DISPLAYCONTROL\| \_displaycontrol voidLiquidCrystal_I２C

noBlink

打开 关闭闪烁的光标

\_displaycontrol&＝ \~LCD_BLINKON

command LCD_DISPLAYCONTROL\| \_displaycontrol voidLiquidCrystal_I２C

blink

\_displaycontrol\|＝ LCD_BLINKON

command LCD_DISPLAYCONTROL\| \_displaycontrol voidLiquidCrystal_I２C

scrollDisplayLeft void 以下命令滚动显示 不改变RAM

command LCD_CURSORSHIFT\|LCD_DISPLAYMOVE\|LCD_MOVELEFT

voidLiquidCrystal_I２C

scrollDisplayRight void

command LCD_CURSORSHIFT\|LCD_DISPLAYMOVE\|LCD_MOVERIGHT

voidLiquidCrystal_I２C

leftToRight void

文本流从左到右

\_displaymode\|＝ LCD_ENTRYLEFT

command LCD_ENTRYMODESET\| \_displaymode voidLiquidCrystal_I２C

rightToLeft void

文本流从右到左

\_displaymode&＝ \~LCD_ENTRYLEFT

command LCD_ENTRYMODESET\| \_displaymode voidLiquidCrystal_I２C

autoscroll void

文本右对齐

\_displaymode\|＝ LCD_ENTRYSHIFTINCREMENT

command LCD_ENTRYMODESET\| \_displaymode voidLiquidCrystal_I２C

noAutoscroll void

文本左对齐

\_displaymode&＝ \~LCD_ENTRYSHIFTINCREMENT

command LCD_ENTRYMODESET\| \_displaymode voidLiquidCrystal_I２C

createChar uint８_tlocation uint８_tcharmap location&＝ ０x７ weonlyhave８locations０－７

command LCD_SETCGRAMADDR\| location ３

for inti＝０ i ８ i++

write charmap i

voidLiquidCrystal_I２C

noBacklight void

开 关背光 可选

\_backlightval＝LCD_NOBACKLIGHT

expanderWrite ０

[]{#index_split_007.html#p421}![index-421_1.png](https://i.imgur.com/2PmXLnI.jpeg){.calibre2}

![index-421_2.png](https://i.imgur.com/c7rHnOc.jpeg){.calibre2}

![index-421_3.png](https://i.imgur.com/nKGgkhs.jpeg){.calibre2}

４１０

voidLiquidCrystal_I２C

backlight void

\_backlightval＝LCD_BACKLIGHT

expanderWrite ０

inlinevoidLiquidCrystal_I２C

command uint８_tvalue

send value ０

voidLiquidCrystal_I２C

send uint８_tvalue uint８_tmode 　　 写命令或数据

uint８_thighnib＝value&０xf０

uint８_tlownib＝ value ４ &０xf０

write４bits highnib \|mode

write４bits lownib \|mode

voidLiquidCrystal_I２C

write４bits uint８_tvalue

expanderWrite value

pulseEnable value

voidLiquidCrystal_I２C

expanderWrite uint８_t\_data

Wire敭beginTransmission \_Addr

printIIC int \_data \| \_backlightval

Wire敭endTransmission

voidLiquidCrystal_I２C

pulseEnable uint８_t\_data

expanderWrite \_data\|En

En取高

delayMicroseconds １

使脉冲大于４５０ns

expanderWrite \_data&\~En

En取低

delayMicroseconds ５０

延迟３７μs

voidLiquidCrystal_I２C

cursor_on

别名

cursor

voidLiquidCrystal_I２C

cursor_off

noCursor

voidLiquidCrystal_I２C

blink_on

blink

voidLiquidCrystal_I２C

blink_off

noBlink

[]{#index_split_007.html#p422}![index-422_1.png](https://i.imgur.com/jCoJmuQ.jpeg){.calibre2}

![index-422_2.png](https://i.imgur.com/wqdp1mB.jpeg){.calibre2}

４１１

voidLiquidCrystal_I２C

load_custom_character uint８_tchar_num uint８_t∗rows createChar char_num rows

voidLiquidCrystal_I２C

setBacklight uint８_tnew_val

if new_val

backlight

打开背光

else

noBacklight

关闭背光

voidLiquidCrystal_I２C

printstr constcharc

print c

voidLiquidCrystal_I２C

off

voidLiquidCrystal_I２C

on

voidLiquidCrystal_I２C

setDelay intcmdDelay

intcharDelay

uint８_tLiquidCrystal_I２C

status return０

uint８_tLiquidCrystal_I２C

keypad return０

uint８_tLiquidCrystal_I２C

init_bargraph uint８_tgraphtype return０

voidLiquidCrystal_I２C draw_horizontal_graph uint８_trow uint８_tcolumn uint８_tlen uint８_tpixel_col_end

voidLiquidCrystal_I２C

draw_vertical_graph uint８_trow uint８_tcolumn uint８_tlen uint８\_

tpixel_row_end

voidLiquidCrystal_I２C

setContrast uint８_tnew_val

１５．

４　产品展示

多角度的产品展示如图１５Ｇ８(

a)\~图１５Ｇ８(e)所示.

图１５Ｇ８　产品展示

[]{#index_split_007.html#p423}![index-423_1.png](https://i.imgur.com/K3Uip3F.jpeg){.calibre2}

![index-423_2.png](https://i.imgur.com/MfvWbtQ.jpeg){.calibre2}

![index-423_3.png](https://i.imgur.com/DniILzc.jpeg){.calibre2}

４１２

图１５Ｇ８　(续)

１５．

５　故障及问题分析

问题１:后期调试小车遥控功能时,出现右轮不能前转问题.

解决方案:手工焊接的主板存在接触不良的情况,将各焊接处进一步检查并补焊后,右

轮正常工作.

问题２:代码上传到 ArduinoUNO 开发板后,LCD１６０２并不能显示预期结果,而是不

断闪烁乱码.

解决方案:对库文件代码进行检查,发现代码存在问题,使程序值输出到 LCD１６０２后

无返回值,将其修改即可解决问题.

问题３:手工焊接时操作不当,误将主板和 ArduinoUNO 开发板部分引脚剪断.

解决方案:由于是第一次 操 作,误 以 为 ArduinoUNO 开发板下面的部分引脚是多余

的,将其剪掉了,以至于不能将其与主板连接,使用杜邦线配合面包板进行连接,成功完成了

[]{#index_split_007.html#p424}![index-424_1.png](https://i.imgur.com/0zq9ft6.jpeg){.calibre2}

４１３

小车的功能实现.

问题４:改变人与车的距离,人体红外感应模块只输出一个信号.

解决方案:经过多次调整两个灵敏度旋钮之后,成功将人体红外感应的距离调整到了

合适的位置.

问题５:连接好电路后,光敏传感器无法正常工作.

解决方案:光敏传感器不需要再外接电阻,于是将电路中与传感器串联的电阻去掉,改

变光强,成功实现 LED 的闪烁.

１５．

６　元件清单

完成本项目所用到的元件及数量如表１５Ｇ２所示.

表１５Ｇ２　多功能蓝牙小车元件清单

元 件 名 称

数量

HCSR０４超声波模块

３个

ZY０８A 小车套件

１个

LCD１６０２AIIC接口

１个

光敏器件１S５２SV

１个

ArduinoUNOR３开发板

１个

ArduinoMEGA２５６０开发板

１个

红外发射接收管

１个

蓝牙模块

１个

杜邦线

若干

导线

若干

[]{#index_split_007.html#p425}参 考 文 献

\[１\]　李永华,高英,陈青云．Arduino软硬件协同设计实战指南\[M\]．北京:清华大学出版社,２０１５．

\[２\]　刘玉田,徐勇进．用 Arduino进行创造\[M\]．２版．北京:清华大学出版社,２０１４．

\[３\]　赵英杰．完美图解 Arduino互动设计入门\[M\]．北京:科学出版社,２０１４．

\[４\]　MartinEvans,JoshuaNoble,JordanHochenbaum．Arduino实战\[M\]．况琪,译．北京:人民邮电出版

社,

２０１４．

\[５\]　JohnBoxall．动手玩转 Arduino\[M\]．翁恺,译．北京:人民邮电出版社,２０１４．

\[６\]　刘培植．数字电路与逻辑设计\[M\]．２版．北京:北京邮电大学出版社,２０１３．

\[７\]　SimonMonk．Arduino编程从零开始\[M\]．刘椮楠,译．北京:科学出版社,２０１３．

\[８\]　MichaelMcRoberts．Arduino从基础到实践\[M\]．杨继志,郭敬,译．北京:电子工业出版社,２０１３．

\[９\]　黄文恺,伍冯洁,陈虹．Arduino开发实战指南\[M\]．北京:机械工业出版社,２０１４．

\[１０\]　唐文彦．传感器\[M\]．北京:机械工业出版社,２００６．

\[１１\]　沈金鑫．Arduino与 LabVIEW 开发实践\[M\]．北京:机械工业出版社,２０１４．

\[１２\]　程晨．Arduino电子设计实战指南\[M\]．北京:机械工业出版社,２０１３．

\[１３\]　沙占友．集成传感器应用\[M\]．北京:中国电力出版社,２００５．

\[１４\]　李军,李冰海．检测技术及仪表\[M\]．北京:中国轻工业出版社,２００８．

\[１５\]　宋楠,韩广义．Arduino开发从零开始学---学电子的都玩这个\[M\]．北京:清华大学出版社,２０１４．

\[１６\]　刘敏,刘泽军,宋庆国．基于 Arduino的简易亮光报警器的设计与实现\[J\]．电子 世 界,２０１２(２１): １２２Ｇ１２３．

[]{#index_split_007.html#outline}

[]{#index_split_008.html}

# Document Outline {#index_split_008.html#calibre_pb_0 .calibre3}

-   [封面](#index_split_000.html#p1)
-   [书名页](#index_split_000.html#p2)
-   [版权页](#index_split_000.html#p3)
-   [前言](#index_split_000.html#p4)
-   [目录页](#index_split_000.html#p6)
-   [第1章 Arduino设计基础](#index_split_000.html#p12)
    -   [1.1 开源硬件概述](#index_split_000.html#p12)
    -   [1.2 Arduino开源硬件](#index_split_000.html#p13)
        -   [1.2.1 Arduino开发板](#index_split_000.html#p13)
        -   [1.2.2 Arduino扩展板](#index_split_000.html#p16)
    -   [1.3 Arduino软件开发平台](#index_split_000.html#p17)
        -   [1.3.1 Arduino平台特点](#index_split_000.html#p18)
        -   [1.3.2 ArduinoIDE的安装](#index_split_000.html#p18)
        -   [1.3.3 ArduinoIDE的使用](#index_split_000.html#p21)
    -   [1.4 Arduino编程语言](#index_split_000.html#p22)
        -   [1.4.1 Arduino编程基础](#index_split_000.html#p23)
        -   [1.4.2 数字I/O引脚的操作函数](#index_split_000.html#p23)
        -   [1.4.3 模拟I/O引脚的操作函数](#index_split_000.html#p24)
        -   [1.4.4 高级I/O引脚的操作函数](#index_split_000.html#p25)
        -   [1.4.5 时间函数](#index_split_000.html#p25)
        -   [1.4.6 中断函数](#index_split_000.html#p27)
        -   [1.4.7 串口通信函数](#index_split_000.html#p30)
        -   [1.4.8 Arduino的库文件](#index_split_000.html#p31)
    -   [1.5 Arduino硬件设计平台](#index_split_000.html#p31)
        -   [1.5.1 Fritzing软件简介](#index_split_000.html#p32)
        -   [1.5.2 Fritzing使用方法](#index_split_000.html#p40)
        -   [1.5.3 Arduino电路设计](#index_split_000.html#p50)
        -   [1.5.4 Arduino开发平台样例与编程](#index_split_000.html#p56)
-   [第2章 LED多模式显示时钟项目设计](#index_split_000.html#p59)
    -   [2.1 项目背景](#index_split_000.html#p59)
    -   [2.2 创新描述](#index_split_000.html#p59)
    -   [2.3 功能及总体设计](#index_split_000.html#p59)
        -   [2.3.1 功能介绍](#index_split_000.html#p60)
        -   [2.3.2 总体设计](#index_split_000.html#p60)
        -   [2.3.3 模块介绍](#index_split_000.html#p63)
    -   [2.4 产品展示](#index_split_001.html#p111)
    -   [2.5 故障及问题分析](#index_split_001.html#p112)
    -   [2.6 元件清单](#index_split_001.html#p113)
-   [第3章 机械臂控制图像识别项目设计](#index_split_001.html#p114)
    -   [3.1 项目背景](#index_split_001.html#p114)
    -   [3.2 创新描述](#index_split_001.html#p114)
    -   [3.3 功能及总体设计](#index_split_001.html#p114)
        -   [3.3.1 功能介绍](#index_split_001.html#p115)
        -   [3.3.2 总体设计](#index_split_001.html#p115)
        -   [3.3.3 模块介绍](#index_split_001.html#p117)
    -   [3.4 产品展示](#index_split_002.html#p149)
    -   [3.5 故障及问题分析](#index_split_002.html#p149)
    -   [3.6 元件清单](#index_split_002.html#p150)
-   [第4章 基于Mathematica的自动接球系统项目设计](#index_split_002.html#p151)
    -   [4.1 项目背景](#index_split_002.html#p151)
    -   [4.2 创新描述](#index_split_002.html#p151)
    -   [4.3 功能及总体设计](#index_split_002.html#p151)
        -   [4.3.1 功能介绍](#index_split_002.html#p152)
        -   [4.3.2 总体设计](#index_split_002.html#p152)
        -   [4.3.3 模块介绍](#index_split_002.html#p157)
    -   [4.4 产品展示](#index_split_002.html#p168)
    -   [4.5 故障及问题分析](#index_split_002.html#p170)
    -   [4.6 元件清单](#index_split_002.html#p171)
-   [第5章 蓝牙遥控四自由度可自动避障机器人项目设计](#index_split_002.html#p173)
    -   [5.1 项目背景](#index_split_002.html#p173)
    -   [5.2 创新描述](#index_split_002.html#p173)
    -   [5.3 功能及总体设计](#index_split_002.html#p173)
        -   [5.3.1 功能介绍](#index_split_002.html#p173)
        -   [5.3.2 总体设计](#index_split_002.html#p173)
        -   [5.3.3 模块介绍](#index_split_003.html#p175)
    -   [5.4 产品展示](#index_split_003.html#p193)
    -   [5.5 故障及问题分析](#index_split_003.html#p194)
    -   [5.6 元件清单](#index_split_003.html#p195)
-   [第6章 遥控智能四驱车项目设计](#index_split_003.html#p196)
    -   [6.1 项目背景](#index_split_003.html#p196)
    -   [6.2 创新描述](#index_split_003.html#p196)
    -   [6.3 功能及总体设计](#index_split_003.html#p196)
        -   [6.3.1 功能介绍](#index_split_003.html#p196)
        -   [6.3.2 总体设计](#index_split_003.html#p197)
        -   [6.3.3 模块介绍](#index_split_003.html#p199)
    -   [6.4 产品展示](#index_split_003.html#p216)
    -   [6.5 故障及问题分析](#index_split_003.html#p216)
    -   [6.6 元件清单](#index_split_003.html#p218)
-   [第7章 电机合奏团项目设计](#index_split_003.html#p219)
    -   [7.1 项目背景](#index_split_003.html#p219)
    -   [7.2 创新描述](#index_split_003.html#p219)
    -   [7.3 功能及总体设计](#index_split_003.html#p219)
        -   [7.3.1 功能介绍](#index_split_004.html#p220)
        -   [7.3.2 总体设计](#index_split_004.html#p220)
        -   [7.3.3 模块介绍](#index_split_004.html#p222)
    -   [7.4 产品展示](#index_split_004.html#p228)
    -   [7.5 故障及问题分析](#index_split_004.html#p229)
    -   [7.6 元件清单](#index_split_004.html#p229)
-   [第8章 教学电子琴项目设计](#index_split_004.html#p231)
    -   [8.1 项目背景](#index_split_004.html#p231)
    -   [8.2 创新描述](#index_split_004.html#p231)
    -   [8.3 功能及总体设计](#index_split_004.html#p231)
        -   [8.3.1 功能介绍](#index_split_004.html#p231)
        -   [8.3.2 总体设计](#index_split_004.html#p232)
        -   [8.3.3 模块介绍](#index_split_004.html#p233)
    -   [8.4 产品展示](#index_split_004.html#p248)
    -   [8.5 故障及问题分析](#index_split_004.html#p249)
    -   [8.6 元件清单](#index_split_004.html#p250)
-   [第9章 微型激光雕刻机项目设计](#index_split_004.html#p251)
    -   [9.1 项目背景](#index_split_004.html#p251)
    -   [9.2 创新描述](#index_split_004.html#p251)
    -   [9.3 功能及总体设计](#index_split_004.html#p251)
        -   [9.3.1 功能介绍](#index_split_004.html#p252)
        -   [9.3.2 总体设计](#index_split_004.html#p252)
        -   [9.3.3 模块介绍](#index_split_004.html#p254)
    -   [9.4 产品展示](#index_split_004.html#p266)
    -   [9.5 故障及问题分析](#index_split_004.html#p267)
    -   [9.6 元件清单](#index_split_004.html#p268)
-   [第10章 遥控吸尘器项目设计](#index_split_004.html#p269)
    -   [10.1 项目背景](#index_split_004.html#p269)
    -   [10.2 创新描述](#index_split_004.html#p269)
    -   [10.3 功能及总体设计](#index_split_004.html#p269)
        -   [10.3.1 功能介绍](#index_split_004.html#p270)
        -   [10.3.2 总体设计](#index_split_004.html#p270)
        -   [10.3.3 模块介绍](#index_split_005.html#p272)
    -   [10.4 产品展示](#index_split_005.html#p283)
    -   [10.5 故障及问题分析](#index_split_005.html#p283)
    -   [10.6 元件清单](#index_split_005.html#p285)
-   [第11章 写字报时机器人项目设计](#index_split_005.html#p286)
    -   [11.1 项目背景](#index_split_005.html#p286)
    -   [11.2 创新描述](#index_split_005.html#p286)
    -   [11.3 功能及总体设计](#index_split_005.html#p286)
        -   [11.3.1 功能介绍](#index_split_005.html#p287)
        -   [11.3.2 总体设计](#index_split_005.html#p287)
        -   [11.3.3 模块介绍](#index_split_005.html#p289)
    -   [11.4 产品展示](#index_split_005.html#p303)
    -   [11.5 故障及问题分析](#index_split_005.html#p304)
    -   [11.6 元件清单](#index_split_005.html#p305)
-   [第12章 棋盘小游戏之守护绿色项目设计](#index_split_005.html#p306)
    -   [12.1 项目背景](#index_split_005.html#p306)
    -   [12.2 创新描述](#index_split_005.html#p306)
    -   [12.3 功能及总体设计](#index_split_005.html#p306)
        -   [12.3.1 功能介绍](#index_split_005.html#p307)
        -   [12.3.2 总体设计](#index_split_005.html#p307)
        -   [12.3.3 模块介绍](#index_split_005.html#p309)
    -   [12.4 产品展示](#index_split_006.html#p338)
    -   [12.5 故障及问题分析](#index_split_006.html#p339)
    -   [12.6 元件清单](#index_split_006.html#p340)
-   [第13章 炮弹发射车项目设计](#index_split_006.html#p341)
    -   [13.1 项目背景](#index_split_006.html#p341)
    -   [13.2 创新描述](#index_split_006.html#p341)
    -   [13.3 功能及总体设计](#index_split_006.html#p341)
        -   [13.3.1 功能介绍](#index_split_006.html#p341)
        -   [13.3.2 总体设计](#index_split_006.html#p342)
        -   [13.3.3 模块介绍](#index_split_006.html#p344)
    -   [13.4 产品展示](#index_split_006.html#p358)
    -   [13.5 问题及故障分析](#index_split_006.html#p359)
    -   [13.6 元件清单](#index_split_006.html#p360)
-   [第14章 球形机器人项目设计](#index_split_006.html#p361)
    -   [14.1 项目背景](#index_split_006.html#p361)
    -   [14.2 创新描述](#index_split_006.html#p363)
    -   [14.3 功能及总体设计](#index_split_006.html#p364)
        -   [14.3.1 功能介绍](#index_split_006.html#p364)
        -   [14.3.2 总体设计](#index_split_006.html#p364)
        -   [14.3.3 模块介绍](#index_split_006.html#p367)
    -   [14.4 产品展示](#index_split_007.html#p400)
    -   [14.5 故障及问题分析](#index_split_007.html#p401)
    -   [14.6 元件清单](#index_split_007.html#p403)
-   [第15章 多功能蓝牙小车项目设计](#index_split_007.html#p404)
    -   [15.1 项目背景](#index_split_007.html#p404)
    -   [15.2 创新描述](#index_split_007.html#p404)
    -   [15.3 功能及总体设计](#index_split_007.html#p404)
        -   [15.3.1 功能介绍](#index_split_007.html#p404)
        -   [15.3.2 总体设计](#index_split_007.html#p405)
        -   [15.3.3 模块介绍](#index_split_007.html#p408)
    -   [15.4 产品展示](#index_split_007.html#p422)
    -   [15.5 故障及问题分析](#index_split_007.html#p423)
    -   [15.6 元件清单](#index_split_007.html#p424)
-   [参考文献](#index_split_007.html#p425)

```{=html}
</p>
```
