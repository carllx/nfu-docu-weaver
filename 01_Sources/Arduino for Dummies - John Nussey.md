![cover.jpg](https://i.imgur.com/JL8TixD.jpeg)

[]{#cover.xhtml}

::: {.section}
![cover.jpg](https://i.imgur.com/UutgLYf.jpeg)
:::

[]{#f01.xhtml}

::: {.section .copyright .copyright-page}
[]{#f01.xhtml#f01-sec-0001}

[]{#f01.xhtml#Page_ii .pagebreak role="doc-pagebreak" title="ii"}**Arduino® For Dummies®, 2nd Edition**

Published by: **John Wiley & Sons, Inc.,** 111 River Street, Hoboken, NJ 07030-5774, [[`www.wiley.com`]{.Code-within-text}](http://www.wiley.com)

Copyright © 2018 by John Wiley & Sons, Inc., Hoboken, New Jersey

Published simultaneously in Canada

No part of this publication may be reproduced, stored in a retrieval system or transmitted in any form or by any means, electronic, mechanical, photocopying, recording, scanning or otherwise, except as permitted under Sections 107 or 108 of the 1976 United States Copyright Act, without the prior written permission of the Publisher. Requests to the Publisher for permission should be addressed to the Permissions Department, John Wiley & Sons, Inc., 111 River Street, Hoboken, NJ 07030, (201) 748-6011, fax (201) 748-6008, or online at [[`http://www.wiley.com/go/permissions`]{.Code-within-text}](http://www.wiley.com/go/permissions).

**Trademarks:** Wiley, For Dummies, the Dummies Man logo, Dummies.com, Making Everything Easier, and related trade dress are trademarks or registered trademarks of John Wiley & Sons, Inc. and may not be used without written permission. Arduino is a registered trademark of Arduino AG Corporation. All other trademarks are the property of their respective owners. John Wiley & Sons, Inc. is not associated with any product or vendor mentioned in this book.

LIMIT OF LIABILITY/DISCLAIMER OF WARRANTY: THE PUBLISHER AND THE AUTHOR MAKE NO REPRESENTATIONS OR WARRANTIES WITH RESPECT TO THE ACCURACY OR COMPLETENESS OF THE CONTENTS OF THIS WORK AND SPECIFICALLY DISCLAIM ALL WARRANTIES, INCLUDING WITHOUT LIMITATION WARRANTIES OF FITNESS FOR A PARTICULAR PURPOSE. NO WARRANTY MAY BE CREATED OR EXTENDED BY SALES OR PROMOTIONAL MATERIALS. THE ADVICE AND STRATEGIES CONTAINED HEREIN MAY NOT BE SUITABLE FOR EVERY SITUATION. THIS WORK IS SOLD WITH THE UNDERSTANDING THAT THE PUBLISHER IS NOT ENGAGED IN RENDERING LEGAL, ACCOUNTING, OR OTHER PROFESSIONAL SERVICES. IF PROFESSIONAL ASSISTANCE IS REQUIRED, THE SERVICES OF A COMPETENT PROFESSIONAL PERSON SHOULD BE SOUGHT. NEITHER THE PUBLISHER NOR THE AUTHOR SHALL BE LIABLE FOR DAMAGES ARISING HEREFROM. THE FACT THAT AN ORGANIZATION OR WEBSITE IS REFERRED TO IN THIS WORK AS A CITATION AND/OR A POTENTIAL SOURCE OF FURTHER INFORMATION DOES NOT MEAN THAT THE AUTHOR OR THE PUBLISHER ENDORSES THE INFORMATION THE ORGANIZATION OR WEBSITE MAY PROVIDE OR RECOMMENDATIONS IT MAY MAKE. FURTHER, READERS SHOULD BE AWARE THAT INTERNET WEBSITES LISTED IN THIS WORK MAY HAVE CHANGED OR DISAPPEARED BETWEEN WHEN THIS WORK WAS WRITTEN AND WHEN IT IS READ.

For general information on our other products and services, please contact our Customer Care Department within the U.S. at 877-762-2974, outside the U.S. at 317-572-3993, or fax 317-572-4002. For technical support, please visit [[`https://hub.wiley.com/community/support/dummies`]{.Code-within-text}](https://hub.wiley.com/community/support/dummies).

Wiley publishes in a variety of print and electronic formats and by print-on-demand. Some material included with standard print versions of this book may not be included in e-books or in print-on-demand. If this book refers to media such as a CD or DVD that is not included in the version you purchased, you may download this material at [[`http://booksupport.wiley.com`]{.Code-within-text}](http://booksupport.wiley.com). For more information about Wiley products, visit [[`www.wiley.com`]{.Code-within-text}](http://www.wiley.com).

Library of Congress Control Number: 2018951004

ISBN 978-1-119-48954-2 (pbk); ISBN 978-1-119-48955-9 (ebk); ISBN 978-1-119-48957-3 (ebk)
:::

[]{#navigation.xhtml}

# Arduino® For Dummies®

### To view this book\'s Cheat Sheet, simply go to [www.dummies.com](http://www.dummies.com) and search for "Arduino For Dummies Cheat Sheet" in the Search box.

```{=html}
<nav class="guideList" epub:type="landmarks" id="guide">
```
## Guide

1.  [Cover](#cover.xhtml)
2.  [Table of Contents](#navigation.xhtml#toc)
3.  [Begin Reading](#c00.xhtml)

```{=html}
</nav>
```
```{=html}
<nav class="pageList" epub:type="page-list" hidden="hidden" id="pages" role="doc-pagelist">
```
## Pages

1.  [i](#f01.xhtml#Page_i)
2.  [ii](#f01.xhtml#Page_ii)
3.  [xiii](#f02.xhtml#Page_xiii)
4.  [1](#c00.xhtml#Page_1)
5.  [2](#c00.xhtml#Page_2)
6.  [3](#c00.xhtml#Page_3)
7.  [5](#p01.xhtml#Page_5)
8.  [6](#p01.xhtml#Page_6)
9.  [7](#c01.xhtml#Page_7)
10. [8](#c01.xhtml#Page_8)
11. [9](#c01.xhtml#Page_9)
12. [10](#c01.xhtml#Page_10)
13. [11](#c01.xhtml#Page_11)
14. [12](#c01.xhtml#Page_12)
15. [13](#c01.xhtml#Page_13)
16. [14](#c01.xhtml#Page_14)
17. [15](#c01.xhtml#Page_15)
18. [16](#c01.xhtml#Page_16)
19. [17](#c02.xhtml#Page_17)
20. [18](#c02.xhtml#Page_18)
21. [19](#c02.xhtml#Page_19)
22. [20](#c02.xhtml#Page_20)
23. [21](#c02.xhtml#Page_21)
24. [22](#c02.xhtml#Page_22)
25. [23](#c02.xhtml#Page_23)
26. [24](#c02.xhtml#Page_24)
27. [25](#c02.xhtml#Page_25)
28. [26](#c02.xhtml#Page_26)
29. [27](#c02.xhtml#Page_27)
30. [28](#c02.xhtml#Page_28)
31. [29](#c02.xhtml#Page_29)
32. [30](#c02.xhtml#Page_30)
33. [31](#c02.xhtml#Page_31)
34. [32](#c02.xhtml#Page_32)
35. [33](#c02.xhtml#Page_33)
36. [34](#c02.xhtml#Page_34)
37. [35](#c02.xhtml#Page_35)
38. [36](#c02.xhtml#Page_36)
39. [37](#c03.xhtml#Page_37)
40. [38](#c03.xhtml#Page_38)
41. [39](#c03.xhtml#Page_39)
42. [40](#c03.xhtml#Page_40)
43. [41](#c03.xhtml#Page_41)
44. [42](#c03.xhtml#Page_42)
45. [43](#c03.xhtml#Page_43)
46. [44](#c03.xhtml#Page_44)
47. [45](#c03.xhtml#Page_45)
48. [46](#c03.xhtml#Page_46)
49. [47](#c03.xhtml#Page_47)
50. [48](#c03.xhtml#Page_48)
51. [49](#c03.xhtml#Page_49)
52. [50](#c03.xhtml#Page_50)
53. [51](#c03.xhtml#Page_51)
54. [52](#c03.xhtml#Page_52)
55. [53](#c03.xhtml#Page_53)
56. [55](#p02.xhtml#Page_55)
57. [56](#p02.xhtml#Page_56)
58. [57](#c04.xhtml#Page_57)
59. [58](#c04.xhtml#Page_58)
60. [59](#c04.xhtml#Page_59)
61. [60](#c04.xhtml#Page_60)
62. [61](#c04.xhtml#Page_61)
63. [62](#c04.xhtml#Page_62)
64. [63](#c04.xhtml#Page_63)
65. [64](#c04.xhtml#Page_64)
66. [65](#c04.xhtml#Page_65)
67. [66](#c04.xhtml#Page_66)
68. [67](#c04.xhtml#Page_67)
69. [69](#c05.xhtml#Page_69)
70. [70](#c05.xhtml#Page_70)
71. [71](#c05.xhtml#Page_71)
72. [72](#c05.xhtml#Page_72)
73. [73](#c05.xhtml#Page_73)
74. [74](#c05.xhtml#Page_74)
75. [75](#c05.xhtml#Page_75)
76. [76](#c05.xhtml#Page_76)
77. [77](#c05.xhtml#Page_77)
78. [78](#c05.xhtml#Page_78)
79. [79](#c05.xhtml#Page_79)
80. [80](#c05.xhtml#Page_80)
81. [81](#c05.xhtml#Page_81)
82. [82](#c05.xhtml#Page_82)
83. [83](#c05.xhtml#Page_83)
84. [85](#c06.xhtml#Page_85)
85. [86](#c06.xhtml#Page_86)
86. [87](#c06.xhtml#Page_87)
87. [88](#c06.xhtml#Page_88)
88. [89](#c06.xhtml#Page_89)
89. [90](#c06.xhtml#Page_90)
90. [91](#c06.xhtml#Page_91)
91. [92](#c06.xhtml#Page_92)
92. [93](#c06.xhtml#Page_93)
93. [94](#c06.xhtml#Page_94)
94. [95](#c06.xhtml#Page_95)
95. [96](#c06.xhtml#Page_96)
96. [97](#c06.xhtml#Page_97)
97. [98](#c06.xhtml#Page_98)
98. [99](#c06.xhtml#Page_99)
99. [100](#c06.xhtml#Page_100)
100. [101](#c06.xhtml#Page_101)
101. [102](#c06.xhtml#Page_102)
102. [103](#c06.xhtml#Page_103)
103. [104](#c06.xhtml#Page_104)
104. [105](#c06.xhtml#Page_105)
105. [106](#c06.xhtml#Page_106)
106. [107](#c06.xhtml#Page_107)
107. [108](#c06.xhtml#Page_108)
108. [109](#c06.xhtml#Page_109)
109. [110](#c06.xhtml#Page_110)
110. [111](#c06.xhtml#Page_111)
111. [112](#c06.xhtml#Page_112)
112. [113](#c06.xhtml#Page_113)
113. [114](#c06.xhtml#Page_114)
114. [115](#c06.xhtml#Page_115)
115. [116](#c06.xhtml#Page_116)
116. [117](#c06.xhtml#Page_117)
117. [118](#c06.xhtml#Page_118)
118. [119](#c07.xhtml#Page_119)
119. [120](#c07.xhtml#Page_120)
120. [121](#c07.xhtml#Page_121)
121. [122](#c07.xhtml#Page_122)
122. [123](#c07.xhtml#Page_123)
123. [124](#c07.xhtml#Page_124)
124. [125](#c07.xhtml#Page_125)
125. [126](#c07.xhtml#Page_126)
126. [127](#c07.xhtml#Page_127)
127. [128](#c07.xhtml#Page_128)
128. [129](#c07.xhtml#Page_129)
129. [130](#c07.xhtml#Page_130)
130. [131](#c07.xhtml#Page_131)
131. [132](#c07.xhtml#Page_132)
132. [133](#c07.xhtml#Page_133)
133. [134](#c07.xhtml#Page_134)
134. [135](#c07.xhtml#Page_135)
135. [136](#c07.xhtml#Page_136)
136. [137](#c07.xhtml#Page_137)
137. [138](#c07.xhtml#Page_138)
138. [139](#c07.xhtml#Page_139)
139. [140](#c07.xhtml#Page_140)
140. [141](#c07.xhtml#Page_141)
141. [142](#c07.xhtml#Page_142)
142. [143](#c07.xhtml#Page_143)
143. [144](#c07.xhtml#Page_144)
144. [145](#c07.xhtml#Page_145)
145. [146](#c07.xhtml#Page_146)
146. [147](#c07.xhtml#Page_147)
147. [148](#c07.xhtml#Page_148)
148. [149](#c07.xhtml#Page_149)
149. [150](#c07.xhtml#Page_150)
150. [151](#c07.xhtml#Page_151)
151. [152](#c07.xhtml#Page_152)
152. [153](#c07.xhtml#Page_153)
153. [154](#c07.xhtml#Page_154)
154. [155](#c07.xhtml#Page_155)
155. [156](#c07.xhtml#Page_156)
156. [157](#c07.xhtml#Page_157)
157. [159](#p03.xhtml#Page_159)
158. [160](#p03.xhtml#Page_160)
159. [161](#c08.xhtml#Page_161)
160. [162](#c08.xhtml#Page_162)
161. [163](#c08.xhtml#Page_163)
162. [164](#c08.xhtml#Page_164)
163. [165](#c08.xhtml#Page_165)
164. [166](#c08.xhtml#Page_166)
165. [167](#c08.xhtml#Page_167)
166. [168](#c08.xhtml#Page_168)
167. [169](#c08.xhtml#Page_169)
168. [170](#c08.xhtml#Page_170)
169. [171](#c08.xhtml#Page_171)
170. [172](#c08.xhtml#Page_172)
171. [173](#c08.xhtml#Page_173)
172. [174](#c08.xhtml#Page_174)
173. [175](#c08.xhtml#Page_175)
174. [176](#c08.xhtml#Page_176)
175. [177](#c09.xhtml#Page_177)
176. [178](#c09.xhtml#Page_178)
177. [179](#c09.xhtml#Page_179)
178. [180](#c09.xhtml#Page_180)
179. [181](#c09.xhtml#Page_181)
180. [182](#c09.xhtml#Page_182)
181. [183](#c09.xhtml#Page_183)
182. [184](#c09.xhtml#Page_184)
183. [185](#c09.xhtml#Page_185)
184. [186](#c09.xhtml#Page_186)
185. [187](#c09.xhtml#Page_187)
186. [188](#c09.xhtml#Page_188)
187. [189](#c09.xhtml#Page_189)
188. [190](#c09.xhtml#Page_190)
189. [191](#c09.xhtml#Page_191)
190. [192](#c09.xhtml#Page_192)
191. [193](#c09.xhtml#Page_193)
192. [194](#c09.xhtml#Page_194)
193. [195](#c09.xhtml#Page_195)
194. [196](#c09.xhtml#Page_196)
195. [197](#c09.xhtml#Page_197)
196. [198](#c09.xhtml#Page_198)
197. [199](#c09.xhtml#Page_199)
198. [200](#c09.xhtml#Page_200)
199. [201](#c09.xhtml#Page_201)
200. [202](#c09.xhtml#Page_202)
201. [203](#c09.xhtml#Page_203)
202. [204](#c09.xhtml#Page_204)
203. [205](#c10.xhtml#Page_205)
204. [206](#c10.xhtml#Page_206)
205. [207](#c10.xhtml#Page_207)
206. [208](#c10.xhtml#Page_208)
207. [209](#c10.xhtml#Page_209)
208. [210](#c10.xhtml#Page_210)
209. [211](#c10.xhtml#Page_211)
210. [212](#c10.xhtml#Page_212)
211. [213](#c10.xhtml#Page_213)
212. [214](#c10.xhtml#Page_214)
213. [215](#c10.xhtml#Page_215)
214. [216](#c10.xhtml#Page_216)
215. [217](#c10.xhtml#Page_217)
216. [218](#c10.xhtml#Page_218)
217. [219](#c10.xhtml#Page_219)
218. [220](#c10.xhtml#Page_220)
219. [221](#c10.xhtml#Page_221)
220. [222](#c10.xhtml#Page_222)
221. [223](#c10.xhtml#Page_223)
222. [224](#c10.xhtml#Page_224)
223. [225](#c10.xhtml#Page_225)
224. [226](#c10.xhtml#Page_226)
225. [227](#c10.xhtml#Page_227)
226. [228](#c10.xhtml#Page_228)
227. [229](#c10.xhtml#Page_229)
228. [230](#c10.xhtml#Page_230)
229. [231](#c10.xhtml#Page_231)
230. [232](#c10.xhtml#Page_232)
231. [233](#c10.xhtml#Page_233)
232. [234](#c10.xhtml#Page_234)
233. [235](#c10.xhtml#Page_235)
234. [236](#c10.xhtml#Page_236)
235. [237](#c11.xhtml#Page_237)
236. [238](#c11.xhtml#Page_238)
237. [239](#c11.xhtml#Page_239)
238. [240](#c11.xhtml#Page_240)
239. [241](#c11.xhtml#Page_241)
240. [242](#c11.xhtml#Page_242)
241. [243](#c11.xhtml#Page_243)
242. [244](#c11.xhtml#Page_244)
243. [245](#c11.xhtml#Page_245)
244. [246](#c11.xhtml#Page_246)
245. [247](#c11.xhtml#Page_247)
246. [248](#c11.xhtml#Page_248)
247. [249](#c11.xhtml#Page_249)
248. [250](#c11.xhtml#Page_250)
249. [251](#c11.xhtml#Page_251)
250. [252](#c11.xhtml#Page_252)
251. [253](#c11.xhtml#Page_253)
252. [254](#c11.xhtml#Page_254)
253. [255](#c11.xhtml#Page_255)
254. [256](#c11.xhtml#Page_256)
255. [257](#c11.xhtml#Page_257)
256. [258](#c11.xhtml#Page_258)
257. [259](#c11.xhtml#Page_259)
258. [260](#c11.xhtml#Page_260)
259. [261](#c11.xhtml#Page_261)
260. [262](#c11.xhtml#Page_262)
261. [263](#c11.xhtml#Page_263)
262. [264](#c11.xhtml#Page_264)
263. [265](#c11.xhtml#Page_265)
264. [266](#c11.xhtml#Page_266)
265. [267](#c11.xhtml#Page_267)
266. [268](#c11.xhtml#Page_268)
267. [269](#c11.xhtml#Page_269)
268. [270](#c11.xhtml#Page_270)
269. [271](#c11.xhtml#Page_271)
270. [272](#c11.xhtml#Page_272)
271. [273](#c11.xhtml#Page_273)
272. [274](#c11.xhtml#Page_274)
273. [275](#c11.xhtml#Page_275)
274. [276](#c11.xhtml#Page_276)
275. [277](#c11.xhtml#Page_277)
276. [278](#c11.xhtml#Page_278)
277. [279](#c11.xhtml#Page_279)
278. [280](#c11.xhtml#Page_280)
279. [281](#c11.xhtml#Page_281)
280. [282](#c11.xhtml#Page_282)
281. [283](#c11.xhtml#Page_283)
282. [284](#c11.xhtml#Page_284)
283. [285](#c12.xhtml#Page_285)
284. [286](#c12.xhtml#Page_286)
285. [287](#c12.xhtml#Page_287)
286. [288](#c12.xhtml#Page_288)
287. [289](#c12.xhtml#Page_289)
288. [290](#c12.xhtml#Page_290)
289. [291](#c12.xhtml#Page_291)
290. [292](#c12.xhtml#Page_292)
291. [293](#c12.xhtml#Page_293)
292. [294](#c12.xhtml#Page_294)
293. [295](#c12.xhtml#Page_295)
294. [296](#c12.xhtml#Page_296)
295. [297](#c12.xhtml#Page_297)
296. [298](#c12.xhtml#Page_298)
297. [299](#c12.xhtml#Page_299)
298. [300](#c12.xhtml#Page_300)
299. [301](#c12.xhtml#Page_301)
300. [302](#c12.xhtml#Page_302)
301. [303](#p04.xhtml#Page_303)
302. [304](#p04.xhtml#Page_304)
303. [305](#c13.xhtml#Page_305)
304. [306](#c13.xhtml#Page_306)
305. [307](#c13.xhtml#Page_307)
306. [308](#c13.xhtml#Page_308)
307. [309](#c13.xhtml#Page_309)
308. [310](#c13.xhtml#Page_310)
309. [311](#c13.xhtml#Page_311)
310. [312](#c13.xhtml#Page_312)
311. [313](#c13.xhtml#Page_313)
312. [314](#c13.xhtml#Page_314)
313. [315](#c13.xhtml#Page_315)
314. [316](#c13.xhtml#Page_316)
315. [317](#c13.xhtml#Page_317)
316. [318](#c13.xhtml#Page_318)
317. [319](#c13.xhtml#Page_319)
318. [320](#c13.xhtml#Page_320)
319. [321](#c13.xhtml#Page_321)
320. [322](#c13.xhtml#Page_322)
321. [323](#c14.xhtml#Page_323)
322. [324](#c14.xhtml#Page_324)
323. [325](#c14.xhtml#Page_325)
324. [326](#c14.xhtml#Page_326)
325. [327](#c14.xhtml#Page_327)
326. [328](#c14.xhtml#Page_328)
327. [329](#c14.xhtml#Page_329)
328. [330](#c14.xhtml#Page_330)
329. [331](#c14.xhtml#Page_331)
330. [332](#c14.xhtml#Page_332)
331. [333](#c14.xhtml#Page_333)
332. [334](#c14.xhtml#Page_334)
333. [335](#c14.xhtml#Page_335)
334. [336](#c14.xhtml#Page_336)
335. [337](#c14.xhtml#Page_337)
336. [338](#c14.xhtml#Page_338)
337. [339](#c14.xhtml#Page_339)
338. [340](#c14.xhtml#Page_340)
339. [341](#c14.xhtml#Page_341)
340. [342](#c14.xhtml#Page_342)
341. [343](#c14.xhtml#Page_343)
342. [344](#c14.xhtml#Page_344)
343. [345](#c14.xhtml#Page_345)
344. [346](#c14.xhtml#Page_346)
345. [347](#c14.xhtml#Page_347)
346. [348](#c14.xhtml#Page_348)
347. [349](#c14.xhtml#Page_349)
348. [350](#c14.xhtml#Page_350)
349. [351](#c14.xhtml#Page_351)
350. [352](#c14.xhtml#Page_352)
351. [353](#c14.xhtml#Page_353)
352. [354](#c14.xhtml#Page_354)
353. [355](#c14.xhtml#Page_355)
354. [356](#c14.xhtml#Page_356)
355. [357](#p05.xhtml#Page_357)
356. [358](#p05.xhtml#Page_358)
357. [359](#c15.xhtml#Page_359)
358. [360](#c15.xhtml#Page_360)
359. [361](#c15.xhtml#Page_361)
360. [362](#c15.xhtml#Page_362)
361. [363](#c16.xhtml#Page_363)
362. [364](#c16.xhtml#Page_364)
363. [365](#c16.xhtml#Page_365)
364. [366](#c16.xhtml#Page_366)
365. [367](#b02.xhtml#Page_367)
366. [368](#b02.xhtml#Page_368)
367. [369](#b02.xhtml#Page_369)
368. [370](#b02.xhtml#Page_370)
369. [371](#b02.xhtml#Page_371)
370. [372](#b02.xhtml#Page_372)
371. [373](#b02.xhtml#Page_373)
372. [374](#b02.xhtml#Page_374)
373. [375](#b02.xhtml#Page_375)
374. [376](#b02.xhtml#Page_376)
375. [377](#b02.xhtml#Page_377)
376. [378](#b02.xhtml#Page_378)
377. [379](#b02.xhtml#Page_379)
378. [380](#b02.xhtml#Page_380)
379. [381](#b02.xhtml#Page_381)
380. [382](#b02.xhtml#Page_382)
381. [383](#b02.xhtml#Page_383)
382. [384](#b02.xhtml#Page_384)
383. [385](#b01.xhtml#Page_385)
384. [386](#b01.xhtml#Page_386)

```{=html}
</nav>
```
[]{#f02.xhtml}

::: {.section .foreword role="doc-foreword"}
# []{#f02.xhtml#Page_xiii .pagebreak role="doc-pagebreak" title="xiii"}[]{#f02.xhtml#Foreword}Foreword {.Chap-Title}

::: {.section}
[]{#f02.xhtml#Flast-sec-0001}

The moment a *For Dummies* book comes out, it\'s definitely a milestone in the history of a product.

Programming embedded computers used to be a very difficult task, reserved only to experienced engineers willing to master the obscure assembly language. In recent years, however, many platforms have tried to make this task simpler and more accessible to everyday people. Arduino is one of the latest attempts at making technology less scary and more creative.

With John, this book's author, we watched this creative tool being adopted by designers and artists in London, making its way into many memorable projects. Now Arduino has escaped the lab of Arts & Design and spread like a virus, becoming the tool of choice for all kinds of people who have great ideas they want to realize.

I\'m really glad that John decided to write this book, because he\'s an early user of the Arduino platform from back in the days when it was still quite experimental. Having taught Arduino classes for many years, he has the ability to introduce the subject to all audiences.

Any newcomer to Arduino will, with the right tools and teaching --- such as those found in this book --- show true genius in no time.

--- Massimo Banzi
:::
:::

[]{#c00.xhtml}

::: {.section .introduction role="doc-introduction"}
# []{#c00.xhtml#Page_1 .pagebreak role="doc-pagebreak" title="1"}[]{#c00.xhtml#introduction}Introduction {.Chap-Title}

::: {.section}
[]{#c00.xhtml#i01-sec-0001}

Arduino is a tool, a community, and a way of thinking that is affecting how we use and understand technology. It has rekindled a love and understanding of electronics for many people, including myself, who felt that electronics was something that they had left behind at school.

Arduino is tiny circuit board that has huge potential. It can be used to blink a Morse-code signal using a single light-emitting diode (LED) or to control every light in a building, depending on how far you take it. Its capabilities are limited only by your imagination.

Arduino is also providing a new, practical approach to technical education, lowering the entry level for those wanting to use electronics to complete small projects and, I hope, encouraging you to read further to take on big ones.

A huge and ever-growing community of Arduinists has emerged --- users and developers who learn from each other and contribute to the open-source philosophy by sharing the details of their projects. This open-source attitude is responsible for the huge popularity of Arduino.

Arduino is more than just a gadget; it's a tool. A piece of technology that makes understanding and using today's technology easier.

So if the prospect of understanding the limitless possibilities of technology doesn't sound interesting to you, please put this book down and back away.

Otherwise, read on!
:::

::: {.section}
[]{#c00.xhtml#i01-sec-0002}

## About This Book {#c00.xhtml#h2-1 .Heading-1}

This is a technical book, but it's not for technical people only. Arduino is designed to be usable by anyone, whether they're technical, creative, crafty, or just curious. All you need is an open mind or a problem to fix and you'll soon find ways that using Arduino can benefit you.

[]{#c00.xhtml#Page_2 .pagebreak role="doc-pagebreak" title="2"}This book starts on the most basic level to get you started with using and understanding Arduino. At times throughout the book, I may refer to a number of technical things that will, like anything, take time to understand. I guide you through all the basics and then on to more advanced activities.

Much of what is in this book is based on my learning and teaching experiences. I learned all about Arduino from scratch, but have always found that the best way to learn is in practice, by making your own projects. The key is to understand the basics that I cover in this book and then build on that knowledge by thinking about how you can apply it to solve problems, create things, or just entertain yourself.
:::

::: {.section}
[]{#c00.xhtml#i01-sec-0003}

## Foolish Assumptions {#c00.xhtml#h2-2 .Heading-1}

I assume nothing about your technical knowledge. Arduino is an easy-to-use platform for learning about electronics and programming. It is for people from all walks of life, whether you're a designer, an artist, or a hobbyist.

It can also be a great platform for people who are already technical. Maybe you've done a bit of coding but want to bring your projects into the physical world in some way. Or maybe you've worked with electronics and want to see what Arduino can bring to the table.

Whoever you are, you'll find that Arduino has great potential. It's really up to you to decide what to make of it.
:::

::: {.section}
[]{#c00.xhtml#i01-sec-0004}

## Icons Used in This Book {#c00.xhtml#h2-3 .Heading-1}

*Arduino For Dummies* uses icons to highlight important points for you. Keep an eye out for the following:

![tip.png](https://i.imgur.com/sTqVTIC.jpeg) This icon highlights a bit of helpful information. That info may be a technique to help you complete a project more easily or the answer to a common problem.

![warning.png](https://i.imgur.com/GbqBQGY.jpeg) Arduinos aren't dangerous on their own; indeed, they're made to be extremely safe and easy to use. But if you use them in a circuit without proper planning as well as care and attention, they can damage your circuit, your computer, and yourself. When you see a Warning icon, please take special note.

[]{#c00.xhtml#Page_3 .pagebreak role="doc-pagebreak" title="3"}![remember.png](https://i.imgur.com/gHT2Fcr.jpeg) Often, you must consider certain points before proceeding with a task. I use Remember icons to remind you of such points.

![technicalstuff.png](https://i.imgur.com/5tapFZY.jpeg) Some information is more technical than others and is not for the faint-hearted. The joy of Arduino is that you don't need to fully understand the technical details immediately. You can skip anything that's marked with this icon if it's more complicated than you want to deal with at the moment; you can always return to it when you're ready.
:::

::: {.section}
[]{#c00.xhtml#i01-sec-0005}

## Beyond the Book {#c00.xhtml#h2-4 .Heading-1}

In addition to what you're reading right now, this product comes with a free access-anywhere Cheat Sheet that provides information on using resistors, getting the tools you\'ll need, and some system shortcuts. To get this Cheat Sheet, simply go to [[`www.dummies.com`]{.Code-within-text}](http://www.dummies.com) and type *Arduino For Dummies 2nd Edition Cheat Sheet* in the Search box. I also provide a bonus chapter that teaches you all about using your Arduino to hack other hardware, such as games, controllers, and toys.
:::

::: {.section}
[]{#c00.xhtml#i01-sec-0006}

## Where to Go from Here {#c00.xhtml#h2-5 .Heading-1}

If you're uncertain about where to start, I suggest the beginning. By the end of [Chapter 2](#c02.xhtml), you'll have acquired a simple understanding of Arduino and will know where you can get a kit to continue learning.

If you've used Arduino before, you may want to jump straight to [Chapter 4](#c04.xhtml) to cover the basics again, or head straight to the area that interests you.
:::
:::

[]{#p01.xhtml}

::: {.section}
[]{#p01.xhtml#Page_5 .pagebreak role="doc-pagebreak" title="5"}Part 1

# Getting to Know Arduino {#p01.xhtml#a1 .Part-Title}

::: {.section}
[]{#p01.xhtml#p01-sec-0001}

[]{#p01.xhtml#Page_6 .pagebreak role="doc-pagebreak" title="6"}IN THIS PART ...

Find out all about the little blue circuit board.

Discover everything you need to get started with Arduino and where to get them.

Learn how to wield the awesome power of an LED, blinking in on command with a few simple lines of code.
:::
:::

[]{#c01.xhtml}

[]{#c01.xhtml#Page_7 .pagebreak role="doc-pagebreak" title="7"}Chapter 1

# Discovering Arduino {#c01.xhtml#a1 .Chap-Title}

::: {.section}
[]{#c01.xhtml#c01-sec-0001}[]{#c01.xhtml#c01-feafxd-0001}

IN THIS CHAPTER

![check.png](https://i.imgur.com/8v55cgT.jpeg) **Discovering what Arduino is**

![check.png](https://i.imgur.com/6p3jYpD.jpeg) **Learning where Arduino came from**

![check.png](https://i.imgur.com/dtdlTCp.jpeg) **Introducing the basic principles**

Arduino is made up of both hardware and software.

The Arduino board is a printed circuit board (PCB) designed to use a microcontroller chip as well as other input and outputs. The board has many other electronic components that are needed for the microcontroller to function or to extend its capabilities.

*A microcontroller* is a small computer contained in a single, integrated circuit or computer chip. Microcontrollers are an excellent way to program and control electronics. *Microcontroller boards* have a microcontroller chip and other useful connectors and components that allow a user to attach inputs and outputs. Some examples of devices with microcontroller boards are the Wiring board, the PIC, and the Basic Stamp.

You write code in the Arduino software to tell the microcontroller what to to-do. For example, by writing a line of code, you can tell an light-emitting diode (LED) to blink on and off. If you connect a pushbutton and add another line of code, you can tell the LED to turn on only when the button is pressed. Next, you may want to tell the LED to blink only when the pushbutton is held down. In this way, you can quickly build a behavior for a system that would be difficult to achieve without a microcontroller.

[]{#c01.xhtml#Page_8 .pagebreak role="doc-pagebreak" title="8"}Similar to a conventional computer, an Arduino can perform a multitude of functions, but it's not much use on its own. It requires inputs or outputs to make it useful. These inputs and outputs allow a computer --- and an Arduino --- to sense objects in the world and to affect the world.

Before you move forward, it might help you to understand a bit of the history of Arduino.
:::

::: {.section}
[]{#c01.xhtml#c01-sec-0002}

## Where Did Arduino Come From? {#c01.xhtml#h2-1 .Heading-1}

Arduino started its life in Italy, at Interaction Design Institute Ivrea (IDII), a graduate school for interaction design that focuses on how people interact with digital products, systems, and environments and how they in turn influence us.

The term *interaction design* was coined by Bill Verplank and Bill Moggridge in the mid-1980s. The sketch in [Figure 1-1](#c01.xhtml#c01-fig-0001){#c01.xhtml#rc01-fig-0001} by Verplank illustrates the basic premise of interaction design: If you do something, you feel a change, and from that you can know something about the world.

::: {#c01.xhtml#c01-fig-0001 .figure}
![9781119489542-fg0101.png](https://i.imgur.com/xUpbgHV.jpeg){.center}
:::

Although interaction design is a general principle, it more commonly refers specifically to how we interact with conventional computers by using peripherals (such as mice, keyboards, and touchscreens) to navigate a digital environment that is graphically displayed on a screen.

Another avenue, referred to as *physical computing,* is about extending the range of these computer programs, software, or systems through electronics. By using electronics, computers can sense more about the world and have a physical effect on the world themselves.

Both areas --- interaction design and physical computing --- require prototypes to fully understand and explore the interactions, which presented a hurdle for non-technical design students.

In 2001, a project called Processing, started by Casey Reas and Benjamin Fry, aimed to get non-programmers into programming by making it quick and easy to produce onscreen visualizations and graphics. The project gave the user a digital sketchbook on which to try ideas and experiment with a small investment of time. This project in turn inspired a similar project for experimenting in the physical world.

In 2003, building on the same principles as Processing, Hernando Barragán started developing a microcontroller board called Wiring. This board was the predecessor to Arduino.

In common with the Processing project, the Wiring project also aimed to involve artists, designers, and other non-technical people. However, Wiring was designed to get people into electronics as well as programming. The Wiring board (shown in [Figure 1-2](#c01.xhtml#c01-fig-0002){#c01.xhtml#rc01-fig-0002}) was less expensive than some other microcontrollers, such as the PIC and the Basic Stamp, but it was still a sizable investment for students.

::: {#c01.xhtml#c01-fig-0002 .figure}
![9781119489542-fg0102.png](https://i.imgur.com/Pb4NC0n.jpeg){.center}
:::

In 2005, the Arduino project began in response to the need for affordable and easy-to-use devices for interaction design students to use in their projects. It is said that Massimo Banzi and David Cuartielles named the project after Arduin of Ivrea, an Italian king, but I've heard from reliable sources that it also happens to be the name of the local pub near the university, which may have been of more significance to the project.

The Arduino project drew from many of the experiences of both Wiring and Processing. For example, an obvious influence from Processing is the *graphic user interface* (GUI) in the Arduino software. This GUI was initially "borrowed" from Processing, and even though it still looks similar, it has since been refined to be more specific to Arduino. I cover the Arduino interface in more depth in [Chapter 3](#c03.xhtml).

[]{#c01.xhtml#Page_10 .pagebreak role="doc-pagebreak" title="10"}Arduino also kept the naming convention from Processing, calling its programs *sketches.* In the same way that Processing gives people a digital sketchbook to create and test programs quickly, Arduino gives people a way to sketch their hardware ideas as well. Throughout this book, I show many sketches that allow your Arduino to perform a huge variety of tasks. By using and editing the example sketches in this book, you can quickly build up your understanding of how they work. You\'ll be writing your own in no time. Each sketch is followed with a line-by-line explanation of how it works to ensure that no stone is left unturned.

The Arduino board, shown in [Figure 1-3](#c01.xhtml#c01-fig-0003){#c01.xhtml#rc01-fig-0003}, was made to be more robust and forgiving than Wiring and other earlier microcontrollers. It was not uncommon for students, especially those from a design or arts background, to break their microcontroller within minutes of using it, simply by getting the wires the wrong way around. This fragility was a huge problem, not only financially but also for the success of the boards outside technical circles. You can also change the microcontroller chip on an Arduino; if the chip becomes damaged, you can replace just it rather than the entire board.

::: {#c01.xhtml#c01-fig-0003 .figure}
![9781119489542-fg0103.png](https://i.imgur.com/tO7cPKo.jpeg){.center}
:::

Another important difference between Arduino and other microcontroller boards is the cost. Back in 2006, another popular microcontroller, the Basic Stamp, cost nearly four times as much (\$119) as an Arduino (\$32). Today, an Arduino Uno costs just \$22.

[]{#c01.xhtml#Page_11 .pagebreak role="doc-pagebreak" title="11"}In one of my first Arduino workshops, I was told that the price was intended to be affordable for students. The price of a nice meal and a glass of wine at that time was about \$42, so if you had a project deadline, you could choose to skip a nice meal that week and make your project instead.

The range of Arduino boards on the market is a lot bigger than it was back in 2006. In [Chapter 2](#c02.xhtml), you learn about just a few of the most useful Arduino and Arduino-compatible boards and how they differ to provide you with a variety of solutions for your own projects. Also, in [Chapter 12](#c12.xhtml), you learn all about a special type of circuit board called a *shield,* which can add useful, and in some cases phenomenal, features to your Arduino, turning it into a GPS (Global Positioning System) receiver, a mobile phone, or even a Geiger counter, to name just a few.
:::

::: {.section}
[]{#c01.xhtml#c01-sec-0003}

## Learning by Doing {#c01.xhtml#h2-2 .Heading-1}

People have used technology in many ways to achieve their own goals without needing to delve into the details of electronics. Following are just a few related schools of thought that have allowed people to play with electronics.

::: {.section}
[]{#c01.xhtml#Page_12 .pagebreak role="doc-pagebreak" title="12"}[]{#c01.xhtml#c01-sec-0004}

### Patching {#c01.xhtml#h3-1 .Heading-2}

*Patching* is a technique for experimenting with systems using wires. The earliest popular example of patching is in phone switchboards. For an operator to put you through to another line, he or she had to physically attach a cable.

This technique was also popular for synthesizing music, such as with the Moog synthesizer. When an electronic instrument generates a sound, it\'s really generating a voltage. Different collections of components in the instrument manipulate that voltage before it is outputted as an audible sound. The Moog synthesizer works by changing the path that that voltage takes, sending it through a number of different components to apply different effects.

Because so many combinations are possible, the musician proceeds largely through trial and error. But the simple interface means that this process is extremely quick and requires little preparation to get going.
:::

::: {.section}
[]{#c01.xhtml#c01-sec-0005}

### Hacking {#c01.xhtml#h3-2 .Heading-2}

*Hacking* is a term that typically refers to the subversive use of technology. More generally, though, it refers to exploring systems and making full use of them or repurposing them to suit your needs.

Hacking in this sense is possible in hardware as well as software. A great example of hardware hacking is a keyboard hack. Say that you want to use a big red button to move through a slideshow. Most software programs contain keyboard shortcuts, and most PDF viewers move to the next page in a slideshow when the user presses the spacebar. If you know this, you ideally want a keyboard with only a spacebar.

Today\'s keyboards have a small circuit board, a bit smaller than a credit card (see [Figure 1-4](#c01.xhtml#c01-fig-0004){#c01.xhtml#rc01-fig-0004}), containing lots of contacts that are connected when you press different keys. If you can find the correct combination, you can connect two contacts by using a pushbutton. Now every time you press that button, you send a space to your computer.

::: {#c01.xhtml#c01-fig-0004 .figure}
![9781119489542-fg0104.png](https://i.imgur.com/g7PHB4b.jpeg){.center}
:::

This technique is great for sidestepping the intricacies of hardware and getting the results you want. In the "Hacking Other Hardware" bonus chapter ([[`www.dummies.com/go/arduinofd`]{.Code-within-text}](http://www.dummies.com/go/arduinofd)), you learn more about the joy of hacking and how you can weave hacked pieces of hardware into your Arduino project to control remote devices, cameras, and even computers with ease.
:::

::: {.section}
[]{#c01.xhtml#Page_13 .pagebreak role="doc-pagebreak" title="13"}[]{#c01.xhtml#c01-sec-0006}

### Circuit bending {#c01.xhtml#h3-3 .Heading-2}

*Circuit bending* flies in the face of traditional education and is all about spontaneous experimentation. Children\'s toys are the staple diet of circuit benders, but really any electronic device has the potential to be experimented with.

By opening a toy or device and revealing the circuitry, you can alter the path of the current to affect its behavior. Although this technique is similar to patching, it\'s a lot more unpredictable. However, after you find a combination that produces a pleasing result, you can add or replace components, such as resistors or switches, to give the user more control over the instrument.

Most commonly, circuit bending is about sound, and the finished instrument becomes a rudimentary synthesizer or drum machine. Two of the most popular devices are the Speak & Spell (see [Figure 1-5](#c01.xhtml#c01-fig-0005){#c01.xhtml#rc01-fig-0005}) and the Nintendo GameBoy. Musicians such as the Modified Toy Orchestra ([[`modifiedtoyorchestra.com`]{.Code-within-text}](http://modifiedtoyorchestra.com/)), in their own words, "explore the hidden potential and surplus value latent inside redundant technology." So think twice before putting your old toys on eBay!

::: {#c01.xhtml#c01-fig-0005 .figure}
![9781119489542-fg0105.png](https://i.imgur.com/HO2hKWH.jpeg){.center}
:::
:::
:::

::: {.section}
[]{#c01.xhtml#c01-sec-0007}

## Electronics {#c01.xhtml#h2-3 .Heading-1}

Although there are many ways to work around technology, eventually you'll want more of everything: more precision, more complexity, and more control.

If you learned about electronics at school, you were most likely taught how to build circuits using specific components. These circuits are based solely on the chemical properties of the components and need to be calculated in detail to make sure that the correct amount of current is going to the correct components.

These are the kind of circuits you find as kits at Radio Shack (or Maplin, in the United Kingdom) that do a specific job, such as an egg timer or a security buzzer that goes off when you open a cookie jar. These kits are good at their specific job, but they can't do much else.

This is where microcontrollers come in. When used with analog circuitry, microcontrollers can give that circuitry a more advanced behavior. They can also be reprogrammed to perform different functions as needed. Your Arduino is designed around one of these microcontrollers, and in [Chapter 2](#c02.xhtml), you look closely at an Arduino Uno to see exactly how it is designed and what it is capable of.

The microcontroller is the brains of a system, but it needs other electronic inputs and outputs to either sense or affect things in its environment.

::: {.section}
[]{#c01.xhtml#Page_15 .pagebreak role="doc-pagebreak" title="15"}[]{#c01.xhtml#c01-sec-0008}

### Inputs {#c01.xhtml#h3-4 .Heading-2}

*Inputs* are senses for your Arduino. They tell it what is going on in the world. At its most basic, an input could be a switch, such as a light switch in your home. At the other end of the spectrum, it could be a gyroscope, telling the Arduino the exact direction it's facing in three dimensions. You learn all about basic inputs in [Chapter 6](#c06.xhtml), and more about the variety of sensors and when to use them in [Chapter 11](#c11.xhtml).
:::

::: {.section}
[]{#c01.xhtml#c01-sec-0009}

### Outputs {#c01.xhtml#h3-5 .Heading-2}

*Outputs* allow your Arduino to affect the real world in some way. An output could be subtle and discreet, such as in the vibration of a cellphone, or it could be a huge visual display on the side of a building that can be seen for miles around. The first sketch in the book walks you through blinking an LED (see [Chapter 3](#c03.xhtml)). From there, you can go on to controlling an electric motor ([Chapter 7](#c07.xhtml)) and even controlling an LCD screen ([Chapter 12](#c12.xhtml)).
:::
:::

::: {.section}
[]{#c01.xhtml#c01-sec-0010}

## Open Source {#c01.xhtml#h2-4 .Heading-1}

Open source software, in particular Processing, has had a huge influence on Arduino development. In the world of computer software, *open source* is a philosophy in which people share the details of a program and encourage others to use, remix, and redistribute it, as they like.

Just as the Processing software is open source, so are Arduino software and hardware. This means that the Arduino software and hardware are both released freely to be adapted as needed. You find the same spirit of openness also amongst the community on the Arduino forums.

On the official Arduino forums ([[`http://forum.arduino.cc/`]{.Code-within-text}](http://forum.arduino.cc/)) and many other ones around the world, people have shared their code, projects, and questions for an informal peer review. This sharing allows all sorts of people, including experienced engineers, talented developers, practiced designers, and innovative artists, to lend their expertise to novices in some or all of these areas. It also provides a means to gauge people's areas of interest, which occasionally filters into the official release of Arduino software or board design with refinements or additions. The Arduino website has an area known as the Playground ([[`playground.arduino.cc/`]{.Code-within-text}](http://playground.arduino.cc/)), where people are free to upload their code for the community to use, share, and edit.

[]{#c01.xhtml#Page_16 .pagebreak role="doc-pagebreak" title="16"}This kind of philosophy has encouraged the relatively small community to pool knowledge on forums, blogs, and websites, thereby creating a vast resource for new Arduinists to tap into.

Despite the open-source nature of Arduino, a huge loyalty to Arduino as a brand exists --- so much so that there is an Arduino naming convention of adding *-duino* or *-ino* to the name of boards and accessories (much to the disgust of Italian members of the Arduino team)!
:::

[]{#c02.xhtml}

[]{#c02.xhtml#Page_17 .pagebreak role="doc-pagebreak" title="17"}Chapter 2

# Finding Your Board and Your Way Around It {#c02.xhtml#a1 .Chap-Title}

::: {.section}
[]{#c02.xhtml#c02-sec-0001}[]{#c02.xhtml#c02-feafxd-0001}

IN THIS CHAPTER

![check.png](https://i.imgur.com/PpSztJh.jpeg) **Inspecting the Arduino Uno**

![check.png](https://i.imgur.com/VYNI4Gd.jpeg) **Discovering other Arduino boards**

![check.png](https://i.imgur.com/d38WtJa.jpeg) **Knowing where to shop for Arduinos**

![check.png](https://i.imgur.com/FZ6QST7.jpeg) **Finding the right Arduino kit to get started**

![check.png](https://i.imgur.com/qPlg764.jpeg) **Setting up a workspace**

![check.png](https://i.imgur.com/LwX4bLU.jpeg) **Installing Arduino**

![check.png](https://i.imgur.com/IE2BQgA.jpeg) **Introducing Arduino Web Editor**

The name *Arduino* encompasses a host of concepts. It can refer to an Arduino board, the physical hardware, the Arduino environment --- that is, a piece of software that runs on your computer --- and, finally, Arduino as a subject in its own right, as in this book: how the hardware and software can be combined with related craft and electronics knowledge to create a tool kit for any situation.

This chapter provides an overview of what you need to get started with Arduino. You may be eager to dive in, so you may want to quickly scan through this chapter, stopping at any areas of uncertainty and referring to them later as needed.

First, you learn about the components used on the Arduino Uno board, which is the starting point for most Arduinists. Beyond that, you get acquainted with the other available Arduino boards, how they differ, and what uses they have. The chapter lists major suppliers that can equip you with all the parts you need and examines some of the starter kits that are ideal for beginners and for accompanying this book. When you have the kit and a workspace, you're ready to start.

[]{#c02.xhtml#Page_18 .pagebreak role="doc-pagebreak" title="18"}Lastly, you find out where to obtain the software to control your Arduino. I walk you through the steps for downloading and installing the software, and give you a brief tour of the environment in which you develop your Arduino programs.
:::

::: {.section}
[]{#c02.xhtml#c02-sec-0002}

## Getting to Know the Arduino Uno {#c02.xhtml#h2-1 .Heading-1}

No one definitive Arduino board exists; many types of Arduino boards are available, each with its own design to suit various applications. Deciding what board to use can be a daunting prospect because the number of boards is increasing, each with new and exciting prospects. However, one board can be considered the archetype of the Arduino hardware, the one that almost all people start with and that is suitable for most applications. It's the Arduino Uno.

The most recent main board to date is the Arduino Uno R3 (released in 2011). Think of it as the plain vanilla of Arduino boards. It's a good and reliable workhorse suitable for a variety of projects. If you\'re just starting out, the Uno R3 is the board for you (see [Figures 2-1](#c02.xhtml#c02-fig-0001){#c02.xhtml#rc02-fig-0001} and [2-2](#c02.xhtml#c02-fig-0002){#c02.xhtml#rc02-fig-0002}).

::: {#c02.xhtml#c02-fig-0001 .figure}
![9781119489542-fg0201.png](https://i.imgur.com/mEcMkFL.jpeg){.center}
:::

::: {#c02.xhtml#c02-fig-0002 .figure}
![9781119489542-fg0202.png](https://i.imgur.com/O24xc95.jpeg){.center}
:::

*Uno* is Italian for the number one, named for the release of version 1.0 of the Arduino software. Predecessors to this release had a variety of names, such as Serial, NG, Diecimila (10,000 in Italian, to mark that 10,000 boards had been sold), and Duemilanove (2009 in Italian, the release date of the board); the Uno has ushered in some much needed order to the naming of the boards. R3 relates to the revision of the features on the board, which includes updates, refinements, and fixes. In this case, it is the third revision.

The board has many small components, described throughout much of this chapter.

::: {.section}
[]{#c02.xhtml#c02-sec-0003}

### The Brains: ATmega328P microcontroller chip {#c02.xhtml#h3-1 .Heading-2}

You can think of the microcontroller chip itself as the brains of the board. The chip used in the Arduino Uno is the ATmega328P, made by Atmel. It's the large, black component in the center of the board. This chip is known as an integrated circuit, or IC. It sits in a socket; if you were to remove it, it would look like the one shown in [Figure 2-3](#c02.xhtml#c02-fig-0003){#c02.xhtml#rc02-fig-0003}.

::: {#c02.xhtml#c02-fig-0003 .figure}
![9781119489542-fg0203.png](https://i.imgur.com/Utdh6uC.jpeg){.center}
:::

This same chip can come in different forms, referred to as *packages.* The one in an Arduino Uno is in a *plated-through hole*, or PTH, package, named because of the way it makes contact with the board. Another variation you may find is the Arduino Uno SMD, or *surface mount device*, package, which is mounted on the surface of the board rather than in holes that go through it. This chip is much smaller, but it is not replaceable, whereas the PTH chip is. Apart from that, it functions exactly the same as the PTH and differs only in looks.
:::

::: {.section}
[]{#c02.xhtml#c02-sec-0004}

### Header sockets {#c02.xhtml#h3-2 .Heading-2}

The *microcontroller socket* connects all the legs of the ATmega328 microcontroller chip to other sockets, referred to as *header sockets,* which are arranged around the edge of the board and are labeled for ease of use. These black sockets are divided into three main groups: digital pins, analog input pins, and power pins.

All these pins transfer a voltage, which can be either sent as output or received as an input. Why are these pins important? They allow you to connect additional circuitry to the board quickly and easily when prototyping with a breadboard (described in [Chapter 6](#c06.xhtml)) and to design additional boards, called *shields,* that fit neatly on top of your Arduino board (see [Chapter 12](#c12.xhtml) for more on shields).

This same process of sending and receiving electrical signals is going on inside modern computers. But because they are so advanced and refined compared to a humble Arduino, it is difficult to directly link a computer accustomed to digital signals (0s and 1s) to an electronic circuit that deals with a range of voltages (0v to 5v in the ATmega328P's case).

The Arduino (see the sketch in [Figure 2-4](#c02.xhtml#c02-fig-0004){#c02.xhtml#rc02-fig-0004}) is special because it can interpret these electric signals and convert them to digital signals that your computer can understand --- and vice versa. It also enables you to write a program using software on a conventional computer that the Arduino IDE (integrated development environment) converts or compiles to electrical signals that your circuit can understand.

::: {#c02.xhtml#c02-fig-0004 .figure}
![9781119489542-fg0204.png](https://i.imgur.com/VOW9fOs.jpeg){.center}
:::

By bridging this gap, it is possible to use a conventional computer\'s benefits --- ease of use, user-friendly interfaces, and code that is easy for humans to understand --- to control a wide range of electronic circuits and even give them complex behaviors with relative ease.
:::

::: {.section}
[]{#c02.xhtml#c02-sec-0005}

### Digital pins {#c02.xhtml#h3-3 .Heading-2}

You use *digital pins* (refer to [Figure 2-4](#c02.xhtml#c02-fig-0004)) to send and receive digital signals. *Digital* implies that the pins have two states: off or on. In electrical terms, these states translate to a value of 0 or 5 volts, but no values in between.
:::

::: {.section}
[]{#c02.xhtml#c02-sec-0006}

### Analog in pins {#c02.xhtml#h3-4 .Heading-2}

You use *analog in* pins (refer to [Figure 2-4](#c02.xhtml#c02-fig-0004)) to receive an analog value. An analog value is taken from a range of values. In this case, the range is the same 0V to 5V as with the digital pins, but the value can be at any point --- 0.1, 0.2, 0.3, and so on.
:::

::: {.section}
[]{#c02.xhtml#c02-sec-0007}

### What about analog out? {#c02.xhtml#h3-5 .Heading-2}

The shrewd ones among you may have noticed that there seem to be no *analog out* pins. In fact, the analog out pins are there, but they're hidden among the digital pins marked as PWM using the \~ symbol. PWM stands for *pulse-width modulation*, which is a technique you can use to give the impression of an analog output using digital pins. I explain how PWM works in [Chapter 6](#c06.xhtml). The \~ symbol appears next to digital pins 3, 5, 6, 9, 10, and 11, showing that you have six pins that are capable of PWM.
:::

::: {.section}
[]{#c02.xhtml#Page_22 .pagebreak role="doc-pagebreak" title="22"}[]{#c02.xhtml#c02-sec-0008}

### Power pins {#c02.xhtml#h3-6 .Heading-2}

You use the *power pins* to distribute power to inputs and outputs wherever power is needed.

Vin, which stands for *voltage in,* can be used to supply a voltage (V) equal to the one supplied by the external supply jack (for example, 12V). You can also use this pin to supply power to the Arduino from another source.

GND marks the ground pins, which are essential to complete circuits. There is also a third ground by pin 13. All these pins are linked and share the same (called *common*) ground.

You can use 5V or 3.3V to supply a 5-volt or 3.3-volt power supply, respectively, to components or circuits.
:::

::: {.section}
[]{#c02.xhtml#c02-sec-0009}

### USB socket {#c02.xhtml#h3-7 .Heading-2}

To tell the microcontroller on the Arduino board what to do, you need to send a program to it. On the Uno, you send programs primarily by a USB connection. The large, metallic socket is a USB port for a USB A-B cable. This cable is similar to the one used on your home printer or scanner, so you may find a few around the house that can serve as handy spares. The Arduino uses the USB both for power and to transfer data. Using a USB cable is perfect for low-power applications and when data is being sent to or received from a computer.
:::

::: {.section}
[]{#c02.xhtml#c02-sec-0010}

### Power socket {#c02.xhtml#h3-8 .Heading-2}

Next to the USB socket is another socket; this one is for power. This socket allows you to power your Arduino from an external power supply. The supply could be from an AC-to-DC adaptor (similar to those used on other consumer electronics), a battery, or even a solar panel.

The connector needed is a 2.1 mm center positive plug. *Center positive* simply means that the plug has an outside and an inside that fit the socket and that the inside of the plug must be positive. You should be able to find this plug among the standard connectors that come with most power supplies; otherwise, you can buy the connector and attach it to bare wires.

![warning.png](https://i.imgur.com/h2zhp7l.jpeg) If you connect a power supply that is the opposite (center negative), it is known as having a reverse polarity. Components on the Arduino Uno will resist your attempts to send voltage the wrong way around the board, but those components can melt in the process of saving your board, depending on how much power you\'re []{#c02.xhtml#Page_23 .pagebreak role="doc-pagebreak" title="23"}sending and how long it takes you to notice the burning smell! If you reverse the polarity when using the Vin, 5V, or 3.3V pins, you bypass this protection and almost instantly destroy several parts of your board and the ATmega328P chip.

The recommended voltage for the Uno board is 7--12V. If you supply too little power, your board might not function correctly. Or if you provide too much power, your board might overheat and potentially be damaged.

::: {.section}
[]{#c02.xhtml#c02-sec-0011}

#### LEDs {#c02.xhtml#h4-1 .Heading-3}

LEDs come in a variety of shapes and sizes and are found in almost every modern piece of consumer electronics, from bike lights to TVs to washing machines. You see a lot more of them in numerous examples throughout the book.

The components described in this section are tiny. The Uno board has four LEDs (light-emitting diodes) labeled L, RX, TX, and ON. An *LED* is a component that produces light when electrical current flows through it.

These four LEDs are used to indicate activity on the board, as follows:

-   [ON is green and signifies that your Arduino is powered.]{#c02.xhtml#c02-li-0008}
-   [RX and TX tell you that data is being **r**eceived or **t**ransmitted by the board.]{#c02.xhtml#c02-li-0009}
-   [L is a special LED connected to digital pin 13. It is great for testing to see whether your board is functioning as you want.]{#c02.xhtml#c02-li-0010}

If your Arduino is plugged in but you don't see any lights, double-check that:

-   [Your USB cable is plugged in]{#c02.xhtml#c02-li-0011}
-   [Your USB port is working --- try another device in the port]{#c02.xhtml#c02-li-0012}
-   [Your cable is working --- try another cable, if possible]{#c02.xhtml#c02-li-0013}

If the LED still doesn\'t illuminate, something is probably wrong with your Arduino. Your first destination should be the Arduino troubleshooting page at [[`http://arduino.cc/en/Guide/troubleshooting`]{.Code-within-text}](http://arduino.cc/en/Guide/troubleshooting). If you still have no luck, request a replacement Arduino from where you purchased the device.
:::
:::

::: {.section}
[]{#c02.xhtml#c02-sec-0012}

### Reset button {#c02.xhtml#h3-9 .Heading-2}

The Uno board also has a button next to the USB socket called the reset button. It resets the program on the Arduino or stops it completely when held down for a []{#c02.xhtml#Page_24 .pagebreak role="doc-pagebreak" title="24"}time. Connecting a wire between GND and the reset pin, which is located next to the 3.3V, achieves the same results.

The board has many other components, all of which perform important jobs, but the ones described in this section are the key ones for you to know for now.
:::
:::

::: {.section}
[]{#c02.xhtml#c02-sec-0013}

## Discovering Other Arduino Boards {#c02.xhtml#h2-2 .Heading-1}

The preceding section describes the standard USB Arduino board, but you should be aware that many others exist, all designed with different needs in mind. Some offer more functionality, and others are designed to be more minimal, but generally they follow a design similar to that of the Arduino Uno. For this reason, all examples in this book are based on the Uno.

Previous revisions of the Uno should work without any changes, but if you\'re using an older or more specialized board, be sure to follow instructions specific to it. This section gives you a brief rundown of other available boards.

::: {.section}
[]{#c02.xhtml#c02-sec-0014}

### Official Arduino boards {#c02.xhtml#h3-10 .Heading-2}

Although Arduino is open source, it is also a trademarked brand, so to guarantee the quality and consistency of its products, the Arduino team must properly approve new boards before they are officially recognized and can bear the name Arduino. You can recognize official boards first by the name --- Arduino Pro, Arduino Fio, or Arduino LilyPad, for example. Other nonofficial boards often include *Arduino compatible* or *for Arduino* in the name. The other way to recognize an official Arduino, made by the Arduino team, is by the branding (in the most recent versions): They are turquoise and display the infinity symbol somewhere on the board, along with a link to [[`www.arduino.cc`]{.Code-within-text}](http://www.arduino.cc/). Some other companies also have their boards accepted as official boards, so you may find other company names printed on them, such as Adafruit Industries and SparkFun.

Because the schematics for the Arduino board are open source, unofficial Arduino boards have a lot of variation, which people have made for their own needs. These boards are usually based on the same microcontroller chips to remain compatible with the Arduino software, but they require extra consideration and reading to be sure that they will work as expected. The Seeeduino v4.2 (by Seeed Studio), for example, is based on the Arduino Uno and is 100 percent compatible but adds various extra connections, switches, and sockets, which may be of more use to you than an official Arduino board in certain situations.

[]{#c02.xhtml#Page_25 .pagebreak role="doc-pagebreak" title="25"}Official boards are the safe option for beginners to choose because the majority of Arduino examples online are based on these boards. Because of this, official boards are more widely used, and because of *that,* any errors or bugs in the board design are likely to be remedied with the next revision or at least well documented.

::: {.section}
[]{#c02.xhtml#c02-sec-0015}

#### Arduino Leonardo {#c02.xhtml#h4-2 .Heading-3}

The Leonardo has the same *footprint* (shape of circuit board), but the microcontroller used is different and can be recognized as a keyboard or mouse by a computer. In the "Hacking Other Hardware" bonus chapter ([[`www.dummies.com/go/arduinofd`]{.Code-within-text}](http://www.dummies.com/go/arduinofd)), I provide more detail about the differences between this board and the Uno and how to use it.
:::

::: {.section}
[]{#c02.xhtml#c02-sec-0016}

#### Arduino Mega 2560 R3 {#c02.xhtml#h4-3 .Heading-3}

As the name suggests, the Arduino Mega 2560 R3 is a bigger board than the Arduino Uno R3. It is for people who want more: more inputs, more outputs, and more processing power! The Mega has 54 digital pins and 16 analog pins whereas the Uno has a measly 15 digital and 6 analog pins.
:::

::: {.section}
[]{#c02.xhtml#c02-sec-0017}

#### Arduino Mega ADK {#c02.xhtml#h4-4 .Heading-3}

The Arduino Mega ADK is essentially the same board as the Mega 2560 Arduino but is designed to interface with Android phones. This means you can share data between your Android mobile or tablet and an Arduino to broaden the range of either.
:::

::: {.section}
[]{#c02.xhtml#c02-sec-0018}

#### Arduino Nano 3.0 {#c02.xhtml#h4-5 .Heading-3}

The Arduino Nano 3.0 is a condensed Arduino that measures just 0.70″ x 1.70″. This size is perfect for making your project smaller. The Nano has all the power of an Arduino Uno (both use the same ATmega328 microcontroller), but it\'s a fraction of the size. The Nano also handily fits into a breadboard, making it ideal for prototyping as well.
:::

::: {.section}
[]{#c02.xhtml#c02-sec-0019}

#### Arduino Mini R5 {#c02.xhtml#h4-6 .Heading-3}

Despite what the names suggest, the Arduino Mini R5 is smaller than the Nano. This board also uses the same ATmega328 microcontroller chip but is condensed further, removing all header pins and the Mini-USB connector of the Nano. The Mini board is great if space is at a premium, but it does require great care when connecting because an incorrect connection can easily destroy the board.
:::

::: {.section}
[]{#c02.xhtml#Page_26 .pagebreak role="doc-pagebreak" title="26"}[]{#c02.xhtml#c02-sec-0020}

#### Arduino 101 {#c02.xhtml#h4-7 .Heading-3}

The Arduino 101 uses the Intel Curie module to provide a board that's as easy to use as Arduino but with the latest Bluetooth low energy technology. It also features a six-axis accelerometer to detect movement, making it a great companion for any wearable technology projects or for talking to other Bluetooth devices.
:::

::: {.section}
[]{#c02.xhtml#c02-sec-0021}

#### Arduino MKR1000 {#c02.xhtml#h4-8 .Heading-3}

The Arduino MKR1000 is a simple but powerful board, combining a 32-bit processor with a Wi-Fi module. It's perfect for linking sensors and actuators to the Internet or prototyping your next Internet of Things (IoT) project. Along with its small form factor, it has a handy battery connector to allow you to take your project on the move.
:::
:::

::: {.section}
[]{#c02.xhtml#c02-sec-0022}

### Contributed (approved) Arduinos {#c02.xhtml#h3-11 .Heading-2}

Many Arduino boards are now standardized and designed by the Arduino team. However, some have been contributed by other companies, such as Adafruit Industries and SparkFun, and are recognized as official boards. I list a few of the best ones here.

::: {.section}
[]{#c02.xhtml#c02-sec-0023}

#### LilyPad Arduino USB {#c02.xhtml#h4-9 .Heading-3}

The LilyPad Arduino USB was made for projects in which technology is combined with textiles to aid in the development of e-textiles or wearable electronics projects. The LilyPad and its accompanying *breakout boards* (printed circuit board that make it easy to integrate various components without the need to build your own boards) can be sewn together using conductive thread instead of conventional wire. This board was designed and developed by Leah Buechley of MIT ([[`www.leahbuechley.com/`]{.Code-within-text}](http://www.leahbuechley.com/)) and SparkFun Electronics. If you're interested in e-textiles or wearable electronics, check out the excellent tutorial on SparkFun's site that introduces the latest version of the board and the ProtoSnap kit. (Go to [[`learn.sparkfun.com/tutorials/lilypad-development-board-hookup-guide`]{.Code-within-text}](https://learn.sparkfun.com/tutorials/lilypad-development-board-hookup-guide).)
:::

::: {.section}
[]{#c02.xhtml#c02-sec-0024}

#### Arduino Pro {#c02.xhtml#h4-10 .Heading-3}

The Arduino Pro is a minimal and super skinny Arduino, by SparkFun Electronics, based on the same microcontroller as those used in the Uno. It comes without any of the normal headers or sockets but has all the same capabilities of an Uno. It's ideal when height is at a short supply. In addition, it has a battery socket, which allows you to easily make your project portable.
:::

::: {.section}
[]{#c02.xhtml#Page_27 .pagebreak role="doc-pagebreak" title="27"}[]{#c02.xhtml#c02-sec-0025}

#### Arduino Pro Mini {#c02.xhtml#h4-11 .Heading-3}

The Pro Mini is another SparkFun product; this one pushes the minimalism of the Arduino Pro to new limits. In the scale of Arduinos, the Pro Mini sits neatly between the Nano and the Mini. It has none of the header pins or the Mini-USB port of the Nano, and is slightly more spread out than the Arduino Mini. The Pro Mini has none of the safety features of the Uno, so take great care when wiring because a wrong connection can easily destroy the board.
:::
:::
:::

::: {.section}
[]{#c02.xhtml#c02-sec-0026}

## Shopping for Arduino {#c02.xhtml#h2-3 .Heading-1}

Initially, Arduino boards were available only from a small number of hobby shops scattered across the world. Now you have lots of places to purchase an Arduino, as listed in the following sections. Later in this chapter, I tell you about beginner's kits, which pull together the basic components for you; I recommend a kit to get you started on your Arduino endeavors.

On the Arduino site, you can find an exhaustive list of Arduino resellers and manufacturers around the world ([[`store.arduino.cc/distributors`]{.Code-within-text}](http://store.arduino.cc/distributors)). Here are just a few of the most useful.

::: {.section}
[]{#c02.xhtml#c02-sec-0027}

### Arduino Store {#c02.xhtml#h3-12 .Heading-2}

[[`https://store.arduino.cc/usa/`]{.Code-within-text}](https://store.arduino.cc/usa/)

A good place to start is the Arduino Store. This location has all the latest Arduino boards, kits, and a select few components.
:::

::: {.section}
[]{#c02.xhtml#c02-sec-0028}

### Adafruit {#c02.xhtml#h3-13 .Heading-2}

[[`www.adafruit.com/`]{.Code-within-text}](https://www.adafruit.com/)

MIT engineer Limor "Ladyada" Fried founded Adafruit in 2005. Through its website, the company offers a wealth of resources, including products that the company designs and makes itself; other products sourced from all over; tools and equipment; and tutorials, forums, and videos covering a wide range of topics. Adafruit is based in New York, New York (it's a wonderful town!). It distributes worldwide.
:::

::: {.section}
[]{#c02.xhtml#Page_28 .pagebreak role="doc-pagebreak" title="28"}[]{#c02.xhtml#c02-sec-0029}

### SparkFun {#c02.xhtml#h3-14 .Heading-2}

[[`www.sparkfun.com/`]{.Code-within-text}](https://www.sparkfun.com/)

SparkFun sells all sorts of parts for every variety of electronics projects. As well as selling Arduino-compatible hardware, it designs and makes a lot of its own boards and kits. SparkFun has an excellent site that acts as a shop front, a support desk, and a classroom for Arduinoists. SparkFun also has active (and vocal) commenters on each of its product pages, which help to support and continually improve the company's products. SparkFun was founded in 2003 and is based in Boulder, Colorado.
:::

::: {.section}
[]{#c02.xhtml#c02-sec-0030}

### Seeed Studio {#c02.xhtml#h3-15 .Heading-2}

[[`www.seeedstudio.com`]{.Code-within-text}](http://www.seeedstudio.com)

Based in Shenzhen, China, Seeed Studio is self-described as an "open hardware facilitation company." The shop uses local manufacturing to quickly make prototypes and small-scale projects that are distributed worldwide. In addition to manufacturing and selling products, the company offers a community area on its website where people can vote for the projects that they want Seeed Studio to bring to fruition ([[`www.seeedstudio.com/wish/`]{.Code-within-text}](http://www.seeedstudio.com/wish/)).
:::

::: {.section}
[]{#c02.xhtml#c02-sec-0031}

### Watterott Electronic {#c02.xhtml#h3-16 .Heading-2}

[[`www.watterott.com`]{.Code-within-text}](http://www.watterott.com/)

Founded by Stephan Watterott back in 2008, Watterott Electronic, based in Leinefelde, Germany, began as a one-man business providing a few microcontroller boards and specialist components. A lot has changed since then, and the company now stocks a large array of Arduino-compatible boards, components and other hardware.
:::

::: {.section}
[]{#c02.xhtml#c02-sec-0032}

### Electronics distributors {#c02.xhtml#h3-17 .Heading-2}

Many well-established global electronics distribution companies deliver to all corners of the world. Relatively recently, they have started stocking Arduino boards, but they are especially useful for bulk buying of components when you know what you're looking for.

![tip.png](https://i.imgur.com/R16cER5.jpeg) You can lose days searching through the extensive catalogues of components, so it's always a good idea to know the name of what you're looking for before you start!

[]{#c02.xhtml#Page_29 .pagebreak role="doc-pagebreak" title="29"}Here are some global distribution companies that stock Arduino boards and components:

-   [**Digi-Key:** [[`www.digikey.com`]{.Code-within-text}](https://www.digikey.com)]{#c02.xhtml#c02-li-0014}
-   [**Farnell:** [[`www.farnell.com`]{.Code-within-text}](http://www.farnell.com)]{#c02.xhtml#c02-li-0015}
-   [**Mouser:** [[`www.mouser.com`]{.Code-within-text}](http://www.mouser.com/)]{#c02.xhtml#c02-li-0016}
-   [**Rapid:** [[`www.rapidonline.com`]{.Code-within-text}](http://www.rapidonline.com)]{#c02.xhtml#c02-li-0017}
-   [**RS Components:** [[`www.rs-components.com`]{.Code-within-text}](http://www.rs-components.com)]{#c02.xhtml#c02-li-0018}
:::

::: {.section}
[]{#c02.xhtml#c02-sec-0033}

### Amazon {#c02.xhtml#h3-18 .Heading-2}

So much has the popularity of Arduino grown that it's also now stocked at Amazon ([[`www.amazon.com`]{.Code-within-text}](http://www.amazon.com)). Most Arduino boards as well as a variety of components and kits are available here, although they\'re harder to find than on more hobby-specific sites.
:::

::: {.section}
[]{#c02.xhtml#c02-sec-0034}

### eBay {#c02.xhtml#h3-19 .Heading-2}

Originally a source of only second-hand components, eBay ([[`www.ebay.com`]{.Code-within-text}](http://www.ebay.com)) has now become a platform used by many retailers and wholesalers. Here you will find official boards, custom boards, and popular components. Some imitation Arduino boards are also available. Most are harmless and will work the same as an official board, but the quality control is often worse, which can result in strange behavior or damage to a connected devices. If in doubt, use a genuine Arduino board from a certified distributor.
:::
:::

::: {.section}
[]{#c02.xhtml#c02-sec-0035}

## Kitted Out: Starting with a Beginner's Kit {#c02.xhtml#h2-4 .Heading-1}

By this point, you probably know a bit about the Arduino board, but no board is an island; you need lots of other bits so that you can make use of the board. In the same way that a computer is of no use without a mouse and keyboard, an Arduino is of no use --- or at least not as much fun --- without components.

Every new Arduinist should follow several basic examples to learn the fundamentals of Arduino (which this book covers in [Chapters 3](#c03.xhtml) through [7](#c07.xhtml)). These examples are all achievable with a few basic components. To save you the time and effort of finding these components, a few enterprising individuals and companies have put together kits that let you experiment in no time!

[]{#c02.xhtml#Page_30 .pagebreak role="doc-pagebreak" title="30"}Many kits have been designed by different individuals and companies based on their experiences, likes, and dislikes. You can also find a lot of components that do the same job but have different appearances, based on their application.

The following short list describes a few core components that should be included in all good Arduino beginners' kits:

-   [**Arduino Uno:** This is the board you know and love.]{#c02.xhtml#c02-li-0019}
-   [**USB A-B cable:** This cable is essential to make use of your Arduino. It can also be found on printers and scanners.]{#c02.xhtml#c02-li-0020}
-   [**LEDs:** Light-emitting diodes in various colors are great for providing visual feedback for your project as well as for testing lighting projects on a small scale.]{#c02.xhtml#c02-li-0021}
-   [**Resistors:** Also referred to as *fixed resistors,* these are fundamental electrical components used to resist the flow of current through a circuit. Resistors are essential for the smooth running of most circuits. Each resistor has a fixed value, which is indicated by a colored band on the side of the resistor. These bands help you to quickly identify a resistor's resistance visually.]{#c02.xhtml#c02-li-0022}
-   [**Variable resistors:** Also known as *potentiometers* or *pots,* variable resistors resist current in the same way as fixed-value resistors, but they can change their resistance. They are most commonly used in radios and hi-fi equipment for tuning and volume control dials, and are available also in other housings to detect other inputs such as force or flex on a surface.]{#c02.xhtml#c02-li-0023}
-   [**Diodes:** Also known as *rectifier diodes,* diodes are similar to LEDs but without the light. They have an extremely high resistance to the flow of current in one direction and an extremely low (ideally zero) resistance in the other, which is the same reason that an LED works in only one direction. Instead of emitting light like LEDs, diodes control the flow of current throughout your circuit.]{#c02.xhtml#c02-li-0024}
-   [**Photo diodes:** Also known as *photo resistors* or *light-dependent resistors* (LDRs), photo diodes change their resistance when light falls on them. They can have a variety of different uses depending on how they're placed relative to the light source.]{#c02.xhtml#c02-li-0025}
-   [**Pushbuttons:** These components are found behind the scenes in many bits of consumer electronics such as game console controllers and stereos. They're used to either connect or disconnect parts of a circuit so that your Arduino can monitor human inputs.]{#c02.xhtml#c02-li-0026}
-   [**Temperature sensors:** These sensors tell you what the ambient temperature is wherever they are placed. They are great for observing changes in your environment.]{#c02.xhtml#c02-li-0027}
-   [**[]{#c02.xhtml#Page_31 .pagebreak role="doc-pagebreak" title="31"}Piezo buzzer:** A piezo buzzer is technically described as a discrete sounding device. These simple components can be supplied with a voltage to produce simple notes or music. They can also be attached to surfaces to measure vibrations.]{#c02.xhtml#c02-li-0028}
-   [**Relays:** These electrically operated switches are used to switch higher power circuits using your low-voltage Arduino. Half of a relay is an electromagnet, and the other half is a magnetic switch. The electromagnet can be activated by the 5V of the Arduino, which moves the contact of the switch. Relays are essential for bigger lighting and motor-based projects.]{#c02.xhtml#c02-li-0029}
-   [**Transistors:** These components are the basis for all modern computers. Transistors are electrically operated switches, similar to relays, but the switch happens on a chemical level rather than a physical level. This means that the switching can be super fast, making transistors perfect for high-frequency operations such as animating LED lighting or controlling the speed of motors.]{#c02.xhtml#c02-li-0030}
-   [**DC motors:** These motors are simple electric motors. When electric current is passed through a motor, it spins in one direction; when that direction is reversed, it spins in the other. Electric motors come in great variety, from those in your phone that vibrate to those in electric drills.]{#c02.xhtml#c02-li-0031}
-   [**Servo motors:** These motors have on-board circuitry that monitors their rotation. Servo motors are commonly used for precision operations such as the controlled opening of valves or moving the joints of robots.]{#c02.xhtml#c02-li-0032}

Here are a few of the better-known kits, ascending in price. They include all the components in the preceding list, and any will be an excellent companion for the examples in this book:

-   [Arduino Starter Kit from Arduino, available from [[`store.arduino.cc/usa/arduino-starter-kit`]{.Code-within-text}](https://store.arduino.cc/usa/arduino-starter-kit), costing \$87.90 at the time of this writing]{#c02.xhtml#c02-li-0033}
-   [Starter Kit for Arduino (ARDX) by Oomlout, available from [[`www.adafruit.com/products/170`]{.Code-within-text}](http://www.adafruit.com/products/170), costing \$84.95 at the time of this writing]{#c02.xhtml#c02-li-0034}
-   [SparkFun Inventor's Kit 4.0 by SparkFun, available from [[`www.sparkfun.com/products/14265`]{.Code-within-text}](https://www.sparkfun.com/products/14265), costing \$99.95 at the time of this writing]{#c02.xhtml#c02-li-0035}

You can create all the basic examples in this book with any kit in the preceding list, although a slight variation may occur in the number and type of components. See an example Arduino kit in [Figure 2-5](#c02.xhtml#c02-fig-0005){#c02.xhtml#rc02-fig-0005}. Sometimes the same component can take many different forms, so be sure to carefully read the parts list to make sure that you can identify each of the components before you start. Cheaper kits are available, but these will likely not include some components, such as motors or the variety of sensors.

::: {#c02.xhtml#c02-fig-0005 .figure}
![9781119489542-fg0205.png](https://i.imgur.com/BXL7QoC.jpeg){.center}
:::
:::

::: {.section}
[]{#c02.xhtml#c02-sec-0036}

## Preparing a Workspace {#c02.xhtml#h2-5 .Heading-1}

When working on an Arduino project, you could sit on your sofa or be at the top of a ladder. I've been there before! But just because it's possible to work this way doesn't mean that it's sensible or advisable. You're far better off to have a good workspace before you dive into your experiment, especially when you\'re just starting out with Arduino.

Working with electronics is a fiddly business. You're dealing with lots of tiny, delicate, and very sensitive components, so you need great precision and patience when assembling your circuit. If you're in a dimly lit room trying to balance things on your lap, you\'ll quickly go through your supply of components by either losing or destroying them.

It's always good to make life easy for yourself, and the best way to do this when working on Arduino projects is to prepare your workspace. The ideal workspace has the following:

-   [Large, uncluttered desk or table]{#c02.xhtml#c02-li-0036}
-   [Good work lamp]{#c02.xhtml#c02-li-0037}
-   [[]{#c02.xhtml#Page_33 .pagebreak role="doc-pagebreak" title="33"}Comfortable chair]{#c02.xhtml#c02-li-0038}
-   [Cup of tea or coffee (recommended)]{#c02.xhtml#c02-li-0039}

After you're comfortable, you\'re ready to learn how to set up the Arduino software. The Arduino software is a type of an integrated development environment (IDE), a tool common in software development that allows you to write, test, and upload programs. Versions of Arduino software are available for Windows, macOS, Linux, and Arduino Web Editor.
:::

::: {.section}
[]{#c02.xhtml#c02-sec-0037}

## Installing Arduino {#c02.xhtml#h2-6 .Heading-1}

This section talks you through installing the Arduino environment on your platform of choice. These instructions are specifically for installation using an Arduino Uno, but also work just as well for previous boards.

Arduino is free to download from [[`www.arduino.cc/en/main/software`]{.Code-within-text}](https://www.arduino.cc/en/main/software) and is supported on macOS, Windows 32-bit and 64-bit, and Linux 32-bit, 64-bit, and ARM. At the time of this writing, Arduino was version 1.8.4.

To install Arduino, do the following:

-   [**On a Mac:** The .zip file unzips automatically, producing the Arduino app file, which you can then drag to your Applications folder. From there, you can drag Arduino to the dock for easy access or create a desktop alias.]{#c02.xhtml#c02-li-0040}
-   [**On Windows:** Download the installer file and double-click to install the file in a directory of your choice. You also have the option to create shortcuts and install the latest USB drivers.]{#c02.xhtml#c02-li-0041}
-   [**On Linux:** Download the compressed file for your version of Linux and extract the package. Open the Arduino folder (whose name includes the version number, such as arduino-1.8.4) created by the extraction process and find the install.sh file. Right-click it and choose Run in Terminal from the contextual menu.]{#c02.xhtml#c02-li-0042}
:::

::: {.section}
[]{#c02.xhtml#c02-sec-0038}

## Surveying the Arduino Environment {#c02.xhtml#h2-7 .Heading-1}

Programs written for Arduino are known as *sketches*. This naming convention was passed down from Processing, which allowed users to create programs quickly, in the same way that you would scribble an idea in a sketchbook.

[]{#c02.xhtml#Page_34 .pagebreak role="doc-pagebreak" title="34"}Before you look at your first sketch, I encourage you to explore the Arduino software. The Arduino software is an integrated development environment, or IDE, and this environment is presented to you as a graphical user interface, or GUI (pronounced "goo-ey").

A *GUI* provides a visual way of interacting with a computer. Without it, you would need to read and write lines of text, similar to what you may have seen in the DOS prompt in Windows, Terminal in macOS, and in that bit about the white rabbit at the start of *The Matrix.*

The turquoise window is Arduino's GUI. It's divided into the following four main areas (labeled in [Figure 2-6](#c02.xhtml#c02-fig-0006){#c02.xhtml#rc02-fig-0006}):

-   [**Menu bar:** Similar to the menu bar in other programs you're familiar with, the Arduino menu bar contains drop-down menus to all the tools, settings, and information that are relevant to the program. In macOS, the menu bar is at the top of your screen; in Windows and Linux, the menu bar is at the top of the active Arduino window.[]{#c02.xhtml#Page_35 .pagebreak role="doc-pagebreak" title="35"}]{#c02.xhtml#c02-li-0043}
-   [**[]{#c02.xhtml#Page_36 .pagebreak role="doc-pagebreak" title="36"}Toolbar:** The toolbar contains several buttons that are commonly needed when writing sketches for Arduino. These buttons, which are also available on the menu bar, perform the following functions:]{#c02.xhtml#c02-li-0044}
    -   [*Verify:* Checks that your code makes sense to the Arduino software. Known as *compiling*, this process is a bit like a spelling and grammar checker. Be aware, however, that although the compiler checks that your code has no obvious mistakes, it does not guarantee that your sketch works correctly.]{#c02.xhtml#c02-li-0045}
    -   [*Upload:* Sends your sketch to a connected Arduino board. It automatically compiles your sketch before uploading it.]{#c02.xhtml#c02-li-0046}
    -   [*New:* Creates a sketch.]{#c02.xhtml#c02-li-0047}
    -   [*Open:* Opens an existing sketch.]{#c02.xhtml#c02-li-0048}
    -   [*Save:* Saves the current sketch.]{#c02.xhtml#c02-li-0049}
    -   [*Serial monitor:* Allows you to view data that is being sent to or received by your Arduino board.]{#c02.xhtml#c02-li-0050}
-   [**Text editor:** This area displays your sketch as text. It is almost identical to a regular text editor but has a few added features. Some text is color coded if the Arduino software recognizes it. You also have the option to auto-format the text so that it is easier to read.]{#c02.xhtml#c02-li-0051}
-   [**Message area:** Even after years of using Arduino, you'll still make mistakes (everybody does), and the message area is the first way for you to find out that something is wrong. (***Note:*** The second way is the smell of burning plastic.)]{#c02.xhtml#c02-li-0052}

::: {#c02.xhtml#c02-fig-0006 .figure}
![9781119489542-fg0206.png](https://i.imgur.com/QMnZQSe.jpeg){.center}
:::
:::

::: {.section}
[]{#c02.xhtml#c02-sec-0039}

## Using Arduino Web Editor {#c02.xhtml#h2-8 .Heading-1}

Arduino Web Editor is a cloud-based version of the downloadable IDE and a great way to get started quickly.

*Cloud-based* means that Web Editor runs in your browser and saves your project files to your online account instead of on your computer. Apart from those differences, Web Editor has all the core features of the downloadable IDE but is more flexible, working across platforms without the need to install any files. In [Figure 2-7](#c02.xhtml#c02-fig-0007){#c02.xhtml#rc02-fig-0007}, you can see how the layout differs.

::: {#c02.xhtml#c02-fig-0007 .figure}
![9781119489542-fg0207.png](https://i.imgur.com/vGnq20V.jpeg){.center}
:::
:::

[]{#c03.xhtml}

[]{#c03.xhtml#Page_37 .pagebreak role="doc-pagebreak" title="37"}Chapter 3

# Blinking an LED {#c03.xhtml#a1 .Chap-Title}

::: {.section}
[]{#c03.xhtml#c03-sec-0001}[]{#c03.xhtml#c03-feafxd-0001}

IN THIS CHAPTER

![check.png](https://i.imgur.com/8CmsTP2.jpeg) **Identifying your board**

![check.png](https://i.imgur.com/BxW3Liu.jpeg) **Setting the software**

![check.png](https://i.imgur.com/WRuQdKv.jpeg) **Uploading Blink**

![check.png](https://i.imgur.com/pN2FQj9.jpeg) **Completing your first Arduino sketch**

Brace yourself. You are about to take your first real step into the world of Arduino! You\'ve bought a board, maybe an Arduino starter kit (possibly from one of the suppliers I recommended), and you\'re ready to go.

It\'s always a good idea to have a clear work surface or desk to use when you\'re tinkering. It\'s not uncommon to drop or misplace some of the many tiny components you work with, so make sure your workspace is clear, well lit, and accompanied by a comfortable chair.

By its nature, Arduino is a device intended for performing practical tasks. The best way to learn about Arduino, then, is in practice --- by working with the device and *doing* something. That is exactly the way I write about it throughout this book. In this chapter, I take you through some simple steps to get you on your way to making something.

I also walk you through uploading your first Arduino sketch. After that, you examine how it works and see how to change it to do your bidding.
:::

::: {.section}
[]{#c03.xhtml#c03-sec-0002}

## Working with Your First Arduino Sketch {#c03.xhtml#h2-1 .Heading-1}

In front of you now should be an Arduino Uno, a USB cable, and a computer running your choice of operating system (Windows, macOS, Linux, or Web Editor). The next section shows what you can do with this little device.

::: {.section}
[]{#c03.xhtml#Page_38 .pagebreak role="doc-pagebreak" title="38"}[]{#c03.xhtml#c03-sec-0003}

### Finding the Blink Sketch {#c03.xhtml#h3-1 .Heading-2}

To make sure that the Arduino software is talking to the hardware, you upload a sketch. What is a sketch, you ask? Arduino was created as a device that allows people to quickly prototype and test ideas using little bits of code that demonstrate the idea --- kind of like how you might sketch out an idea on paper. For this reason, programs written for Arduino are referred to as *sketches.* Although a device for quick prototyping was its starting point, Arduino devices are being used for increasingly complex operations. So don\'t infer from the name sketch that an Arduino program is trivial.

The specific sketch you want to use here is called Blink. It\'s about the most basic sketch you can write, a sort of "Hello, world!" for Arduino. Click in the Arduino window. From the menu bar, choose File  ⇒   Examples  ⇒   01.Basics  ⇒   Blink (see [Figure 3-1](#c03.xhtml#c03-fig-0001){#c03.xhtml#rc03-fig-0001}).

::: {#c03.xhtml#c03-fig-0001 .figure}
![9781119489542-fg0301.png](https://i.imgur.com/Wajcxbp.jpeg){.center}
:::

A new window opens in front of your blank sketch and looks similar to [Figure 3-2](#c03.xhtml#c03-fig-0002){#c03.xhtml#rc03-fig-0002}.

::: {#c03.xhtml#c03-fig-0002 .figure}
![9781119489542-fg0302.png](https://i.imgur.com/vEMbCYZ.jpeg){.center}
:::
:::

::: {.section}
[]{#c03.xhtml#c03-sec-0004}

### Identifying your board {#c03.xhtml#h3-2 .Heading-2}

Before you can upload the sketch, you need to check a few things. First you should confirm which board you have. As I mention in [Chapter 2](#c02.xhtml), you can choose from a variety of Arduino devices and several variations on the USB board. The latest []{#c03.xhtml#Page_39 .pagebreak role="doc-pagebreak" title="39"}generation of USB boards is the Uno R3. If you bought your device new, you can be fairly certain that you have this type of board. To make doubly sure, check the back of the board. You should see details about the board\'s model, as shown in [Figure 3-3](#c03.xhtml#c03-fig-0003){#c03.xhtml#rc03-fig-0003}.

::: {#c03.xhtml#c03-fig-0003 .figure}
![9781119489542-fg0303.png](https://i.imgur.com/az68oUt.jpeg){.center}
:::

Also worth checking is the Atmel chip on the Arduino. As I mention in [Chapter 2](#c02.xhtml), the Atmel chip is the brains of the Arduino and is similar to the processor in your computer. Because the Uno and earlier boards allow you to replace the chip, there is always a chance, especially with a used board, that the chip has been replaced with a different one.

Although the Atmel chip looks distinctive on an individual board, if you compare it to an older Arduino, telling them apart at first glance would be difficult. The important distinguishing feature is written on the surface of the chip. In this case, you are looking for ATmega328P. [Figure 3-4](#c03.xhtml#c03-fig-0004){#c03.xhtml#rc03-fig-0004} shows a close-up of the chip. The chip has *PU* at the end of its name, which is a more specific name for this variant.

::: {#c03.xhtml#c03-fig-0004 .figure}
![9781119489542-fg0304.png](https://i.imgur.com/Qqo9BH6.jpeg){.center}
:::
:::

::: {.section}
[]{#c03.xhtml#c03-sec-0005}

### Configuring the software {#c03.xhtml#h3-3 .Heading-2}

After you confirm the type of board you\'re using, you have to provide that information to the software. From the Arduino main menu bar (at the top of the Arduino window in Windows and at the top of the screen in macOS), choose Tools  ⇒   Board. You should see a list of the different kinds of boards supported by the Arduino software. Select your board from the list, as shown in [Figure 3-5](#c03.xhtml#c03-fig-0005){#c03.xhtml#rc03-fig-0005}.

::: {#c03.xhtml#c03-fig-0005 .figure}
![9781119489542-fg0305.png](https://i.imgur.com/W3zVIrq.jpeg){.center}
:::

Next, you need to select the serial port. The *serial port* is the connection that enables your computer and the Arduino device to communicate. *Serial* describes the way that data is sent, one bit of data (0 or 1) at a time. The *port* is the physical interface, in this case a USB socket. I talk more about serial communication in [Chapter 6](#c06.xhtml).

[]{#c03.xhtml#Page_41 .pagebreak role="doc-pagebreak" title="41"}To determine the serial port, choose Tools  ⇒   Port. A list of devices connected to your computer is displayed (see [Figure 3-6](#c03.xhtml#c03-fig-0006){#c03.xhtml#rc03-fig-0006}). This list contains any device that can talk in serial, but for the moment, you\'re interested only in finding the Arduino. If you\'ve just installed Arduino and plugged it in, it should be at the top of the list. For macOS users, the Arduino is shown as /dev/cu.usbmodem*XXXXXX* or /dev/cu.usbmodem*XXXXXX* (where *XXXXXX* is a randomly assigned number). On Windows, the same is true, but the serial ports are named COM1, COM2, COM3, and so on. The highest number is usually the most recent device.

::: {#c03.xhtml#c03-fig-0006 .figure}
![9781119489542-fg0306.png](https://i.imgur.com/HaSbahf.jpeg){.center}
:::

After you find your serial port, select it. It should appear in the bottom right of the Arduino graphic user interface (GUI), along with the board you selected (see [Figure 3-7](#c03.xhtml#c03-fig-0007){#c03.xhtml#rc03-fig-0007}).

::: {#c03.xhtml#c03-fig-0007 .figure}
![9781119489542-fg0307.png](https://i.imgur.com/DRjpiqA.jpeg){.center}
:::
:::

::: {.section}
[]{#c03.xhtml#c03-sec-0006}

### Uploading the sketch {#c03.xhtml#h3-4 .Heading-2}

Now that you have told the Arduino software what kind of board you\'re communicating with and which serial port connection it\'s using, you can upload the Blink sketch you found earlier in this chapter.

First click the Verify button (check mark). Verify checks the code to make sure it makes sense, that is, that the syntax is written in a way Arduino can understand (see [Chapter 2](#c02.xhtml)). However, this process doesn\'t necessarily mean that your code will do what you\'re anticipating.

You should see a progress bar and the message *Compiling Sketch* (see [Figure 3-8](#c03.xhtml#c03-fig-0008){#c03.xhtml#rc03-fig-0008}) for a few seconds, followed by the message *Done Compiling* after the process has finished.

::: {#c03.xhtml#c03-fig-0008 .figure}
![9781119489542-fg0308.png](https://i.imgur.com/TS2XLev.jpeg){.center}
:::

If the sketch compiled successfully, you can now click the Upload button (right arrow) next to the Verify button. A progress bar appears, and you see a flurry of activity on your board from the two LEDs marked RX and TX (mentioned in [Chapter 2](#c02.xhtml)). These show that the Arduino is sending and receiving data. After a few seconds, the RX and TX LEDs stop blinking, and a *Done Uploading* message appears at the bottom of the Arduino window (see [Figure 3-9](#c03.xhtml#c03-fig-0009){#c03.xhtml#rc03-fig-0009}).[]{#c03.xhtml#Page_43 .pagebreak role="doc-pagebreak" title="43"}

::: {#c03.xhtml#c03-fig-0009 .figure}
![9781119489542-fg0309.png](https://i.imgur.com/lHTsb13.jpeg){.center}
:::
:::

::: {.section}
[]{#c03.xhtml#c03-sec-0007}

### Congratulate yourself! {#c03.xhtml#h3-5 .Heading-2}

You should see the LED marked L blinking away reassuringly: on for a second, off for a second. If that is the case, give yourself a pat on the back. You\'ve just uploaded your first piece of Arduino code and entered the world of physical computing!

If you don\'t see the blinking L, go back through the previous sections. Make sure you have installed Arduino properly and then give it one more go. If you still don\'t see the blinking L, check out the excellent troubleshooting page on the official Arduino site at [[`arduino.cc/en/guide/troubleshooting`]{.Code-within-text}](http://arduino.cc/en/guide/troubleshooting).
:::

::: {.section}
[]{#c03.xhtml#c03-sec-0008}

### What just happened? {#c03.xhtml#h3-6 .Heading-2}

Without breaking a sweat, you\'ve just uploaded your first sketch to an Arduino. Congratulations!

Just to recap, you have now:

-   [Plugged your Arduino into your computer]{#c03.xhtml#c03-li-0005}
-   [Opened the Arduino software]{#c03.xhtml#c03-li-0006}
-   [Set the board and serial port]{#c03.xhtml#c03-li-0007}
-   [Opened the Blink sketch from the Examples folder and uploaded it to the board]{#c03.xhtml#c03-li-0008}

In the following section, I walk you through the various parts of the sketch you just uploaded.
:::
:::

::: {.section}
[]{#c03.xhtml#c03-sec-0009}

## Looking Closer at the Sketch {#c03.xhtml#h2-2 .Heading-1}

In this section, I show you the Blink sketch in a bit more detail so that you can see what\'s actually going on. When the Arduino software reads a sketch, it quickly works through it one line at a time, in order. So the best way to understand the code is to work through it the same way but slowly.

Arduino uses the programming language C, which is one of the most widely used languages of all time. It\'s an extremely powerful and versatile language, but it takes some getting used to.

[]{#c03.xhtml#Page_45 .pagebreak role="doc-pagebreak" title="45"}If you followed the previous section, you should already have the Blink sketch on your screen. If not, you can find it by choosing File  ⇒   Examples  ⇒   01.Basics  ⇒   Blink (refer to [Figure 3-1](#c03.xhtml#c03-fig-0001)).

When the sketch is open, you should see something like this:

[]{#c03.xhtml#c03-code-0001}[]{#c03.xhtml#c03-lntxt-0001}

`/*`{#c03.xhtml#c03-line-0001}

`  Blink`{#c03.xhtml#c03-line-0002}

`  Turns on an LED on for one second, then off for one second, repeatedly.`{#c03.xhtml#c03-line-0003}

 

`  Most Arduinos have an on-board LED you can control. On the UNO, MEGA and ZERO`{#c03.xhtml#c03-line-0005}

`  it is attached to digital pin 13, on MKR1000 on pin 6. LED_BUILTIN is set to`{#c03.xhtml#c03-line-0006}

`  the correct LED pin independent of which board is used.`{#c03.xhtml#c03-line-0007}

`  If you want to know what pin the on-board LED is connected to on your Arduino model, check`{#c03.xhtml#c03-line-0008}

`  the Technical Specs of your board at https://www.arduino.cc/en/Main/Products`{#c03.xhtml#c03-line-0009}`</span>`{=html}`</a>`{=html}`</code>`{=html}

 

`  This example code is in the public domain.`{#c03.xhtml#c03-line-0010}

 

`  modified 8 May 2014`{#c03.xhtml#c03-line-0012}

`  by Scott Fitzgerald`{#c03.xhtml#c03-line-0013}

 

`  modified 2 Sep 2016`{#c03.xhtml#c03-line-0014}

`  by Arturo Guadalupi`{#c03.xhtml#c03-line-0015}

 

`  modified 8 Sep 2016`{#c03.xhtml#c03-line-0016}

`  by Colby Newman`{#c03.xhtml#c03-line-0017}

`*/`{#c03.xhtml#c03-line-0018}

 

`// the setup function runs once when you press reset or power the board`{#c03.xhtml#c03-line-0021}

`void setup() {`{#c03.xhtml#c03-line-0022}

`  // initialize digital pin LED_BUILTIN as an output.`{#c03.xhtml#c03-line-0023}

`  pinMode(LED_BUILTIN, OUTPUT);`{#c03.xhtml#c03-line-0024}

`}`{#c03.xhtml#c03-line-0025}

 

`// the loop function runs over and over again forever`{#c03.xhtml#c03-line-0027}

`void loop() {`{#c03.xhtml#c03-line-0028}

`  digitalWrite(LED_BUILTIN, HIGH);   // turn the LED on (HIGH is the voltage level)`{#c03.xhtml#c03-line-0029}

`  delay(1000);                       // wait for a second`{#c03.xhtml#c03-line-0030}

`  digitalWrite(LED_BUILTIN, LOW);    // turn the LED off by making the voltage LOW`{#c03.xhtml#c03-line-0031}

`  delay(1000);                       // wait for a second`{#c03.xhtml#c03-line-0032}

`}`{#c03.xhtml#c03-line-0033}

[]{#c03.xhtml#Page_46 .pagebreak role="doc-pagebreak" title="46"} The sketch is made up of lines of code. When looking at the code as a whole, you can identify three distinct sections:

-   [Comments]{#c03.xhtml#c03-li-0009}
-   [[`void loop`]{.Code-within-text}]{#c03.xhtml#c03-li-0010}
-   [[`void setup`]{.Code-within-text}]{#c03.xhtml#c03-li-0011}

Read on for more details about each of these sections.

::: {.section}
[]{#c03.xhtml#c03-sec-0010}

### Comments {#c03.xhtml#h3-7 .Heading-2}

Here\'s what you see in the first section of the code:

[]{#c03.xhtml#c03-code-0002}[]{#c03.xhtml#c03-lntxt-0002}

`/*`{#c03.xhtml#c03-line-0034}

`  Blink`{#c03.xhtml#c03-line-0035}

`  Turns on an LED on for one second, then off for one second, repeatedly.`{#c03.xhtml#c03-line-0036}

 

`  Most Arduinos have an on-board LED you can control. On the UNO, MEGA and ZERO`{#c03.xhtml#c03-line-0038}

`  it is attached to digital pin 13, on MKR1000 on pin 6. LED_BUILTIN is set to`{#c03.xhtml#c03-line-0039}

`  the correct LED pin independent of which board is used.`{#c03.xhtml#c03-line-0040}

`  If you want to know what pin the on-board LED is connected to on your Arduino model, check`{#c03.xhtml#c03-line-0041}

`  the Technical Specs of your board at https://www.arduino.cc/en/Main/Products`{#c03.xhtml#c03-line-0042}`</span>`{=html}`</a>`{=html}`</code>`{=html}

 

`  This example code is in the public domain.`{#c03.xhtml#c03-line-0043}

 

`  modified 8 May 2014`{#c03.xhtml#c03-line-0045}

`  by Scott Fitzgerald`{#c03.xhtml#c03-line-0046}

 

`  modified 2 Sep 2016`{#c03.xhtml#c03-line-0047}

`  by Arturo Guadalupi`{#c03.xhtml#c03-line-0048}

 

`  modified 8 Sep 2016`{#c03.xhtml#c03-line-0049}

`  by Colby Newman`{#c03.xhtml#c03-line-0050}

`*/`{#c03.xhtml#c03-line-0051}

::: {.section}
[]{#c03.xhtml#c03-sec-0011}

#### Multiline comment {#c03.xhtml#h4-1 .Heading-3}

Note that the code lines are enclosed within the symbols [`/*`]{.Code-within-text} and [`*/`]{.Code-within-text}. These symbols mark the beginning and end of a *multiline* or *block comment*. Comments are written in plain English and, as the name suggests, provide an explanation or comment on the code. The software ignores comments when the sketch is compiled and []{#c03.xhtml#Page_47 .pagebreak role="doc-pagebreak" title="47"}uploaded. Consequently, comments can contain useful information about the code without interfering with how the code runs.

In this example, the comment simply tells you the name of the sketch and what it does, and provides a note explaining that this example code is in the public domain. Comments often include other details such as the name of the author or editor, the date the code was written or edited, a short description of what the code does, a project URL, and sometimes even contact information for the author.
:::

::: {.section}
[]{#c03.xhtml#c03-sec-0012}

#### Single-line comment {#c03.xhtml#h4-2 .Heading-3}

Further down the sketch, inside the [`setup`]{.Code-within-text} and [`loop`]{.Code-within-text} functions, text on your screen appears with the same shade of gray as the comments above. This text is also a comment. The symbols [`//`]{.Code-within-text} signify a single-line comment as opposed to a multiline comment. Any code written after these forward slashes will be ignored for that line. In this case, the comment is describing the piece of code that comes after it:

[]{#c03.xhtml#c03-code-0003}[]{#c03.xhtml#c03-lntxt-0003}

`// the setup function runs once when you press reset or power the board`{#c03.xhtml#c03-line-0052}
:::
:::

::: {.section}
[]{#c03.xhtml#c03-sec-0013}

### Functions {#c03.xhtml#h3-8 .Heading-2}

The next two sections are functions and begin with the word [`void`]{.Code-within-text}: [`void setup`]{.Code-within-text} and [`void loop`]{.Code-within-text}. A *function* is a bit of code that performs a specific task, and that task is often repetitive. Rather than writing the same code out again and again, you can use a function to tell the code to perform the task again.

Consider the general process you follow to assemble IKEA furniture. If you were to write these general instructions in code, using a function, they would look something like this:

[]{#c03.xhtml#c03-code-0004}[]{#c03.xhtml#c03-lntxt-0004}

`void buildFlatpackFurniture() {`{#c03.xhtml#c03-line-0053}

`          buy a flatpack;`{#c03.xhtml#c03-line-0054}

`          open the box;`{#c03.xhtml#c03-line-0055}

`          read the instructions;`{#c03.xhtml#c03-line-0056}

`          put the pieces together;`{#c03.xhtml#c03-line-0057}

`          admire your handiwork;`{#c03.xhtml#c03-line-0058}

`          vow never to do it again;`{#c03.xhtml#c03-line-0059}

`}`{#c03.xhtml#c03-line-0060}

The next time you want to use these same instructions, rather than writing out the individual steps, you can simply call the function named [`buildFlatpackFurniture()`]{.Code-within-text}.

[]{#c03.xhtml#Page_48 .pagebreak role="doc-pagebreak" title="48"}![tip.png](https://i.imgur.com/5L29eEY.jpeg) Although not compulsory, the Camel Case naming convention exists for function and variable names that contain multiple words. (If the convention were a function name, it would be written as CamelCase or camelCase.) Because these names can\'t have spaces, you need a way to distinguish where all the words start and end; otherwise, it takes a lot longer to scan them. The convention is to capitalize the first letter of each word after the first. This convention greatly improves the readability of your code, so I highly recommend that you adhere to this rule in all your sketches for your benefit and the benefit of those reading your code!

The word [`void`]{.Code-within-text} is used for a function that returns no value, and the word that follows is the name of that function. In some circumstances, you might either put one or more values into a function or expect one or more values back from it, the same way you might put numbers into a calculation and expect a total back.

![remember.png](https://i.imgur.com/b4YRd9J.jpeg) You must include [`void setup`]{.Code-within-text} and [`void loop`]{.Code-within-text} in every Arduino sketch; they\'re the minimum required to upload. But it\'s also possible to write your own custom functions for the task you need to do. For now, just remember that you have to include [`void setup`]{.Code-within-text} and [`void loop`]{.Code-within-text} in every Arduino sketch you create. Without these functions, the sketch will not compile.
:::

::: {.section}
[]{#c03.xhtml#c03-sec-0014}

### Setup {#c03.xhtml#h3-9 .Heading-2}

Setup is the first function an Arduino program reads, and it runs only once. Its purpose, as hinted in the name, is to set up the Arduino device, assigning values and properties to the board that do not change during its operation. In the Blink sketch, the [`setup`]{.Code-within-text} function looks like this:

[]{#c03.xhtml#c03-code-0005}[]{#c03.xhtml#c03-lntxt-0005}

`// the setup function runs once when you press reset or power the board`{#c03.xhtml#c03-line-0061}

`void setup() {`{#c03.xhtml#c03-line-0062}

`  // initialize digital pin LED_BUILTIN as an output.`{#c03.xhtml#c03-line-0063}

`  pinMode(LED_BUILTIN, OUTPUT);`{#c03.xhtml#c03-line-0064}

`}`{#c03.xhtml#c03-line-0065}

![tip.png](https://i.imgur.com/CkeQx9z.jpeg) Note on your screen that the word [`void`]{.Code-within-text} is turquoise and the word [`setup`]{.Code-within-text} is green. These colors indicate that the Arduino software recognizes these words as *core* functions, as opposed to a function you have written. If you change the case of the words to [`Void Setup,`]{.Code-within-text} they turn black, which illustrates that the Arduino code is *case sensitive.* Having the correct case is an important point to remember, especially when it\'s late at night and the code doesn\'t seem to be working.

The contents of the [`setup`]{.Code-within-text} function are contained within the curly brackets, [`{`]{.Code-within-text} and [`}`]{.Code-within-text}. Each function needs a matching set of curly brackets. If you have too many of either bracket, the code does not compile, and you are presented with an error message like the one in [Figure 3-10](#c03.xhtml#c03-fig-0010){#c03.xhtml#rc03-fig-0010}.

::: {#c03.xhtml#c03-fig-0010 .figure}
![9781119489542-fg0310.png](https://i.imgur.com/QIdueUd.jpeg){.center}
:::

::: {.section}
[]{#c03.xhtml#c03-sec-0015}

#### PinMode {#c03.xhtml#h4-3 .Heading-3}

The [`pinMode`]{.Code-within-text} function configures a specified pin for either input (receive data) or output (send data). The function includes two parameters:

-   [[`pin`]{.Code-within-text}: The number of the pin whose mode you want to set]{#c03.xhtml#c03-li-0012}
-   [[`mode`]{.Code-within-text}: Either [`INPUT`]{.Code-within-text} or [`OUTPUT`]{.Code-within-text}]{#c03.xhtml#c03-li-0013}

In the Blink sketch, after the single-line comment, you see this line of code:

[]{#c03.xhtml#c03-code-0006}[]{#c03.xhtml#c03-lntxt-0006}

`pinMode(LED_BUILTIN, OUTPUT);`{#c03.xhtml#c03-line-0066}

The word [`pinMode`]{.Code-within-text} is colored orange. As I mention previously in this chapter, highlighted text indicates that Arduino recognizes the word as a core function. [`LED_BUILTIN`]{.Code-within-text} and [`OUTPUT`]{.Code-within-text} are colored blue so that they can be identified as *predefined variables,* values that the Arduino integrated development environment (IDE) recognizes. In this case, [`LED_BUILTIN`]{.Code-within-text} tells the function that you want to control the onboard LED on the Arduino board (marked *L*) and [`OUTPUT`]{.Code-within-text} sets the mode of that pin. I go into more detail about variables in [Chapter 6](#c06.xhtml).

That\'s all you need for [`setup`]{.Code-within-text}. Next up, the [`loop`]{.Code-within-text} section.
:::
:::

::: {.section}
[]{#c03.xhtml#Page_50 .pagebreak role="doc-pagebreak" title="50"}[]{#c03.xhtml#c03-sec-0016}

### Loop {#c03.xhtml#h3-10 .Heading-2}

The next section you see in the Blink sketch is the [`loop`]{.Code-within-text} function, with the word [`void`]{.Code-within-text} in turquoise and the word [`loop`]{.Code-within-text} in green, which means the Arduino software recognizes it as a core function. [`loop`]{.Code-within-text} is a function, but instead of running one time, it runs continuously until you press the reset button on the Arduino board or remove the power. Here is the [`loop`]{.Code-within-text} code:

[]{#c03.xhtml#c03-code-0007}[]{#c03.xhtml#c03-lntxt-0007}

`// the loop function runs over and over again forever`{#c03.xhtml#c03-line-0067}

`void loop() {`{#c03.xhtml#c03-line-0068}

`  digitalWrite(LED_BUILTIN, HIGH);   // turn the LED on (HIGH is the voltage level)`{#c03.xhtml#c03-line-0069}

`  delay(1000);                       // wait for a second`{#c03.xhtml#c03-line-0070}

`  digitalWrite(LED_BUILTIN, LOW);    // turn the LED off by making the voltage LOW`{#c03.xhtml#c03-line-0071}

`  delay(1000);                       // wait for a second`{#c03.xhtml#c03-line-0072}

`}`{#c03.xhtml#c03-line-0073}

::: {.section}
[]{#c03.xhtml#c03-sec-0017}

#### DigitalWrite {#c03.xhtml#h4-4 .Heading-3}

Within the [`loop`]{.Code-within-text} function, you again see curly brackets and two orange functions: [`digitalWrite`]{.Code-within-text} and [`delay`]{.Code-within-text}.

First is digitalWrite:

[]{#c03.xhtml#c03-code-0008}[]{#c03.xhtml#c03-lntxt-0008}

`digitalWrite(LED_BUILTIN, HIGH);   // turn the LED on (HIGH is the voltage level)`{#c03.xhtml#c03-line-0074}

The comment says [`turn the LED on`]{.Code-within-text}, but what exactly does that mean? The [`digitalWrite`]{.Code-within-text} function sends a digital value to a pin. As mentioned in [Chapter 2](#c02.xhtml), digital pins have only two states: on or off. In electrical terms, these can be referred to as either a [`HIGH`]{.Code-within-text} or [`LOW`]{.Code-within-text} value, which is relative to the voltage of the board.

An Arduino Uno requires 5V to run, which is provided by either a USB or an external power supply (as mentioned in [Chapter 2](#c02.xhtml)), which the Arduino board reduces to 5V. This voltage is interpreted by the Arduino. A [`HIGH`]{.Code-within-text} value is equal to 5V and [`LOW`]{.Code-within-text} is equal to 0V.

The [`digitalWrite`]{.Code-within-text} function includes two parameters:

-   [[`pin`]{.Code-within-text}: The name or number of the pin whose mode you want to set]{#c03.xhtml#c03-li-0014}
-   [[`value`]{.Code-within-text}: Either [`HIGH`]{.Code-within-text} or [`LOW`]{.Code-within-text}]{#c03.xhtml#c03-li-0015}

[]{#c03.xhtml#Page_51 .pagebreak role="doc-pagebreak" title="51"}So [`digitalWrite(LED_BUILTIN, HIGH);`]{.Code-within-text} in plain English would be "send 5V to the onboard LED on the Arduino," which is enough voltage to turn on an LED.
:::

::: {.section}
[]{#c03.xhtml#c03-sec-0018}

#### Delay {#c03.xhtml#h4-5 .Heading-3}

In the middle of the [`loop`]{.Code-within-text} code, you see this line:

[]{#c03.xhtml#c03-code-0009}[]{#c03.xhtml#c03-lntxt-0009}

`delay(1000);                       // wait for a second`{#c03.xhtml#c03-line-0075}

This function does just what it says: It stops the program, in this case for an amount of time in milliseconds. In this case, the value is 1000 milliseconds, which is equal to one second. During this time, nothing happens. Your Arduino is chilling out, waiting for the delay to finish.

The next line of the sketch provides another [`digitalWrite`]{.Code-within-text} function to the same pin, but this time writing it low:

[]{#c03.xhtml#c03-code-0010}[]{#c03.xhtml#c03-lntxt-0010}

`digitalWrite(LED_BUILTIN, LOW);    // turn the LED off by making the voltage LOW`{#c03.xhtml#c03-line-0076}

This function tells Arduino to send 0V (ground) to the onboard LED, which turns off the LED. This line of code is followed by another delay that pauses the program for one second:

[]{#c03.xhtml#c03-code-0011}[]{#c03.xhtml#c03-lntxt-0011}

`delay(1000);                       // wait for a second`{#c03.xhtml#c03-line-0077}

At this point, the program returns to the start of the loop and repeats itself, ad infinitum.

So the loop is doing this:

-   [Sending 5v to the LED]{#c03.xhtml#c03-li-0016}
-   [Waiting a second]{#c03.xhtml#c03-li-0017}
-   [Sending 0v to the LED]{#c03.xhtml#c03-li-0018}
-   [Waiting a second]{#c03.xhtml#c03-li-0019}

As you can see, this gives you the blink!
:::
:::
:::

::: {.section}
[]{#c03.xhtml#Page_52 .pagebreak role="doc-pagebreak" title="52"}[]{#c03.xhtml#c03-sec-0019}

## Blinking Brighter {#c03.xhtml#h2-3 .Heading-1}

The LED marked L is actually connected just before it reaches pin 13. On earlier boards, it was necessary to provide your own LED. But because the LED proved so useful for debugging and signaling, one is now in permanent residence to help you out.

For this next bit, you need a loose LED from your kit. LEDs come in a variety of shapes, colors, and sizes but should look something like the one in [Figure 3-11](#c03.xhtml#c03-fig-0011){#c03.xhtml#rc03-fig-0011}.

::: {#c03.xhtml#c03-fig-0011 .figure}
![9781119489542-fg0311.png](https://i.imgur.com/R5H13hK.jpeg){.center}
:::

Take a look at your LED and note that one leg is longer than the other. Place the long leg (anode or +) of the LED in pin 13 and the short leg (cathode or nd) in GND (ground). See [Figure 3-12](#c03.xhtml#c03-fig-0012){#c03.xhtml#rc03-fig-0012}. You see the same blink, but it is (I hope) bigger and brighter depending on the LED you use.

::: {#c03.xhtml#c03-fig-0012 .figure}
![9781119489542-fg0312.png](https://i.imgur.com/Agp17UM.jpeg){.center}
:::

As mentioned previously, the [`LED_BUILTIN`]{.Code-within-text} variable is a predefined variable that refers to the onboard LED. Because the LED is controlled by pin 13 on your Arduino, it's possible to control a different component by connecting it to pin 13. The voltage supplied by all other pins can be too high for most LEDs. Fortunately, another feature of pin 13 is its built-in, pull-down resistor. This resistor keeps your LED at a comfortable voltage and ensures that it has a long and happy life.
:::

::: {.section}
[]{#c03.xhtml#c03-sec-0020}

## Tweaking the Sketch {#c03.xhtml#h2-4 .Heading-1}

I've gone over this sketch in great detail, and I hope everything is making sense. The best way to understand what is going on, however, is to experiment! Try changing the delay times to see what results you get. Here are a couple of things you can try:

-   [Make the LED blink the SOS signal.]{#c03.xhtml#c03-li-0020}
-   [See how fast you can make the LED blink before it appears to be on all the time.]{#c03.xhtml#c03-li-0021}

While experimenting, it's wise to save your sketch under a different name. If the name is descriptive, such as sosLED, you can more easily find your project again. Also, each time you make a change to your code, remember to repeat the steps in this chapter to verify the code and upload it to your Arduino.
:::

[]{#p02.xhtml}

::: {.section}
[]{#p02.xhtml#Page_55 .pagebreak role="doc-pagebreak" title="55"}Part 2

# Getting Physical with Arduino {#p02.xhtml#a1 .Part-Title}

::: {.section}
[]{#p02.xhtml#p02-sec-0001}

[]{#p02.xhtml#Page_56 .pagebreak role="doc-pagebreak" title="56"}IN THIS PART ...

Find out more about the prototyping tools you need to build your projects.

Dip into a bit of electronics theory.

Discover new and interesting things that your Arduino can do by building a few basic examples.
:::
:::

[]{#c04.xhtml}

[]{#c04.xhtml#Page_57 .pagebreak role="doc-pagebreak" title="57"}Chapter 4

# Tools of the Trade {#c04.xhtml#a1 .Chap-Title}

::: {.section}
[]{#c04.xhtml#c04-sec-0001}[]{#c04.xhtml#c04-feafxd-0001}

IN THIS CHAPTER

![check.png](https://i.imgur.com/uCLGIoy.jpeg) **Introducing the breadboard, a blank canvas for circuits**

![check.png](https://i.imgur.com/hF6gsDR.jpeg) **Assembling a tool kit**

![check.png](https://i.imgur.com/C9atbe3.jpeg) **Becoming an electronics super sleuth, with a multimeter**

In [Chapter 3](#c03.xhtml), I cover one of the most basic Arduino applications: blinking an LED. This application requires only an Arduino and a few lines of code. Although blinking an LED is fun, you can use an Arduino for an almost unlimited number of other things --- making interactive installations, controlling your home appliances, and talking with the Internet, to name a few.

In this chapter, you branch out by gaining an understanding of prototyping and how to use some basic prototyping tools to do more with your Arduino. Prototyping tools allow you to make temporary circuits to try new components, test circuits, and build simple prototypes. In this chapter, you find out about all the equipment and techniques you need to build your own circuits and prototype your ideas.
:::

::: {.section}
[]{#c04.xhtml#c04-sec-0002}

## Finding the Right Tools for the Job {#c04.xhtml#h2-1 .Heading-1}

*Prototyping* is all about exploring ideas, which also happens to be the core of what Arduino is all about. Although theory is important, you often learn better and faster from doing an experiment.

This section introduces you to some prototyping tools and components that you can use to start building circuits. You can then use these circuits to form the basis for your own projects.

[]{#c04.xhtml#Page_58 .pagebreak role="doc-pagebreak" title="58"}A great number of tools are at your disposal to help you experiment. This section contains a short list of the recommended ones. Breadboards and jumper wires are included in most kits and are essential for building circuits for your Arduino project. Needle-nose pliers are not essential but are highly recommended.

::: {.section}
[]{#c04.xhtml#c04-sec-0003}

### Breadboard {#c04.xhtml#h3-1 .Heading-2}

*Breadboards* are the most essential part of your prototyping kit. They are the base on which you can prototype your circuits. Breadboards allow you to temporarily use components rather than committing them to a circuit and soldering them in place. (Soldering is covered in [Chapter 9](#c09.xhtml).).

Breadboards get their name from a practice used in the early 1900s. At that time, components were a lot bigger, and people would prototype circuits by fixing them to an actual breadboard --- that is, a board intended for cutting bread on. The components were joined by wrapping lengths of wire around nails that came in contact with the components. By unwrapping the wire from one nail and wrapping it around another, you could quickly change the circuit.

Modern breadboards are much more refined. The outside consists of a plastic case with rows and columns of holes, underneath which are tracks of copper. These tracks allow you to quickly and easily connect components electrically.

Breadboards come in different shapes and sizes, and many have connectors to allow you to lay them out in the arrangement you need.

[Figure 4-1](#c04.xhtml#c04-fig-0001){#c04.xhtml#rc04-fig-0001} shows a fairly standard breadboard. If you were to remove the cream-colored plastic coating, two parallel copper tracks would run down each of the long sides of the board. These copper lengths are generally used to provide a source of power (PWR) and ground (GND) and are sometimes marked with a positive (+) or negative (--) symbol or a red and black or a red and blue line. Red is always positive (+) and black or blue is negative (--).

::: {#c04.xhtml#c04-fig-0001 .figure}
![9781119489542-fg0401.png](https://i.imgur.com/yQa6B1C.jpeg){.center}
:::

A *power rail,* or *ground rail,* is basically a source of voltage or ground. Circuits often need power or ground for a variety of different functions, and one source often isn\'t enough. When you have multiple wires that all need to get to the same place, you use a rail. From this rail, jump wires can source whatever is needed.

![tip.png](https://i.imgur.com/hDuYHHk.jpeg) Although these tracks are marked, you can use them for anything. However, keeping to convention ensures that other people can easily understand your circuit, so I advise that you do so.

[]{#c04.xhtml#Page_59 .pagebreak role="doc-pagebreak" title="59"}Down the middle of the breadboard are lots of short tracks running parallel to the short edge, separated with a trench down the middle. You use this middle trench to mount components and integrated circuits, including pushbuttons (discussed in [Chapter 6](#c06.xhtml)) and optocouplers (see the bonus chapter "Hacking Other Hardware" at [[`www.dummies.com/go/arduinofd`]{.Code-within-text}](http://www.dummies.com/go/arduinofd)). The trench makes it easier to lay out your circuit and also provides space for jump wires to connect your components to the places they need to get to.

When you place a jump wire or a component into one of the breadboard's sockets, you should feel a bit of friction. A pincer-like device holds the wire or component in place. It provides enough grip to hold things in place for a project while working at a desk, but it's loose enough for you to easily remove it with your fingers.

I have seen people taping breadboards into boxes for their projects, but this practice isn\'t advisable. Smaller components or loose wires can easily come loose, and it can be a pain to figure out why something isn\'t working. If you have a project working and want to get it out into the real world, jump ahead to soldering (explained in [Chapter 9](#c09.xhtml)). Soldering makes your project last longer, and it's a lot of fun, too!
:::

::: {.section}
[]{#c04.xhtml#c04-sec-0004}

### Jump wires {#c04.xhtml#h3-2 .Heading-2}

*Jump wires* (shown in [Figure 4-2](#c04.xhtml#c04-fig-0002){#c04.xhtml#rc04-fig-0002}) are short lengths of insulated equipment wire. You use them to connect your components to the rows of your breadboard, []{#c04.xhtml#Page_60 .pagebreak role="doc-pagebreak" title="60"}other components, and your Arduino. A jump wire is no different from other wire in a material sense, but it's usually cut to a short length that is useful for breadboards.

::: {#c04.xhtml#c04-fig-0002 .figure}
![9781119489542-fg0402.png](https://i.imgur.com/cC8LKt4.jpeg){.center}
:::

You can find insulated wire everywhere. It can be the thick power cord used to plug in a household appliances or it can be much thinner, such as wire used for an earphone. Insulated wire is basically a conductive metal wire surrounded by an insulator that protects you from the electricity and protects the electrical signal from any outside interference.

The wire you use most often in this book (and most useful for your Arduino projects) could be subcategorized as *insulated equipment wire.* This type of wire is generally used on a small scale for low-voltage electrical applications.

The equipment wire you use is one of two varieties: single core and multicore. *single-core wire* is a single piece of wire, just as a coat hanger is a single piece. Single-core wire is extremely good for holding its shape but shears if you bend it too much. Therefore, this type of wire is useful for laying out wires on your breadboard neatly as long as you won\'t need to move them much.

*Multicore wire* can have the same diameter as single core but consists of lots of little wires instead of just one wire. The little wires are twisted together, giving the multicore wire more strength and resistance to bending than a single-core wire. This twisted design is the same technique used on suspension bridges. Multicore wires are especially suited to connections that will change often, and they last a long time.

[]{#c04.xhtml#Page_61 .pagebreak role="doc-pagebreak" title="61"}You can cut jump wires yourself, but they also come in handy packs of assorted colors and lengths. Cutting them yourself is significantly cheaper because you can buy a large reel of wire. On the other hand, if you want a variety of colors, you have to buy a reel for each color, which can amount to a fairly big investment for your first circuit. The packs save you this initial cost and give you the variety you need. You can buy the large reels when you know you'll need them.

Also, when considering cutting your own wire, bear in mind the difference in finishing for homemade jump wires. Single-core wires are much the same whether you or someone else cuts them yourself, but they deteriorate quickly as they bend. Multicore wires last longer, but if they are cut from a reel, you\'re left with a few small wires on the ends that can easily fray in the same way as the end of a piece of string or thread does. You have to fiddle with them often, twisting with your thumb and forefinger between uses to ensure that the small wires stay as straight and rigid as possible.

Premade multicore jump wires are usually either soldered together into a single point or have a connecting pin soldered to the end of the strands of wire. This design ensures that the connecting end is as reliable as single core while giving you the flexibility of multicore.

Ideally, you should have a pack of premade multicore jump wires to get you going. These packs are the most versatile and long-lasting choice for your prototyping kit. Eventually, you'll want to have a variety of jump wires so that you can be prepared for any situation when building a circuit.
:::

::: {.section}
[]{#c04.xhtml#c04-sec-0005}

### Needle-nose pliers {#c04.xhtml#h3-3 .Heading-2}

*Needle-nosed pliers,* shown in [Figure 4-3](#c04.xhtml#c04-fig-0003){#c04.xhtml#rc04-fig-0003}, are the same as regular pliers but with a very fine point, ideal for picking up tiny components. Electronics can be an extremely fiddly business, and it's extremely easy to mangle the delicate legs of components when pushing them into a breadboard. These specialist pliers are not essential but add a little bit of finesse to building circuits.

::: {#c04.xhtml#c04-fig-0003 .figure}
![9781119489542-fg0403.png](https://i.imgur.com/vwzbJ3m.jpeg){.center}
:::
:::

::: {.section}
[]{#c04.xhtml#c04-sec-0006}

### Multimeter {#c04.xhtml#h3-4 .Heading-2}

A *multimeter* is a meter that measures volts, amps, and resistance. It can tell you the values of different components and what\'s going on with different parts of your circuit. Because you can't see what's going on in a circuit or component, a multimeter is essential for understanding its inner workings. Without it, you have to rely on guesswork, which is always a bad idea with electronics.

[Figure 4-4](#c04.xhtml#c04-fig-0004){#c04.xhtml#rc04-fig-0004} shows a good mid-range digital multimeter. As does this one, most multimeters include:

-   [**A digital display:** This display looks like the one on your digital alarm clock and shows the values you\'re reading. Because of the limited number of digits, the decimal place moves to accommodate a larger or smaller number. A multimeter with an auto-ranging function finds the number automatically. If your multimeter doesn't have this feature, you must change the mode manually to the range you require.]{#c04.xhtml#c04-li-0004}

-   ::: {#c04.xhtml#c04-li-0005}
    **A mode-selection dial:** This dial allows you to choose among the different functions on the multimeter. These functions can be for volts, amperes, and ohms as well as for the range within each of these, such as hundreds, thousands, tens of thousands, hundreds of thousands, and millions of ohms.

    []{#c04.xhtml#Page_63 .pagebreak role="doc-pagebreak" title="63"}![tip.png](https://i.imgur.com/pW0oF0j.jpeg) The best multimeters also include a continuity tester, which tells you whether your connections are actually connected by sounding a tone. Having a tone has saved me hours of work retracing my steps on projects, so I definitely recommend investing in a good mid-range multimeter with this feature.
    :::

-   [**A set of probes:** Probes (also called *test leads*) are the implements you use to test parts of your circuit. Multimeters come with two skewer-like probes that are designed to fit into tight places and are most useful for making contact with small components on circuit boards. You can also find probes with crocodile clips on the end, or you can simply buy crocodile clips that you can attach yourself. These clips are especially useful for grabbing onto wires.]{#c04.xhtml#c04-li-0006}

-   [**A set of sockets:** The probes can be repositioned into different sockets depending on the use. In this case, the sockets are labeled A, mA, COM, and VΩHz. The socket marked A is for measuring large currents in amps (A), up to 20A. Note that the probe can read that current for only 10 seconds. These limits are indicated on a line between this socket and the COM socket, which also indicates that the two probes should be placed in A (red probe) and COM (black probe). The mA socket (red probe) is for smaller currents that are less than 500mA. The COM socket (black probe) is short for Common and is a point of reference for your measurements. In most cases, COM is the ground of your circuit and uses the black probe. The socket marked VΩHz (red probe) is used for measuring the voltage (V or volts), resistance (Ω or ohms), and frequency (Hz or hertz) between this socket and the COM port (black probe).]{#c04.xhtml#c04-li-0007}

::: {#c04.xhtml#c04-fig-0004 .figure}
![9781119489542-fg0404.png](https://i.imgur.com/HjL0939.jpeg){.center}
:::
:::
:::

::: {.section}
[]{#c04.xhtml#c04-sec-0007}

## Using a Multimeter to Measure Voltage, Current, and Resistance {#c04.xhtml#h2-2 .Heading-1}

All Arduinists should know a few basic techniques for checking their circuits. Volts, amps, and current can all be calculated in advance (as you learn in [Chapter 5](#c05.xhtml)), but in the real world, many other factors can arise that you can't account for. If you have a broken component or a faulty connection, you can lose hours guessing what could be wrong, so a multimeter becomes essential for solving problems in your circuit. In this section, you learn about measuring voltage, current, and resistance and checking the continuity of your connections.

::: {.section}
[]{#c04.xhtml#c04-sec-0008}

### Measuring voltage in a circuit {#c04.xhtml#h3-5 .Heading-2}

Measuring the voltage is essential, whether you\'re checking the voltage of a battery or the voltage passing through a component. If things aren't lighting up []{#c04.xhtml#Page_64 .pagebreak role="doc-pagebreak" title="64"}or whirring, a connection might be loose or you might have sent too much power and burnt out what you were trying to power. When something isn\'t working, it\'s time to check the voltage in your circuit and make sure it is correct.

First you need to check that the probes of your multimeter are in the correct sockets. Use the red probe in the socket marked V, for volts, and use the black probe in the socket marked COM, for ground. Next, set your multimeter to volts by using the dial in the center of the multimeter.

Some multimeters, such as the one in [Figure 4-4](#c04.xhtml#c04-fig-0004), have a button to toggle between DC and AC. On other multimeters, a DC voltage is signified by a V followed by a square-shaped digital wave, as opposed to an AC voltage, which is indicated by a smooth, analog wave.

![technicalstuff.png](https://i.imgur.com/mM1wYi0.jpeg) Voltage is measured in parallel. To measure in parallel you must bridge the part of the circuit that you want to measure without interfering in it. [Figure 4-5](#c04.xhtml#c04-fig-0005){#c04.xhtml#rc04-fig-0005} shows how you do this. The positive probe should always be on the positive side of the component and the negative on the other side. Getting the probes the wrong way won't cause any damage to your circuit but will give you a negative reading rather than a positive one.

::: {#c04.xhtml#c04-fig-0005 .figure}
![9781119489542-fg0405.png](https://i.imgur.com/3pD2aQV.jpeg){.center}
:::

A good way to test your multimeter is to measure the voltage between the 5V pin and GND on your Arduino. Make sure that your Arduino is plugged in, and connect a jump wire to each pin to make them easier to access with your probes. Place the red voltage probe on the 5V wire and the black common probe on the GND wire. Doing so should return a value of 5V on the multimeter screen and prove that your Arduino is supplying 5 volts as expected.
:::

::: {.section}
[]{#c04.xhtml#c04-sec-0009}

### Measuring current in a circuit {#c04.xhtml#h3-6 .Heading-2}

You may have the right voltage, but there isn\'t enough current to power the light or motor you're driving. The best way to find out is to check the circuit to see how much current is being drawn and compare that to the power supply you're using.

[]{#c04.xhtml#Page_65 .pagebreak role="doc-pagebreak" title="65"}Check that your probes are connected to the correct sockets of the multimeter. Some meters have two possible sockets, one for very high currents measured in amps (or A) and another for low currents measured in milliamps (mA). Most basic Arduino circuits require only a reading in milliamps, but circuits with large lights, motors, or other devices, require a reading in amps. Then turn the dial on your meter to select the correct level of amps, A or mA or even μA (microamps).

Current is measured in series, which means that the multimeter must be placed in line with the other components in the circuit so that the current flows through the multimeter as if it were another component. [Figure 4-6](#c04.xhtml#c04-fig-0006){#c04.xhtml#rc04-fig-0006} shows this series measurement in action.

::: {#c04.xhtml#c04-fig-0006 .figure}
![9781119489542-fg0406.png](https://i.imgur.com/6TsIiL3.jpeg){.center}
:::

By using the 5V and GND pins on your Arduino, you can use jump wires to build the circuit in [Figure 4-6](#c04.xhtml#c04-fig-0006). By using your multimeter to connect the LED and GND, you will be able to read the current in the circuit. You'll learn how to build circuits similar to [Figure 4-6](#c04.xhtml#c04-fig-0006) in [Chapter 6](#c06.xhtml).

![technicalstuff.png](https://i.imgur.com/A5o2VFa.jpeg) If you\'re blinking or fading the output, your current changes, so you may want to set it to always be on to be sure of the maximum continuous current.
:::

::: {.section}
[]{#c04.xhtml#c04-sec-0010}

### Measuring resistance of a resistor {#c04.xhtml#h3-7 .Heading-2}

Sometimes it can be difficult to read the value of a resistor, and it is necessary, or just easier, to confirm it with a multimeter. Simply set the multimeter to ohms or Ω and place one probe on each leg of the resistor, as shown in [Figure 4-7](#c04.xhtml#c04-fig-0007){#c04.xhtml#rc04-fig-0007}.

::: {#c04.xhtml#c04-fig-0007 .figure}
![9781119489542-fg0407.png](https://i.imgur.com/58quX7Q.jpeg){.center}
:::
:::

::: {.section}
[]{#c04.xhtml#c04-sec-0011}

### Measuring resistance of a variable resistor {#c04.xhtml#h3-8 .Heading-2}

With variable resistors, it can be good to know that you're getting the full range of resistances promised on the label. Variable resistors are similar to passive resistors but have three legs. If you connect the probes across the legs on either side, you are reading the maximum resistance of the variable resistor, and the reading does not change when you move the dial. If you place the probes between the center and one side of the resistor, you are reading the value of variable resistance, which changes as you turn the dial, as shown in [Figure 4-8](#c04.xhtml#c04-fig-0008){#c04.xhtml#rc04-fig-0008}. If you switch to the center and the opposite side, you change the direction of the dial.

::: {#c04.xhtml#c04-fig-0008 .figure}
![9781119489542-fg0408.png](https://i.imgur.com/dNGax5x.jpeg){.center}
:::
:::

::: {.section}
[]{#c04.xhtml#c04-sec-0012}

### Checking the continuity (in bleeps) of your circuit {#c04.xhtml#h3-9 .Heading-2}

If you have a high-quality multimeter, it should have a continuity tester, represented by a speaker or sound symbol on the dial. You use the continuity tester to verify that parts of your circuit are connected; the multimeter communicates the connection by bleeping, ideally producing a continuous tone when the connection is good.

First test the continuity feature itself by turning your dial to the continuity test symbol and touching the ends together. If you hear an unbroken tone, the feature is working. Next, test the connection in your circuit by placing the probes along any length of wire or connection, as shown in [Figure 4-9](#c04.xhtml#c04-fig-0009){#c04.xhtml#rc04-fig-0009}.

::: {#c04.xhtml#c04-fig-0009 .figure}
![9781119489542-fg0409.png](https://i.imgur.com/o6lfaEi.jpeg){.center}
:::
:::
:::

[]{#c05.xhtml}

[]{#c05.xhtml#Page_69 .pagebreak role="doc-pagebreak" title="69"}Chapter 5

# A Primer on Electricity and Circuitry {#c05.xhtml#a1 .Chap-Title}

::: {.section}
[]{#c05.xhtml#c05-sec-0001}[]{#c05.xhtml#c05-feafxd-0001}

IN THIS CHAPTER

![check.png](https://i.imgur.com/rGPHMtS.jpeg) **Coming to grips with electricity**

![check.png](https://i.imgur.com/RhSCRO3.jpeg) **Understanding a few useful equations**

![check.png](https://i.imgur.com/teXyy5z.jpeg) **Finding your way around circuit diagrams**

![check.png](https://i.imgur.com/Tw0XDKk.jpeg) **Realizing the importance of color coding**

In this chapter, you look at the fundamentals of electricity. In later chapters, you delve deeper into electronics, so it's important that you have a basic understanding of how electricity behaves in your circuit.

The great thing about Arduino is that you don't need to study electronics for years to use it. That said, it's a good idea to know a bit of the theory to back up the practical side of your project. In this chapter, you look at a few equations to help you build a balanced and efficient circuit, you look at circuit diagrams, which provide you with a roadmap of your circuit, and you learn a bit about color coding, which can make your life easier when building circuits.
:::

::: {.section}
[]{#c05.xhtml#c05-sec-0002}

## Understanding Electricity {#c05.xhtml#h2-1 .Heading-1}

Most people take electricity for granted but find it difficult to define. Simply put, *electricity* is a form of energy resulting from the existence of charged particles (such as electrons or protons), either statically as an accumulation of charge or dynamically as a current.

[]{#c05.xhtml#Page_70 .pagebreak role="doc-pagebreak" title="70"}This definition of electricity is describing electricity on an atomic level, which is more complex than you need to know when dealing with the circuitry in your Arduino projects. Your main concern is simply to understand that electricity is energy and has a current. For those of you who want to understand electricity at this level, you can check out *Electronics For Dummies*, 3rd Edition, by Cathleen Shamieh.

To illustrate the idea of the flow of a current, take a look at a simple light switch circuit (see [Figure 5-1](#c05.xhtml#c05-fig-0001){#c05.xhtml#rc05-fig-0001}). The circuit is similar to those you may have made in physics or electronics classes at school with no Arduino involved, using only a battery, a switch, a resistor, and an LED.

::: {#c05.xhtml#c05-fig-0001 .figure}
![9781119489542-fg0501.png](https://i.imgur.com/Haftl3X.jpeg){.center}
:::

In this circuit, you have a source of electrical power in the form of a battery. Power is supplied in watts and is made up of voltage (in volts) and current (in amps). Voltage and current are supplied to the circuit through the positive (+) end of the battery.

You use a switch to control the power to the circuit. The switch can either be open, which breaks the circuit and stops the flow of current, or closed, which completes the circuit and allows it to function.

The power can be used for various applications. In this case, the circuit is powering an LED. The battery is supplying the LED with 4.5V, which is more than the LED needs to light. If the LED were supplied with this much voltage, you would risk damaging it, so you need a resistor before it to resist the voltage. Also, if the voltage is too low, the LED will not reach full brightness.

To complete the circuit, the power must return to ground at the negative (--) end of the battery. The LED draws as much current as necessary to light to full brightness.

By drawing current, the LED is also resisting the flow, ensuring that only the required current is drawn. Unless the current is used or resisted by components, []{#c05.xhtml#Page_71 .pagebreak role="doc-pagebreak" title="71"}the circuit draws all the available current as quickly as possible. This is known as a *short circuit*. An example of a short circuit is connecting the positive directly to the negative, with no components in between.

The basic principles that you need to understand follow:

-   [An electrical circuit is, as the name suggests, a circular system.]{#c05.xhtml#c05-li-0005}
-   [The circuit needs to use the power inside it before it returns to the source.]{#c05.xhtml#c05-li-0006}
-   [If the circuit does not use the power, that power has nowhere to go and can damage the circuit.]{#c05.xhtml#c05-li-0007}
-   [The easiest way to interact with a circuit is to break it. By controlling when and where the power is, you have instant control over the outputs.]{#c05.xhtml#c05-li-0008}
:::

::: {.section}
[]{#c05.xhtml#c05-sec-0003}

## Using Equations to Build Your Circuits {#c05.xhtml#h2-2 .Heading-1}

You are now aware of a few characteristics of electricity:

-   [Power (P) is in watts, such as 60W]{#c05.xhtml#c05-li-0009}
-   [Voltage (V) is in volts, such as 12V]{#c05.xhtml#c05-li-0010}
-   [Current (I) is in amps, or amperes, such as 3A]{#c05.xhtml#c05-li-0011}
-   [Resistance (R) is in ohms, such as 150Ω]{#c05.xhtml#c05-li-0012}

These characteristics can be quantified and put into equations, which allow you to carefully balance your circuit to ensure that everything works in harmony. A variety of equations exist for determining all manner of attributes, but in this section I cover two basic ones that will be the most useful to you when working with Arduino: Ohm's Law and Joule's Law.

::: {.section}
[]{#c05.xhtml#c05-sec-0004}

### Ohm's Law {#c05.xhtml#h3-1 .Heading-2}

Perhaps the most important relationship to understand is that among voltage, current, and resistance. In 1827, Georg Simon Ohm discovered that voltage and current were directly proportional if applied to a simple equation (recall from the preceding list that *I* stands for current, measured in *amps,* or *amperes*):

::: {#c05.xhtml#c05-disp-0001 .equation}
![](m:math>-->`{=html})`<!--<m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:mrow><m:mi mathvariant="normal">V</m:mi><m:mo>=</m:mo><m:mi mathvariant="normal">I</m:mi><m:mo>&#215;</m:mo><m:mi mathvariant="normal">R</m:mi></m:mrow></m:math>-->`{=html}
:::

[]{#c05.xhtml#Page_72 .pagebreak role="doc-pagebreak" title="72"}

This equation became known as *Ohm's Law.* Using algebra, the equation can be rearranged to give you any one value from the remaining two:

::: {#c05.xhtml#c05-disp-0002 .equation}
![](m:math>-->`{=html})`<!--<m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:mrow><m:mi mathvariant="normal">I</m:mi><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mi mathvariant="normal">V</m:mi><m:mo>/</m:mo><m:mi mathvariant="normal">R</m:mi></m:mrow></m:math>-->`{=html}
:::

or

::: {#c05.xhtml#c05-disp-0003 .equation}
![](m:math>-->`{=html})`<!--<m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:mrow><m:mi mathvariant="normal">R</m:mi><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mi mathvariant="normal">V</m:mi><m:mo>/</m:mo><m:mi mathvariant="normal">I</m:mi></m:mrow></m:math>-->`{=html}
:::

You can take a look at this equation at work in an actual circuit. [Figure 5-2](#c05.xhtml#c05-fig-0002){#c05.xhtml#rc05-fig-0002} shows a simple circuit with a power source and a resistor.

::: {#c05.xhtml#c05-fig-0002 .figure}
![9781119489542-fg0502.png](https://i.imgur.com/DnECDsg.jpeg){.center}
:::

In many situations, you will know the voltage of your power supply and the value of the resistor, so you can first calculate the current of the circuit as follows:

::: {#c05.xhtml#c05-disp-0004 .equation}
![](m:math>-->`{=html})`<!--<m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:mrow><m:mi mathvariant="normal">I</m:mi><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mi mathvariant="normal">V</m:mi><m:mo>/</m:mo><m:mi mathvariant="normal">R</m:mi><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mn>4.5</m:mn><m:mi mathvariant="normal">V</m:mi><m:mo>/</m:mo><m:mn>150</m:mn><m:mi>&#937;</m:mi><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mn>0.03</m:mn><m:mi mathvariant="normal">A</m:mi></m:mrow></m:math>-->`{=html}
:::

This equation works in any order you want to put the values:

::: {#c05.xhtml#c05-disp-0005 .equation}
![](m:math>-->`{=html})`<!--<m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:mrow><m:mtable columnalign="left"><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:mi mathvariant="normal">R</m:mi><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mi mathvariant="normal">V</m:mi><m:mo>/</m:mo><m:mi mathvariant="normal">I</m:mi><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mn>4.5</m:mn><m:mi mathvariant="normal">V</m:mi><m:mo>/</m:mo><m:mn>0.03</m:mn><m:mi mathvariant="normal">A</m:mi><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mn>150</m:mn><m:mi>&#937;</m:mi></m:mrow></m:mtd></m:mtr><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:mi mathvariant="normal">V</m:mi><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mi mathvariant="normal">I</m:mi><m:mo>&#215;</m:mo><m:mi mathvariant="normal">R</m:mi><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mn>0.03</m:mn><m:mi mathvariant="normal">A</m:mi><m:mo>&#215;</m:mo><m:mn>150</m:mn><m:mi>&#937;</m:mi><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mn>4.5</m:mn><m:mi mathvariant="normal">V</m:mi></m:mrow></m:mtd></m:mtr></m:mtable></m:mrow></m:math>-->`{=html}
:::

The easiest way to remember Ohm's Law is as a pyramid (see [Figure 5-3](#c05.xhtml#c05-fig-0003){#c05.xhtml#rc05-fig-0003}). By eliminating any one element from the pyramid, you are left with the equation.

::: {#c05.xhtml#c05-fig-0003 .figure}
![9781119489542-fg0503.png](https://i.imgur.com/cZf4tjj.jpeg){.center}
:::

"But how is this calculation useful to me in the context of Arduino?" I hear you cry. Here's a practical example that you might run into in a basic Arduino circuit.

The digital pins on an Arduino can supply up to 5V, so this is the most common supply of power that you use. An LED is one of the most basic outputs you want to control, and a fairly standard LED requires a voltage of 2V and about 30 milliamps or 30mA (0.03A) of current.

[]{#c05.xhtml#Page_73 .pagebreak role="doc-pagebreak" title="73"}If you were to plug in the LED directly to the power supply, you would promptly witness a bright light followed by a plume of smoke and a burning smell. You're not likely to want that! To make sure that you can use the LED again and again safely, you should add a resistor.

Ohm's Law tells you that

::: {#c05.xhtml#c05-disp-0006 .equation}
![](m:math>-->`{=html})`<!--<m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:mrow><m:mi mathvariant="normal">R</m:mi><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mi mathvariant="normal">V</m:mi><m:mo>/</m:mo><m:mi mathvariant="normal">I</m:mi></m:mrow></m:math>-->`{=html}
:::

But you also have to include two different voltage values, the voltage of the power supply (supply voltage) and the voltage required to power the LED (forward voltage). *Forward voltage,* a term that is often found in datasheets, especially when referring to diodes, indicates the recommended amount of voltage that the component can take in the direction that the current is intended to flow. For LEDs, this direction is from anode to cathode, with the anode connected to positive and the cathode to negative.

When referring to non-light-emitting diodes (covered in [Chapter 7](#c07.xhtml)), you\'re using them to resist the flow of current in the opposite direction, from cathode to anode. In this case, the term is *reverse voltage*, which indicates the value in volts that the circuit must exceed for current to flow through the diode.

In this case, the voltages are labelled V~SUPPLY~ and V~FORWARD,~ respectively. The Ohm's Law equation requires the voltage across the resistor (voltage that passes through the resistor), which is equal to the supply voltage minus the LED forward voltage, or

::: {#c05.xhtml#c05-disp-0007 .equation}
![](m:math>-->`{=html})`<!--<m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:mrow><m:msub><m:mi mathvariant="normal">V</m:mi><m:mrow><m:mi mathvariant="normal">SUPPLY</m:mi></m:mrow></m:msub><m:mo>&#45;</m:mo><m:msub><m:mi mathvariant="normal">V</m:mi><m:mrow><m:mi mathvariant="normal">FORWARD</m:mi></m:mrow></m:msub></m:mrow></m:math>-->`{=html}
:::

The new equation looks like this:

::: {#c05.xhtml#c05-disp-0008 .equation}
![](m:math>-->`{=html})`<!--<m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:mrow><m:mi mathvariant="normal">R</m:mi><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mrow><m:mo>(</m:mo><m:mrow><m:msub><m:mi mathvariant="normal">V</m:mi><m:mrow><m:mi mathvariant="normal">SUPPLY</m:mi></m:mrow></m:msub><m:mo>&#45;</m:mo><m:msub><m:mi mathvariant="normal">V</m:mi><m:mrow><m:mi mathvariant="normal">FORWARD</m:mi></m:mrow></m:msub></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>/</m:mo><m:mi mathvariant="normal">I</m:mi><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mrow><m:mo>(</m:mo><m:mrow><m:mn>5</m:mn><m:mi mathvariant="normal">V</m:mi><m:mo>&#45;</m:mo><m:mn>2</m:mn><m:mi mathvariant="normal">V</m:mi></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>/</m:mo><m:mn>0.03</m:mn><m:mi mathvariant="normal">A</m:mi><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mn>100</m:mn><m:mi>&#937;</m:mi></m:mrow></m:math>-->`{=html}
:::

This tells you that you need a 100-ohm resistor to power an LED safely; the example circuit is shown in [Figure 5-4](#c05.xhtml#c05-fig-0004){#c05.xhtml#rc05-fig-0004}.

::: {#c05.xhtml#c05-fig-0004 .figure}
![9781119489542-fg0504.png](https://i.imgur.com/yTPbdWI.jpeg){.center}
:::
:::

::: {.section}
[]{#c05.xhtml#c05-sec-0005}

### Calculating power {#c05.xhtml#h3-2 .Heading-2}

To calculate the power consumption of your circuit in watts, you multiply the voltage and current of the circuit. The equation is

::: {#c05.xhtml#c05-disp-0009 .equation}
![](m:math>-->`{=html})`<!--<m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:mrow><m:mi mathvariant="normal">P</m:mi><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mi mathvariant="normal">V</m:mi><m:mo>&#215;</m:mo><m:mi mathvariant="normal">I</m:mi></m:mrow></m:math>-->`{=html}
:::

If you apply this equation to the same circuit as the example in the "[Ohm's Law](#c05.xhtml#c05-sec-0004)" section, earlier in this chapter, you can calculate its power:

::: {#c05.xhtml#c05-disp-0010 .equation}
![](m:math>-->`{=html})`<!--<m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:mrow><m:mi mathvariant="normal">P</m:mi><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mo stretchy="false">(</m:mo><m:msub><m:mi mathvariant="normal">V</m:mi><m:mrow><m:mi mathvariant="normal">SUPPLY</m:mi></m:mrow></m:msub><m:mo>&#45;</m:mo><m:msub><m:mi mathvariant="normal">V</m:mi><m:mrow><m:mi mathvariant="normal">FORWARD</m:mi></m:mrow></m:msub><m:mo stretchy="false">)</m:mo><m:mo>&#215;</m:mo><m:mi mathvariant="normal">I</m:mi><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mo stretchy="false">(</m:mo><m:mn>5</m:mn><m:mi mathvariant="normal">V</m:mi><m:mo>&#45;</m:mo><m:mn>2</m:mn><m:mi mathvariant="normal">V</m:mi><m:mo stretchy="false">)</m:mo><m:mo>&#215;</m:mo><m:mn>0.03</m:mn><m:mi mathvariant="normal">A</m:mi><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mn>0.09</m:mn><m:mi mathvariant="normal">W</m:mi></m:mrow></m:math>-->`{=html}
:::

[]{#c05.xhtml#Page_74 .pagebreak role="doc-pagebreak" title="74"}

This algebra works in the same way as Ohm's Law and can be reconfigured to find the missing value:

::: {#c05.xhtml#c05-disp-0011 .equation}
![](m:math>-->`{=html})`<!--<m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:mrow><m:mtable><m:mtr><m:mtd><m:mrow><m:mi mathvariant="normal">V</m:mi><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mi mathvariant="normal">P</m:mi><m:mo>/</m:mo><m:mi mathvariant="normal">I</m:mi></m:mrow></m:mtd></m:mtr><m:mtr><m:mtd><m:mrow><m:mi mathvariant="normal">I</m:mi><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mi mathvariant="normal">P</m:mi><m:mo>/</m:mo><m:mi mathvariant="normal">V</m:mi></m:mrow></m:mtd></m:mtr></m:mtable></m:mrow></m:math>-->`{=html}
:::

This calculation is useful because some types of hardware, such as a light bulb, show only the power and voltage rating, leaving you to figure out the current draw. The calculation is especially useful if you are trying (or failing) to run power-hungry devices, such as lighting or motors, off your Arduino pins. A USB-powered Arduino is capable of supplying 500mA of current, but an Arduino Uno can supply only a maximum of 40mA per pin *and* 200mA total from all the pins being used, which is not much at all. (You can find more details at [[`http://playground.arduino.cc/Main/ArduinoPinCurrentLimitations`]{.Code-within-text}](http://playground.arduino.cc/Main/ArduinoPinCurrentLimitations).).

This calculation is simple, but you can combine it with your knowledge of Ohm's Law to fill in the blanks in a number of different circuits.
:::

::: {.section}
[]{#c05.xhtml#c05-sec-0006}

### Joule's Law {#c05.xhtml#h3-3 .Heading-2}

Another man who gave his name to an equation was James Prescott Joule. Although not as well known as Georg Simon Ohm, he discovered a similar and perhaps complementary mathematical relationship between power, current, and resistance in a circuit.

[]{#c05.xhtml#Page_75 .pagebreak role="doc-pagebreak" title="75"}Joule's Law is written like so:

::: {#c05.xhtml#c05-disp-0012 .equation}
![](m:math>-->`{=html})`<!--<m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:mrow><m:mi mathvariant="normal">P</m:mi><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:msup><m:mi mathvariant="normal">I</m:mi><m:mn>2</m:mn></m:msup><m:mi mathvariant="normal">R</m:mi></m:mrow></m:math>-->`{=html}
:::

The best way to understand it is to look at how you arrive at it.

::: {#c05.xhtml#c05-disp-0013 .equation}
![](m:math>-->`{=html})`<!--<m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:mrow><m:mtable columnalign="left"><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:mi>I</m:mi><m:mi>f</m:mi><m:mo>,</m:mo></m:mrow></m:mtd><m:mtd columnalign="left"><m:mrow><m:mi mathvariant="normal">V</m:mi><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mi mathvariant="normal">I</m:mi><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mo>&#215;</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mi mathvariant="normal">R</m:mi><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mrow><m:mo>(</m:mo><m:mrow><m:mi mathvariant="normal">Ohm's&#160;Law</m:mi></m:mrow><m:mo>)</m:mo></m:mrow><m:mi mathvariant="normal">&#160;and&#160;P</m:mi><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mo>=</m:mo><m:mi mathvariant="normal">I</m:mi><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mo>&#215;</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mi mathvariant="normal">R&#160;</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:mi mathvariant="normal">Power&#160;Calculation</m:mi></m:mrow><m:mo>)</m:mo></m:mrow></m:mrow></m:mtd></m:mtr><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:mi>T</m:mi><m:mi>h</m:mi><m:mi>e</m:mi><m:mi>n</m:mi><m:mo>,</m:mo></m:mrow></m:mtd><m:mtd columnalign="left"><m:mrow><m:mi mathvariant="normal">P</m:mi><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mi mathvariant="normal">I</m:mi><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mo>&#215;</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mrow><m:mo>(</m:mo><m:mrow><m:mi mathvariant="normal">I</m:mi><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mo>&#215;</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mi mathvariant="normal">R</m:mi></m:mrow><m:mo>)</m:mo></m:mrow></m:mrow></m:mtd></m:mtr></m:mtable></m:mrow></m:math>-->`{=html}
:::

Which can also be written as

::: {#c05.xhtml#c05-disp-0014 .equation}
![](m:math>-->`{=html})`<!--<m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:mrow><m:mi mathvariant="normal">P</m:mi><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:msup><m:mi mathvariant="normal">I</m:mi><m:mn>2</m:mn></m:msup><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mo>&#215;</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mi mathvariant="normal">R</m:mi></m:mrow></m:math>-->`{=html}
:::

If this equation is applied to the circuit in [Figure 5-2](#c05.xhtml#c05-fig-0002), you can discover the power consumption of the circuit:

::: {#c05.xhtml#c05-disp-0015 .equation}
![](m:math>-->`{=html})`<!--<m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:mrow><m:mi mathvariant="normal">P</m:mi><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:msup><m:mi mathvariant="normal">I</m:mi><m:mn>2</m:mn></m:msup><m:mo>&#215;</m:mo><m:mi mathvariant="normal">R</m:mi><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mrow><m:mo>(</m:mo><m:mrow><m:mn>0.03</m:mn><m:mi mathvariant="normal">A</m:mi><m:mo>&#215;</m:mo><m:mn>0.03</m:mn><m:mi mathvariant="normal">A</m:mi></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>&#215;</m:mo><m:mn>100</m:mn><m:mi>&#937;</m:mi><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mn>0.09</m:mn><m:mi mathvariant="normal">W</m:mi></m:mrow></m:math>-->`{=html}
:::

This calculation tallies with our previous power calculation. You can calculate the power knowing only the current and resistance, or any combination of the three (power, current, and resistance).

::: {#c05.xhtml#c05-disp-0016 .equation}
![](m:math>-->`{=html})`<!--<m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:mrow><m:mtable columnalign="left"><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:mi mathvariant="normal">I</m:mi><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mi mathvariant="normal">P</m:mi><m:mo>/</m:mo><m:mrow><m:mo>(</m:mo><m:mrow><m:mi mathvariant="normal">I</m:mi><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mo>&#215;</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mi mathvariant="normal">R</m:mi></m:mrow><m:mo>)</m:mo></m:mrow></m:mrow></m:mtd></m:mtr><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:mi mathvariant="normal">R</m:mi><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mi mathvariant="normal">P</m:mi><m:mo>/</m:mo><m:msup><m:mi mathvariant="normal">I</m:mi><m:mn>2</m:mn></m:msup></m:mrow></m:mtd></m:mtr></m:mtable></m:mrow></m:math>-->`{=html}
:::

You can also do the same calculation for situations where you know only the voltage and resistance:

::: {#c05.xhtml#c05-disp-0017 .equation}
![](m:math>-->`{=html})`<!--<m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:mrow><m:mtable columnalign="left"><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:mi>I</m:mi><m:mi>f</m:mi><m:mo>,</m:mo></m:mrow></m:mtd><m:mtd columnalign="left"><m:mrow><m:mi mathvariant="normal">I</m:mi><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mi mathvariant="normal">V</m:mi><m:mo>/</m:mo><m:mi mathvariant="normal">R</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:mi mathvariant="normal">Ohm's&#160;Law</m:mi></m:mrow><m:mo>)</m:mo></m:mrow><m:mi mathvariant="normal">&#160;and&#160;P</m:mi><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mi mathvariant="normal">I</m:mi><m:mo>/</m:mo><m:mi mathvariant="normal">V</m:mi><m:mrow><m:mo>(</m:mo><m:mrow><m:mi mathvariant="normal">Power&#160;Calculation</m:mi></m:mrow><m:mo>)</m:mo></m:mrow></m:mrow></m:mtd></m:mtr><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:mi>T</m:mi><m:mi>h</m:mi><m:mi>e</m:mi><m:mi>n</m:mi><m:mo>,</m:mo></m:mrow></m:mtd><m:mtd columnalign="left"><m:mrow><m:mi mathvariant="normal">P</m:mi><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:mrow><m:mo>(</m:mo><m:mrow><m:mi mathvariant="normal">V</m:mi><m:mo>/</m:mo><m:mi mathvariant="normal">R</m:mi></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>*</m:mo><m:mi mathvariant="normal">V</m:mi></m:mrow></m:mtd></m:mtr></m:mtable></m:mrow></m:math>-->`{=html}
:::

Which can also be written as

::: {#c05.xhtml#c05-disp-0018 .equation}
![](m:math>-->`{=html})`<!--<m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:mrow><m:mi mathvariant="normal">P</m:mi><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:msup><m:mi mathvariant="normal">V</m:mi><m:mn>2</m:mn></m:msup><m:mo>/</m:mo><m:mi mathvariant="normal">R</m:mi></m:mrow></m:math>-->`{=html}
:::

Try the same circuit again to check the results:

::: {#c05.xhtml#c05-disp-0019 .equation}
![](m:math>-->`{=html})`<!--<m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:mrow><m:mo stretchy="false">(</m:mo><m:mo stretchy="false">(</m:mo><m:mn>5</m:mn><m:mi mathvariant="normal">V</m:mi><m:mo>&#45;</m:mo><m:mn>2</m:mn><m:mi mathvariant="normal">V</m:mi><m:mo stretchy="false">)</m:mo><m:mo>*</m:mo><m:mo stretchy="false">(</m:mo><m:mn>5</m:mn><m:mi mathvariant="normal">V</m:mi><m:mo>&#45;</m:mo><m:mn>2</m:mn><m:mi mathvariant="normal">V</m:mi><m:mo stretchy="false">)</m:mo><m:mo stretchy="false">)</m:mo><m:mo>/</m:mo><m:mn>100</m:mn><m:mi>&#937;</m:mi><m:mo>=</m:mo><m:mn>0.09</m:mn><m:mi mathvariant="normal">W</m:mi></m:mrow></m:math>-->`{=html}
:::

This equation can also be rearranged into any combination, depending on which values you know:

::: {#c05.xhtml#c05-disp-0020 .equation}
![](m:math>-->`{=html})`<!--<m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:mrow><m:mtable><m:mtr><m:mtd><m:mrow><m:mi mathvariant="normal">V</m:mi><m:mo>=</m:mo><m:mi mathvariant="normal">P</m:mi><m:mo>/</m:mo><m:mrow><m:mo>(</m:mo><m:mrow><m:mi mathvariant="normal">V</m:mi><m:mo>*</m:mo><m:mi mathvariant="normal">R</m:mi></m:mrow><m:mo>)</m:mo></m:mrow></m:mrow></m:mtd></m:mtr><m:mtr><m:mtd><m:mrow><m:mi mathvariant="normal">R</m:mi><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:m:mspace width="0.25em"/><m:msup><m:mi mathvariant="normal">V</m:mi><m:mn>2</m:mn></m:msup><m:mo>/</m:mo><m:mi mathvariant="normal">P</m:mi></m:mrow></m:mtd></m:mtr></m:mtable></m:mrow></m:math>-->`{=html}
:::

Many Arduinists, myself included, are more practical than theoretical, attempting to build the circuit based on examples and documentation before doing the sums. This approach is perfectly all right and in the spirit of Arduino! In most cases, your circuit will have the desired outcome. However, with these few equations, it's possible to fill in the blanks in most circuits and ensure that everything is in order.
:::
:::

::: {.section}
[]{#c05.xhtml#Page_76 .pagebreak role="doc-pagebreak" title="76"}[]{#c05.xhtml#c05-sec-0007}

## Working with Circuit Diagrams {#c05.xhtml#h2-3 .Heading-1}

Recreating circuits from photos or illustrations can be difficult, and for that reason, standardized symbols are used to represent the variety of components and connections in a circuit. These *circuit diagrams* are like maps of the subway system: They show you every connection clearly but have little resemblance to the way things look or connect in the physical world. The following sections delve a bit more into circuit diagrams.

::: {.section}
[]{#c05.xhtml#c05-sec-0008}

### A simple circuit diagram {#c05.xhtml#h3-4 .Heading-2}

This section looks at a basic light switch circuit made up of four components: a battery, a pushbutton, a resistor, and an LED, as shown in [Figure 5-5](#c05.xhtml#c05-fig-0005){#c05.xhtml#rc05-fig-0005}.

::: {#c05.xhtml#c05-fig-0005 .figure}
![9781119489542-fg0505.png](https://i.imgur.com/OUSdwJ5.jpeg){.center}
:::

[Table 5-1](#c05.xhtml#c05-tbl-0001){#c05.xhtml#rc05-tbl-0001} shows the individual symbols for each component.

![9781119489542-ma001.png](https://i.imgur.com/rzmZpV9.jpeg){.center}

[Figure 5-6](#c05.xhtml#c05-fig-0006){#c05.xhtml#rc05-fig-0006} shows the same circuit laid out on a breadboard. The first thing you may notice is that this example has no battery. Because your Arduino has a 5V pin and a GND pin, these take the place of the positive (+) and negative (--) of the battery and allow you make the same circuit. The second thing you may notice is that the circuit uses a pushbutton and, therefore, is not technically a light *switch*. Many pushbuttons are made to fit a breadboard, which is more convenient.

::: {#c05.xhtml#c05-fig-0006 .figure}
![9781119489542-fg0506.png](https://i.imgur.com/DXoyBUK.jpeg){.center}
:::

I find that the best way to compare a circuit diagram to the actual circuit is to follow the connections from positive to negative.

If you start at the positive (+) 5V pin on the Arduino, it leads to the pushbutton. The physical pushbutton has four legs, whereas the symbol has only two. The legs of the physical pushbutton are mirrored so that two are connected on one side and two on the other. For this reason, it's important to get the orientation of the pushbutton right. The physical switch has four legs to make it more versatile, but as far as the circuit diagram is concerned, there is only one switch with one line in and one line out.

[]{#c05.xhtml#Page_78 .pagebreak role="doc-pagebreak" title="78"}The other side of the pushbutton is connected to a resistor. Other than the fact that the resistor symbol in the diagram is not as bulbous as the physical resistor, the diagram and physical resistor match up well; one wire goes into the resistor and another goes out. The value of the resistor is written alongside the component, as opposed to the color-coded stripes on the physical one. Resistors do not have polarity (no positive or negative), so there is nothing else to show.

An LED, by contrast, does have a polarity. If you connect it the wrong way around, it won't illuminate. In the circuit diagram, the polarity of the LED is marked by the triangle in the symbol, pointing in the direction of the current flow from + (anode) to -- (cathode), with a horizontal line as a barrier in the other direction. On the physical LED, a long leg marks the anode (+) and the flat section on the side of the lens marks the cathode (--),in case the legs are chopped off. See [Figure 5-7](#c05.xhtml#c05-fig-0007){#c05.xhtml#rc05-fig-0007}.

::: {#c05.xhtml#c05-fig-0007 .figure}
![9781119489542-fg0507.png](https://i.imgur.com/fT8WJWx.jpeg){.center}
:::

The -- (cathode) of the LED is connected to the negative (--) GND pin on the Arduino and then to the negative terminal of the battery to complete the circuit.
:::

::: {.section}
[]{#c05.xhtml#c05-sec-0009}

### Using a circuit diagram with an Arduino {#c05.xhtml#h3-5 .Heading-2}

Although it's useful to understand the simple circuit in [Figure 5-6](#c05.xhtml#c05-fig-0006), you will most likely be using an Arduino in your circuit somewhere, so take a look again at the same circuit powered from an Arduino (see [Figure 5-8](#c05.xhtml#c05-fig-0008){#c05.xhtml#rc05-fig-0008}).

::: {#c05.xhtml#c05-fig-0008 .figure}
![9781119489542-fg0508.png](https://i.imgur.com/lsjLHEi.jpeg){.center}
:::

This circuit has more components than the circuit described in the previous section.

The Arduino is on the left in the diagram. This symbol is standard for an integrated circuit and is similar to its physical representation --- a rectangle with lots of legs poking out. All the legs or pins are labeled so that you can tell them apart.

[]{#c05.xhtml#Page_79 .pagebreak role="doc-pagebreak" title="79"}Also, rather than have one circuit, the diagram shows two, each running back to the Arduino, to illustrate how the Arduino fits in with conventional circuits. Instead of switching the power on and off, you're sending a signal to the Arduino, which interprets it and outputs it to the LED.

Here is a great practice to adopt when you have a complicated circuit: Rather than tackle it as a whole, break it up into its components. This circuit has one input circuit and one output. I describe this circuit in more depth in [Chapter 6](#c06.xhtml).
:::
:::

::: {.section}
[]{#c05.xhtml#c05-sec-0010}

## Color-Coding {#c05.xhtml#h2-4 .Heading-1}

An important technique in electronics is color-coding, and it becomes even more important as you progress to more complex circuits. Wiring circuits correctly can be hard enough, but staring at a sea of same-colored wires makes the task infinitely harder.

You're probably aware of color-coding even if you're new to electronics. Traffic lights, for example, are color coded to give drivers a clear message of what to do:

-   [Green means proceed.]{#c05.xhtml#c05-li-0013}
-   [Amber means prepare to stop.]{#c05.xhtml#c05-li-0014}
-   [Red means stop.]{#c05.xhtml#c05-li-0015}

[]{#c05.xhtml#Page_80 .pagebreak role="doc-pagebreak" title="80"}Color-coding is a quick and easy way to visually get a message across without lots of words.

All sorts of electrical applications, such as the 120v or 240v plugs and sockets in your home, are color-coded. Because plugs and sockets are widely used and potentially dangerous, the colors need to be consistent from plug to plug and match national standards. This color-coding makes it easy for any electrician or DIY enthusiast to make the correct connections.

Because you will be working with low-voltage DC electronics, you have less potential for causing yourself serious harm, but you still have great potential for destroying the delicate components in your circuit. No definitive rules exist for organizing your circuit, but here are a few conventions that can help you and others know what's going on:

-   [Red is positive (+).]{#c05.xhtml#c05-li-0016}
-   [Black is negative (--).]{#c05.xhtml#c05-li-0017}
-   [Different colors are used for different signal pins.]{#c05.xhtml#c05-li-0018}

These conventions are true on most breadboard circuits. Power and ground colors can change; for example, they can be white (+) and black (--) or brown (+) and blue (--), sometimes depending on the wire that is available to the person. As long as you use a color-coding system of some sort (and it's consistent), reading, copying, and fixing the circuit will be easier.

I've fixed many circuits that were broken because of the simple error of connecting the wires to the wrong places.

If the color-coding of the wire is ever questionable, check the connection (using the continuity checker on your multimeter) or the voltage running through the wire (using the voltage meter on your multimeter) to make sure that everything is as expected.
:::

::: {.section}
[]{#c05.xhtml#c05-sec-0011}

## Datasheets {#c05.xhtml#h2-5 .Heading-1}

Picture the scene. Your friend has heard that you know a bit of electronics and has asked you to look at a circuit, copied from the Internet, that isn't working. But the board has lots of nondescript integrated circuits, so what do you do? The answer: Google!

The world contains millions, if not billions, of different components. The information you need to make sense of them is normally presented in the form of a *[]{#c05.xhtml#Page_81 .pagebreak role="doc-pagebreak" title="81"}datasheet.* Every component should have a datasheet, provided by the manufacturer, that lists every detail of the component (often more detail than you need).

The easiest way to find a datasheet is to Google it. To find the right one, you need to know as much about the component as you can find out. The most important information for search purposes is the model number of the component. [Figure 5-9](#c05.xhtml#c05-fig-0009){#c05.xhtml#rc05-fig-0009} shows the model number of a transistor: P2N2 222A B01. If you Google that number plus the word *datasheet*, you should locate numerous PDF files that provide details about the component. If you can't find a model or part number, try to find it out from the place where you purchased the component.

::: {#c05.xhtml#c05-fig-0009 .figure}
![9781119489542-fg0509.png](https://i.imgur.com/EY5BVtO.jpeg){.center}
:::
:::

::: {.section}
[]{#c05.xhtml#c05-sec-0012}

## Resistor Color Charts {#c05.xhtml#h2-6 .Heading-1}

Resistors are extremely important to Arduino projects, and you can find a great variety of them to allow you to finely tune your circuit. Resistors can also be extremely small, making it impossible to write the resistance value on the resistor. For this reason, a color chart system exists to tell you what you need to know about these tiny components. If you take a close look at a resistor, such as the one in [Figure 5-10](#c05.xhtml#c05-fig-0010){#c05.xhtml#rc05-fig-0010}, you can see a number of colored bands, which indicate the value in ohms of the resistor.

::: {#c05.xhtml#c05-fig-0010 .figure}
![9781119489542-fg0510.png](https://i.imgur.com/oiqpvHW.jpeg){.center}
:::

A standard resistor has four bands that represent the following:

-   [First digit]{#c05.xhtml#c05-li-0019}
-   [Second digit]{#c05.xhtml#c05-li-0020}
-   [Multiplier]{#c05.xhtml#c05-li-0021}
-   [Tolerance]{#c05.xhtml#c05-li-0022}

![tip.png](https://i.imgur.com/3NjZh9N.jpeg) Resistors are small and some colors can be difficult to distinguish unless you have extremely good vision. You can use a magnifying glass or smartphone camera to see the colors of the bands more clearly.

[Table 5-2](#c05.xhtml#c05-tbl-0002){#c05.xhtml#rc05-tbl-0002} lists the value in ohms, the multiplier, and the tolerance value that each color represents. First, you need to know the order in which to read the bands. Normally, you will see an equal-sized gap between the first three bands and a larger gap separating the fourth tolerance band.

```{=html}
<figure>
```
```{=html}
<figcaption>
```
[[]{#c05.xhtml#Page_83 .pagebreak role="doc-pagebreak" title="83"}TABLE 5-2](#c05.xhtml#rc05-tbl-0002) Resistor Color Chart

```{=html}
</figcaption>
```
  **Color**   **Value**   **Multiplier**   **Tolerance**
  ----------- ----------- ---------------- ---------------
  Black       0           x10^0^           --
  Brown       1           x10^1^           ±1%
  Red         2           x10^2^           ±2%
  Orange      3           x10^3^           --
  Yellow      4           x10^4^           ±5%
  Green       5           x10^5^           ±0.5%
  Blue        6           x10^6^           ±0.25%
  Violet      7           x10^7^           ±0.1%
  Gray        8           x10^8^           ±0.05%
  White       9           x10^9^           --
  Gold        --          x10^--1^         ±5%
  Silver      --          x10^--2^         ±10%
  None        --          --               ±20%

```{=html}
</figure>
```
For example, here a few values you might find in your kit:

-   [Orange (3), Orange (3), Brown (x10^1^), Gold ![](m:math>-->`{=html} ohms with ±5% tolerance]{#c05.xhtml#c05-li-0023})`<!--<m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:mrow><m:mrow><m:mo>(</m:mo><m:mrow><m:mo>&#177;</m:mo><m:mn>5</m:mn><m:mi>&#37;</m:mi></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mn>33</m:mn><m:mo>*</m:mo><m:mn>10</m:mn><m:mo>=</m:mo><m:mn>330</m:mn></m:mrow></m:math>-->`{=html} ohms with ±5% tolerance]{#c05.xhtml#c05-li-0023}
-   [Red (2), Red (2), Red (x10^2^), Gold ![](m:math>-->`{=html} ohms ±5% tolerance]{#c05.xhtml#c05-li-0024})`<!--<m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:mrow><m:mrow><m:mo>(</m:mo><m:mrow><m:mo>&#177;</m:mo><m:mn>5</m:mn><m:mi>&#37;</m:mi></m:mrow><m:mo>)</m:mo></m:mrow><m:m:mspace width="0.25em"/><m:mo>=</m:mo><m:m:mspace width="0.25em"/><m:mn>22</m:mn><m:mo>*</m:mo><m:mn>10</m:mn><m:mo>*</m:mo><m:mn>10</m:mn><m:mo>=</m:mo><m:mn>2.2</m:mn><m:mi mathvariant="normal">K</m:mi></m:mrow></m:math>-->`{=html} ohms ±5% tolerance]{#c05.xhtml#c05-li-0024}
-   [Brown (1), Black (0), Orange (x10^3^), Gold ![](m:math>-->`{=html} ohms ±5% tolerance]{#c05.xhtml#c05-li-0025})`<!--<m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:mrow><m:mrow><m:mo>(</m:mo><m:mrow><m:mo>&#177;</m:mo><m:mn>5</m:mn><m:mi>&#37;</m:mi></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mn>10</m:mn><m:mo>*</m:mo><m:mn>10</m:mn><m:mo>*</m:mo><m:mn>10</m:mn><m:mo>*</m:mo><m:mn>10</m:mn><m:mo>=</m:mo><m:mn>10</m:mn><m:mi mathvariant="normal">K</m:mi></m:mrow></m:math>-->`{=html} ohms ±5% tolerance]{#c05.xhtml#c05-li-0025}

Seeing the colors and sometimes even telling which end to start reading from can be difficult. So, in most situations, it's best to use a multimeter to check the value of your resistor in ohms. (Remember to set the dial on your multimeter to ohm, or Ω.)

![tip.png](https://i.imgur.com/R38t4O6.jpeg) Resistors of the same value are often supplied on a reel of paper tape that holds the resistors together in a kind of ladder. This arrangement enables machines to feed in a reel of resistors in an orderly fashion before placing them on a PCB. If you write the value of that reel of resistors, you won\'t have to spend time reading or measuring the resistors each time you use them.
:::

[]{#c06.xhtml}

[]{#c06.xhtml#Page_85 .pagebreak role="doc-pagebreak" title="85"}Chapter 6

# Basic Sketches: Inputs, Outputs, and Communication {#c06.xhtml#a1 .Chap-Title}

::: {.section}
[]{#c06.xhtml#c06-sec-0001}[]{#c06.xhtml#c06-feafxd-0001}

IN THIS CHAPTER

![check.png](https://i.imgur.com/JGVhFYj.jpeg) **Fading like a pro**

![check.png](https://i.imgur.com/QyI9tZI.jpeg) **Understanding inputs**

![check.png](https://i.imgur.com/rzY5X1m.jpeg) **Varying resistances with potentiometers**

![check.png](https://i.imgur.com/qneqlK6.jpeg) **Showing off your stats with the serial monitor**

In this chapter, I discuss some of the basic sketches needed to get you on your Arduino feet. This chapter covers a broad range of inputs and outputs using the sensors in your kit. If you don't yet have a kit, I suggest reading through [Chapter 2](#c02.xhtml) to find one of the recommended ones.

The Blink sketch (described in [Chapter 3](#c03.xhtml)) gives you the basis of an Arduino sketch. This chapter expands it by adding circuits to your Arduino. I walk you through building circuits using a breadboard, as mentioned in [Chapter 4](#c04.xhtml), and introduce a few new components from your kit.

I detail uploading the appropriate code to your Arduino, walk you through each sketch line by line, and suggest tweaking the code yourself to gain a better understanding of it.
:::

::: {.section}
[]{#c06.xhtml#Page_86 .pagebreak role="doc-pagebreak" title="86"}[]{#c06.xhtml#c06-sec-0002}

## Uploading a Sketch {#c06.xhtml#h2-1 .Heading-1}

Throughout this chapter and much of the book, you learn about a variety of circuits, each with their respective sketches. The content of the circuits and sketches can vary greatly and are detailed in each of the examples in this book. Before you get started, you need to know one simple process for uploading a sketch to an Arduino board.

Follow these steps to upload your sketch:

1.  ::: {#c06.xhtml#c06-li-0005}
    **Connect your Arduino using the USB cable.**

    The square end of the USB cable connects to your Arduino and the flat end connects to a USB port on your computer.
    :::

2.  ::: {#c06.xhtml#c06-li-0006}
    **Select your board type and serial port.**

    If you're using the Web IDE, it automatically detects the board type and port. You can find the full list of supported boards by clicking the board\'s drop-down menu and clicking Select Other Board and Port.

    Using the downloadable IDE requires a few steps. Select your board type by choosing Tools ⇒ Board ⇒ Arduino/Genuino Uno from the menu bar. You can find a list of all available serial ports by choosing Tools ⇒ Port ⇒ com*X* or /dev/tty.usbmodem*XXXXX,* where *X* is a sequentially or randomly assigned number.

    In Windows, if you have just connected your Arduino, the COM port will normally be the highest number, such as com 3 or com 15. Many devices can be listed on the COM port list, and if you plug in multiple Arduinos, each one will be assigned a new number.

    On macOS, the /dev/cu.usbmodem *number* will be randomly assigned and can vary in length, such as /dev/cu.usbmodem1421 or /dev/cu.usbmodem262471. Unless you have another Arduino connected, it should be the only one visible.
    :::

3.  ::: {#c06.xhtml#c06-li-0007}
    **Click the Verify button.**

    The Verify button is a check mark. Your code is checked to make sure that it can be understood by the IDE. Common mistakes such as typos will be highlighted.
    :::

4.  ::: {#c06.xhtml#c06-li-0008}
    **Click the Upload button (arrow).**

    The code is compiled and sent to the Arduino.
    :::

Now that you know how to upload a sketch, you should be suitably hungry for some more Arduino sketches. To help you understand the first sketch in this chapter, I first tell you about a technique called pulse-width modulation (PWM). The next section briefly describes PWM and prepares you for fading an LED.
:::

::: {.section}
[]{#c06.xhtml#Page_87 .pagebreak role="doc-pagebreak" title="87"}[]{#c06.xhtml#c06-sec-0003}

## Using Pulse-Width Modulation (PWM) {#c06.xhtml#h2-2 .Heading-1}

In [Chapter 2](#c02.xhtml), I mention that sending an analog value uses something called pulse-width modulation (PWM). This technique allows your Arduino, which is a digital device, to act like an analog device. In the following example, PWM allows you to fade an LED rather than just turn it on or off.

Here\'s how it works: A digital output is either on or off. But it can be turned on and off extremely quickly thanks in part to the miracle of silicon chips. If the output is on half the time and off half the time, it is described as having a 50 percent duty cycle. The *duty cycle* is the period of time during which the output is active, so that could be any percentage --- 20 percent, 30 percent, 40 percent, and so on.

When you're using LEDs as an output, the duty cycle has a special effect. Because the LED is blinking faster than the human eye can perceive, an LED with a 50 percent duty cycle looks as though it is at half brightness. This same effect allows you to perceive still images shown at 24 frames per second (or above) as a moving image.

With a DC motor as an output, a 50 percent duty cycle has the effect of moving the motor at half speed. In this case, PWM allows you to control the speed of a motor by pulsing it at an extremely fast rate.

So despite PWM's being a digital function, it is referred to as [`analogWrite`]{.Code-within-text} because of the perceived effect it has on components.
:::

::: {.section}
[]{#c06.xhtml#c06-sec-0004}

## The LED Fade Sketch {#c06.xhtml#h2-3 .Heading-1}

In this sketch, you make an LED fade on and off. In contrast to the sketch that resulted in a blinking LED in [Chapter 3](#c03.xhtml), you need some extra hardware to make the LED fade on and off.

For this project you need:

-   [An Arduino Uno]{#c06.xhtml#c06-li-0009}
-   [A breadboard]{#c06.xhtml#c06-li-0010}
-   [An LED]{#c06.xhtml#c06-li-0011}
-   [A resistor (greater than 120 ohm)]{#c06.xhtml#c06-li-0012}
-   [Jump wires]{#c06.xhtml#c06-li-0013}

[]{#c06.xhtml#Page_88 .pagebreak role="doc-pagebreak" title="88"}![warning.png](https://i.imgur.com/NuTdm7l.jpeg) It\'s always important to make sure that your circuit is not powered while you're making changes to it. You can easily make incorrect connections, potentially damaging the components. So before you begin, make sure that the Arduino is unplugged from your computer or any external power supply.

Lay out the circuit as shown in [Figure 6-1](#c06.xhtml#c06-fig-0001){#c06.xhtml#rc06-fig-0001}, which is a simple circuit like the one used for the Blink sketch in [Chapter 3](#c03.xhtml) but uses pin 9 instead of pin 13. Pin 9, unlike pin 13, is capable of pulse-width modulation, which is necessary to fade the LED. However, note that pin 9 requires a resistor to limit the amount of current supplied to the LED. (On pin 13, this resistor is included on the Arduino board itself.)

::: {#c06.xhtml#c06-fig-0001 .figure}
![9781119489542-fg0601.png](https://i.imgur.com/HLhjtbR.jpeg){.center}
:::

```{=html}
<aside>
```
::: {#c06.xhtml#c06-fea-0001 .sidebar}
# PUTTING UP RESISTANCE {.SB-Head}

[]{#c06.xhtml#c06-sec-0005}

As you learn in [Chapter 5](#c05.xhtml), calculating the correct resistance is important for a safe and long-lasting circuit. In the circuit you\'re building in this chapter, you are potentially supplying your LED with a source of 5V (volts), the maximum that a digital pin can supply. A typical LED such as those in your kit has an approximate maximum forward voltage of 2.1V (volts), so a resistor is needed to protect it. The LED draws a maximum current of approximately 25mA (milliamps). Using these figures, you can calculate the resistance (ohms):

::: {#c06.xhtml#c06-disp-0001 .equation}
![](m:math>-->`{=html})`<!--<m:math xmlns:m="http://www.w3.org/1998/Math/MathML"><m:mrow><m:mtable columnalign="left"><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:mi mathvariant="normal">R</m:mi><m:mo>=</m:mo><m:mrow><m:mo>(</m:mo><m:mrow><m:msub><m:mi mathvariant="normal">V</m:mi><m:mi mathvariant="normal">S</m:mi></m:msub><m:mo>&#45;</m:mo><m:msub><m:mi mathvariant="normal">V</m:mi><m:mi mathvariant="normal">L</m:mi></m:msub></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>/</m:mo><m:mi mathvariant="normal">I</m:mi></m:mrow></m:mtd></m:mtr><m:mtr columnalign="left"><m:mtd columnalign="left"><m:mrow><m:mi mathvariant="normal">R</m:mi><m:mo>=</m:mo><m:mrow><m:mo>(</m:mo><m:mrow><m:mn>5</m:mn><m:mo>&#45;</m:mo><m:mn>2.1</m:mn></m:mrow><m:mo>)</m:mo></m:mrow><m:mo>/</m:mo><m:mn>0.025</m:mn><m:mo>=</m:mo><m:mn>116</m:mn><m:mi mathvariant="normal">&#160;ohms</m:mi></m:mrow></m:mtd></m:mtr></m:mtable></m:mrow></m:math>-->`{=html}
:::

The nearest fixed resistor above this calculation that you can buy is 120 ohms (brown, red, brown), so you\'re in luck if you have one of those. If not, you can apply the rule of using the nearest resistor above this value. This resistor resists more voltage than the optimum, but your LED is safe and you can always switch out the resistor later when you want to make your project more permanent. Suitable values from various kits include 220Ω, 330Ω, and 560Ω.

You can always refer to [Chapter 5](#c05.xhtml) to find your resistor value on the color chart or use a multimeter to measure the value of your resistors. There are even smartphone apps that have resistor color charts (although this may be a source of great embarrassment and ridicule among friends).
:::

```{=html}
</aside>
```
The schematic in [Figure 6-2](#c06.xhtml#c06-fig-0002){#c06.xhtml#rc06-fig-0002} shows you the simple circuit connection. The digital pin, pin 9, is connected to the long leg of the LED; the short leg connects to the resistor, which goes on to ground, GND. In this circuit, the resistor can be either before or after the LED, as long as it is in the circuit.[]{#c06.xhtml#Page_89 .pagebreak role="doc-pagebreak" title="89"}

::: {#c06.xhtml#c06-fig-0002 .figure}
![9781119489542-fg0602.png](https://i.imgur.com/e4IcRjq.jpeg){.center}
:::

![tip.png](https://i.imgur.com/EZdjDXK.jpeg) It's always a good idea to *color code* your circuits --- that is, use various colors to distinguish one type of circuit from another. Doing so greatly helps keep things clear and can make problem solving much easier.

You should adhere to a few good standards. The most important areas to color code are power and ground. These are nearly always colored red and black, respectively, but you might occasionally see them as white and black as well, as mentioned in [Chapter 5](#c05.xhtml). The other type of connection is usually referred to as a *signal wire,* which is a wire that sends or receives an electrical signal between the Arduino and a component. Signal wires can be any color that is not the same as the power or ground color.

After you assemble your circuit, you need the appropriate software to use it. From the Arduino menu, choose File ⇒ Examples ⇒ 01.Basics  ⇒ Fade to call up the Fade sketch. The complete code for the Fade sketch follows:

[]{#c06.xhtml#c06-code-0001}[]{#c06.xhtml#c06-lntxt-0001}

`/*`{#c06.xhtml#c06-line-0001}

`  Fade`{#c06.xhtml#c06-line-0002}

` `{#c06.xhtml#c06-line-0003}

`  This example shows how to fade an LED on pin 9 using the analogWrite()`{#c06.xhtml#c06-line-0004}

`  function.`{#c06.xhtml#c06-line-0005}

` `{#c06.xhtml#c06-line-0006}

`The analogWrite() function uses PWM, so if you want to change the pin you're using, be sure to use another PWM capable pin. On most Arduino, the PWM pins are identified with a "~" sign, like ~3, ~5, ~6, ~9, ~10 and ~11.`{#c06.xhtml#c06-line-0007}

` `{#c06.xhtml#c06-line-0008}

`  This example code is in the public domain.`{#c06.xhtml#c06-line-0009}

` `{#c06.xhtml#c06-line-0010}

`  http://www.arduino.cc/en/Tutorial/Fade`{#c06.xhtml#c06-line-0011}

`*/`{#c06.xhtml#c06-line-0012}

` `{#c06.xhtml#c06-line-0013}

`int led = 9;           // the PWM pin the LED is attached to`{#c06.xhtml#c06-line-0014}

`int brightness = 0;    // how bright the LED is`{#c06.xhtml#c06-line-0015}

`int fadeAmount = 5;    // how many points to fade the LED by`{#c06.xhtml#c06-line-0016}

` `{#c06.xhtml#c06-line-0017}

`// the setup routine runs once when you press reset:`{#c06.xhtml#c06-line-0018}

`void setup() {`{#c06.xhtml#c06-line-0019}

`  // declare pin 9 to be an output:`{#c06.xhtml#c06-line-0020}

`  pinMode(led, OUTPUT);`{#c06.xhtml#c06-line-0021}

`}`{#c06.xhtml#c06-line-0022}

` `{#c06.xhtml#c06-line-0023}

`// the loop routine runs over and over again forever:`{#c06.xhtml#c06-line-0024}

`void loop() {`{#c06.xhtml#c06-line-0025}

`  // set the brightness of pin 9:`{#c06.xhtml#c06-line-0026}

`  analogWrite(led, brightness);`{#c06.xhtml#c06-line-0027}

` `{#c06.xhtml#c06-line-0028}

`  // change the brightness for next time through the loop:`{#c06.xhtml#c06-line-0029}

`  brightness = brightness + fadeAmount;`{#c06.xhtml#c06-line-0030}

` `{#c06.xhtml#c06-line-0031}

`  // reverse the direction of the fading at the ends of the fade:`{#c06.xhtml#c06-line-0032}

`  if (brightness <= 0 || brightness >= 255) {`{#c06.xhtml#c06-line-0033}

`    fadeAmount = -fadeAmount;`{#c06.xhtml#c06-line-0034}

`  }`{#c06.xhtml#c06-line-0035}

`  // wait for 30 milliseconds to see the dimming effect`{#c06.xhtml#c06-line-0036}

`  delay(30);`{#c06.xhtml#c06-line-0037}

`}`{#c06.xhtml#c06-line-0038}

Upload this sketch to your board following the instructions at the start of the chapter. If everything has uploaded successfully, the LED fades from off to full brightness and then back off again.

If you don't see any fading, double-check your wiring:

-   [Make sure that you're using the correct pin number.]{#c06.xhtml#c06-li-0014}
-   [Check that your LED is correctly situated, with the long leg connected by a wire to pin 9 and the short leg connected via the resistor and a wire to GND (ground).]{#c06.xhtml#c06-li-0015}
-   [Check the connections on the breadboard. If the jump wires or components are not connected using the correct rows in the breadboard, they will not work.]{#c06.xhtml#c06-li-0016}

::: {.section}
[]{#c06.xhtml#c06-sec-0006}

### Understanding the Fade sketch {#c06.xhtml#h3-1 .Heading-2}

By the light of your fading LED, take a look at how this sketch works.

The comments at the top of the sketch reveal exactly what's happening in this sketch: Using pin 9, a new function called [`analogWrite()`]{.Code-within-text} causes the LED to fade off and on. After the comments, three declarations appear:

[]{#c06.xhtml#c06-code-0002}[]{#c06.xhtml#c06-lntxt-0002}

`int led = 9;           // the PWM pin the LED is attached to`{#c06.xhtml#c06-line-0039}

`int brightness = 0;    // how bright the LED is`{#c06.xhtml#c06-line-0040}

`int fadeAmount = 5;    // how many points to fade the LED by`{#c06.xhtml#c06-line-0041}

"But what is a declaration?" I hear you ask. Read on to find out.
:::

::: {.section}
[]{#c06.xhtml#Page_92 .pagebreak role="doc-pagebreak" title="92"}[]{#c06.xhtml#c06-sec-0007}

### Declarations {#c06.xhtml#h3-2 .Heading-2}

*Declarations* (which aren't something you put up at Christmas, ho ho ho) are values stored for later use by the program. In this case, three variables are declared, but you could declare many other variables or even include libraries of code in your sketch. For now, just remember that variables are declared before the [`setup`]{.Code-within-text} function.
:::

::: {.section}
[]{#c06.xhtml#c06-sec-0008}

### Variables {#c06.xhtml#h3-3 .Heading-2}

*Variables* are values that can change depending on what the program does with them. In C, you can declare the type, name, and value of the variable before the main body of code, much as ingredients are listed at the start of a recipe:

[]{#c06.xhtml#c06-code-0003}[]{#c06.xhtml#c06-lntxt-0003}

`int led = 9;`{#c06.xhtml#c06-line-0042}

The first part sets the type of the variable, creating an integer ([`int`]{.Code-within-text}). An integer is a whole number, positive or negative, so no decimal places are required. Note that Arduino has lower and upper limits for the [`int`]{.Code-within-text} variable: -32,768 to 32,767. Beyond those limits, a different type of variable must be used, known as a [`long`]{.Code-within-text}. (You learn more about [`long`]{.Code-within-text} variables in [Chapter 10](#c10.xhtml).) For now, an [`int`]{.Code-within-text} will do just fine. The name of the variable is [`led`]{.Code-within-text} and is purely for reference; it can be any single word that\'s useful for figuring out what the variable applies to. Finally, the value of the variable is set to 9, which is the number of the pin that is being used.

Variables are especially useful when you refer to a value repeatedly. In this case, the variable is called [`led`]{.Code-within-text} because it refers to the pin to which the physical LED is attached. Now, every time you want to refer to pin 9, you can write [`led`]{.Code-within-text} instead. Although this approach may seem like extra work initially, if you decided to change the pin to, say, pin 11, you would need to change only the variable at the start; every subsequent mention of [`led`]{.Code-within-text} would automatically be updated. That\'s a big timesaver over having to trawl through the code to update every occurrence of 9.

The Fade sketch has three variables: [`led`]{.Code-within-text}, [`brightness`]{.Code-within-text}, and [`fadeAmount`]{.Code-within-text}. These are integer variables and are capable of the same range of values, but each one is used for a different part of the process of fading an LED.

![tip.png](https://i.imgur.com/799ND54.jpeg) With declarations made, the code enters the [`setup`]{.Code-within-text} function. The comments are reminders that [`setup`]{.Code-within-text} runs only once and that just one pin is set as an output. Here you can see the first variable at work. Instead of writing [`pinMode(9, OUTPUT),`]{.Code-within-text} you have [`pinMode(led, OUTPUT)`]{.Code-within-text}. Both work the same, but the latter uses the [`led`]{.Code-within-text} variable: []{#c06.xhtml#Page_93 .pagebreak role="doc-pagebreak" title="93"}

[]{#c06.xhtml#c06-code-0004}[]{#c06.xhtml#c06-lntxt-0004}

`// the setup routine runs once when you press reset:`{#c06.xhtml#c06-line-0043}

`void setup() {`{#c06.xhtml#c06-line-0044}

`  // declare pin 9 to be an output:`{#c06.xhtml#c06-line-0045}

`  pinMode(led, OUTPUT);`{#c06.xhtml#c06-line-0046}

`}`{#c06.xhtml#c06-line-0047}

Then the loop starts to get a bit more complicated:

[]{#c06.xhtml#c06-code-0005}[]{#c06.xhtml#c06-lntxt-0005}

`// the loop routine runs over and over again forever:`{#c06.xhtml#c06-line-0048}

`void loop() {`{#c06.xhtml#c06-line-0049}

`  // set the brightness of pin 9:`{#c06.xhtml#c06-line-0050}

`  analogWrite(led, brightness);`{#c06.xhtml#c06-line-0051}

` `{#c06.xhtml#c06-line-0052}

`  // change the brightness for next time through the loop:`{#c06.xhtml#c06-line-0053}

`  brightness = brightness + fadeAmount;`{#c06.xhtml#c06-line-0054}

` `{#c06.xhtml#c06-line-0055}

`  // reverse the direction of the fading at the ends of the fade:`{#c06.xhtml#c06-line-0056}

`  if (brightness <= 0 || brightness >= 255) {`{#c06.xhtml#c06-line-0057}

`    fadeAmount = -fadeAmount;`{#c06.xhtml#c06-line-0058}

`  }`{#c06.xhtml#c06-line-0059}

`  // wait for 30 milliseconds to see the dimming effect`{#c06.xhtml#c06-line-0060}

`  delay(30);`{#c06.xhtml#c06-line-0061}

`}`{#c06.xhtml#c06-line-0062}

Instead of just on and off values, a fade needs a range of values. [`analogWrite`]{.Code-within-text} allows you to send a value of 0 to 255 to a PWM pin on the Arduino. 0 is equal to 0v and 255 is equal to 5v, and any value in between gives a proportional voltage, thus fading the LED.

The loop begins by writing the [`brightness`]{.Code-within-text} value to pin 9. A [`brightness`]{.Code-within-text} value of 0 means that the LED is currently off:

[]{#c06.xhtml#c06-code-0006}[]{#c06.xhtml#c06-lntxt-0006}

`  // set the brightness of pin 9:`{#c06.xhtml#c06-line-0063}

`  analogWrite(led, brightness);`{#c06.xhtml#c06-line-0064}

Next you add the fade amount to the [`brightness`]{.Code-within-text} variable, making it equal to 5. This value won\'t be written to pin 9 until the next loop:

[]{#c06.xhtml#c06-code-0007}[]{#c06.xhtml#c06-lntxt-0007}

`// change the brightness for next time through the loop:`{#c06.xhtml#c06-line-0065}

`  brightness = brightness + fadeAmount;`{#c06.xhtml#c06-line-0066}

The brightness must stay within the range that the LED can understand. This is accomplished by using an [`if`]{.Code-within-text} statement that tests the value of the brightness variables to determine what to do next.

[]{#c06.xhtml#Page_94 .pagebreak role="doc-pagebreak" title="94"}The word [`if`]{.Code-within-text} starts the statement. The conditions are in the parentheses that follow, so in this case you have two. Is [`brightness`]{.Code-within-text} less than or equal to 0 (indicated by the [`<=`]{.Code-within-text} symbol) is the first condition. Is [`brightness`]{.Code-within-text} greater than or equal to 255 (indicated by the [`>=`]{.Code-within-text} symbol) is the second condition. In between the two conditional statements is the [`||`]{.Code-within-text} symbol, which is the symbol for [`OR`]{.Code-within-text}:

[]{#c06.xhtml#c06-code-0008}[]{#c06.xhtml#c06-lntxt-0008}

`// reverse the direction of the fading at the ends of the fade:`{#c06.xhtml#c06-line-0067}

`  if (brightness <= 0 || brightness >= 255) {`{#c06.xhtml#c06-line-0068}

`    fadeAmount = -fadeAmount;`{#c06.xhtml#c06-line-0069}

`  }`{#c06.xhtml#c06-line-0070}

So the complete statement is, "If the variable named brightness is less than or equal to 0, or greater than or equal to 255, do whatever is inside the curly brackets." When this eventually becomes true, the line of code inside the curly brackets is read. This basic mathematical statement inverts the [`fadeAmount`]{.Code-within-text} variable. During the fade up to full brightness, 5 is added to the brightness with every loop. When 255 is reached, the [`if`]{.Code-within-text} statement becomes true and [`fadeAmount`]{.Code-within-text} changes from 5 to -5. Then every loop updates to "add minus 5" to the brightness until 0 is reached, when the [`if`]{.Code-within-text} statement becomes true again. This inverts the [`fadeAmount`]{.Code-within-text} of -5 to 5 to bring everything back to where it started:

[]{#c06.xhtml#c06-code-0009}[]{#c06.xhtml#c06-lntxt-0009}

`    fadeAmount = -fadeAmount;`{#c06.xhtml#c06-line-0071}

These conditions give us a number continually counting up and then down that the Arduino can use to continually fade your LED on and then off again.
:::

::: {.section}
[]{#c06.xhtml#c06-sec-0009}

### Tweaking the Fade sketch {#c06.xhtml#h3-4 .Heading-2}

You can accomplish a task on your Arduino board in many ways. In this section, I will you one different way to fade an LED using the circuit that you created in the preceding section. The following code is the Fading example. From the Arduino menu, choose File ⇒ Examples ⇒ 03.Analog ⇒ Fading to open the Fading sketch. Upload it and you will see that no visible difference exists between this and the preceding example.

![remember.png](https://i.imgur.com/T4FGM6I.jpeg) Some areas of the code appear colored on your screen, most often turquoise, green, or orange. This coloring marks a function or a statement recognized by the Arduino environment (and can be extremely handy for spotting typos). Color is impossible to recreate in a black-and-white book, so any colored code appears here in **bold**. []{#c06.xhtml#Page_95 .pagebreak role="doc-pagebreak" title="95"}

[]{#c06.xhtml#c06-code-0010}[]{#c06.xhtml#c06-lntxt-0010}

`/*`{#c06.xhtml#c06-line-0072}

`  Fading`{#c06.xhtml#c06-line-0073}

` `{#c06.xhtml#c06-line-0074}

`  This example shows how to fade an LED using the analogWrite() function.`{#c06.xhtml#c06-line-0075}

` `{#c06.xhtml#c06-line-0076}

`  The circuit:`{#c06.xhtml#c06-line-0077}

`  - LED attached from digital pin 9 to ground.`{#c06.xhtml#c06-line-0078}

` `{#c06.xhtml#c06-line-0079}

`  created 1 Nov 2008`{#c06.xhtml#c06-line-0080}

`  by David A. Mellis`{#c06.xhtml#c06-line-0081}

`  modified 30 Aug 2011`{#c06.xhtml#c06-line-0082}

`  by Tom Igoe`{#c06.xhtml#c06-line-0083}

` `{#c06.xhtml#c06-line-0084}

`  This example code is in the public domain.`{#c06.xhtml#c06-line-0085}

` `{#c06.xhtml#c06-line-0086}

`  http://www.arduino.cc/en/Tutorial/Fading`{#c06.xhtml#c06-line-0087}

`*/`{#c06.xhtml#c06-line-0088}

` `{#c06.xhtml#c06-line-0089}

`int ledPin = 9;    // LED connected to digital pin 9`{#c06.xhtml#c06-line-0090}

` `{#c06.xhtml#c06-line-0091}

`void setup()  {`{#c06.xhtml#c06-line-0092}

`  // nothing happens in setup`{#c06.xhtml#c06-line-0093}

`}`{#c06.xhtml#c06-line-0094}

` `{#c06.xhtml#c06-line-0095}

`void loop()  {`{#c06.xhtml#c06-line-0096}

`  // fade in from min to max in increments of 5 points:`{#c06.xhtml#c06-line-0097}

`  for(int fadeValue = 0;fadeValue <= 255;fadeValue += 5) {`{#c06.xhtml#c06-line-0098}

`    // sets the value (range from 0 to 255):`{#c06.xhtml#c06-line-0099}

`    analogWrite(ledPin, fadeValue);`{#c06.xhtml#c06-line-0100}

`    // wait for 30 milliseconds to see the dimming effect`{#c06.xhtml#c06-line-0101}

`    delay(30);`{#c06.xhtml#c06-line-0102}

`  }`{#c06.xhtml#c06-line-0103}

` `{#c06.xhtml#c06-line-0104}

`  // fade out from max to min in increments of 5 points:`{#c06.xhtml#c06-line-0105}

`  for(int fadeValue = 255 ; fadeValue >= 0; fadeValue -= 5) {`{#c06.xhtml#c06-line-0106}

`    // sets the value (range from 0 to 255):`{#c06.xhtml#c06-line-0107}

`    analogWrite(ledPin, fadeValue);`{#c06.xhtml#c06-line-0108}

`    // wait for 30 milliseconds to see the dimming effect`{#c06.xhtml#c06-line-0109}

`    delay(30);`{#c06.xhtml#c06-line-0110}

`  }`{#c06.xhtml#c06-line-0111}

`}`{#c06.xhtml#c06-line-0112}

The Fade example is efficient and does a simple fade very well, but it relies on the [`loop`]{.Code-within-text} function to update the LED value. This version uses [`for`]{.Code-within-text} loops, which operate within the main Arduino [`loop`]{.Code-within-text} function.

::: {.section}
[]{#c06.xhtml#Page_96 .pagebreak role="doc-pagebreak" title="96"}[]{#c06.xhtml#c06-sec-0010}

#### Using for loops {#c06.xhtml#h4-1 .Heading-3}

When a sketch enters a [`for`]{.Code-within-text} loop, it sets up the criteria for exiting the loop and can\'t move out of it until the criteria are met. [`for`]{.Code-within-text} loops are often used for repetitive operations; in this case, [`for`]{.Code-within-text} loops are used to increase or decrease a number at a set rate to create the repeating fade.

The first line of the [`for`]{.Code-within-text} loop defines the initialization, the test, and the amount of increment or decrement:

[]{#c06.xhtml#c06-code-0011}[]{#c06.xhtml#c06-lntxt-0011}

`for(int fadeValue = 0;fadeValue <= 255;fadeValue += 5)`{#c06.xhtml#c06-line-0113}

In plain English, this reads: "Make a variable called [`fadeValue`]{.Code-within-text} (that is local to this [`for`]{.Code-within-text} loop) equal to a value of 0; check to see whether it is less than or equal to 255; if it is, set [`fadeValue`]{.Code-within-text} to be equal to [`fadeValue`]{.Code-within-text} plus 5." [`fadeValue`]{.Code-within-text} is equal to 0 only when it is created; after that, it is increased by 5 every time the [`for`]{.Code-within-text} loop cycles.

Within the loop, the code updates the [`analogWrite`]{.Code-within-text} value of the LED and waits 30 milliseconds (ms) before attempting the loop one more time:

[]{#c06.xhtml#c06-code-0012}[]{#c06.xhtml#c06-lntxt-0012}

`for (int fadeValue = 0 ; fadeValue <= 255; fadeValue += 5) {`{#c06.xhtml#c06-line-0114}

`    // sets the value (range from 0 to 255):`{#c06.xhtml#c06-line-0115}

`    analogWrite(ledPin, fadeValue);`{#c06.xhtml#c06-line-0116}

`    // wait for 30 milliseconds to see the dimming effect`{#c06.xhtml#c06-line-0117}

`    delay(30);`{#c06.xhtml#c06-line-0118}

`  }`{#c06.xhtml#c06-line-0119}

This [`for`]{.Code-within-text} loop behaves in the same way as the main [`loop`]{.Code-within-text} in the default Fade example, but because the [`fadeValue`]{.Code-within-text} is contained in its own loop, and broken into fade up and fade down loops, it is a lot easier to experiment with fading patterns in a more controlled way. For example, change [`+= 5`]{.Code-within-text} and [`–= 5`]{.Code-within-text} to different values (that divide into 255 neatly) for some interesting asymmetrical fading.

You could also copy and paste the same [`for`]{.Code-within-text} loops to create further fading animations. However, bear in mind that your Arduino can do nothing else while it is in a [`for`]{.Code-within-text} loop.
:::
:::
:::

::: {.section}
[]{#c06.xhtml#c06-sec-0011}

## The Button Sketch {#c06.xhtml#h2-4 .Heading-1}

The first and perhaps most basic of inputs that you can and should learn for your Arduino projects is the modest pushbutton.

[]{#c06.xhtml#Page_97 .pagebreak role="doc-pagebreak" title="97"}For the Button project, you need the following:

-   [An Arduino Uno]{#c06.xhtml#c06-li-0017}
-   [A breadboard]{#c06.xhtml#c06-li-0018}
-   [A 10k ohm resistor]{#c06.xhtml#c06-li-0019}
-   [A pushbutton]{#c06.xhtml#c06-li-0020}
-   [An LED]{#c06.xhtml#c06-li-0021}
-   [Jump wires]{#c06.xhtml#c06-li-0022}

[Figure 6-3](#c06.xhtml#c06-fig-0003){#c06.xhtml#rc06-fig-0003} shows the breadboard layout for the Button circuit. It\'s important to note which legs of the pushbutton are connected. In most cases, these small pushbuttons are made to bridge the gap over the center of your breadboard exactly. If they do bridge the gap, the legs are usually split at 90 degrees to the gap (left to right on this diagram).

::: {#c06.xhtml#c06-fig-0003 .figure}
![9781119489542-fg0603.png](https://i.imgur.com/tVhhe6F.jpeg){.center}
:::

You can test the legs of a pushbutton with a continuity tester if your multimeter has that function (as detailed in [Chapter 4](#c04.xhtml)).

From the schematic in [Figure 6-4](#c06.xhtml#c06-fig-0004){#c06.xhtml#rc06-fig-0004}, you can see that the resistor leading to ground should be connected to the same side of the pushbutton as pin 2, and that when the pushbutton is pressed, it connects the 5V pin to both D2 and GND. This setup is used to compare ground (0V) to a voltage (5V) so that you can tell whether the switch is open or closed.

::: {#c06.xhtml#c06-fig-0004 .figure}
![9781119489542-fg0604.png](https://i.imgur.com/vkDhuNC.jpeg){.center}
:::

Build the circuit and upload the code from File ⇒ Examples ⇒ 02.Digital ⇒ Button.

[]{#c06.xhtml#c06-code-0013}[]{#c06.xhtml#c06-lntxt-0013}

`/*`{#c06.xhtml#c06-line-0120}

`  Button`{#c06.xhtml#c06-line-0121}

` `{#c06.xhtml#c06-line-0122}

`  Turns on and off a light emitting diode(LED) connected to digital pin 13,`{#c06.xhtml#c06-line-0123}

`  when pressing a pushbutton attached to pin 2.`{#c06.xhtml#c06-line-0124}

` `{#c06.xhtml#c06-line-0125}

`  The circuit:`{#c06.xhtml#c06-line-0126}

`  - LED attached from pin 13 to ground`{#c06.xhtml#c06-line-0127}

`  - pushbutton attached to pin 2 from +5V`{#c06.xhtml#c06-line-0128}

`  - 10K resistor attached to pin 2 from ground`{#c06.xhtml#c06-line-0129}

`  - Note: on most Arduinos there is already an LED on the board`{#c06.xhtml#c06-line-0131}

`    attached to pin 13.`{#c06.xhtml#c06-line-0132}

` `{#c06.xhtml#c06-line-0133}

`  created 2005`{#c06.xhtml#c06-line-0134}

`  by DojoDave <http://www.0j0.org>`{#c06.xhtml#c06-line-0135}

`  modified 30 Aug 2011`{#c06.xhtml#c06-line-0136}

`  by Tom Igoe`{#c06.xhtml#c06-line-0137}

` `{#c06.xhtml#c06-line-0138}

`  This example code is in the public domain.`{#c06.xhtml#c06-line-0139}

` `{#c06.xhtml#c06-line-0140}

`  http://www.arduino.cc/en/Tutorial/Button`{#c06.xhtml#c06-line-0141}

`*/`{#c06.xhtml#c06-line-0142}

` `{#c06.xhtml#c06-line-0143}

`// constants won't change. They're used here to`{#c06.xhtml#c06-line-0144}

`// set pin numbers:`{#c06.xhtml#c06-line-0145}

`const int buttonPin = 2;     // the number of the pushbutton pin`{#c06.xhtml#c06-line-0146}

`const int ledPin =  13;      // the number of the LED pin`{#c06.xhtml#c06-line-0147}

` `{#c06.xhtml#c06-line-0148}

`// variables will change:`{#c06.xhtml#c06-line-0149}

`int buttonState = 0;         // variable for reading the pushbutton status`{#c06.xhtml#c06-line-0150}

` `{#c06.xhtml#c06-line-0151}

`void setup() {`{#c06.xhtml#c06-line-0152}

`  // initialize the LED pin as an output:`{#c06.xhtml#c06-line-0153}

`  pinMode(ledPin, OUTPUT);`{#c06.xhtml#c06-line-0154}

`  // initialize the pushbutton pin as an input:`{#c06.xhtml#c06-line-0155}

`  pinMode(buttonPin, INPUT);`{#c06.xhtml#c06-line-0156}

`}`{#c06.xhtml#c06-line-0157}

` `{#c06.xhtml#c06-line-0158}

`void loop(){`{#c06.xhtml#c06-line-0159}

`  // read the state of the pushbutton value:`{#c06.xhtml#c06-line-0160}

`  buttonState = digitalRead(buttonPin);`{#c06.xhtml#c06-line-0161}

` `{#c06.xhtml#c06-line-0162}

`  // check if the pushbutton is pressed.`{#c06.xhtml#c06-line-0163}

`  // if it is, the buttonState is HIGH:`{#c06.xhtml#c06-line-0164}

`  if (buttonState == HIGH) {`{#c06.xhtml#c06-line-0165}

`    // turn LED on:`{#c06.xhtml#c06-line-0166}

`    digitalWrite(ledPin, HIGH);`{#c06.xhtml#c06-line-0167}

`  }`{#c06.xhtml#c06-line-0168}

`  else {`{#c06.xhtml#c06-line-0169}

`    // turn LED off:`{#c06.xhtml#c06-line-0170}

`    digitalWrite(ledPin, LOW);`{#c06.xhtml#c06-line-0171}

`  }`{#c06.xhtml#c06-line-0172}

`}`{#c06.xhtml#c06-line-0173}

[]{#c06.xhtml#Page_100 .pagebreak role="doc-pagebreak" title="100"} After you upload the sketch, give your button a press and you should see the pin 13 LED light. (To make the light easier to see, add a bigger LED to your Arduino board between pin 13 and GND.)

If you don't see anything lighting up, double-check your wiring:

-   [Make sure that your button is connected to the correct pin number.]{#c06.xhtml#c06-li-0023}
-   [If you\'re using an additional LED, check that it is correctly situated, with the long leg in pin 13 and the short leg in GND. You can also remove it and monitor the LED mounted on the board (marked L) instead.]{#c06.xhtml#c06-li-0024}
-   [Check the connections on the breadboard. Make sure that the jump wires and components are connected using the correct rows in the breadboard.]{#c06.xhtml#c06-li-0025}

::: {.section}
[]{#c06.xhtml#c06-sec-0012}

### Understanding the Button sketch {#c06.xhtml#h3-5 .Heading-2}

This sketch is your first interactive Arduino project. The previous sketches were all about outputs, but now you can affect those outputs by providing real-world human input!

While pressed, your button turns on a light. When the button is released, the light turns off. Let\'s take a look at the sketch from the top to see how this happens.

The first step in the Button sketch is to declare constants and variables. A *constant,* displayed as [`const`]{.Code-within-text}, is a value or an identifier whose value doesn't change for the duration of the program. In the next example the values of [`buttonPin`]{.Code-within-text} and [`ledPin`]{.Code-within-text} are both defined as constants. This approach is best used for values that aren\'t supposed to change; this way, you are making doubly sure that they won't. Pin numbers are being assigned because you won't change the pin number physically.

The variable [`buttonState`]{.Code-within-text} is set to 0. This variable monitors changes to the button:

[]{#c06.xhtml#c06-code-0014}[]{#c06.xhtml#c06-lntxt-0014}

`const int buttonPin = 2;     // the number of the pushbutton pin`{#c06.xhtml#c06-line-0174}

`const int ledPin =  13;      // the number of the LED pin`{#c06.xhtml#c06-line-0175}

` `{#c06.xhtml#c06-line-0176}

`// variables will change:`{#c06.xhtml#c06-line-0177}

`int buttonState = 0;         // variable for reading the pushbutton status`{#c06.xhtml#c06-line-0178}

[`setup`]{.Code-within-text} establishes [`pinMode`]{.Code-within-text}, with [`ledPin`]{.Code-within-text} (pin 13) as the output and [`buttonPin`]{.Code-within-text},(pin 2) as the input: []{#c06.xhtml#Page_101 .pagebreak role="doc-pagebreak" title="101"}

[]{#c06.xhtml#c06-code-0015}[]{#c06.xhtml#c06-lntxt-0015}

`void setup() {`{#c06.xhtml#c06-line-0179}

`  // initialize the LED pin as an output:`{#c06.xhtml#c06-line-0180}

`  pinMode(ledPin, OUTPUT);`{#c06.xhtml#c06-line-0181}

`  // initialize the pushbutton pin as an input:`{#c06.xhtml#c06-line-0182}

`  pinMode(buttonPin, INPUT);`{#c06.xhtml#c06-line-0183}

`}`{#c06.xhtml#c06-line-0184}

In the main loop, you can see the order of things clearly. First, the [`digitalRead`]{.Code-within-text} function is used on pin 2. Just as [`digitalWrite`]{.Code-within-text} can write a [`HIGH`]{.Code-within-text} or [`LOW`]{.Code-within-text} (1 or 0) value to a pin, [`digitalRead`]{.Code-within-text} can read the current value, either HIGH (1) or LOW (0), from a pin. That value is then stored in the [`buttonState`]{.Code-within-text} variable:

[]{#c06.xhtml#c06-code-0016}[]{#c06.xhtml#c06-lntxt-0016}

`void loop(){`{#c06.xhtml#c06-line-0185}

`  // read the state of the pushbutton value:`{#c06.xhtml#c06-line-0186}

`  buttonState = digitalRead(buttonPin);`{#c06.xhtml#c06-line-0187}

With the button state established, a test uses an [`if`]{.Code-within-text} statement to determine what happens next. The statement reads: "If there is a [`HIGH`]{.Code-within-text} value (voltage connected to the circuit), then send a [`HIGH`]{.Code-within-text} value to [`ledPin`]{.Code-within-text} (pin 13) to turn the LED on; if there is a [`LOW`]{.Code-within-text} value (the pin is grounded), then send a [`LOW`]{.Code-within-text} value to [`ledPin`]{.Code-within-text} to turn the LED off; repeat."

[]{#c06.xhtml#c06-code-0017}[]{#c06.xhtml#c06-lntxt-0017}

`  // check if the pushbutton is pressed.`{#c06.xhtml#c06-line-0188}

`  // if it is, the buttonState is HIGH:`{#c06.xhtml#c06-line-0189}

`  if (buttonState == HIGH) {`{#c06.xhtml#c06-line-0190}

`    // turn LED on:`{#c06.xhtml#c06-line-0191}

`    digitalWrite(ledPin, HIGH);`{#c06.xhtml#c06-line-0192}

`  }`{#c06.xhtml#c06-line-0193}

`  else {`{#c06.xhtml#c06-line-0194}

`    // turn LED off:`{#c06.xhtml#c06-line-0195}

`    digitalWrite(ledPin, LOW);`{#c06.xhtml#c06-line-0196}

`  }`{#c06.xhtml#c06-line-0197}

`}`{#c06.xhtml#c06-line-0198}
:::

::: {.section}
[]{#c06.xhtml#c06-sec-0013}

### Tweaking the Button sketch {#c06.xhtml#h3-6 .Heading-2}

It\'s often necessary to invert the output of a switch or sensor, and you can do this in two ways. The easiest is to change one word in the code.

By changing the line of code in the preceding sketch from

[]{#c06.xhtml#c06-code-0018}[]{#c06.xhtml#c06-lntxt-0018}

`  if (buttonState == HIGH)`{#c06.xhtml#c06-line-0199}

[]{#c06.xhtml#Page_102 .pagebreak role="doc-pagebreak" title="102"}to

[]{#c06.xhtml#c06-code-0019}[]{#c06.xhtml#c06-lntxt-0019}

`  if (buttonState == LOW)`{#c06.xhtml#c06-line-0200}

the output is reversed. This means that the LED is on until the button is pressed. If you have a computer, this option is the easiest. Simply upload the code.

However, sometimes (such as when your laptop battery is dead) you don't have the means to upload the edited code. Often, the easiest way to flip the logic is to flip the polarity of the circuit.

Instead of connecting pin 2 to a resistor and then GND, connect that resistor to 5V and move the GND wire to the other side of the button, as shown in [Figure 6-5](#c06.xhtml#c06-fig-0005){#c06.xhtml#rc06-fig-0005}.

::: {#c06.xhtml#c06-fig-0005 .figure}
![9781119489542-fg0605.png](https://i.imgur.com/dRP2jlq.jpeg){.center}
:::
:::
:::

::: {.section}
[]{#c06.xhtml#c06-sec-0014}

## The AnalogInput Sketch {#c06.xhtml#h2-5 .Heading-1}

The preceding sketch showed you how to use [`digitalRead`]{.Code-within-text} to read either on or off, but what if you want to handle an analog value such as a dimmer switch or a volume control knob?

For the AnalogInput project, you need

-   [An Arduino Uno]{#c06.xhtml#c06-li-0026}
-   [A breadboard]{#c06.xhtml#c06-li-0027}
-   [A 10k ohm variable resistor]{#c06.xhtml#c06-li-0028}
-   [An LED]{#c06.xhtml#c06-li-0029}
-   [Jump wires]{#c06.xhtml#c06-li-0030}

[]{#c06.xhtml#Page_104 .pagebreak role="doc-pagebreak" title="104"}In [Figure 6-6](#c06.xhtml#c06-fig-0006){#c06.xhtml#rc06-fig-0006} you see the layout for this circuit. You need an LED and a resistor for your output, and a variable resistor for your input. If you're not quite sure what a variable resistor is, check out the "[Variable Resistors](#c06.xhtml#c06-fea-0002)" sidebar.

::: {#c06.xhtml#c06-fig-0006 .figure}
![9781119489542-fg0606.png](https://i.imgur.com/8kCXIhR.jpeg){.center}
:::

```{=html}
<aside>
```
::: {#c06.xhtml#c06-fea-0002 .sidebar}
# VARIABLE RESISTORS {.SB-Head}

[]{#c06.xhtml#c06-sec-0015}

*Variable resistors* (also known as *potentiometers* or *pots*), like standard passive resistors, resist the flow of current in a circuit. The difference is that rather than having a fixed value, they have a range. Normally, the upper limit of this range is printed on the resistor. For example, a variable resistor with a value of 10K Ω gives you a range of 0 ohms to 10,000 ohms. This change is something that can be monitored electrically to give a variable analog input.

Variable resistors come in a variety of shapes and sizes, as shown in the following figure. Anything with this analog movement, such as a thermostat, the dial on your washing machine, or the dial on your toaster to set the time, most likely contains a potentiometer.

::: {#c06.xhtml#c06-blkfxd-0001 .figure}
![9781119489542-sb0601.png](https://i.imgur.com/x75WyKC.jpeg){.center}
:::
:::

```{=html}
</aside>
```
In [Figures 6-6](#c06.xhtml#c06-fig-0006) and [6-7](#c06.xhtml#c06-fig-0007){#c06.xhtml#rc06-fig-0007}, the variable resistor has power and ground connected across opposite pins, with the central pin providing the reading. To read the analog input, you need to use the special set of analog input pins on the Arduino board.

::: {#c06.xhtml#c06-fig-0007 .figure}
![9781119489542-fg0607.png](https://i.imgur.com/eaJKi6I.jpeg){.center}
:::

![tip.png](https://i.imgur.com/WXALTPK.jpeg) Note that if you were to swap the resistor\'s polarity (the positive and negative wires), you would invert the direction of the potentiometer. This can be a quick fix if you find that your resistor's value is going in the wrong direction.

Build the circuit in [Figure 6-6](#c06.xhtml#c06-fig-0006), and then upload the code from File ⇒ Examples ⇒ 03.Analog ⇒ AnalogInput to start controlling your variable resistor. []{#c06.xhtml#Page_105 .pagebreak role="doc-pagebreak" title="105"}

[]{#c06.xhtml#c06-code-0020}[]{#c06.xhtml#c06-lntxt-0020}

`/*`{#c06.xhtml#c06-line-0201}

`  Analog Input`{#c06.xhtml#c06-line-0202}

` `{#c06.xhtml#c06-line-0203}

`  Demonstrates analog input by reading an analog sensor on analog pin 0 and`{#c06.xhtml#c06-line-0204}

`  turning on and off a light emitting diode(LED) connected to digital pin 13.`{#c06.xhtml#c06-line-0205}

`  The amount of time the LED will be on and off depends on the value obtained`{#c06.xhtml#c06-line-0206}

`  by analogRead().`{#c06.xhtml#c06-line-0207}

` `{#c06.xhtml#c06-line-0208}

`  The circuit:`{#c06.xhtml#c06-line-0209}

`  - potentiometer`{#c06.xhtml#c06-line-0210}

`    center pin of the potentiometer to the analog input 0`{#c06.xhtml#c06-line-0211}

`    one side pin (either one) to ground`{#c06.xhtml#c06-line-0212}

`    the other side pin to +5V`{#c06.xhtml#c06-line-0213}

`  - LED`{#c06.xhtml#c06-line-0214}

`    anode (long leg) attached to digital output 13`{#c06.xhtml#c06-line-0215}

`    cathode (short leg) attached to ground`{#c06.xhtml#c06-line-0216}

` `{#c06.xhtml#c06-line-0217}

`  - Note: because most Arduinos have a built-in LED attached to pin 13 on the`{#c06.xhtml#c06-line-0218}

`    board, the LED is optional.`{#c06.xhtml#c06-line-0219}

` `{#c06.xhtml#c06-line-0220}

`  created by David Cuartielles`{#c06.xhtml#c06-line-0221}

`  modified 30 Aug 2011`{#c06.xhtml#c06-line-0222}

`  By Tom Igoe`{#c06.xhtml#c06-line-0223}

` `{#c06.xhtml#c06-line-0224}

`  This example code is in the public domain.`{#c06.xhtml#c06-line-0225}

` `{#c06.xhtml#c06-line-0226}

`  http://www.arduino.cc/en/Tutorial/AnalogInput`{#c06.xhtml#c06-line-0227}

`*/`{#c06.xhtml#c06-line-0228}

` `{#c06.xhtml#c06-line-0229}

`int sensorPin = A0;    // select the input pin for the potentiometer`{#c06.xhtml#c06-line-0230}

`int ledPin = 13;      // select the pin for the LED`{#c06.xhtml#c06-line-0231}

`int sensorValue = 0;  // variable to store the value coming from the sensor`{#c06.xhtml#c06-line-0232}

` `{#c06.xhtml#c06-line-0233}

`void setup() {`{#c06.xhtml#c06-line-0234}

`  // declare the ledPin as an OUTPUT:`{#c06.xhtml#c06-line-0235}

`  pinMode(ledPin, OUTPUT);`{#c06.xhtml#c06-line-0236}

`}`{#c06.xhtml#c06-line-0237}

` `{#c06.xhtml#c06-line-0238}

`void loop() {`{#c06.xhtml#c06-line-0239}

`  // read the value from the sensor:`{#c06.xhtml#c06-line-0240}

`  sensorValue = analogRead(sensorPin);`{#c06.xhtml#c06-line-0241}

`  // turn the ledPin on`{#c06.xhtml#c06-line-0242}

`  digitalWrite(ledPin, HIGH);`{#c06.xhtml#c06-line-0243}

`  // stop the program for <sensorValue> milliseconds:`{#c06.xhtml#c06-line-0244}

`  delay(sensorValue);`{#c06.xhtml#c06-line-0245}

`  // turn the ledPin off:`{#c06.xhtml#c06-line-0246}

`  digitalWrite(ledPin, LOW);`{#c06.xhtml#c06-line-0247}

`  // stop the program for <sensorValue> milliseconds:`{#c06.xhtml#c06-line-0248}

`  delay(sensorValue);`{#c06.xhtml#c06-line-0249}

`}`{#c06.xhtml#c06-line-0250}

After the sketch is uploaded, turn the potentiometer. The result is an LED that blinks slower or faster depending on the value of the potentiometer. You can add another LED between pin 13 and GND to improve the effect of this spectacle.

If you don't see anything lighting up, double-check your wiring:

-   [Make sure that you're using the correct pin number for your variable resistor.]{#c06.xhtml#c06-li-0031}
-   [Check that your LED is the correct way around, with the long leg in pin 13 and the short leg in GND.]{#c06.xhtml#c06-li-0032}
-   [Check the connections on the breadboard. If the jump wires or components are not connected using the correct rows in the breadboard, they will not work.]{#c06.xhtml#c06-li-0033}

::: {.section}
[]{#c06.xhtml#c06-sec-0016}

### Understanding the AnalogInput sketch {#c06.xhtml#h3-7 .Heading-2}

Analog sensors come in a variety of forms, but the principle is generally the same for each of them. In this section you examine the AnalogInput sketch to get a better understanding of how Arduino interprets these sensors.

[]{#c06.xhtml#Page_107 .pagebreak role="doc-pagebreak" title="107"}The declarations state the pins that this sketch uses. The pin for the analog reading is written as [`A0`]{.Code-within-text}, which is short for analog input pin 0 to mark it as the first analog input pin in the row of 6 (numbered 0 to 5). Both [`ledPin`]{.Code-within-text} and [`sensorValue`]{.Code-within-text} are declared as standard variables. It\'s worth noting that [`ledPin`]{.Code-within-text} and [`sensorPin`]{.Code-within-text} could both be declared as constant integers ([`const`]{.Code-within-text}) because they don\'t change. Because the [`sensorValue`]{.Code-within-text} value will change, it is stored as a variable:

[]{#c06.xhtml#c06-code-0021}[]{#c06.xhtml#c06-lntxt-0021}

`int sensorPin = A0;    // select the input pin for the potentiometer`{#c06.xhtml#c06-line-0251}

`int ledPin = 13;      // select the pin for the LED`{#c06.xhtml#c06-line-0252}

`int sensorValue = 0;  // variable to store the value coming from the sensor`{#c06.xhtml#c06-line-0253}

During setup, you need only declare the [`pinMode`]{.Code-within-text} of the digital [`ledPin`]{.Code-within-text}. The analog input pins, as their name implies, are for input only.

![tip.png](https://i.imgur.com/JlxgNQp.jpeg) You can use the analog input pins also as more basic digital input or output pins. Instead of referring to them as analog pins A0--A5, you could number them as digital pins 14--19, as an extension of the existing digital pins. Each must then be declared as either an input or a n output using the [[`pinMode`]{.Code-within-text}]{style="text-decoration:underline"} function, as with any digital pin:

[]{#c06.xhtml#c06-code-0022}[]{#c06.xhtml#c06-lntxt-0022}

`void setup() {`{#c06.xhtml#c06-line-0254}

`  // declare the ledPin as an OUTPUT:`{#c06.xhtml#c06-line-0255}

`  pinMode(ledPin, OUTPUT);`{#c06.xhtml#c06-line-0256}

`}`{#c06.xhtml#c06-line-0257}

Similarly to the Button sketch, the AnalogInput sketch reads the sensor first. When using the a[`nalogRead`]{.Code-within-text} function, it interprets the voltage value of an analog pin. As the resistance changes, so too does the voltage. The accuracy of the value depends on the quality of the variable resistor. The Arduino uses the analog-to-digital converter on the ATmega328 chip to read this analog voltage. Instead of 0V, 0.1V, 0.2V, and so on, the Arduino returns a value as an integer in the range of 0--1023. For example, a voltage of 2.5V is interpreted as 511.

It\'s generally a good idea to read the sensor data first to prevent any delays when reading values, even though the looping occurs extremely quickly. Otherwise, this can give the effect of a lag in the response of the sensor.

After [`sensorValue`]{.Code-within-text} is read, the sketch is essentially the same as the Blink sketch, but with a variable delay. The [`ledPin`]{.Code-within-text} is written [`HIGH`]{.Code-within-text}, waits, is written [`LOW`]{.Code-within-text}, waits for the same amount of time, updates the sensor value, and repeats.

[]{#c06.xhtml#Page_108 .pagebreak role="doc-pagebreak" title="108"}Using the raw sensor value (0--1023) makes the delay between 0 seconds and 1.023 seconds:

[]{#c06.xhtml#c06-code-0023}[]{#c06.xhtml#c06-lntxt-0023}

`void loop() {`{#c06.xhtml#c06-line-0258}

`  // read the value from the sensor:`{#c06.xhtml#c06-line-0259}

`  sensorValue = analogRead(sensorPin);`{#c06.xhtml#c06-line-0260}

`  // turn the ledPin on`{#c06.xhtml#c06-line-0261}

`  digitalWrite(ledPin, HIGH);`{#c06.xhtml#c06-line-0262}

`  // stop the program for <sensorValue> milliseconds:`{#c06.xhtml#c06-line-0263}

`  delay(sensorValue);`{#c06.xhtml#c06-line-0264}

`  // turn the ledPin off:`{#c06.xhtml#c06-line-0265}

`  digitalWrite(ledPin, LOW);`{#c06.xhtml#c06-line-0266}

`  // stop the program for <sensorValue> milliseconds:`{#c06.xhtml#c06-line-0267}

`  delay(sensorValue);`{#c06.xhtml#c06-line-0268}

`}`{#c06.xhtml#c06-line-0269}

This sketch blinks your LED at various rates. However, as the blinks become slower, the delays in the loop become longer and, therefore, the readings from the sensor become less frequent. This can make your sensor less responsive when it\'s at the higher values, giving you less consistent readings. For another look at sensors, as well as how to smooth and calibrate them, head over to [Chapter 10](#c10.xhtml).
:::

::: {.section}
[]{#c06.xhtml#c06-sec-0017}

### Tweaking the AnalogInput sketch {#c06.xhtml#h3-8 .Heading-2}

The [`analogRead`]{.Code-within-text} function has supplied an integer value, and you can apply all sorts of conditions or calculations to that number in your sketch. In this example, I show you how to measure whether a sensor value is above a certain number or threshold.

By putting an [`if`]{.Code-within-text} statement around the [`digitalWrite`]{.Code-within-text} part of the loop, you are able to set a threshold. In this example, the LED blinks only if it is over the sensor\'s halfway value of 511:

[]{#c06.xhtml#c06-code-0024}[]{#c06.xhtml#c06-lntxt-0024}

`void loop() {`{#c06.xhtml#c06-line-0270}

`  // read the value from the sensor:`{#c06.xhtml#c06-line-0271}

`  sensorValue = analogRead(sensorPin);`{#c06.xhtml#c06-line-0272}

`if (sensorValue > 511){`{#c06.xhtml#c06-line-0273}

`  // turn the ledPin on`{#c06.xhtml#c06-line-0274}

`  digitalWrite(ledPin, HIGH);`{#c06.xhtml#c06-line-0275}

`  // stop the program for <sensorValue> milliseconds:`{#c06.xhtml#c06-line-0276}

`  delay(sensorValue);`{#c06.xhtml#c06-line-0277}

`  // turn the ledPin off:`{#c06.xhtml#c06-line-0278}

`  digitalWrite(ledPin, LOW);`{#c06.xhtml#c06-line-0279}

`  // stop the program for <sensorValue> milliseconds:`{#c06.xhtml#c06-line-0280}

`  delay(sensorValue);`{#c06.xhtml#c06-line-0281}

` }`{#c06.xhtml#c06-line-0282}

`}`{#c06.xhtml#c06-line-0283}

Try adding some conditions, but be aware that the sensor won\'t update as frequently if there are too many delays. For other sketches that remedy this problem, check out the BlinkWithoutDelay sketch in [Chapter 10](#c10.xhtml).
:::
:::

::: {.section}
[]{#c06.xhtml#c06-sec-0018}

## Talking Serial {#c06.xhtml#h2-6 .Heading-1}

It's good to see the effects of your circuit through an LED, but unless you can see the values, you might find it difficult to know whether a circuit is behaving as expected. The project in this section and the one following are designed to display the value of inputs by using the *serial monitor*

*Serial* is a method of communication between a peripheral and a computer. In this case, it is serial communication over Universal Serial Bus (USB). Data is sent one byte at a time in the order that it is written. When reading sensors with an Arduino, the values are sent over this connection and can be monitored or interpreted on your computer.

::: {.section}
[]{#c06.xhtml#c06-sec-0019}

### The DigitalReadSerial Sketch {#c06.xhtml#h3-9 .Heading-2}

In the DigitalReadSerial project, you monitor the [`HIGH`]{.Code-within-text} and [`LOW`]{.Code-within-text} values of a button over the serial monitor.

For this project, you need the following:

-   [An Arduino Uno]{#c06.xhtml#c06-li-0034}
-   [A breadboard]{#c06.xhtml#c06-li-0035}
-   [A 10k ohm resistor]{#c06.xhtml#c06-li-0036}
-   [A pushbutton]{#c06.xhtml#c06-li-0037}
-   [Jump wires]{#c06.xhtml#c06-li-0038}

[Figures 6-8](#c06.xhtml#c06-fig-0008){#c06.xhtml#rc06-fig-0008} and [6-9](#c06.xhtml#c06-fig-0009){#c06.xhtml#rc06-fig-0009} use the same circuit as you use for the Button sketch described previously in this chapter, but note that there are some slight changes to the code for this project.[]{#c06.xhtml#Page_110 .pagebreak role="doc-pagebreak" title="110"}

::: {#c06.xhtml#c06-fig-0008 .figure}
![9781119489542-fg0608.png](https://i.imgur.com/Q6DJwPl.jpeg){.center}
:::

::: {#c06.xhtml#c06-fig-0009 .figure}
![9781119489542-fg0609.png](https://i.imgur.com/i6apQMz.jpeg){.center}
:::

Complete the circuit and upload the code from File ⇒ Examples ⇒ 01.Basics ⇒ DigitalReadSerial:

[]{#c06.xhtml#c06-code-0025}[]{#c06.xhtml#c06-lntxt-0025}

`/*`{#c06.xhtml#c06-line-0284}

`  DigitalReadSerial`{#c06.xhtml#c06-line-0285}

` `{#c06.xhtml#c06-line-0286}

`  Reads a digital input on pin 2, prints the result to the Serial Monitor`{#c06.xhtml#c06-line-0287}

` `{#c06.xhtml#c06-line-0288}

`  This example code is in the public domain.`{#c06.xhtml#c06-line-0289}

` `{#c06.xhtml#c06-line-0290}

`  http://www.arduino.cc/en/Tutorial/DigitalReadSerial`{#c06.xhtml#c06-line-0291}

`*/`{#c06.xhtml#c06-line-0292}

` `{#c06.xhtml#c06-line-0293}

`// digital pin 2 has a pushbutton attached to it. Give it a name:`{#c06.xhtml#c06-line-0294}

`int pushButton = 2;`{#c06.xhtml#c06-line-0295}

` `{#c06.xhtml#c06-line-0296}

`// the setup routine runs once when you press reset:`{#c06.xhtml#c06-line-0297}

`void setup() {`{#c06.xhtml#c06-line-0298}

`  // initialize serial communication at 9600 bits per second:`{#c06.xhtml#c06-line-0299}

`  Serial.begin(9600);`{#c06.xhtml#c06-line-0300}

`  // make the pushbutton's pin an input:`{#c06.xhtml#c06-line-0301}

`  pinMode(pushButton, INPUT);`{#c06.xhtml#c06-line-0302}

`}`{#c06.xhtml#c06-line-0303}

` `{#c06.xhtml#c06-line-0304}

`// the loop routine runs over and over again forever:`{#c06.xhtml#c06-line-0305}

`void loop() {`{#c06.xhtml#c06-line-0306}

`  // read the input pin:`{#c06.xhtml#c06-line-0307}

`  int buttonState = digitalRead(pushButton);`{#c06.xhtml#c06-line-0308}

`  // print out the state of the button:`{#c06.xhtml#c06-line-0309}

`  Serial.println(buttonState);`{#c06.xhtml#c06-line-0310}

`  delay(1);        // delay in between reads for stability`{#c06.xhtml#c06-line-0311}

`}`{#c06.xhtml#c06-line-0312}

After you upload the sketch, click the serial monitor button on the top right of the Arduino window. Clicking this button opens the serial monitor window shown in [Figure 6-10](#c06.xhtml#c06-fig-0010){#c06.xhtml#rc06-fig-0010} and displays any values being sent to the currently selected serial port (which is the same as the one you have just uploaded to unless you selected otherwise).

::: {#c06.xhtml#c06-fig-0010 .figure}
![9781119489542-fg0610.png](https://i.imgur.com/VjbqlsE.jpeg){.center}
:::

You should see a cascade of [`0`]{.Code-within-text} values in the window. Press the button a few times, and some [`1`]{.Code-within-text} values should appear.

[]{#c06.xhtml#Page_112 .pagebreak role="doc-pagebreak" title="112"}If you don\'t see anything, or you see incorrect values, double-check your wiring:

-   [Make sure that you're using the correct pin number for your button.]{#c06.xhtml#c06-li-0039}
-   [Check the connections on the breadboard. If the jump wires or components are not connected using the correct rows in the breadboard, they will not work.]{#c06.xhtml#c06-li-0040}
-   [If you receive strange characters instead of 0s and 1s, check the baud rate in the serial monitor; if it is not set to 9600, use the drop-down menu to select that rate.]{#c06.xhtml#c06-li-0041}
:::

::: {.section}
[]{#c06.xhtml#c06-sec-0020}

### Understanding the DigitalReadSerial sketch {#c06.xhtml#h3-10 .Heading-2}

The only variable to declare in this sketch is the pin number for the pushbutton:

[]{#c06.xhtml#c06-code-0026}[]{#c06.xhtml#c06-lntxt-0026}

`int pushButton = 2;`{#c06.xhtml#c06-line-0313}

In the [`setup`]{.Code-within-text} function, there is a new function called [`Serial.begin`]{.Code-within-text}. This function initializes serial communication. The number in parentheses represents the speed of the communication, or *baud rate,* and is the number of bits sent per second. In this case, the Arduino is sending data at 9600 bits per second.

When viewing the communication in the serial monitor, it is important to read the data at the same rate it is being written. If you don\'t, the data is scrambled and you are presented with what looks like gibberish. In the bottom right of the window, you can set the baud rate, but by default it should be set to 9600. []{#c06.xhtml#Page_113 .pagebreak role="doc-pagebreak" title="113"}

[]{#c06.xhtml#c06-code-0027}[]{#c06.xhtml#c06-lntxt-0027}

`void setup() {`{#c06.xhtml#c06-line-0314}

`  // initialize serial communication at 9600 bits per second:`{#c06.xhtml#c06-line-0315}

`  Serial.begin(9600);`{#c06.xhtml#c06-line-0316}

`  // make the pushbutton's pin an input:`{#c06.xhtml#c06-line-0317}

`  pinMode(pushButton, INPUT);`{#c06.xhtml#c06-line-0318}

`}`{#c06.xhtml#c06-line-0319}

In the loop, [`pushButton`]{.Code-within-text} is read and its value stored in the [`buttonState`]{.Code-within-text} variable:

[]{#c06.xhtml#c06-code-0028}[]{#c06.xhtml#c06-lntxt-0028}

`void loop() {`{#c06.xhtml#c06-line-0320}

`  // read the input pin:`{#c06.xhtml#c06-line-0321}

`  int buttonState = digitalRead(pushButton);`{#c06.xhtml#c06-line-0322}

The [`Serial.println`]{.Code-within-text} function then writes the value of to the serial port. When [`println`]{.Code-within-text} is used, it signifies that a carriage return (new line) should be added after the value is printed. The carriage return is especially useful when you\'re reading values because they appear much clearer than they do in one line of values:

[]{#c06.xhtml#c06-code-0029}[]{#c06.xhtml#c06-lntxt-0029}

`  // print out the state of the button:`{#c06.xhtml#c06-line-0323}

`  Serial.println(buttonState);`{#c06.xhtml#c06-line-0324}

A delay of 1ms is added to the end of the loop to slow the speed at which the button is read. Having values written faster than they can be displayed can cause unstable results, so it's advisable to keep this delay:

[]{#c06.xhtml#c06-code-0030}[]{#c06.xhtml#c06-lntxt-0030}

`  delay(1);        // delay in between reads for stability`{#c06.xhtml#c06-line-0325}

`}`{#c06.xhtml#c06-line-0326}
:::

::: {.section}
[]{#c06.xhtml#c06-sec-0021}

### The AnalogInOutSerial Sketch {#c06.xhtml#h3-11 .Heading-2}

In the AnalogInOutSerial project, you monitor an analog value sent by a variable resistor over the serial monitor. These variable resistors are the same as the volume control knobs on your stereo, but people often have no idea how they work. In this example, you monitor the value as detected by your Arduino and display it on your screen in the serial monitor, giving you a greater understanding of the range of values and the performance of this analog sensor.

You need the following:

-   [An Arduino Uno]{#c06.xhtml#c06-li-0042}
-   [A breadboard]{#c06.xhtml#c06-li-0043}
-   [A 10k ohm variable resistor]{#c06.xhtml#c06-li-0044}
-   [[]{#c06.xhtml#Page_114 .pagebreak role="doc-pagebreak" title="114"}A resistor (greater than 120 ohm)]{#c06.xhtml#c06-li-0045}
-   [An LED]{#c06.xhtml#c06-li-0046}
-   [Jump wires]{#c06.xhtml#c06-li-0047}

The circuit, as shown in [Figures 6-11](#c06.xhtml#c06-fig-0011){#c06.xhtml#rc06-fig-0011} and [6-12](#c06.xhtml#c06-fig-0012){#c06.xhtml#rc06-fig-0012}, is similar to the example for the [`AnalogInput`]{.Code-within-text} circuit, but with the addition of an LED connected to pin 9 as in the Fade circuit. The code fades the LED on and off according to the turn of the potentiometer. Because the input and the output have a different range of values, the sketch includes a conversion to use the potentiometer to fade the LED. This circuit is a great example of using the serial monitor for debugging and displays both the input and output values for maximum clarity.

::: {#c06.xhtml#c06-fig-0011 .figure}
![9781119489542-fg0611.png](https://i.imgur.com/IH5LjAa.jpeg){.center}
:::

::: {#c06.xhtml#c06-fig-0012 .figure}
![9781119489542-fg0612.png](https://i.imgur.com/wK1nzwf.jpeg){.center}
:::

Complete the circuit and upload the code from File ⇒ Examples ⇒ 03.Analog ⇒ AnalogInOutSerial. []{#c06.xhtml#Page_115 .pagebreak role="doc-pagebreak" title="115"}

[]{#c06.xhtml#c06-code-0031}[]{#c06.xhtml#c06-lntxt-0031}

`/*`{#c06.xhtml#c06-line-0327}

`  Analog input, analog output, serial output`{#c06.xhtml#c06-line-0328}

` `{#c06.xhtml#c06-line-0329}

`  Reads an analog input pin, maps the result to a range from 0 to 255 and uses`{#c06.xhtml#c06-line-0330}

`  the result to set the pulse width modulation (PWM) of an output pin.`{#c06.xhtml#c06-line-0331}

`  Also prints the results to the Serial Monitor.`{#c06.xhtml#c06-line-0332}

` `{#c06.xhtml#c06-line-0333}

`  The circuit:`{#c06.xhtml#c06-line-0334}

`  - potentiometer connected to analog pin 0.`{#c06.xhtml#c06-line-0335}

`    Center pin of the potentiometer goes to the analog pin.`{#c06.xhtml#c06-line-0336}

`    side pins of the potentiometer go to +5V and ground`{#c06.xhtml#c06-line-0337}

`  - LED connected from digital pin 9 to ground`{#c06.xhtml#c06-line-0338}

` `{#c06.xhtml#c06-line-0339}

`  created 29 Dec. 2008`{#c06.xhtml#c06-line-0340}

`  modified 9 Apr 2012`{#c06.xhtml#c06-line-0341}

`  by Tom Igoe`{#c06.xhtml#c06-line-0342}

` `{#c06.xhtml#c06-line-0343}

`  This example code is in the public domain.`{#c06.xhtml#c06-line-0344}

` `{#c06.xhtml#c06-line-0345}

`  http://www.arduino.cc/en/Tutorial/AnalogInOutSerial`{#c06.xhtml#c06-line-0346}

`*/`{#c06.xhtml#c06-line-0347}

` `{#c06.xhtml#c06-line-0348}

`// These constants won't change.  They're used to give names`{#c06.xhtml#c06-line-0349}

`// to the pins used:`{#c06.xhtml#c06-line-0350}

`const int analogInPin = A0;  // Analog input pin that the potentiometer is attached to`{#c06.xhtml#c06-line-0351}

`const int analogOutPin = 9; // Analog output pin that the LED is attached to`{#c06.xhtml#c06-line-0352}

` `{#c06.xhtml#c06-line-0353}

`int sensorValue = 0;        // value read from the pot`{#c06.xhtml#c06-line-0354}

`int outputValue = 0;        // value output to the PWM (analog out)`{#c06.xhtml#c06-line-0355}

` `{#c06.xhtml#c06-line-0356}

`void setup() {`{#c06.xhtml#c06-line-0357}

`  // initialize serial communications at 9600 bps:`{#c06.xhtml#c06-line-0358}

`  Serial.begin(9600);`{#c06.xhtml#c06-line-0359}

`}`{#c06.xhtml#c06-line-0360}

` `{#c06.xhtml#c06-line-0361}

`void loop() {`{#c06.xhtml#c06-line-0362}

`  // read the analog in value:`{#c06.xhtml#c06-line-0363}

`  sensorValue = analogRead(analogInPin);`{#c06.xhtml#c06-line-0364}

`  // map it to the range of the analog out:`{#c06.xhtml#c06-line-0365}

`  outputValue = map(sensorValue, 0, 1023, 0, 255);`{#c06.xhtml#c06-line-0366}

`  // change the analog out value:`{#c06.xhtml#c06-line-0367}

`  analogWrite(analogOutPin, outputValue);`{#c06.xhtml#c06-line-0368}

` `{#c06.xhtml#c06-line-0369}

`  // print the results to the serial monitor:`{#c06.xhtml#c06-line-0370}

`  Serial.print("sensor = " );`{#c06.xhtml#c06-line-0371}

`  Serial.print(sensorValue);`{#c06.xhtml#c06-line-0372}

`  Serial.print("\t output = ");`{#c06.xhtml#c06-line-0373}

`  Serial.println(outputValue);`{#c06.xhtml#c06-line-0374}

` `{#c06.xhtml#c06-line-0375}

`  // wait 2 milliseconds before the next loop`{#c06.xhtml#c06-line-0376}

`  // for the analog-to-digital converter to settle`{#c06.xhtml#c06-line-0377}

`  // after the last reading:`{#c06.xhtml#c06-line-0378}

`  delay(2);`{#c06.xhtml#c06-line-0379}

`}`{#c06.xhtml#c06-line-0380}

After you upload the sketch, turn the potentiometer with your fingers. The result should be an LED that fades on and off depending on the value of the potentiometer. Now click the serial monitor button on the top right of the Arduino window to monitor the numerical values you are receiving and sending to the LED.

If you don't see anything happening, double-check your wiring:

-   [Make sure that you're using the correct pin number for your variable resistor.]{#c06.xhtml#c06-li-0048}
-   [Check that your LED is the correct way round, with the long leg connected to Pin 9 and the short leg connected to GND, via a resistor.]{#c06.xhtml#c06-li-0049}
-   [Check the connections on the breadboard. The jump wires and components will not work if you are not using the correct rows in the breadboard.]{#c06.xhtml#c06-li-0050}
-   [If you receive strange characters instead of words and numbers, check the baud rate in the serial monitor. If it is not set to 9600, use the drop-down menu to select that rate.]{#c06.xhtml#c06-li-0051}
:::

::: {.section}
[]{#c06.xhtml#Page_117 .pagebreak role="doc-pagebreak" title="117"}[]{#c06.xhtml#c06-sec-0022}

### Understanding the AnalogInOutSerial sketch {#c06.xhtml#h3-12 .Heading-2}

The start of the sketch is straightforward. It declares constants for both of the pins in use for the analog input and the PWM output. There are also two variables for the raw data from the sensor ([`sensorValue`]{.Code-within-text}) and the value that is sent to the LED ([`outputValue`]{.Code-within-text}):

[]{#c06.xhtml#c06-code-0032}[]{#c06.xhtml#c06-lntxt-0032}

`const int analogInPin = A0;  // Analog input pin that the potentiometer is             attached to`{#c06.xhtml#c06-line-0381}

`const int analogOutPin = 9; // Analog output pin that the LED is attached to`{#c06.xhtml#c06-line-0382}

` `{#c06.xhtml#c06-line-0383}

`int sensorValue = 0;        // value read from the pot`{#c06.xhtml#c06-line-0384}

`int outputValue = 0;        // value output to the PWM (analog out)`{#c06.xhtml#c06-line-0385}

In the [`setup`]{.Code-within-text} function, you have little to do beyond opening the serial communication line:

[]{#c06.xhtml#c06-code-0033}[]{#c06.xhtml#c06-lntxt-0033}

`void setup() {`{#c06.xhtml#c06-line-0386}

`  // initialize serial communications at 9600 bps:`{#c06.xhtml#c06-line-0387}

`  Serial.begin(9600);`{#c06.xhtml#c06-line-0388}

`}`{#c06.xhtml#c06-line-0389}

The real action is in the loop. As in the Fade sketch, the best place to start is with reading the input. The [`sensorValue`]{.Code-within-text} variable stores the reading from [`analogInPin`]{.Code-within-text}, which will be in the range of 0--1024:

[]{#c06.xhtml#c06-code-0034}[]{#c06.xhtml#c06-lntxt-0034}

`void loop() {`{#c06.xhtml#c06-line-0390}

`  // read the analog in value:`{#c06.xhtml#c06-line-0391}

`  sensorValue = analogRead(analogInPin);`{#c06.xhtml#c06-line-0392}

Because fading an LED using PWM requires a range of 0--255, you need to scale the [`sensorValue`]{.Code-within-text} down to make it fit the lower range of [`outputValue`]{.Code-within-text}. To do so, you use the [`map`]{.Code-within-text} function. The [`map`]{.Code-within-text} function scales a variable. By setting the variable\'s minimum and maximum to a new minimum and maximum, all the scaling is handled for you. The [`map`]{.Code-within-text} function creates an [`outputValue`]{.Code-within-text} directly proportional to the [`sensorValue`]{.Code-within-text} but on a smaller scale:

[]{#c06.xhtml#c06-code-0035}[]{#c06.xhtml#c06-lntxt-0035}

`  // map it to the range of the analog out:`{#c06.xhtml#c06-line-0393}

`  outputValue = map(sensorValue, 0, 1023, 0, 255);`{#c06.xhtml#c06-line-0394}

![tip.png](https://i.imgur.com/uF1Sbcw.jpeg) Functions like this are useful but can sometimes be overkill. In this example, you can achieve the same result by simply dividing the sensor value by 4:

[]{#c06.xhtml#c06-code-0036}[]{#c06.xhtml#c06-lntxt-0036}

`  outputValue = sensorValue/4;`{#c06.xhtml#c06-line-0395}

[]{#c06.xhtml#Page_118 .pagebreak role="doc-pagebreak" title="118"} Because [`outputValue`]{.Code-within-text} is an integer, it is rounded to the nearest whole number. The [`outputValue`]{.Code-within-text} is then written to the LED using the [`analogWrite`]{.Code-within-text} function:

[]{#c06.xhtml#c06-code-0037}[]{#c06.xhtml#c06-lntxt-0037}

`  // change the analog out value:`{#c06.xhtml#c06-line-0396}

`  analogWrite(analogOutPin, outputValue);`{#c06.xhtml#c06-line-0397}

This code is enough for the circuit to function, but if you want to know what\'s going on, you need to write some values to the serial port. The code has three lines of [`Serial.print`]{.Code-within-text} before [`Serial.println`]{.Code-within-text}. Each occurrence of [`Serial.print`]{.Code-within-text} writes text on the same line of the serial monitor. Using [`Serial.println`]{.Code-within-text} finishes that text with a carriage return, starting a new line. Therefore, a new line of text is written every time the program completes a loop.

Text inside the quotation marks is for labeling or adding characters. You can also use special characters, such as [`\t`]{.Code-within-text}, which adds a tab for spacing:

[]{#c06.xhtml#c06-code-0038}[]{#c06.xhtml#c06-lntxt-0038}

`  // print the results to the serial monitor:`{#c06.xhtml#c06-line-0398}

`  Serial.print("sensor = " );`{#c06.xhtml#c06-line-0399}

`  Serial.print(sensorValue);`{#c06.xhtml#c06-line-0400}

`  Serial.print("\t output = ");`{#c06.xhtml#c06-line-0401}

`  Serial.println(outputValue);`{#c06.xhtml#c06-line-0402}

An example of this line in the serial monitor follows:

[]{#c06.xhtml#c06-code-0039}[]{#c06.xhtml#c06-lntxt-0039}

`sensor = 1023   output = 511`{#c06.xhtml#c06-line-0403}

The loop is finished with a short delay to stabilize the results and then the loop is repeated, updating the input, output, and readings on the serial monitor.

[]{#c06.xhtml#c06-code-0040}[]{#c06.xhtml#c06-lntxt-0040}

`  // wait 2 milliseconds before the next loop`{#c06.xhtml#c06-line-0404}

`  // for the analog-to-digital converter to settle`{#c06.xhtml#c06-line-0405}

`  // after the last reading:`{#c06.xhtml#c06-line-0406}

`  delay(2);`{#c06.xhtml#c06-line-0407}

`}`{#c06.xhtml#c06-line-0408}

![tip.png](https://i.imgur.com/oBMe35c.jpeg) This delay time is largely arbitrary. The 2 ms could just as well be 1 ms, as in the previous example. You may have to experiment with these small delays. If a sensor is jumpy, you may want to go up to 10 ms, or you may find that the reading is perfectly smooth and can be removed completely. There is no magic value.
:::
:::

[]{#c07.xhtml}

[]{#c07.xhtml#Page_119 .pagebreak role="doc-pagebreak" title="119"}Chapter 7

# More Basic Sketches: Motion and Sound {#c07.xhtml#a1 .Chap-Title}

::: {.section}
[]{#c07.xhtml#c07-sec-0001}[]{#c07.xhtml#c07-feafxd-0001}

IN THIS CHAPTER

![check.png](https://i.imgur.com/r991D3N.jpeg) **Moving DC motors**

![check.png](https://i.imgur.com/LNWfMxH.jpeg) **Switching bigger loads with transistors**

![check.png](https://i.imgur.com/oaQM1Ql.jpeg) **Speeding up your motor**

![check.png](https://i.imgur.com/t55FlKg.jpeg) **Turning with precision using a stepper motor**

![check.png](https://i.imgur.com/Eijxrnm.jpeg) **Making electronic music with a buzzer**

[Chapter 6](#c06.xhtml) shows you how to use some simple LEDs as outputs for various circuits. In Arduino land, nothing is more beautiful than a blinking LED, but you have a variety of other outputs as options. In this chapter, I explore two other areas: motion provided by motors and sound from a buzzer.
:::

::: {.section}
[]{#c07.xhtml#c07-sec-0002}

## Working with Electric Motors {#c07.xhtml#h2-1 .Heading-1}

Electric motors allow you to move things with electricity using the power of *electromagnetism.* When an electrical current is passed through a coil of wire, it creates an electromagnetic field. This process works similarly to a normal permanent bar magnet but gives you control over the presence of the field, meaning that you can turn it on and off at will and even change the direction of the magnetism. As you may remember from school, magnets have two possible states: attraction or repulsion. In an electromagnetic field, you can switch between these by changing the polarity, which in practical terms means switching the positive and negative wires.

[]{#c07.xhtml#Page_120 .pagebreak role="doc-pagebreak" title="120"}Electromagnets have a variety of uses, such as in electrically operated locks, automated plumbing valves, and read-write heads on hard disks. They're used also for lifting scrap metal. Even the CERN Large Hadron Collider uses an electromagnet. In this chapter, I focus on another important use: electric motors.

An electric motor is made up of a coil of wire (electromagnet) between two regular, permanent magnets. By alternating the polarity of the coil, it is possible to rotate it because it is pulled by one magnet and then pushed toward the next. If this is done fast enough, the coil gathers momentum to spin.

The first part to understand is how the coil can spin if it is attached to wires. This spin is achieved by mounting two copper brushes on the axle. The brushes stay in contact with two semicircles of copper, as shown in [Figure 7-1](#c07.xhtml#c07-fig-0001){#c07.xhtml#rc07-fig-0001}, so a connection can be maintained without any fixed wires. The semicircles also mean that the two points are never in contact, which would cause a short circuit.

::: {#c07.xhtml#c07-fig-0001 .figure}
![9781119489542-fg0701.png](https://i.imgur.com/ki3Yn1e.jpeg){.center}
:::

With a freely spinning coil in place on an axle, you can affect the coil by placing two permanent bar magnets near it. As shown in [Figure 7-2](#c07.xhtml#c07-fig-0002){#c07.xhtml#rc07-fig-0002}, the magnets are placed on either side of the coil, with different poles on each side. If you put electrical current across the coil, you give it a polarity --- either north or south, as with conventional bar magnets. If the coil is north, it is repelled by the north bar magnet and attracted by the south bar magnet.

::: {#c07.xhtml#c07-fig-0002 .figure}
![9781119489542-fg0702.png](https://i.imgur.com/D4xUxQA.jpeg){.center}
:::

If you look at the brush again, you realize that something else happens when the coil does a half rotation: The polarity flips. When this happens, the cycle starts again and the north coil becomes south and is pushed away by the south magnet back to north. Because of the momentum produced when the coil is repelled, this movement continues in the same direction while sufficient power exists.

[]{#c07.xhtml#Page_121 .pagebreak role="doc-pagebreak" title="121"}This type of electric motor is the most basic; modern ones are highly refined, with more coils and magnets to produce a smoother movement. Other motors are also based on this principle but have more advanced controls to move, for example, by a precise number of degrees or to a specific location. In your kit, you should have two varieties of electric motor: a DC motor and a servo motor.
:::

::: {.section}
[]{#c07.xhtml#c07-sec-0003}

## Discovering Diodes {#c07.xhtml#h2-2 .Heading-1}

An essential component for motor control circuits is the diode. As explained earlier in this chapter, you can spin an electric motor by putting voltage through it. But if a motor is spinning or is turned without having a voltage put through it, it generates a voltage in the opposite direction; this is how electric generators and dynamos produce electricity from movement.

If this reversal of voltage happens in your circuit, the effects can be disastrous, including damaged or destroyed components. So to control this reverse current, you use a diode. *Diodes* block current in one direction and allow it in the other. Current can flow from the anode to the cathode. [Figure 7-3](#c07.xhtml#c07-fig-0003){#c07.xhtml#rc07-fig-0003} shows how the anode and cathode are marked for both the physical diode and the circuit diagram, with a band on the physical diode and a solid line on the schematic, both indicating the cathode.

::: {#c07.xhtml#c07-fig-0003 .figure}
![9781119489542-fg0703.png](https://i.imgur.com/q5Z7kLC.jpeg){.center}
:::
:::

::: {.section}
[]{#c07.xhtml#c07-sec-0004}

## Spinning a DC Motor {#c07.xhtml#h2-3 .Heading-1}

The DC motor in your kit (also known as a hobby motor or a brushed DC motor) is the most basic of electric motors and is used in all types of hobby electronics such as model planes and trains. When current is passed through a DC motor, it spins continuously in one direction until the current stops. Unless specifically marked with a + or -, DC motors have no polarity, which means that you can swap the two wires to reverse the direction of the motor. Many other, bigger motors exist, but in this example I stick to the small hobby motors.

::: {.section}
[]{#c07.xhtml#Page_122 .pagebreak role="doc-pagebreak" title="122"}[]{#c07.xhtml#c07-sec-0005}

### The Motor sketch {#c07.xhtml#h3-1 .Heading-2}

In this section, I show you how to set up a simple control circuit to turn your motor on and off.

You need the following:

-   [An Arduino Uno]{#c07.xhtml#c07-li-0006}
-   [A breadboard]{#c07.xhtml#c07-li-0007}
-   [A transistor]{#c07.xhtml#c07-li-0008}
-   [A DC motor]{#c07.xhtml#c07-li-0009}
-   [A diode]{#c07.xhtml#c07-li-0010}
-   [A 2.2k ohm resistor]{#c07.xhtml#c07-li-0011}
-   [Jump wires]{#c07.xhtml#c07-li-0012}

[Figure 7-4](#c07.xhtml#c07-fig-0004){#c07.xhtml#rc07-fig-0004} shows the layout for this circuit.

::: {#c07.xhtml#c07-fig-0004 .figure}
![9781119489542-fg0704.png](https://i.imgur.com/LIaxdM8.jpeg){.center}
:::

The circuit diagram in [Figure 7-5](#c07.xhtml#c07-fig-0005){#c07.xhtml#rc07-fig-0005} should clarify exactly what is going on. To power the motor, you need to send 5V through it and then on to ground. This voltage spins the motor, but you have control of it. To give your Arduino control of the motor's power, and therefore its rotation, you place a transistor just after the motor. The transistor, as described in the sidebar "[Understanding Transistors](#c07.xhtml#c07-fea-0001)," is an electrically operated switch that can be activated by your Arduino's digital pins. In this example, it is controlled by pin 9 on your Arduino, in the same way as an LED except that the transistor allows you the turn the motor circuit on and off.

::: {#c07.xhtml#c07-fig-0005 .figure}
![9781119489542-fg0705.png](https://i.imgur.com/6siNVRN.jpeg){.center}
:::

```{=html}
<aside>
```
::: {#c07.xhtml#c07-fea-0001 .sidebar}
# UNDERSTANDING TRANSISTORS {.SB-Head}

[]{#c07.xhtml#c07-sec-0006}

Sometime it's not possible or advisable to power an output directly from your Arduino pins. By using a transistor, you can control a bigger circuit from your modestly powerful Arduino.

Motors and other larger outputs (such as lots of LED lighting) often require more voltage and current than your Arduino pins can supply, so they need their own circuits to supply this power. To allow you to control these bigger circuits, you can use a component called a transistor. In the same way that a physical switch is used to turn a circuit on and off, a *transistor* is an electronic switch that can be turned on and off by using a very small voltage.

There are many transistors in the world, and each has its own product number that you can Google for details. The one I use in this section's example is a P2N2222A, which is an NPN-type transistor. (There are two kinds of transistor --- NPN and PNP.)

A transistor has three legs: base, collector, and emitter. The *base* (or *gate*) is where the Arduino digital signal is sent; the *collector* (or *drain*) is the power source; and the *emitter* (or *source*) is the ground. The legs are numbered and, you hope, named in the datasheet to tell you which leg is which. In a circuit diagram, a transistor is drawn as in the following figure, with the collector at the top, the base to the left, and the emitter at the bottom.

::: {#c07.xhtml#c07-blkfxd-0001 .figure}
![9781119489542-sb0701.png](https://i.imgur.com/mOu383V.jpeg){.center}
:::
:::

```{=html}
</aside>
```
This circuit works, but it still allows the chance of creating a reverse current because of the momentum of the motor as it slows down or because the motor could be turned. If reverse current is generated, it travels from the negative side of the motor and tries to find the easiest route to ground. This route may be through the transistor or through the Arduino. You can't know for sure what will happen, so you need to provide a way to control this excess current.

To be safe, you place a diode across the motor. The diode faces toward the source of the voltage, so the voltage is forced through the motor, which is what you want. If current is generated in the opposite direction, it will now be blocked from flowing into the Arduino.

![warning.png](https://i.imgur.com/G864xxB.jpeg) If you place the diode the wrong way, the current bypasses the motor and you create a short circuit. The short circuit tries to ground all the available current and could break your USB port or, at the very least, display a warning message, informing you that your USB port is drawing too much power.[]{#c07.xhtml#Page_123 .pagebreak role="doc-pagebreak" title="123"}

[]{#c07.xhtml#Page_124 .pagebreak role="doc-pagebreak" title="124"}Build the circuit as shown, and open a new Arduino sketch. Press the Save button and save the sketch with a memorable name, such as myMotor, and then type the following code:

[]{#c07.xhtml#c07-code-0001}[]{#c07.xhtml#c07-lntxt-0001}

`int motorPin = 9;`{#c07.xhtml#c07-line-0001}

` `{#c07.xhtml#c07-line-0002}

`void setup() {`{#c07.xhtml#c07-line-0003}

`                `{#c07.xhtml#c07-line-0004}

`  pinMode(motorPin, OUTPUT);`{#c07.xhtml#c07-line-0005}

`}`{#c07.xhtml#c07-line-0007}

` `{#c07.xhtml#c07-line-0008}

`void loop() {`{#c07.xhtml#c07-line-0009}

``{#c07.xhtml#c07-line-0010} 

`  digitalWrite(motorPin, HIGH);   `{#c07.xhtml#c07-line-0011}

`  delay(1000);        `{#c07.xhtml#c07-line-0012}

`      `{#c07.xhtml#c07-line-0013}

`  digitalWrite(motorPin, LOW);   `{#c07.xhtml#c07-line-0014}

`  delay(1000);     `{#c07.xhtml#c07-line-0015}

`          `{#c07.xhtml#c07-line-0016}

`}`{#c07.xhtml#c07-line-0017}

After you've typed the sketch, save it and press the Compile button to check your code. The Arduino IDE (introduced in [Chapter 2](#c02.xhtml)) checks your code for any syntax errors (code grammar) and highlights them in the message area. The most common mistakes include typos, missing semicolons, and case sensitivity.

If the sketch compiles correctly, click Upload to upload the sketch to your board. You should see your motor spinning for one second and stopping for one second repeatedly.

If that's not what happens, you should double-check your wiring:

-   [Make sure that you're using pin number 9.]{#c07.xhtml#c07-li-0013}
-   [Check that your diode is facing the correct way, with the band facing the 5v connection.]{#c07.xhtml#c07-li-0014}
-   [Check the connections on the breadboard. If the jump wires or components are not connected using the correct rows in the breadboard, they will not work.]{#c07.xhtml#c07-li-0015}
:::

::: {.section}
[]{#c07.xhtml#c07-sec-0007}

### Understanding the Motor sketch {#c07.xhtml#h3-2 .Heading-2}

The Motor sketch is a basic sketch, and you may have noticed that it's a variation on the Blink sketch. This example changes the hardware but uses the same code to control an LED.

First, the pin is declared using digital pin 9:

[]{#c07.xhtml#c07-code-0002}[]{#c07.xhtml#c07-lntxt-0002}

`int motorPin = 9;`{#c07.xhtml#c07-line-0018}

[]{#c07.xhtml#Page_126 .pagebreak role="doc-pagebreak" title="126"} In the [`setup`]{.Code-within-text} function, pin 9 is defined as an output:

[]{#c07.xhtml#c07-code-0003}[]{#c07.xhtml#c07-lntxt-0003}

`void setup() {`{#c07.xhtml#c07-line-0019}

`                `{#c07.xhtml#c07-line-0020}

`  pinMode(motorPin, OUTPUT);`{#c07.xhtml#c07-line-0021}

`    `{#c07.xhtml#c07-line-0022}

`}`{#c07.xhtml#c07-line-0023}

The loop tells the output signal to go to [`HIGH`]{.Code-within-text}, wait for 1000mS (1 second), go to [`LOW`]{.Code-within-text}, wait for another 1000mS, and then repeat. This scenario gives you the most basic of motor control, telling the motor when to go on and off:

[]{#c07.xhtml#c07-code-0004}[]{#c07.xhtml#c07-lntxt-0004}

`void loop() {`{#c07.xhtml#c07-line-0024}

``{#c07.xhtml#c07-line-0025} 

`  digitalWrite(motorPin, HIGH);  `{#c07.xhtml#c07-line-0026}

`  delay(1000); `{#c07.xhtml#c07-line-0027}

`             `{#c07.xhtml#c07-line-0028}

`  digitalWrite(motorPin, LOW);    `{#c07.xhtml#c07-line-0029}

`  delay(1000);`{#c07.xhtml#c07-line-0030}

`         `{#c07.xhtml#c07-line-0031}

`}`{#c07.xhtml#c07-line-0032}
:::
:::

::: {.section}
[]{#c07.xhtml#c07-sec-0008}

## Changing the Speed of Your Motor {#c07.xhtml#h2-4 .Heading-1}

On and off is all well and good, but sometimes you want greater control over the speed of your motor. The following sketch shows you how to control the speed of your motor with the same circuit.

::: {.section}
[]{#c07.xhtml#c07-sec-0009}

### The MotorSpeed sketch {#c07.xhtml#h3-3 .Heading-2}

Using the same circuit as in the preceding section, open a new Arduino sketch, save it with another memorable name, such as myMotorSpeed, and then type the following code:

[]{#c07.xhtml#c07-code-0005}[]{#c07.xhtml#c07-lntxt-0005}

`int motorPin = 9;`{#c07.xhtml#c07-line-0033}

``{#c07.xhtml#c07-line-0034} 

`void setup(){`{#c07.xhtml#c07-line-0035}

``{#c07.xhtml#c07-line-0036} 

`  pinMode(motorPin, OUTPUT);`{#c07.xhtml#c07-line-0037}

`   `{#c07.xhtml#c07-line-0038}

`} `{#c07.xhtml#c07-line-0039}

[]{#c07.xhtml#Page_127 .pagebreak role="doc-pagebreak" title="127"}``{#c07.xhtml#c07-line-0040}

`void loop()  {`{#c07.xhtml#c07-line-0041}

``{#c07.xhtml#c07-line-0042} 

`  for(int motorValue = 0; motorValue <= 255; motorValue +=5){ `{#c07.xhtml#c07-line-0043}

`    analogWrite(motorPin, motorValue);        `{#c07.xhtml#c07-line-0044}

`    delay(30);                            `{#c07.xhtml#c07-line-0045}

`  }`{#c07.xhtml#c07-line-0046}

``{#c07.xhtml#c07-line-0047} 

`  for(int motorValue = 255; motorValue >= 0; motorValue -=5){ `{#c07.xhtml#c07-line-0048}

`    analogWrite(motorPin, motorValue);        `{#c07.xhtml#c07-line-0049}

`    delay(30);                            `{#c07.xhtml#c07-line-0050}

`  }`{#c07.xhtml#c07-line-0051}

``{#c07.xhtml#c07-line-0052} 

`}`{#c07.xhtml#c07-line-0053}

After you\'ve typed the sketch, save it and press the Compile button to check your code. The Arduino IDE should highlight any grammatical errors in the message area if they are discovered.

If the sketch compiles correctly, click Upload to upload the sketch to your board. When uploading is finished, you should have a motor that spins very slowly to start, speeds up to its fastest spin, spins back down to a stop, and then repeats. It can be difficult to see this, so you should affix something more visible, such as a piece of tape or adhesive putty (such as Blu-Tack), to the motor spindle to see what's going on.

You may find that at its slowest point, the motor just hums. This hum is not a problem; it just means that the electromagnet doesn't have enough voltage to spin the motor; more voltage is required to generate the magnetism and gain momentum.
:::

::: {.section}
[]{#c07.xhtml#c07-sec-0010}

### Understanding the MotorSpeed sketch {#c07.xhtml#h3-4 .Heading-2}

The MotorSpeed sketch is a slight variation of the Fade sketch described in [Chapter 6](#c06.xhtml), but works in the same way.

The pin you\'re using to control the motor circuit, digital pin 9, is declared:

[]{#c07.xhtml#c07-code-0006}[]{#c07.xhtml#c07-lntxt-0006}

`int motorPin = 9;`{#c07.xhtml#c07-line-0054}

Because it's an output, you define it in the [`setup`]{.Code-within-text} function:

[]{#c07.xhtml#c07-code-0007}[]{#c07.xhtml#c07-lntxt-0007}

`void setup()  {`{#c07.xhtml#c07-line-0055}

`  pinMode(motorPin, OUTPUT);    `{#c07.xhtml#c07-line-0056}

`} `{#c07.xhtml#c07-line-0057}

[]{#c07.xhtml#Page_128 .pagebreak role="doc-pagebreak" title="128"} In the main loop, you use [`analogWrite`]{.Code-within-text} to send a PWM value to pin 9. This same principle is in the Fade sketch, which fades an LED. The first [`for`]{.Code-within-text} loop sends a gradually increasing value to pin 9 until it reaches the maximum PWM value of 255. The second [`for`]{.Code-within-text} loop gradually returns this value to 0; then the cycle repeats:

[]{#c07.xhtml#c07-code-0008}[]{#c07.xhtml#c07-lntxt-0008}

`void loop()  {`{#c07.xhtml#c07-line-0058}

``{#c07.xhtml#c07-line-0059} 

`  for(int motorValue = 0; motorValue <= 255; motorValue +=5){`{#c07.xhtml#c07-line-0060}

`    analogWrite(motorPin, motorValue);        `{#c07.xhtml#c07-line-0061}

`    delay(30);                            `{#c07.xhtml#c07-line-0062}

`  }`{#c07.xhtml#c07-line-0063}

``{#c07.xhtml#c07-line-0064} 

`  for(int motorValue = 255; motorValue >= 0; motorValue -=5){ `{#c07.xhtml#c07-line-0065}

`    analogWrite(motorPin, motorValue);        `{#c07.xhtml#c07-line-0066}

`    delay(30);                            `{#c07.xhtml#c07-line-0067}

`  }`{#c07.xhtml#c07-line-0068}

``{#c07.xhtml#c07-line-0069} 

`}`{#c07.xhtml#c07-line-0070}

This process could be likened to revving a car engine. If you push down the pedal, you accelerate the engine to full speed. If you tap the gas pedal, the engine accelerates and then slows down. If you tap it at a constant rate before it slows, you maintain some of the momentum of the spinning motor and achieve an average (if somewhat jerky) speed. The transistor is doing this action, but very quickly. The intervals between on and off and the momentum of the motor allow you to achieve analog behavior from a digital signal.
:::
:::

::: {.section}
[]{#c07.xhtml#c07-sec-0011}

## Controlling the Speed of Your Motor {#c07.xhtml#h2-5 .Heading-1}

The sketch in the preceding section gave you control of the motor. In this section, you find out how to put some input into your circuit to give you full control of the motor on the fly.

::: {.section}
[]{#c07.xhtml#c07-sec-0012}

### The MotorControl sketch {#c07.xhtml#h3-5 .Heading-2}

To gain control of the speed of your motor whenever you need it, add a potentiometer to your circuit.

You need the following: []{#c07.xhtml#Page_129 .pagebreak role="doc-pagebreak" title="129"}

-   [An Arduino Uno]{#c07.xhtml#c07-li-0016}
-   [A breadboard]{#c07.xhtml#c07-li-0017}
-   [A transistor]{#c07.xhtml#c07-li-0018}
-   [A DC motor]{#c07.xhtml#c07-li-0019}
-   [A diode]{#c07.xhtml#c07-li-0020}
-   [A 10k ohm variable resistor]{#c07.xhtml#c07-li-0021}
-   [A 2.2k ohm resistor]{#c07.xhtml#c07-li-0022}
-   [Jump wires]{#c07.xhtml#c07-li-0023}

Follow the diagram in [Figure 7-6](#c07.xhtml#c07-fig-0006){#c07.xhtml#rc07-fig-0006} and the circuit diagram in [Figure 7-7](#c07.xhtml#c07-fig-0007){#c07.xhtml#rc07-fig-0007} to add a potentiometer alongside your motor control circuit.

::: {#c07.xhtml#c07-fig-0006 .figure}
![9781119489542-fg0706.png](https://i.imgur.com/M3JHc5B.jpeg){.center}
:::

::: {#c07.xhtml#c07-fig-0007 .figure}
![9781119489542-fg0707.png](https://i.imgur.com/rVAqZIL.jpeg){.center}
:::

Find a space on your breadboard to place your potentiometer. The central pin of the potentiometer is connected back to pin 9 using a jump wire, and the remaining two pins are connected to 5V on one side and GND on the other. The 5V and GND can be on either side, but switching them will invert the value that the potentiometer sends to the Arduino. Although the potentiometer uses the same power and ground as the motor, note that they are separate circuits that both communicate through the Arduino.

After you\'ve built the circuit, open a new Arduino sketch and save it with another memorable name, such as myMotorControl. Then type the following code:

[]{#c07.xhtml#c07-code-0009}[]{#c07.xhtml#c07-lntxt-0009}

`int potPin = A0;`{#c07.xhtml#c07-line-0071}

`int motorPin = 9;`{#c07.xhtml#c07-line-0072}

``{#c07.xhtml#c07-line-0073} 

`int potValue = 0;`{#c07.xhtml#c07-line-0074}

`int motorValue = 0;`{#c07.xhtml#c07-line-0075}

``{#c07.xhtml#c07-line-0076} 

`void setup() {`{#c07.xhtml#c07-line-0077}

`  Serial.begin(9600); `{#c07.xhtml#c07-line-0078}

`}`{#c07.xhtml#c07-line-0079}

``{#c07.xhtml#c07-line-0080} 

`void loop() {`{#c07.xhtml#c07-line-0081}

`  potValue = analogRead(potPin);            `{#c07.xhtml#c07-line-0082}

`  motorValue = map(potValue, 0, 1023, 0, 255);  `{#c07.xhtml#c07-line-0083}

``{#c07.xhtml#c07-line-0084} 

`  analogWrite(motorPin, motorValue);          `{#c07.xhtml#c07-line-0085}

[]{#c07.xhtml#Page_131 .pagebreak role="doc-pagebreak" title="131"}``{#c07.xhtml#c07-line-0086}

`  Serial.print("potentiometer = ");                      `{#c07.xhtml#c07-line-0087}

`  Serial.print(potValue);      `{#c07.xhtml#c07-line-0088}

`  Serial.print("\t motor = ");      `{#c07.xhtml#c07-line-0089}

`  Serial.println(motorValue);  `{#c07.xhtml#c07-line-0090}

``{#c07.xhtml#c07-line-0091} 

`  delay(2);                    `{#c07.xhtml#c07-line-0092}

`}`{#c07.xhtml#c07-line-0093}

After you\'ve typed the sketch, save it and click the Compile button to highlight any syntax errors.

If the sketch compiles correctly, click Upload to upload the sketch to your board. When it has finished uploading, you should be able to control your motor using the potentiometer. Turning the potentiometer in one direction speeds up the motor; turning it the other way slows down the motor. The next section explains how the code allows the potentiometer to change the speed.
:::

::: {.section}
[]{#c07.xhtml#c07-sec-0013}

### Understanding the MotorControl Sketch {#c07.xhtml#h3-6 .Heading-2}

The MotorControl sketch is a variation on the AnalogInOutSerial sketch and works the same way, with a few name changes to better indicate what you are controlling and monitoring on the circuit.

As always, you declare the different variables used in the sketch. You use [`potPin`]{.Code-within-text} to assign the potentiometer pin and [`motorPin`]{.Code-within-text} to send a signal to the motor. The [`potValue`]{.Code-within-text} variable is used to store the raw value of the potentiometer, and the [`motorValue`]{.Code-within-text} variable stores the converted value that you want to output to the transistor to switch the motor:

[]{#c07.xhtml#c07-code-0010}[]{#c07.xhtml#c07-lntxt-0010}

`int potPin = A0;`{#c07.xhtml#c07-line-0094}

`int motorPin = 9;`{#c07.xhtml#c07-line-0095}

``{#c07.xhtml#c07-line-0096} 

`int potValue = 0;`{#c07.xhtml#c07-line-0097}

`int motorValue = 0;`{#c07.xhtml#c07-line-0098}

For more details on the workings of this sketch, see the AnalogInOutSerial example in [Chapter 6](#c06.xhtml).
:::

::: {.section}
[]{#c07.xhtml#c07-sec-0014}

### Tweaking the MotorControl sketch {#c07.xhtml#h3-7 .Heading-2}

You may find that the motor just hums below a minimum speed. It does so because it doesn\'t have enough power to spin. By monitoring the values sent to the motor using the MotorControl sketch, you can find the motor's minimum value to turn, and then optimize [`motorValue`]{.Code-within-text} to turn the motor within its true range.

[]{#c07.xhtml#Page_132 .pagebreak role="doc-pagebreak" title="132"}To find the range of [`motorValue`]{.Code-within-text}, follow these steps:

1.  ::: {#c07.xhtml#c07-li-0024}
    **With the MotorControl sketch uploaded, click the serial monitor button at the top right of your Arduino window.**

    The serial monitor window displays the potentiometer value followed by the output value being sent to the motor, in this fashion:

    potentiometer = 1023 motor = 255

    These values are displayed in a long list and are updated as you turn the potentiometer. If you don\'t see the list scrolling down, make sure that the Autoscroll option is selected.
    :::

2.  [**Starting with your potentiometer reading a value of 0, turn your potentiometer very slowly until the humming stops and the motor starts spinning.**]{#c07.xhtml#c07-li-0025}

3.  [**Make a note of the value displayed at this point.**]{#c07.xhtml#c07-li-0026}

4.  [**Use an** [`if`]{.Code-within-text} **statement to tell the motor to change speed only if the value is greater than the minimum speed needed to spin the motor, as follows:**]{#c07.xhtml#c07-li-0027}
    1.  [*Find the part of your code that writes the [`motorValue`]{.Code-within-text} to the motor:*[]{#c07.xhtml#c07-code-0011}[]{#c07.xhtml#c07-lntxt-0011}]{#c07.xhtml#c07-li-0028}

        `analogWrite(motorPin, motorValue);`{#c07.xhtml#c07-line-0099}

    2.  [*Replace it with the following piece of code:*[]{#c07.xhtml#c07-code-0012}[]{#c07.xhtml#c07-lntxt-0012}]{#c07.xhtml#c07-li-0029}

        `if(motorValue > yourValue) {`{#c07.xhtml#c07-line-0100}

        `  analogWrite(motorPin, motorValue); `{#c07.xhtml#c07-line-0101}

        `} else {`{#c07.xhtml#c07-line-0102}

        `  digitalWrite(motorPin, LOW);`{#c07.xhtml#c07-line-0103}

        `}`{#c07.xhtml#c07-line-0104}

5.  ::: {#c07.xhtml#c07-li-0030}
    **Replace [`yourValue`]{.Code-within-text} with the number that you noted.**

    If the value is greater than [`motorValue`]{.Code-within-text}, the motor speeds up. If it is lower, the pin is written [`LOW`]{.Code-within-text} so that it is fully off. You could also type [`analogWrite(motorPin, 0)`]{.Code-within-text} to accomplish the same thing. Tiny optimizations like this can help your project function smoothly, with no wasted movement or values.
    :::
:::
:::

::: {.section}
[]{#c07.xhtml#c07-sec-0015}

## Getting to Know Servo motors {#c07.xhtml#h2-6 .Heading-1}

A servo motor is made up of a motor and a device called an encoder that can track the rotation of the motor. *Servo motors* are used for precision movements, moving by a number of degrees to an exact location. Using your Arduino, you can tell the []{#c07.xhtml#Page_133 .pagebreak role="doc-pagebreak" title="133"}servo motor what degree you want it to move to, and it will go there from its current position. Most servo motors can move only 180 degrees, but you can use gearing to extend this range.

The servo in your kit will most likely be a hobby servo, similar to those shown in [Figure 7-8](#c07.xhtml#c07-fig-0008){#c07.xhtml#rc07-fig-0008}. A hobby servo motor has plastic gears and can manage only relatively light loads. After you experiment with small servos, you have plenty of larger ones to choose from for heavy lifting. Servos are widely used in the robotics community for walkers that need precise movement in each of their feet.

::: {#c07.xhtml#c07-fig-0008 .figure}
![9781119489542-fg0708.png](https://i.imgur.com/kJI91AL.jpeg){.center}
:::

The examples in the following section walk you through the basic operations of sending signals to a servo and controlling one directly with a potentiometer.
:::

::: {.section}
[]{#c07.xhtml#c07-sec-0016}

## Creating Sweeping Movements {#c07.xhtml#h2-7 .Heading-1}

This first servo motor example requires only a servo motor and will allow you to turn the motor through its full range of movement. The servo sweeps from 0° to 179° and then back again, in a similar way to the movement of an old rotary clock.

::: {.section}
[]{#c07.xhtml#c07-sec-0017}

### The Sweep sketch {#c07.xhtml#h3-8 .Heading-2}

You need the following for the Sweep sketch:

-   [An Arduino Uno]{#c07.xhtml#c07-li-0031}
-   [A servo]{#c07.xhtml#c07-li-0032}
-   [Jump wires]{#c07.xhtml#c07-li-0033}

[]{#c07.xhtml#Page_134 .pagebreak role="doc-pagebreak" title="134"}The wiring for a servo is simple because it comes with a neat three-pin socket. To connect it to your Arduino, simply use jump wires between the Arduino pins and the servo sockets directly or use a set of header pins to connect the socket to your breadboard.

As shown in [Figures 7-9](#c07.xhtml#c07-fig-0009){#c07.xhtml#rc07-fig-0009} and [7-10](#c07.xhtml#c07-fig-0010){#c07.xhtml#rc07-fig-0010}, the servo has a set of three sockets with wires connected to them, usually red, black, and white. All the calculations and readings to move the motor are done on the circuitry inside the servo itself, so all that is needed is power and a signal from the Arduino.

::: {#c07.xhtml#c07-fig-0009 .figure}
![9781119489542-fg0709.png](https://i.imgur.com/sa9Esul.jpeg){.center}
:::

Red is connected to 5V on the Arduino to power the motor and the circuitry inside it; black is connected to GND to ground the servo; and white is connected to pin 9 to control the servo\'s movement. The colors of these wires can vary, so always check the datasheet or any available documentation for your specific motor. Other common colors are red (5V), brown (GND), and yellow (signal).

::: {#c07.xhtml#c07-fig-0010 .figure}
![9781119489542-fg0710.png](https://i.imgur.com/KGQX1xw.jpeg){.center}
:::

Complete the circuit as described and open the Sweep sketch by choosing File ⇒   Examples ⇒   Servo ⇒   Sweep. The Sweep sketch is as follows:

[]{#c07.xhtml#c07-code-0013}[]{#c07.xhtml#c07-lntxt-0013}

`/* Sweep`{#c07.xhtml#c07-line-0105}

` by BARRAGAN <http://barraganstudio.com>`{#c07.xhtml#c07-line-0106}

` This example code is in the public domain.`{#c07.xhtml#c07-line-0107}

``{#c07.xhtml#c07-line-0108} 

` modified 8 Nov 2013`{#c07.xhtml#c07-line-0109}

` by Scott Fitzgerald`{#c07.xhtml#c07-line-0110}

` http://www.arduino.cc/en/Tutorial/Sweep`{#c07.xhtml#c07-line-0111}

`*/`{#c07.xhtml#c07-line-0112}

``{#c07.xhtml#c07-line-0113} 

``{#c07.xhtml#c07-line-0114} 

`#include <Servo.h> `{#c07.xhtml#c07-line-0115}

` `{#c07.xhtml#c07-line-0116}

`Servo myservo;  // create servo object to control a servo`{#c07.xhtml#c07-line-0117}

`// twelve servo objects can be created on most boards`{#c07.xhtml#c07-line-0118}

` `{#c07.xhtml#c07-line-0119}

`int pos = 0;    // variable to store the servo position`{#c07.xhtml#c07-line-0120}

` `{#c07.xhtml#c07-line-0121}

`void setup() { `{#c07.xhtml#c07-line-0122}

`  myservo.attach(9);  // attaches the servo on pin 9 to the servo object`{#c07.xhtml#c07-line-0123}

`} `{#c07.xhtml#c07-line-0124}

` `{#c07.xhtml#c07-line-0125}

`void loop() { `{#c07.xhtml#c07-line-0126}

`  for(pos = 0; pos < 180; pos += 1)       // goes from 0 degrees to 180 degrees`{#c07.xhtml#c07-line-0127}

`  {                                                 // in steps of 1 degree`{#c07.xhtml#c07-line-0128}

`    myservo.write(pos);                       // tell servo to go to position in`{#c07.xhtml#c07-line-0129}

`                                         // variable 'pos' `{#c07.xhtml#c07-line-0130}

`    delay(15);                                     // waits 15ms for the servo to reach`{#c07.xhtml#c07-line-0131}

`                                        // the position `{#c07.xhtml#c07-line-0132}

`  }`{#c07.xhtml#c07-line-0133}

`  for(pos = 180; pos>=1; pos-=1)            // goes from 180 degrees to 0 degrees`{#c07.xhtml#c07-line-0134}

`  {                                `{#c07.xhtml#c07-line-0135}

`    myservo.write(pos);                               // tell servo to go to position in`{#c07.xhtml#c07-line-0136}

`                                        // variable 'pos' `{#c07.xhtml#c07-line-0137}

`    delay(15);                                    // waits 15ms for the servo to reach`{#c07.xhtml#c07-line-0138}

`                                        // the position `{#c07.xhtml#c07-line-0139}

`  }`{#c07.xhtml#c07-line-0140}

`}`{#c07.xhtml#c07-line-0141}

After you find the sketch, press the Compile button to check the code. The compiler should, as always, highlight any grammatical errors in red in the message area.

If the sketch compiles correctly, click Upload to upload the sketch to your board. When the sketch has finished uploading, your motor should start turning backward and forward through 180 degrees, doing a dance on the table.

If nothing happens, you should double-check your wiring:

-   [Make sure that you\'re using pin 9 for the data (white/yellow) line.]{#c07.xhtml#c07-li-0034}
-   [Check that you have the other servo wires connected to the correct pins.]{#c07.xhtml#c07-li-0035}
:::

::: {.section}
[]{#c07.xhtml#c07-sec-0018}

### Understanding the Sweep sketch {#c07.xhtml#h3-9 .Heading-2}

A servo library is included at the start of the Sweep sketch. This library will help you to get a lot out of your servo with little complex code:

[]{#c07.xhtml#c07-code-0014}[]{#c07.xhtml#c07-lntxt-0014}

`#include <Servo.h> `{#c07.xhtml#c07-line-0142}

The next line makes a servo object. The library knows how to use servos but needs you to give each one a name so that it can talk to each one. In this case, the new Servo object is called [`myservo`]{.Code-within-text}. Using a name is similar to naming your variables; that is, they can be any name as long as they\'re consistent throughout your code and you don't use any Arduino reserved names, such as [`int`]{.Code-within-text} or [`delay`]{.Code-within-text}: []{#c07.xhtml#Page_137 .pagebreak role="doc-pagebreak" title="137"}

[]{#c07.xhtml#c07-code-0015}[]{#c07.xhtml#c07-lntxt-0015}

`Servo myservo;  // create servo object to control a servo`{#c07.xhtml#c07-line-0143}

`                     // a maximum of eight servo objects can be created`{#c07.xhtml#c07-line-0144}

The final line in the declarations is a variable to store the position of the servo:

[]{#c07.xhtml#c07-code-0016}[]{#c07.xhtml#c07-lntxt-0016}

`int pos = 0;    // variable to store the servo position`{#c07.xhtml#c07-line-0145}

In the [`setup`]{.Code-within-text} function, the only item to set is the pin number of the Arduino pin that is communicating with the servo. In this case, you are using pin 9, but it could be any PWM pin.

[]{#c07.xhtml#c07-code-0017}[]{#c07.xhtml#c07-lntxt-0017}

`void setup() `{#c07.xhtml#c07-line-0146}

`{ `{#c07.xhtml#c07-line-0147}

`  myservo.attach(9);  // attaches the servo on pin 9 to the servo object`{#c07.xhtml#c07-line-0148}

`} `{#c07.xhtml#c07-line-0149}

The [`loop`]{.Code-within-text} function performs two simple actions, and both are [`for`]{.Code-within-text} loops. The first [`for`]{.Code-within-text} loop gradually increases the [`pos`]{.Code-within-text} variable from 0 to 180. Because of the library, you can write values in degrees rather than the normal 0 to 255 used for PWM control. With every loop, the value is increased by 1 and sent to the servo using a function specific to the servo library, [`<servoName>.write(<value>)`]{.Code-within-text}. After the loop updates the value, a short delay of 15 milliseconds occurs while the servo reaches its new location.

![remember.png](https://i.imgur.com/r2Vc10A.jpeg) In contrast to other outputs, after a servo is updated, it starts moving to its new position instead of needing to be told to do so.

[]{#c07.xhtml#c07-code-0018}[]{#c07.xhtml#c07-lntxt-0018}

`void loop() `{#c07.xhtml#c07-line-0150}

`{ `{#c07.xhtml#c07-line-0151}

`  for(pos = 0; pos < 180; pos += 1)    // goes from 0 degrees to 180 degrees`{#c07.xhtml#c07-line-0152}

`  {                                                  // in steps of 1 degree`{#c07.xhtml#c07-line-0153}

`    myservo.write(pos);                              // tell servo to go to position in`{#c07.xhtml#c07-line-0154}

`                                       // variable 'pos'`{#c07.xhtml#c07-line-0155}

`    delay(15);                                   // waits 15ms for the servo to reach`{#c07.xhtml#c07-line-0156}

`                                       // the position`{#c07.xhtml#c07-line-0157}

`  }`{#c07.xhtml#c07-line-0158}

The second [`for`]{.Code-within-text} loop does the same in the opposite direction, returning the servo to its start position:

[]{#c07.xhtml#c07-code-0019}[]{#c07.xhtml#c07-lntxt-0019}

`  for(pos = 180; pos>=1; pos-=1)      // goes from 180 degrees to 0 degrees`{#c07.xhtml#c07-line-0159}

`  {                                `{#c07.xhtml#c07-line-0160}

`    myservo.write(pos);                   // tell servo to go to position in`{#c07.xhtml#c07-line-0161}

`                                      // variable 'pos' `{#c07.xhtml#c07-line-0162}

`    delay(15);                               // waits 15ms for the servo to reach`{#c07.xhtml#c07-line-0163}

`                                      // the position`{#c07.xhtml#c07-line-0164}

`  }`{#c07.xhtml#c07-line-0165}

`}`{#c07.xhtml#c07-line-0166}

It\'s a good idea to use this simple servo example to test whether your servo is working correctly, before coding more complex examples.
:::
:::

::: {.section}
[]{#c07.xhtml#c07-sec-0019}

## Controlling Your Servo {#c07.xhtml#h2-8 .Heading-1}

Now that you have mastered control of the servo, you can try something with a bit more interaction. By using a potentiometer (or any analog sensor), you can directly control your servo in the same way that you\'d control a mechanical claw at the arcades.

::: {.section}
[]{#c07.xhtml#c07-sec-0020}

### The Knob sketch {#c07.xhtml#h3-10 .Heading-2}

The Knob example shows you how you can easily use a potentiometer to move your servo to a specific degree.

You need the following:

-   [An Arduino Uno]{#c07.xhtml#c07-li-0036}
-   [A breadboard]{#c07.xhtml#c07-li-0037}
-   [A servo]{#c07.xhtml#c07-li-0038}
-   [A 10k ohm variable resistor]{#c07.xhtml#c07-li-0039}
-   [Jump wires]{#c07.xhtml#c07-li-0040}

The servo is wired exactly as in the Sweep example, but this time you need extra connections to 5V and GND for the potentiometer, so you must use a breadboard to provide the extra pins. Connect the 5V and GND pins on the Arduino to the positive (+) and negative (-) rows on the breadboard. Connect the servo to the breadboard by using either a row of three header pins or three jump wires.

Connect the red socket to the 5V row, the black/brown socket to the GND row, and the white/yellow socket to pin 9 on the Arduino. Find a space on the breadboard for the potentiometer. Connect the center pin to pin A0 on the Arduino and the remaining pins to 5V on one side and GND on the other. Refer to the circuit diagram in [Figure 7-11](#c07.xhtml#c07-fig-0011){#c07.xhtml#rc07-fig-0011} and the schematic in [Figure 7-12](#c07.xhtml#c07-fig-0012){#c07.xhtml#rc07-fig-0012}.[]{#c07.xhtml#Page_139 .pagebreak role="doc-pagebreak" title="139"}

::: {#c07.xhtml#c07-fig-0011 .figure}
![9781119489542-fg0711.png](https://i.imgur.com/cmev254.jpeg){.center}
:::

::: {#c07.xhtml#c07-fig-0012 .figure}
![9781119489542-fg0712.png](https://i.imgur.com/BlGL0Va.jpeg){.center}
:::

After you have built the circuit, open the sketch by choosing File ⇒   Examples ⇒   Servo ⇒   Knob. The code for the sketch is as follows:

[]{#c07.xhtml#c07-code-0020}[]{#c07.xhtml#c07-lntxt-0020}

`/*`{#c07.xhtml#c07-line-0167}

` Controlling a servo position using a potentiometer (variable resistor)`{#c07.xhtml#c07-line-0168}

` by Michal Rinott <http://people.interaction-ivrea.it/m.rinott>`{#c07.xhtml#c07-line-0169}

``{#c07.xhtml#c07-line-0170} 

` modified on 8 Nov 2013`{#c07.xhtml#c07-line-0171}

` by Scott Fitzgerald`{#c07.xhtml#c07-line-0172}

` http://www.arduino.cc/en/Tutorial/Knob`{#c07.xhtml#c07-line-0173}

`*/`{#c07.xhtml#c07-line-0174}

``{#c07.xhtml#c07-line-0175} 

`#include <Servo.h> `{#c07.xhtml#c07-line-0176}

` `{#c07.xhtml#c07-line-0177}

`Servo myservo;  // create servo object to control a servo`{#c07.xhtml#c07-line-0178}

` `{#c07.xhtml#c07-line-0179}

`int potpin = 0;  // analog pin used to connect the potentiometer`{#c07.xhtml#c07-line-0180}

`int val;    // variable to read the value from the analog pin`{#c07.xhtml#c07-line-0181}

` `{#c07.xhtml#c07-line-0182}

`void setup() { `{#c07.xhtml#c07-line-0183}

`  myservo.attach(9);  // attaches the servo on pin 9 to the servo object`{#c07.xhtml#c07-line-0184}

`} `{#c07.xhtml#c07-line-0185}

` `{#c07.xhtml#c07-line-0186}

`void loop() { `{#c07.xhtml#c07-line-0187}

`  val = analogRead(potpin);                  // reads the value of the`{#c07.xhtml#c07-line-0188}

`                                       // potentiometer (value between`{#c07.xhtml#c07-line-0189}

`                                       // 0 and 1023)`{#c07.xhtml#c07-line-0190}

`  val = map(val, 0, 1023, 0, 179);        // scale it to use it with the`{#c07.xhtml#c07-line-0191}

`                                       // servo (value between 0 and 180)`{#c07.xhtml#c07-line-0192}

`  myservo.write(val);                         // sets the servo position according`{#c07.xhtml#c07-line-0193}

`                                       // to the scaled value `{#c07.xhtml#c07-line-0194}

`  delay(15);                                      // waits for the servo to get there`{#c07.xhtml#c07-line-0195}

`}`{#c07.xhtml#c07-line-0196}

![tip.png](https://i.imgur.com/eReE5qA.jpeg) With all Arduino examples, it's best to assume that they are works-in-progress and may not always be accurate. You may have noticed a few discrepancies between the comments and the code. When referring to the range of degrees to move the servo, the sketch mentions both 0 to 179 and 0 to 180. The correct range is 0 to 179, which gives you 180 values. Counting from zero is referred to as *zero indexing* and is a common occurrence in Arduino, as you may have noticed by this point.

After you\'ve found the sketch, press the Compile button to check the code. If the compiler encounters any syntax errors, they are highlighted in the message area, which lights up red.

[]{#c07.xhtml#Page_141 .pagebreak role="doc-pagebreak" title="141"}If the sketch compiles correctly, click Upload to upload the sketch to your board. When it is has finished uploading, your servo should turn as you turn your potentiometer.

If that isn't what happens, you should double-check your wiring:

-   [Make sure that you're using pin 9 to connect the data (white/yellow) line to the servo.]{#c07.xhtml#c07-li-0041}
-   [Check your connections to the potentiometer and make sure that the center pin is connected to analog pin 0.]{#c07.xhtml#c07-li-0042}
-   [Check the connections on the breadboard. If the jump wires or components are not connected using the correct rows in the breadboard, they will not work.]{#c07.xhtml#c07-li-0043}
:::

::: {.section}
[]{#c07.xhtml#c07-sec-0021}

### Understanding the Knob sketch {#c07.xhtml#h3-11 .Heading-2}

In the declarations, the servo library, Servo.h, and a new servo object are named. The analog input pin is declared with a value of 0, showing that you are using analog 0.

![tip.png](https://i.imgur.com/1qapInq.jpeg) You may have noticed that the pin is numbered 0, not A0 as in other examples. Either is fine, because A0 is just an alias of 0, as A1 is of 1, and so on. Using A0 is good for clarity but optional.

One last variable stores the value of the reading, which will become the output:

[]{#c07.xhtml#c07-code-0021}[]{#c07.xhtml#c07-lntxt-0021}

`#include <Servo.h> `{#c07.xhtml#c07-line-0197}

` `{#c07.xhtml#c07-line-0198}

`Servo myservo;  // create servo object to control a servo`{#c07.xhtml#c07-line-0199}

` `{#c07.xhtml#c07-line-0200}

`int potpin = 0;  // analog pin used to connect the potentiometer`{#c07.xhtml#c07-line-0201}

`int val;    // variable to read the value from the analog pin`{#c07.xhtml#c07-line-0202}

In the [`setup`]{.Code-within-text} function, the only item to define is [`myservo`]{.Code-within-text}, which is using pin 9.

[]{#c07.xhtml#c07-code-0022}[]{#c07.xhtml#c07-lntxt-0022}

`void setup() `{#c07.xhtml#c07-line-0203}

`{ `{#c07.xhtml#c07-line-0204}

`  myservo.attach(9);  // attaches the servo on pin 9 to the servo object`{#c07.xhtml#c07-line-0205}

`} `{#c07.xhtml#c07-line-0206}

Rather than use two separate variables for input and output, the Knob sketch simply uses one. First, [`val`]{.Code-within-text} is used to store the raw sensor data, a value from 0 to 1023. The [`map`]{.Code-within-text} function processes this value by scaling its range to that of the servo: 0 to 179. [`myservo.write`]{.Code-within-text} then writes this value to the servo. There is a 15-millisecond []{#c07.xhtml#Page_142 .pagebreak role="doc-pagebreak" title="142"}delay to allow the servo motor to reach its destination. Then the loop repeats and updates the position of the servo as necessary:

[]{#c07.xhtml#c07-code-0023}[]{#c07.xhtml#c07-lntxt-0023}

`void loop() `{#c07.xhtml#c07-line-0207}

`{ `{#c07.xhtml#c07-line-0208}

`  val = analogRead(potpin);               // reads the value of the potentiometer`{#c07.xhtml#c07-line-0209}

`                                       // (value between 0 and 1023) `{#c07.xhtml#c07-line-0210}

`  val = map(val, 0, 1023, 0, 179);      // scale it to use it with the servo`{#c07.xhtml#c07-line-0211}

`                                       // (value between 0 and 180) `{#c07.xhtml#c07-line-0212}

`  myservo.write(val);                         // sets the servo position according`{#c07.xhtml#c07-line-0213}

`                                      // to the scaled value `{#c07.xhtml#c07-line-0214}

`  delay(15);                                     // waits for the servo to get there `{#c07.xhtml#c07-line-0215}

`}`{#c07.xhtml#c07-line-0216}

With this simple addition to the circuit, it\'s possible to control a servo with any sort of input. In this example, the code uses an analog input, but with a few changes it could just as easily use a digital input.
:::
:::

::: {.section}
[]{#c07.xhtml#c07-sec-0022}

## Making Noises {#c07.xhtml#h2-9 .Heading-1}

If you've just finished the motor sketches, you have mastered movement and must be ready for a new challenge. In this section, you look at a project that's a bit more tuneful than the previous ones: making music (or noise at least) with your Arduino. Yes, you can make electronic music --- albeit simple --- using a piezo buzzer.

::: {.section}
[]{#c07.xhtml#c07-sec-0023}

### Piezo buzzer {#c07.xhtml#h3-12 .Heading-2}

A piezo or piezoelectric buzzer is found in hundreds of thousands of devices. If you hear a tick, buzz, or beep, it's likely caused by a piezo. The *piezo* is composed of two layers, a ceramic and a metal plate joined together. When electricity passes from one layer to the other, the piezo bends on a microscopic level and makes a sound, as shown in [Figure 7-13](#c07.xhtml#c07-fig-0013){#c07.xhtml#rc07-fig-0013}.

::: {#c07.xhtml#c07-fig-0013 .figure}
![9781119489542-fg0713.png](https://i.imgur.com/f1I8A2L.jpeg){.center}
:::

If you switch between a voltage and ground, the piezo bends and generates a tick sound; if this happens fast enough, these ticks turn into a tone. This tone can be quite harsh, similar to the old mobile phone ringtone or computer game sounds from the 1980s, and is known as a square wave. Every time the piezo changes polarity fully, it produces a square wave with abrupt, hard edges, like a square. Other types of waves include triangle waves and sine waves, which are progressively less harsh. [Figure 7-14](#c07.xhtml#c07-fig-0014){#c07.xhtml#rc07-fig-0014} is an illustration of these waves so you can see the differences between them.

::: {#c07.xhtml#c07-fig-0014 .figure}
![9781119489542-fg0714.png](https://i.imgur.com/fmfvXEG.jpeg){.center}
:::

Piezos generate square waves, resulting in a buzzing sound. The buzzer isn't restricted to just one pitch. By changing the frequency that the buzzer is switched at (the width between the square waves), you can generate different frequencies and therefore different notes.
:::

::: {.section}
[]{#c07.xhtml#c07-sec-0024}

### The toneMelody sketch {#c07.xhtml#h3-13 .Heading-2}

With the toneMelody sketch, you see how to change the frequency of your piezo and play a predefined melody. This circuit allows you to program your own sounds. With a bit of time and consideration you can turn these sounds into melodies.

Piezo buzzers are supplied in most Arduino kits but can take many different forms. They can be supplied without an enclosure, as shown in [Figure 7-15](#c07.xhtml#c07-fig-0015){#c07.xhtml#rc07-fig-0015}, or can be enclosed in plastic housing ranging from small cylinders to flat coin-like shapes. []{#c07.xhtml#Page_144 .pagebreak role="doc-pagebreak" title="144"}They may also have different connections, either a set of two pins protruding from the underside of the piezo or two wires protruding from its side.

::: {#c07.xhtml#c07-fig-0015 .figure}
![9781119489542-fg0715.png](https://i.imgur.com/fwM3jLj.jpeg){.center}
:::

For the toneMelody sketch, you need the following:

-   [An Arduino Uno]{#c07.xhtml#c07-li-0044}
-   [A breadboard]{#c07.xhtml#c07-li-0045}
-   [A piezo buzzer]{#c07.xhtml#c07-li-0046}
-   [Jump wires]{#c07.xhtml#c07-li-0047}

Connect the piezo buzzer to the breadboard and use a set of jump wires to connect it to digital pin 8 on one side and ground on the other. Some piezos have a polarity, so make sure that you connect the positive (+) to pin 8 and the negative (-) to GND. Other piezos don't have a polarity, so if you don\'t see any symbols, don't worry. The piezo circuit is shown in [Figure 7-16](#c07.xhtml#c07-fig-0016){#c07.xhtml#rc07-fig-0016}, and the circuit diagram appears in [7-17](#c07.xhtml#c07-fig-0017){#c07.xhtml#rc07-fig-0017}.

::: {#c07.xhtml#c07-fig-0016 .figure}
![9781119489542-fg0716.png](https://i.imgur.com/AcNdO96.jpeg){.center}
:::

::: {#c07.xhtml#c07-fig-0017 .figure}
![9781119489542-fg0717.png](https://i.imgur.com/KaqSfnL.jpeg){.center}
:::

Complete the circuit and open the sketch by choosing File ⇒   Examples ⇒   02.digital ⇒   toneMelody. You see the following code:

[]{#c07.xhtml#c07-code-0024}[]{#c07.xhtml#c07-lntxt-0024}

`/*`{#c07.xhtml#c07-line-0217}

`  Melody`{#c07.xhtml#c07-line-0218}

` `{#c07.xhtml#c07-line-0219}

` Plays a melody `{#c07.xhtml#c07-line-0220}

` `{#c07.xhtml#c07-line-0221}

` circuit:`{#c07.xhtml#c07-line-0222}

` * 8-ohm speaker on digital pin 8`{#c07.xhtml#c07-line-0223}

` `{#c07.xhtml#c07-line-0224}

` created 21 Jan 2010`{#c07.xhtml#c07-line-0225}

` modified 30 Aug 2011`{#c07.xhtml#c07-line-0226}

` by Tom Igoe `{#c07.xhtml#c07-line-0227}

``{#c07.xhtml#c07-line-0228} 

` This example code is in the public domain.`{#c07.xhtml#c07-line-0229}

` `{#c07.xhtml#c07-line-0230}

` http://arduino.cc/en/Tutorial/Tone`{#c07.xhtml#c07-line-0231}

` `{#c07.xhtml#c07-line-0232}

` */`{#c07.xhtml#c07-line-0233}

` [[include]] "pitches.h"`{#c07.xhtml#c07-line-0234}

``{#c07.xhtml#c07-line-0235} 

`// notes in the melody:`{#c07.xhtml#c07-line-0236}

`int melody[] = {`{#c07.xhtml#c07-line-0237}

`  NOTE_C4, NOTE_G3,NOTE_G3, NOTE_A3, NOTE_G3,0, NOTE_B3, NOTE_C4};`{#c07.xhtml#c07-line-0238}

``{#c07.xhtml#c07-line-0239} 

`// note durations: 4 = quarter note, 8 = eighth note, etc.:`{#c07.xhtml#c07-line-0240}

`int noteDurations[] = {`{#c07.xhtml#c07-line-0241}

`  4, 8, 8, 4,4,4,4,4 };`{#c07.xhtml#c07-line-0242}

``{#c07.xhtml#c07-line-0243} 

`void setup() {`{#c07.xhtml#c07-line-0244}

`  // iterate over the notes of the melody:`{#c07.xhtml#c07-line-0245}

`  for (int thisNote = 0; thisNote < 8; thisNote++) {`{#c07.xhtml#c07-line-0246}

``{#c07.xhtml#c07-line-0247} 

`    // to calculate the note duration, take one second `{#c07.xhtml#c07-line-0248}

`    // divided by the note type.`{#c07.xhtml#c07-line-0249}

`    //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc.`{#c07.xhtml#c07-line-0250}

`    int noteDuration = 1000/noteDurations[thisNote];`{#c07.xhtml#c07-line-0251}

`    tone(8, melody[thisNote],noteDuration);`{#c07.xhtml#c07-line-0252}

``{#c07.xhtml#c07-line-0253} 

`    // to distinguish the notes, set a minimum time between them.`{#c07.xhtml#c07-line-0254}

`    // the note's duration + 30% seems to work well:`{#c07.xhtml#c07-line-0255}

`    int pauseBetweenNotes = noteDuration * 1.30;`{#c07.xhtml#c07-line-0256}

`    delay(pauseBetweenNotes);`{#c07.xhtml#c07-line-0257}

`    // stop the tone playing:`{#c07.xhtml#c07-line-0258}

`    noTone(8);`{#c07.xhtml#c07-line-0259}

`  }`{#c07.xhtml#c07-line-0260}

`}`{#c07.xhtml#c07-line-0261}

``{#c07.xhtml#c07-line-0262} 

`void loop() {`{#c07.xhtml#c07-line-0263}

`  // no need to repeat the melody.`{#c07.xhtml#c07-line-0264}

`}`{#c07.xhtml#c07-line-0265}

[]{#c07.xhtml#Page_146 .pagebreak role="doc-pagebreak" title="146"}[]{#c07.xhtml#Page_147 .pagebreak role="doc-pagebreak" title="147"}In the toneMelody sketch, you have another tab called pitches.h, which contains all the data needed to make the correct tones with your buzzer. In your Arduino sketch folder, this tab (and other, additional tabs) appears as its own individual file and must be included in the main sketch using the [`#include`]{.Code-within-text} function followed by the name of the file to be included. In this case, the code reads [`#include "pitches.h"`]{.Code-within-text}. The pitches.h file follows for your reference.

[]{#c07.xhtml#c07-fea-0002}

pitches.h

[]{#c07.xhtml#c07-sec-0025}[]{#c07.xhtml#c07-code-0025}[]{#c07.xhtml#c07-lntxt-0025}

` `{#c07.xhtml#c07-line-0266}

`/*************************************************`{#c07.xhtml#c07-line-0267}

` * Public Constants`{#c07.xhtml#c07-line-0268}

` *************************************************/`{#c07.xhtml#c07-line-0269}

``{#c07.xhtml#c07-line-0270} 

`#define NOTE_B0  31`{#c07.xhtml#c07-line-0271}

`#define NOTE_C1  33`{#c07.xhtml#c07-line-0272}

`#define NOTE_CS1 35`{#c07.xhtml#c07-line-0273}

`#define NOTE_D1  37`{#c07.xhtml#c07-line-0274}

`#define NOTE_DS1 39`{#c07.xhtml#c07-line-0275}

`#define NOTE_E1  41`{#c07.xhtml#c07-line-0276}

`#define NOTE_F1  44`{#c07.xhtml#c07-line-0277}

`#define NOTE_FS1 46`{#c07.xhtml#c07-line-0278}

`#define NOTE_G1  49`{#c07.xhtml#c07-line-0279}

`#define NOTE_GS1 52`{#c07.xhtml#c07-line-0280}

`#define NOTE_A1  55`{#c07.xhtml#c07-line-0281}

`#define NOTE_AS1 58`{#c07.xhtml#c07-line-0282}

`#define NOTE_B1  62`{#c07.xhtml#c07-line-0283}

`#define NOTE_C2  65`{#c07.xhtml#c07-line-0284}

`#define NOTE_CS2 69`{#c07.xhtml#c07-line-0285}

`#define NOTE_D2  73`{#c07.xhtml#c07-line-0286}

`#define NOTE_DS2 78`{#c07.xhtml#c07-line-0287}

`#define NOTE_E2  82`{#c07.xhtml#c07-line-0288}

`#define NOTE_F2  87`{#c07.xhtml#c07-line-0289}

`#define NOTE_FS2 93`{#c07.xhtml#c07-line-0290}

`#define NOTE_G2  98`{#c07.xhtml#c07-line-0291}

`#define NOTE_GS2 104`{#c07.xhtml#c07-line-0292}

`#define NOTE_A2  110`{#c07.xhtml#c07-line-0293}

`#define NOTE_AS2 117`{#c07.xhtml#c07-line-0294}

`#define NOTE_B2  123`{#c07.xhtml#c07-line-0295}

`#define NOTE_C3  131`{#c07.xhtml#c07-line-0296}

`#define NOTE_CS3 139`{#c07.xhtml#c07-line-0297}

`#define NOTE_D3  147`{#c07.xhtml#c07-line-0298}

`#define NOTE_DS3 156`{#c07.xhtml#c07-line-0299}

`#define NOTE_E3  165`{#c07.xhtml#c07-line-0300}

`#define NOTE_F3  175`{#c07.xhtml#c07-line-0301}

`#define NOTE_FS3 185`{#c07.xhtml#c07-line-0302}

`#define NOTE_G3  196`{#c07.xhtml#c07-line-0303}

`#define NOTE_GS3 208`{#c07.xhtml#c07-line-0304}

`#define NOTE_A3  220`{#c07.xhtml#c07-line-0305}

`#define NOTE_AS3 233`{#c07.xhtml#c07-line-0306}

`#define NOTE_B3  247`{#c07.xhtml#c07-line-0307}

`#define NOTE_C4  262`{#c07.xhtml#c07-line-0308}

`#define NOTE_CS4 277`{#c07.xhtml#c07-line-0309}

`#define NOTE_D4  294`{#c07.xhtml#c07-line-0310}

`#define NOTE_DS4 311`{#c07.xhtml#c07-line-0311}

`#define NOTE_E4  330`{#c07.xhtml#c07-line-0312}

`#define NOTE_F4  349`{#c07.xhtml#c07-line-0313}

`#define NOTE_FS4 370`{#c07.xhtml#c07-line-0314}

`#define NOTE_G4  392`{#c07.xhtml#c07-line-0315}

`#define NOTE_GS4 415`{#c07.xhtml#c07-line-0316}

`#define NOTE_A4  440`{#c07.xhtml#c07-line-0317}

`#define NOTE_AS4 466`{#c07.xhtml#c07-line-0318}

`#define NOTE_B4  494`{#c07.xhtml#c07-line-0319}

`#define NOTE_C5  523`{#c07.xhtml#c07-line-0320}

`#define NOTE_CS5 554`{#c07.xhtml#c07-line-0321}

`#define NOTE_D5  587`{#c07.xhtml#c07-line-0322}

`#define NOTE_DS5 622`{#c07.xhtml#c07-line-0323}

`#define NOTE_E5  659`{#c07.xhtml#c07-line-0324}

`#define NOTE_F5  698`{#c07.xhtml#c07-line-0325}

`#define NOTE_FS5 740`{#c07.xhtml#c07-line-0326}

`#define NOTE_G5  784`{#c07.xhtml#c07-line-0327}

`#define NOTE_GS5 831`{#c07.xhtml#c07-line-0328}

`#define NOTE_A5  880`{#c07.xhtml#c07-line-0329}

`#define NOTE_AS5 932`{#c07.xhtml#c07-line-0330}

`#define NOTE_B5  988`{#c07.xhtml#c07-line-0331}

`#define NOTE_C6  1047`{#c07.xhtml#c07-line-0332}

`#define NOTE_CS6 1109`{#c07.xhtml#c07-line-0333}

`#define NOTE_D6  1175`{#c07.xhtml#c07-line-0334}

`#define NOTE_DS6 1245`{#c07.xhtml#c07-line-0335}

`#define NOTE_E6  1319`{#c07.xhtml#c07-line-0336}

`#define NOTE_F6  1397`{#c07.xhtml#c07-line-0337}

`#define NOTE_FS6 1480`{#c07.xhtml#c07-line-0338}

`#define NOTE_G6  1568`{#c07.xhtml#c07-line-0339}

`#define NOTE_GS6 1661`{#c07.xhtml#c07-line-0340}

`#define NOTE_A6  1760`{#c07.xhtml#c07-line-0341}

`#define NOTE_AS6 1865`{#c07.xhtml#c07-line-0342}

`#define NOTE_B6  1976`{#c07.xhtml#c07-line-0343}

`#define NOTE_C7  2093`{#c07.xhtml#c07-line-0344}

`#define NOTE_CS7 2217`{#c07.xhtml#c07-line-0345}

`#define NOTE_D7  2349`{#c07.xhtml#c07-line-0346}

`#define NOTE_DS7 2489`{#c07.xhtml#c07-line-0347}

`#define NOTE_E7  2637`{#c07.xhtml#c07-line-0348}

`#define NOTE_F7  2794`{#c07.xhtml#c07-line-0349}

`#define NOTE_FS7 2960`{#c07.xhtml#c07-line-0350}

`#define NOTE_G7  3136`{#c07.xhtml#c07-line-0351}

`#define NOTE_GS7 3322`{#c07.xhtml#c07-line-0352}

`#define NOTE_A7  3520`{#c07.xhtml#c07-line-0353}

`#define NOTE_AS7 3729`{#c07.xhtml#c07-line-0354}

`#define NOTE_B7  3951`{#c07.xhtml#c07-line-0355}

`#define NOTE_C8  4186`{#c07.xhtml#c07-line-0356}

`#define NOTE_CS8 4435`{#c07.xhtml#c07-line-0357}

`#define NOTE_D8  4699`{#c07.xhtml#c07-line-0358}

`#define NOTE_DS8 4978`{#c07.xhtml#c07-line-0359}

[]{#c07.xhtml#Page_150 .pagebreak role="doc-pagebreak" title="150"}After you\'ve found the sketch, press the Compile button to check the code. The message area highlights grammatical errors in red if any are discovered.

If the sketch compiles correctly, press Upload to upload the sketch to your board. When it has finished uploading, you should hear a buzzer that sings a tune to you and then stops. To hear the tune again, press the reset button on your Arduino.

If you don\'t hear a buzzer, you should double-check your wiring:

-   [Make sure you're using pin 8 as your output.]{#c07.xhtml#c07-li-0048}
-   [Check that your piezo is correctly positioned. Symbols may be hidden on the underside if they are not visible on the top. If you don\'t see any markings, try the piezo in the other orientation.]{#c07.xhtml#c07-li-0049}
-   [Check the connections on the breadboard. If the jump wires or components are not connected using the correct rows in the breadboard, they will not work.]{#c07.xhtml#c07-li-0050}
:::

::: {.section}
[]{#c07.xhtml#c07-sec-0026}

### Understanding the sketch {#c07.xhtml#h3-14 .Heading-2}

The toneMelody sketch is the first one in this book that uses multiple tabs. You sometimes use *tabs* as a convenient way of separating sketches. In this case, the [`pitches.h`]{.Code-within-text} tab is a reference or lookup table for all the possible notes in the piezo's range. Because this code won't change, it doesn't need to be in the main body of code.

At the top of the toneMelody sketch is a note to include [`pitches.h`]{.Code-within-text}, which is treated in the same way as a library. It is an external file that can be brought into sketches if needed. In this case, we need it to determine which frequencies are used to create the notes:

[]{#c07.xhtml#c07-code-0026}[]{#c07.xhtml#c07-lntxt-0026}

`#include "pitches.h"`{#c07.xhtml#c07-line-0360}

[]{#c07.xhtml#Page_151 .pagebreak role="doc-pagebreak" title="151"} Now that the sketch knows the different notes, the melody is defined in an array so that the notes can be stepped through in order. To find out more about arrays, see the "[Introducing Arrays](#c07.xhtml#c07-sec-0027)" sidebar. The names, such as [`NOTE_C4`]{.Code-within-text}, refer to the names of notes in the pitches.h tab. If you look at pitches.h, you will see that it uses a C function called [`define`]{.Code-within-text} for each of these note references and follows them with a number, such as [`#define NOTE_C4 262`]{.Code-within-text}. So whenever [`NOTE_C4`]{.Code-within-text} is mentioned, it is really just a variable name for the value 262:

[]{#c07.xhtml#c07-code-0027}[]{#c07.xhtml#c07-lntxt-0027}

`// notes in the melody:`{#c07.xhtml#c07-line-0361}

`int melody[] = {`{#c07.xhtml#c07-line-0362}

`  NOTE_C4, NOTE_G3,NOTE_G3, NOTE_A3, NOTE_G3,0, NOTE_B3, NOTE_C4};`{#c07.xhtml#c07-line-0363}

```{=html}
<aside>
```
::: {#c07.xhtml#c07-tblfxd-0001 .sidebar}
# []{#c07.xhtml#Page_152 .pagebreak role="doc-pagebreak" title="152"}INTRODUCING ARRAYS {.SB-Head}

[]{#c07.xhtml#c07-sec-0027}

In its simplest form, an *array* is a list of data. Think of it as being like a shopping list, as shown in the following table. Each row has a number, referred to as the *index,* and the data contained in that part of the list. This kind of array is a one-dimensional array, containing only one item of data for each, in this case the name of a piece of fruit.

In computing, it\'s common to use *zero indexing*, which means starting your list from zero, as shown in the following table.

```{=html}
<figure>
```
  **Index**   **Value**
  ----------- -----------
  0           apples
  1           bananas
  2           oranges

```{=html}
</figure>
```
How is an array relevant to Arduino? Arrays can store integers, floats, characters, or any other type of data, but I use integers here to keep things simple. Here is an array of six integer values:

[]{#c07.xhtml#c07-code-0028}[]{#c07.xhtml#c07-lntxt-0028}

`int simpleArray[] =`{#c07.xhtml#c07-line-0364}

`       {1, 255, -51, 0, 102, 27};`{#c07.xhtml#c07-line-0365}

First, [`int`]{.Code-within-text} defines the type of data being stored as integers (whole numbers). The data type could also be [`float`]{.Code-within-text} for floating-point numbers or [`char`]{.Code-within-text} for characters. The name of the array is [`simpleArray`]{.Code-within-text} but can be any relevant name that best describes your array. The square brackets ([`[])`]{.Code-within-text} store the length of the array (the number of values that can be stored in the array); in this case, the space is blank, which means that this array has no fixed length. The numbers inside the curly braces [`{}`]{.Code-within-text} are values defined in the array. These are optional, so if they are not defined, the array will be left empty.

There are other correct ways to declare arrays, including the following:

[]{#c07.xhtml#c07-code-0029}[]{#c07.xhtml#c07-lntxt-0029}

`int simpleArray[10];`{#c07.xhtml#c07-line-0366}

`float simpleArray[5] = {2.7, 42.1, -9.1, 300.6};`{#c07.xhtml#c07-line-0367}

`char simpleArray[14] = "hello, world!";`{#c07.xhtml#c07-line-0368}

Note that the character array entry has a number one greater than the number of characters. Remember this requirement if you\'re getting errors.

Now that your array is defined, you need to know how to use it. To use values in an array, you refer to them by their index. If you wanted to send a value to the serial monitor, you would write the following:

[]{#c07.xhtml#c07-code-0030}[]{#c07.xhtml#c07-lntxt-0030}

`Serial.println(simpleArray[2]);`{#c07.xhtml#c07-line-0369}

This line would display a value of -51 because that is the value stored in index 2 of the array.

You can also update values in the array. An effective way to update is with a [`for`]{.Code-within-text} loop, to count through each index in the array (see [Chapter 10](#c10.xhtml) for more details) as in the following example:

[]{#c07.xhtml#c07-code-0031}[]{#c07.xhtml#c07-lntxt-0031}

`for (int i = 0; i < 6; i++) {`{#c07.xhtml#c07-line-0370}

`    simpleArray[i] = analogRead(sensorPin);          `{#c07.xhtml#c07-line-0371}

`} `{#c07.xhtml#c07-line-0372}

The [`for`]{.Code-within-text} loop in this case will loop six times, increasing the [`i`]{.Code-within-text} variable by 1 each loop. The [`i`]{.Code-within-text} variable is used also to represent the index of the array, so with each loop, a new analog reading from [`sensorPin`]{.Code-within-text} is stored in the current index and the index of the array is incremented for the next loop.

This loop is a clever and efficient way to work through arrays, either using or updating the data stored in them. Arrays can get even more complicated, storing many strings of text, or they can be multidimensional, like a spreadsheet, with many values associated with each index. For more information, head over to the official Arduino reference page on arrays at [[`http://arduino.cc/en/Reference/Array`]{.Code-within-text}](http://arduino.cc/en/Reference/Array).
:::

```{=html}
</aside>
```
Without the beat, your melody wouldn\'t sound right, so another array stores the duration for each note:

[]{#c07.xhtml#c07-code-0032}[]{#c07.xhtml#c07-lntxt-0032}

`// note durations: 4 = quarter note, 8 = eighth note, etc.:`{#c07.xhtml#c07-line-0373}

`int noteDurations[] = {`{#c07.xhtml#c07-line-0374}

`  4, 8, 8, 4,4,4,4,4 };`{#c07.xhtml#c07-line-0375}

In [`setup`]{.Code-within-text}, a [`for`]{.Code-within-text} loop is used to cycle through each of the eight notes, from 0 to 7. The [`thisNote`]{.Code-within-text} value is used as an index to point to the correct items in each array:

[]{#c07.xhtml#c07-code-0033}[]{#c07.xhtml#c07-lntxt-0033}

`void setup() {`{#c07.xhtml#c07-line-0376}

`  // iterate over the notes of the melody:`{#c07.xhtml#c07-line-0377}

`  for (int thisNote = 0; thisNote < 8; thisNote++) {`{#c07.xhtml#c07-line-0378}

The duration is calculated by dividing 1,000 (or 1 second) by the required duration, 4 for a quarter note or crotchet, 8 for and eighth note or quaver, and so on. This value is then written to the function tone, which sends the current note to pin 8 for the assigned duration:

[]{#c07.xhtml#c07-code-0034}[]{#c07.xhtml#c07-lntxt-0034}

`    // to calculate the note duration, take one second `{#c07.xhtml#c07-line-0379}

`    // divided by the note type.`{#c07.xhtml#c07-line-0380}

`    //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc.`{#c07.xhtml#c07-line-0381}

`    int noteDuration = 1000/noteDurations[thisNote];`{#c07.xhtml#c07-line-0382}

`    tone(8, melody[thisNote],noteDuration);`{#c07.xhtml#c07-line-0383}

A small pause between notes is used so that they are better defined. In this case, the pause is relative to the length of the note and is set to 30 percent of the current note duration:

[]{#c07.xhtml#c07-code-0035}[]{#c07.xhtml#c07-lntxt-0035}

`// to distinguish the notes, set a minimum time between them.`{#c07.xhtml#c07-line-0384}

`    // the note's duration + 30% seems to work well:`{#c07.xhtml#c07-line-0385}

`    int pauseBetweenNotes = noteDuration * 1.30;`{#c07.xhtml#c07-line-0386}

`    delay(pauseBetweenNotes);`{#c07.xhtml#c07-line-0387}

Next, the [`noTone`]{.Code-within-text} function is used to turn off pin 8, stopping the note after it has played for its duration:

[]{#c07.xhtml#c07-code-0036}[]{#c07.xhtml#c07-lntxt-0036}

`  // stop the tone playing:`{#c07.xhtml#c07-line-0388}

` noTone(8);`{#c07.xhtml#c07-line-0389}

` }`{#c07.xhtml#c07-line-0390}

`}`{#c07.xhtml#c07-line-0391}

In the loop, nothing happens. As it stands, the melody plays once at the start and then ends. The melody could be moved to the loop to play forever, but this decision may cause mild headaches: []{#c07.xhtml#Page_153 .pagebreak role="doc-pagebreak" title="153"}

[]{#c07.xhtml#c07-code-0037}[]{#c07.xhtml#c07-lntxt-0037}

`void loop() {`{#c07.xhtml#c07-line-0392}

`  // no need to repeat the melody.`{#c07.xhtml#c07-line-0393}

`}`{#c07.xhtml#c07-line-0394}

![tip.png](https://i.imgur.com/Ki0GRw9.jpeg) The toneMelody sketch is a great example of using a melody as an audio signal at the start of a sketch. Audio feedback can be a great alternative or addition to visual feedback in your project.
:::
:::

::: {.section}
[]{#c07.xhtml#c07-sec-0028}

## Making an Instrument {#c07.xhtml#h2-10 .Heading-1}

In the preceding section, you find out how to make your project play a sound rather than blink a light, as in previous sketches. In the example in this section, you see how to go beyond playing a sound --- you create your own instrument, similar to the Theremin. The *Theremin*, named after its inventor Léon Theremin, was one of the first electronic instruments, developed in the 1920s. It worked by detecting the electromagnetic field of the player\'s hands to change signals: one hand for volume and the other for pitch.

::: {.section}
[]{#c07.xhtml#c07-sec-0029}

### The PitchFollower sketch {#c07.xhtml#h3-15 .Heading-2}

In the PitchFollower sketch, you find out how to make a budget Theremin by using a piezo as a light sensor to control the pitch.

You need the following:

-   [An Arduino Uno]{#c07.xhtml#c07-li-0051}
-   [A breadboard]{#c07.xhtml#c07-li-0052}
-   [A piezo]{#c07.xhtml#c07-li-0053}
-   [A light sensor]{#c07.xhtml#c07-li-0054}
-   [A 4.7k ohm resistor]{#c07.xhtml#c07-li-0055}
-   [Jump wires]{#c07.xhtml#c07-li-0056}

This circuit has two separate halves: the piezo and the light sensor circuit. The piezo is wired as in the toneMelody sketch, with one wire to digital pin 9 and the other to GND. The light sensor is connected to analog 0 on one side and 5V on the other; the 4.7K resistor is connected between analog 0 and ground (as shown in [Figures 7-18](#c07.xhtml#c07-fig-0018){#c07.xhtml#rc07-fig-0018} and [7-19](#c07.xhtml#c07-fig-0019){#c07.xhtml#rc07-fig-0019}). If you do not have a 4.7K resistor, use the nearest you have to that value.[]{#c07.xhtml#Page_154 .pagebreak role="doc-pagebreak" title="154"}

::: {#c07.xhtml#c07-fig-0018 .figure}
![9781119489542-fg0718.png](https://i.imgur.com/rxNfFGr.jpeg){.center}
:::

::: {#c07.xhtml#c07-fig-0019 .figure}
![9781119489542-fg0719.png](https://i.imgur.com/7A1N0gd.jpeg){.center}
:::

Complete the circuit, and open the sketch by choosing File ⇒   Examples ⇒   02.Digital ⇒   tonePitchFollower:

[]{#c07.xhtml#c07-code-0038}[]{#c07.xhtml#c07-lntxt-0038}

`/*`{#c07.xhtml#c07-line-0395}

`  Pitch follower`{#c07.xhtml#c07-line-0396}

` `{#c07.xhtml#c07-line-0397}

` Plays a pitch that changes based on a changing analog input`{#c07.xhtml#c07-line-0398}

` `{#c07.xhtml#c07-line-0399}

` circuit:`{#c07.xhtml#c07-line-0400}

` * 8-ohm speaker on digital pin 9`{#c07.xhtml#c07-line-0401}

` * photoresistor on analog 0 to 5V`{#c07.xhtml#c07-line-0402}

` * 4.7K resistor on analog 0 to ground`{#c07.xhtml#c07-line-0403}

` `{#c07.xhtml#c07-line-0404}

` created 21 Jan 2010`{#c07.xhtml#c07-line-0405}

` modified 9 Apr 2012`{#c07.xhtml#c07-line-0406}

` by Tom Igoe `{#c07.xhtml#c07-line-0407}

``{#c07.xhtml#c07-line-0408} 

`This example code is in the public domain.`{#c07.xhtml#c07-line-0409}

` `{#c07.xhtml#c07-line-0410}

` http://arduino.cc/en/Tutorial/Tone2`{#c07.xhtml#c07-line-0411}

` `{#c07.xhtml#c07-line-0412}

` */`{#c07.xhtml#c07-line-0413}

` `{#c07.xhtml#c07-line-04012}

``{#c07.xhtml#c07-line-0414} 

``{#c07.xhtml#c07-line-0415} 

`void setup() {`{#c07.xhtml#c07-line-0416}

`  // initialize serial communications (for debugging only):`{#c07.xhtml#c07-line-0417}

`  Serial.begin(9600);`{#c07.xhtml#c07-line-0418}

`}`{#c07.xhtml#c07-line-0419}

``{#c07.xhtml#c07-line-0420} 

`void loop() {`{#c07.xhtml#c07-line-0421}

`  // read the sensor:`{#c07.xhtml#c07-line-0422}

`  int sensorReading = analogRead(A0);`{#c07.xhtml#c07-line-0423}

`  // print the sensor reading so you know its range`{#c07.xhtml#c07-line-0424}

`  Serial.println(sensorReading);`{#c07.xhtml#c07-line-0425}

`  // map the analog input range (in this case, 400 - 1000 from the `{#c07.xhtml#c07-line-0426}

`  // photoresistor) to the output pitch range (120 - 1500Hz)`{#c07.xhtml#c07-line-0427}

`  // change the minimum and maximum input numbers below depending on the `{#c07.xhtml#c07-line-0428}

`  // range your sensor's giving:  `{#c07.xhtml#c07-line-0429}

`int thisPitch = map(sensorReading, 400, 1000, 120, 1500);`{#c07.xhtml#c07-line-0430}

``{#c07.xhtml#c07-line-0431} 

`  // play the pitch:`{#c07.xhtml#c07-line-0432}

`  tone(9, thisPitch, 10);`{#c07.xhtml#c07-line-0433}

`  delay(1);        // delay in between reads for stability`{#c07.xhtml#c07-line-0434}

`}`{#c07.xhtml#c07-line-0435}

[]{#c07.xhtml#Page_156 .pagebreak role="doc-pagebreak" title="156"} After you\'ve found the sketch, press the Compile button to check the code. Any syntax errors turn the message area red when they are discovered, and you see an error message stating what is wrong.

If the sketch compiles correctly, press Upload to upload the sketch to your board. When it has finished uploading, you should have a light sensor that will change the pitch of your buzzer. If you don't hear a change, make sure that you are in a well-lit area or turn a desk lamp on over your breadboard to increase the difference when you cover the light sensor with your hand.

If nothing happens, you should double-check your wiring:

-   [Make sure that you're using the correct pin number for the inputs and outputs.]{#c07.xhtml#c07-li-0057}
-   [Check that your piezo is turned the correct way. Symbols may be hidden on the underside if they are not visible.]{#c07.xhtml#c07-li-0058}
-   [Check the connections on the breadboard. If the jump wires or components are not connected using the correct rows in the breadboard, they will not work.]{#c07.xhtml#c07-li-0059}
:::

::: {.section}
[]{#c07.xhtml#c07-sec-0030}

### Understanding the sketch {#c07.xhtml#h3-16 .Heading-2}

This sketch is a lot shorter than the toneMelody sketch, presented earlier in the chapter, because it converts the readings from the light sensor to a frequency directly rather than requires a lookup table. Because you are converting readings, you can slide between notes as well as choose them individually.

In the [`setup`]{.Code-within-text} function, the serial port is opened to allow you to monitor the sensor readings as they come in:

[]{#c07.xhtml#c07-code-0039}[]{#c07.xhtml#c07-lntxt-0039}

`void setup() {`{#c07.xhtml#c07-line-0436}

`  // initialize serial communications (for debugging only):`{#c07.xhtml#c07-line-0437}

`  Serial.begin(9600);`{#c07.xhtml#c07-line-0438}

`}`{#c07.xhtml#c07-line-0439}

In the main loop, the light sensor is read from analog pin 0. This reading is also forwarded to the serial monitor:

[]{#c07.xhtml#c07-code-0040}[]{#c07.xhtml#c07-lntxt-0040}

`void loop() {`{#c07.xhtml#c07-line-0440}

`  // read the sensor:`{#c07.xhtml#c07-line-0441}

`  int sensorReading = analogRead(A0);`{#c07.xhtml#c07-line-0442}

`  // print the sensor reading so you know its range`{#c07.xhtml#c07-line-0443}

`  Serial.println(sensorReading);`{#c07.xhtml#c07-line-0444}

[]{#c07.xhtml#Page_157 .pagebreak role="doc-pagebreak" title="157"} To convert the sensor's range to the range of frequencies that the buzzer can cover, you use the [`map`]{.Code-within-text} function:

[]{#c07.xhtml#c07-code-0041}[]{#c07.xhtml#c07-lntxt-0041}

`  // map the analog input range (in this case, 400 - 1000 from the `{#c07.xhtml#c07-line-0445}

`  // photoresistor) to the output pitch range (120 - 1500Hz)`{#c07.xhtml#c07-line-0446}

`  // change the minimum and maximum input numbers below depending on the `{#c07.xhtml#c07-line-0447}

`  // range your sensor's giving:  `{#c07.xhtml#c07-line-0448}

`  int thisPitch = ma(sensorReading, 400, 1000, 100, 1000);`{#c07.xhtml#c07-line-0449}

The tone function then outputs the note with the mapped sensor value and a very short duration of 10 milliseconds. This duration serves to make the sound audible, but the real duration is determined by how long you hold your hand over the sensor, as described previously:

[]{#c07.xhtml#c07-code-0042}[]{#c07.xhtml#c07-lntxt-0042}

`  // play the pitch:`{#c07.xhtml#c07-line-0450}

`  tone(9, thisPitch, 10);`{#c07.xhtml#c07-line-0451}

Finally, a tiny delay occurs at the end of the loop to improve the stability for the readings:

[]{#c07.xhtml#c07-code-0043}[]{#c07.xhtml#c07-lntxt-0043}

`  delay(1);        // delay in between reads for stability`{#c07.xhtml#c07-line-0452}

`}`{#c07.xhtml#c07-line-0453}

With this setup, you can quickly make an easy controller and maybe even form a traveling Theremin band with your friends.
:::
:::

[]{#p03.xhtml}

::: {.section}
[]{#p03.xhtml#Page_159 .pagebreak role="doc-pagebreak" title="159"}Part 3

# Building on the Basics {#p03.xhtml#a1 .Part-Title}

::: {.section}
[]{#p03.xhtml#p03-sec-0001}

[]{#p03.xhtml#Page_160 .pagebreak role="doc-pagebreak" title="160"}IN THIS PART ...

See some of the varied uses of Arduino though a few projects already out in the world.

Make your basic prototypes into something more solid by learning about soldering.

Use code to improve the reliability of your project.

Learn how to choose the right sensors for your projects.

Discover new possibilities by using shields and libraries.
:::
:::

[]{#c08.xhtml}

[]{#c08.xhtml#Page_161 .pagebreak role="doc-pagebreak" title="161"}Chapter 8

# Learning by Example {#c08.xhtml#a1 .Chap-Title}

::: {.section}
[]{#c08.xhtml#c08-sec-0001}[]{#c08.xhtml#c08-feafxd-0001}

IN THIS CHAPTER

![check.png](https://i.imgur.com/CnjQOsp.jpeg) **Looking at successful Arduino projects**

![check.png](https://i.imgur.com/p6yY9D5.jpeg) **Understanding how these projects work and why they're so great**

![check.png](https://i.imgur.com/9sE1xhp.jpeg) **Getting ideas for your own amazing Arduino projects**

In previous chapters, I show you the beginnings of Arduino projects, but it can be difficult to know what to do with that knowledge. Read this chapter for a taste of the vast variety of uses and huge potential of Arduino. You discover projects that have used Arduino to create breathtaking art installations, long-lasting interactive exhibitions, and prototypes for products that have made it out into the world.
:::

::: {.section}
[]{#c08.xhtml#c08-sec-0002}

## Skube {#c08.xhtml#h2-1 .Heading-1}

The Skube project was developed by Andrew Nip, Ruben van der Vleuten, Malthe Borch, and Andrew Spitz as part of the Tangible User Interface module at the Copenhagen Institute of Interaction Design (CIID). It\'s an excellent example of how to use Arduino for product prototyping and development.

Skube (shown in [Figure 8-1](#c08.xhtml#c08-fig-0001){#c08.xhtml#rc08-fig-0001}) is a product that allows you to interact with digital music services that you would usually access on your computer. To make better use of digital music services, the project aims to rethink the way audio devices work and how they are used. Each Skube has two modes, Playlist and Discovery, that you select by tapping the top of the device. Playlist plays through a predefined playlist of music, and Discovery searches for similar artists or tracks. Skubes can also be combined to shuffle between each of the predefined playlists. They will physically snap together, giving the user a tangible way of mixing different playlists and discovering new music.

::: {#c08.xhtml#c08-fig-0001 .figure}
![9781119489542-fg0801.png](https://i.imgur.com/fhUMR96.jpeg){.center}
:::

::: {.section}
[]{#c08.xhtml#c08-sec-0003}

### How it works {#c08.xhtml#h3-1 .Heading-2}

Thankfully, the Skube team offers a great amount of documentation and an excellent video of the finished prototypes as well as a good look under the hood. Inside each Skube is an Arduino and an XBee wireless module (unfortunately, this book doesn't have enough room to cover this amazing module, but you should find ample resources online with a quick Google search).

The Arduino's main function is to act as the middleman, hosting a number of different sensors and communication devices and relaying the correct data to the correct places. The tap sensor is the same as that described in [Chapter 11](#c11.xhtml) and uses a simple piezo element to monitor vibrations. When Skubes snap together, the magnet is acting as a switch as well, activating a reed switch. The *reed switch* closes its metal contacts when a magnet comes near, giving the device a clear indication of when the magnet is present.

The project also has an FM radio module, which is used to output the music for each Skube. With the XBee wireless modules, you can communicate with and coordinate each Skube by using custom software on a computer, which is written in Max/MSP language, a visual programming language found in many audio and music projects.

The Skube team gathered data from playlists on Last.fm and Spotify to find similar artist features. These companies provide various features to their customers []{#c08.xhtml#Page_163 .pagebreak role="doc-pagebreak" title="163"}(such as assembling playlists based on your favorite tracks and providing a database of albums and artists), as well as access to these features for developers who have interesting ideas for projects, smartphone applications, or products. This resource is known as an application programming interface (API). The API for Last.fm ([[`www.last.fm/api`]{.Code-within-text}](http://www.last.fm/api)) and Spotify ([[`developer.spotify.com/technologies/web-api/`]{.Code-within-text}](https://developer.spotify.com/technologies/web-api/)) are just two examples; many more are available for other specific web services as well, so always give it a Google!

You can see that this project has many elements, involving not just communicating wirelessly using Arduino (which can be a task in itself) but also communicating with other software, and from that software, communicating with other services on the Internet. For the more code-savvy among you, this application of Arduino may allow you to build from your existing knowledge to integrate hardware with other software. In [Part 5](#p05.xhtml), I introduce other available software and look in more depth at communicating with the Processing software environment.
:::

::: {.section}
[]{#c08.xhtml#c08-sec-0004}

### Further reading {#c08.xhtml#h3-2 .Heading-2}

You can find out more about this project by checking out the project pages on the CIID website at [[`ciid.dk/education/portfolio/idp12/courses/tangible-user-interface/projects/skube/`]{.Code-within-text}](http://ciid.dk/education/portfolio/idp12/courses/tangible-user-interface/projects/skube/) and Andrew Spitz's website at [[`www.soundplusdesign.com/?p=5516`]{.Code-within-text}](http://www.soundplusdesign.com/?p=5516).
:::
:::

::: {.section}
[]{#c08.xhtml#c08-sec-0005}

## Chorus {#c08.xhtml#h2-2 .Heading-1}

Chorus is a kinetic installation by United Visual Artists (UVA), a London-based art and design practice. UVA's work crosses many disciplines, including sculpture, architecture, live performance, moving image, and installation. The group has a reputation for creating visually stunning projects that push the boundaries of those disciplines.

Chorus (shown in [Figure 8-2](#c08.xhtml#c08-fig-0002){#c08.xhtml#rc08-fig-0002}) uses sound, light, and motion with dramatic effect and is an excellent example of how Arduino can play a role in huge installations as well as in tiny prototypes. The installation is made up of eight tall black pendulums swinging back and forth, simultaneously emitting light and sound. Spectators can walk underneath the pendulums, immersing themselves in the performance, as "the rhythm of the work moves between chaos and unison." Each pendulum has its own score, composed by Mira Calix, which can be heard when the audience gets near enough.

::: {#c08.xhtml#c08-fig-0002 .figure}
![9781119489542-fg0802.png](https://i.imgur.com/iQ1nxQ1.jpeg){.center}
:::

::: {.section}
[]{#c08.xhtml#c08-sec-0006}

### How it works {#c08.xhtml#h3-3 .Heading-2}

In this project, an Arduino is used for not only light and sound but also the motion of the pendulums. The swing of each pendulum is controlled by an electric motor mounted on a reduction gearbox. This motor can be controlled with a relay circuit, allowing the Arduino to affect this huge mechanical object. Each pendulum has two custom circuit boards, each with 50 LEDs to provide the light for the piece, and one speaker mounted in the base of the pendulum and controlled by the Arduino. The Arduino itself is controlled by custom software that is constantly sending and receiving data to make sure that the pendulums are coordinated to coincide with the score that is playing.

This project shows that you can use Arduino to great effect when combined with an understanding of other disciplines, such as art, mechanical engineering, and architecture. On their own, each of the elements of this project is relatively simple: controlling a motor, controlling an LED, and playing a melody. The challenge is when the scale of each of these increases. Controlling high-powered motors requires knowledge of loads and mechanics; controlling lots of LEDs requires an understanding of controlling higher voltage and current; and playing high-quality sound requires specific hardware.

[Chapter 12](#c12.xhtml) introduces you to shields that can make a lot of functions, similar to those used in Chorus, a lot easier to achieve with your Arduino.
:::

::: {.section}
[]{#c08.xhtml#Page_165 .pagebreak role="doc-pagebreak" title="165"}[]{#c08.xhtml#c08-sec-0007}

### Further reading {#c08.xhtml#h3-4 .Heading-2}

You can find the project page at UVA's website: [[`www.uva.co.uk/works/chorus`]{.Code-within-text}](http://www.uva.co.uk/works/chorus). In addition, an excellent paper by Vince Dziekan looks at both UVA's working practice and the Chorus project in detail: [[`http://fibreculturejournal.org/wp-content/pdfs/FCJ-122Vince Dziekan.pdf`]{.Code-within-text}](http://fibreculturejournal.org/wp-content/pdfs/FCJ-122Vince%20Dziekan.pdf).
:::
:::

::: {.section}
[]{#c08.xhtml#c08-sec-0008}

## Push Snowboarding {#c08.xhtml#h2-3 .Heading-1}

Push Snowboarding is a collaborative project between Nokia and Burton that aimed to visualize all the data about your snowboarding run. Vitamins Design Ltd (now Special Projects) was tasked to design and build a set of wireless sensors to communicate with a mobile phone in the snowboarder's pocket. Vitamins was founded by Duncan Fitzsimons, Clara Gaggero, and Adrian Westaway, who dub themselves a "design and invention studio." They are located in London, where they develop and make products, experiences, concepts, and systems for their clients. They have worked on a variety of projects, which is best described in their own words, having "worked on fashion catwalks and in operating theatres ... with pro snowboarders and factory workers ... for experimental theatre as well as techno-phobic pensioners."

For the snowboarding project, Vitamins designed a set of 3D printed sensor boxes (shown in [Figure 8-3](#c08.xhtml#c08-fig-0003){#c08.xhtml#rc08-fig-0003}) to measure galvanic skin response, heart rate, balance, 3D motion, position, geographical location, speed, and altitude. This data was then layered over a live video of the snowboarding run to show the links between different situations and the physical response of the snowboarder. This project is an excellent example of making well-finished Arduino products that are closer to customized products than prototypes.

::: {#c08.xhtml#c08-fig-0003 .figure}
![9781119489542-fg0803.png](https://i.imgur.com/mju1xsj.jpeg){.center}
:::

::: {.section}
[]{#c08.xhtml#c08-sec-0009}

### How it works {#c08.xhtml#h3-5 .Heading-2}

Each sensor is in a waterproof enclosure with a power button. When switched on, the Arduino talks wirelessly to the smartphone, communicating whatever data it finds. From there, the smartphone, with its superior processing power, crunches the numbers and compiles the data to present the snowboard run visually to the snowboarder.

The first challenge of this project was the size. Many sensors can be tiny, but the Arduino itself creates a big footprint, and if a snowboarder were wearing several sensor boxes, the data would be useless if the boxes were obstructing his or her movement. For this reason, each sensor box has an Arduino Pro Mini, which is wafer thin and only 18mm x 33mm. The same is true for the power source, which []{#c08.xhtml#Page_166 .pagebreak role="doc-pagebreak" title="166"}is provided by a rechargeable lithium battery, the same kind found in model aircraft and smartphones.

The project uses a variety of sensors: pressure sensors on the feet to judge balance; inertial measurement units (IMU), also referred to as degrees of freedom sensors, which are used to find the 3D orientation of the snowboarder; galvanic skin-response sensors to monitor sweat levels of the snowboarder; and a heart rate monitor to track the snowboarder's BPM.

This data is sent back to the phone wirelessly using a Bluetooth module located in each sensor box. The Bluetooth module is small, has a secure connection, and will reliably work over the short distance between the sensor box and the phone in the snowboarder's pocket. The data can then be combined with other data gathered by the phone, such as Global Positioning System (GPS), and then formatted by custom software on the phone.

Each of the sensors in this project is available from most online Arduino-related shops, along with examples and tutorials of how you can integrate them into your own project. The execution of this project is what makes it a great example for aspiring Arduinists. The combination of sensors provides snowboarders with a wealth of information that could be used to improve their technique or rate their performance in different ways. In addition, these products were made to survive in tough environments. The electronics, are located behind a tough case to protect []{#c08.xhtml#Page_167 .pagebreak role="doc-pagebreak" title="167"}them from impact and are carefully padded to protect them from shock, but they are also accessible. The case even includes a damp course to trap any moisture that may get in.
:::

::: {.section}
[]{#c08.xhtml#c08-sec-0010}

### Further reading {#c08.xhtml#h3-6 .Heading-2}

You can find more details about the project on the Vitamins website at [[`specialprojects.studio/project/push-snowboarding/`]{.Code-within-text}](http://specialprojects.studio/project/push-snowboarding/).
:::
:::

::: {.section}
[]{#c08.xhtml#c08-sec-0011}

## Baker Tweet {#c08.xhtml#h2-4 .Heading-1}

Baker Tweet is a project by Poke that tweets the latest freshly baked goods from the Albion Café as they come out of the oven. Poke is a creative company based in London and New York that specializes in all things digital. The project resulted from an assignment Poke London was given to put the newly opened Albion Café on the map. It proposed a "magical box" that allowed the café to announce its freshly baked goods using Twitter so that the locals would know when to visit to get the freshest bread, croissants, and buns. You can see a picture of the Baker Tweet device in [Figure 8-4](#c08.xhtml#c08-fig-0004){#c08.xhtml#rc08-fig-0004}, or pop into the café if you're in the neighborhood!

::: {#c08.xhtml#c08-fig-0004 .figure}
![9781119489542-fg0804.png](https://i.imgur.com/xdNDvzQ.jpeg){.center}
:::

::: {.section}
[]{#c08.xhtml#c08-sec-0012}

### How it works {#c08.xhtml#h3-7 .Heading-2}

The "magical box" that produces Twitter messages has a simple interface consisting of a dial, a button, and an LCD screen. The café\'s employee uses the dial to select the freshly baked item to be tweeted, the tweet is displayed on the LCD screen, the person pushes the button to send the tweet, and feedback on the LCD appears when the tweet is successfully sent. This simple interface is ideal for a busy café, requiring little time to update the online status. To add new items, the project uses an easy-to-use web interface that updates the list.

At the heart of this project is an Arduino that communicates with the Internet. This can be accomplished either with a wired Ethernet connection, using the Arduino Ethernet shield, or wirelessly, using a Linksys Wi-Fi adapter. The dial provides an analog input; the button provides a digital input. Combined with the LCD screen, they create a user interface for easily moving through the list and sending tweets. The prototype is encased in a sturdy enclosure to prevent dough and floury hands from damaging the circuit.

This project shows a great application for Arduino that performs the often time-consuming activity of updating an online status quickly and easily. The prototype is also built to suit its environment, being robust enough with its stainless steel inputs to survive constant use. It's also easy to clean considering the messy bakery environment. The complexity of this project lies in the communication with the Internet, which for the more web savvy of you may be an area of interest, allowing your physical project to send data to the World Wide Web and vice versa.
:::

::: {.section}
[]{#c08.xhtml#c08-sec-0013}

### Further reading {#c08.xhtml#h3-8 .Heading-2}

You can find much more information on the Baker Tweet site at [[`http://www.bakertweet.com`]{.Code-within-text}](http://www.bakertweet.com)) and the Poke London projects page at [[`pokelondon.com/work/baker-tweet/`]{.Code-within-text}](https://pokelondon.com/work/baker-tweet/). Also, take a look at a few excellent prototyping photos that show the development of the project from breadboard to bakery ([[`flickr.com/photos/aszolty/sets/72157614293377430/`]{.Code-within-text}](http://flickr.com/photos/aszolty/sets/72157614293377430/)).
:::
:::

::: {.section}
[]{#c08.xhtml#c08-sec-0014}

## The National Maritime Museum's Compass Lounge and Compass Card {#c08.xhtml#h2-5 .Heading-1}

The Compass Lounge was developed as part of a new wing of the National Maritime Museum in London. London-based design studio Kin designed and developed the interactive areas of the Compass Lounge, which used a number of []{#c08.xhtml#Page_169 .pagebreak role="doc-pagebreak" title="169"}Arduino projects behind the scenes to allow the public to interact with the digital archive of the museum as well as the physical pieces on display.

A set of digital plan chests (*plan chests* are large drawers that usually store large prints, blueprints, or paperwork) allow visitors to browse the museum\'s online archive and access the most popular items in high resolution. When the plan chest is opened, a large touchscreen is activated, and the visitor can browse the items on display. While the visitors are browsing, a hidden LED display lights up through the wallpaper (as shown in [Figure 8-5](#c08.xhtml#c08-fig-0005){#c08.xhtml#rc08-fig-0005}), displaying the reference number of the current item so that it can be found in the physical archive.

::: {#c08.xhtml#c08-fig-0005 .figure}
![9781119489542-fg0805.png](https://i.imgur.com/ijUW3GO.jpeg){.center}
:::

Another aspect of the Arduino-powered part of this project is the Compass card system. Each visitor is given a card to use to collect items from all over the museum. Next to certain items are collection points where the card is scanned to collect the item digitally and stamped to leave a physical mark on the card to show the visitors journey through the museum. Visitors can browse their collected items in the Compass Lounge or at home in a browser.

::: {.section}
[]{#c08.xhtml#Page_170 .pagebreak role="doc-pagebreak" title="170"}[]{#c08.xhtml#c08-sec-0015}

### How it works {#c08.xhtml#h3-9 .Heading-2}

The plan chests use a couple of simple Arduino projects to complement the digital content displayed on the large touchscreens.

The Arduino is used to activate the screens when they\'re opened. If the screens are left on throughout the day when not in use, the image can often be burned into the screen, leaving shadows when the content is changed. Setting the background to black when the plan chest is closed reduces this screen burn and extends the lifetime of the monitors. This result is accomplished by a microswitch on the back of each drawer --- no different from the setup for the Button sketch in [Chapter 6](#c06.xhtml). Whenever the button is pressed, a character is sent over the serial port to tell the monitor to go black. This sort of communication is covered in [Chapter 7](#c07.xhtml).

Above the plan chests is a hidden LED display made up of rows of LEDs aligned in a grid. The letters are sent over the serial port as a string from the custom software that displays the images so that the correct number appears with the correct image. Because the LEDs are so bright, they can shine through the fabric wallpaper when on and remain hidden when not. This is an excellent example of using a premade product in a different arrangement to suit the purpose.

The Compass cards are also a great example of using (relatively) old and existing technologies in a new and interesting way. The Compass cards use barcodes to know which card is being scanned. This returns a number to the Arduino that can be forwarded to a central server that coordinates the barcode number and the scanner number to identify where the card has been scanned and by who.

All this information is sent over the Ethernet to a server using an Ethernet shield, where the information can be collated and outputted as needed. Arduinos are doing the relatively complicated task of relaying data over a network without the need for computers at every collection point. This scenario not only cuts the cost of data transfer but also makes the operation of the network easier because an Arduino requires no startup or shutdown procedures. This digital system works alongside a physical stamping system to mark the cards with an embosser, which makes an impression into the card when the lever is pushed. (The inside of the Compass card collection point is shown in [Figure 8-6](#c08.xhtml#c08-fig-0006){#c08.xhtml#rc08-fig-0006}.)

::: {#c08.xhtml#c08-fig-0006 .figure}
![9781119489542-fg0806.png](https://i.imgur.com/nFDTrAN.jpeg){.center}
:::

This collection of projects illustrates how many applications you can bring together to create an experience, providing many different forms of interaction and feedback. It's also a great example of an extreme-use case for Arduino. Many projects, prototypes, or installations show that Arduino can work, but it is often regarded as unreliable and seen as a temporary solution rather than a long-term one. In this case, the museum demanded a reliable and robust solution, and Arduino was more than capable of the task when used correctly.
:::

::: {.section}
[]{#c08.xhtml#Page_171 .pagebreak role="doc-pagebreak" title="171"}[]{#c08.xhtml#c08-sec-0016}

### Further reading {#c08.xhtml#h3-10 .Heading-2}

You can find much more information as well as illustrations on the Kin project page at [[`kin-design.com/commissioned-work/arts_culture/compass-card-system-national-maritime-museum/`]{.Code-within-text}](http://kin-design.com/commissioned-work/arts_culture/compass-card-system-national-maritime-museum/).
:::
:::

::: {.section}
[]{#c08.xhtml#c08-sec-0017}

## The Good Night Lamp {#c08.xhtml#h2-6 .Heading-1}

The Good Night Lamp project is an Internet-connected family of lamps founded by Alexandra Dechamps-Sonsino. Each family is made up of a Big Lamp and numerous Little Lamps. When the Big Lamp is on, the connected Little Lamps turn on as well, wherever they are in the world. They allow loved ones to remain in touch with each other by simply going about their daily routine, without actively using any application. The Good Night Lamp is currently in development using Arduino as the basis for the prototypes. A set of lamps appears in [Figure 8-7](#c08.xhtml#c08-fig-0007){#c08.xhtml#rc08-fig-0007}.

::: {#c08.xhtml#c08-fig-0007 .figure}
![9781119489542-fg0807.png](https://i.imgur.com/dMXIl07.jpeg){.center}
:::

::: {.section}
[]{#c08.xhtml#c08-sec-0018}

### How it works {#c08.xhtml#h3-11 .Heading-2}

The system for the preproduction prototypes of the Good Night Lamp is relatively simple. The Big Lamp is a functional light operated with a pushbutton, similar to []{#c08.xhtml#Page_172 .pagebreak role="doc-pagebreak" title="172"}the ButtonChangeState example in [Chapter 10](#c10.xhtml). It illuminates the light and sends the ID number of the lamp and state of the light to a web server by using an Arduino Wi-Fi shield.

Somewhere else, maybe on the other side of the world, the Little Lamps download the state of the Big Lamp by using the same Wi-Fi shield. If a Big Lamp is on, any Little Lamps that are paired with it are also turned on.

The lamps themselves are high-power LED bulbs running off 12V and requiring 0.15 amps for the Little Lamps and 0.4 amps for the Big Lamp. These LED bulbs are ideal for the high brightness needed for functional lamps and require a transistor circuit to run them, the same as the one explained in [Chapter 7](#c07.xhtml).

This project is a great example of using Arduino to produce a prototype of a product with relatively complex behavior. Using Arduino and other tools enable you to develop the electronics inside a product to reliably demonstrate its behavior.
:::

::: {.section}
[]{#c08.xhtml#Page_173 .pagebreak role="doc-pagebreak" title="173"}[]{#c08.xhtml#c08-sec-0019}

### Further reading {#c08.xhtml#h3-12 .Heading-2}

If you would like to read more about the Good Night Lamp, go to the product home page at [[`goodnightlamp.com`]{.Code-within-text}](http://goodnightlamp.com/).
:::
:::

::: {.section}
[]{#c08.xhtml#c08-sec-0020}

## Little Printer {#c08.xhtml#h2-7 .Heading-1}

Little Printer (shown in [Figure 8-8](#c08.xhtml#c08-fig-0008){#c08.xhtml#rc08-fig-0008}) is a miniature home printer developed by Berg, a design consultancy based in London. Using your smartphone, you can manage content from the web to print all sorts of information to create your own personal newspaper. In between your phone and the web is BERG Cloud, which does all the heavy lifting. Little Printer is built with custom hardware and software but was prototyped using Arduino.

::: {#c08.xhtml#c08-fig-0008 .figure}
![9781119489542-fg0808.png](https://i.imgur.com/0kowsih.jpeg){.center}
:::

::: {.section}
[]{#c08.xhtml#c08-sec-0021}

### How it works {#c08.xhtml#h3-13 .Heading-2}

The Little Printer is made up of several parts, starting with the printer itself, which is a thermal printer, similar to those used to print shopping receipts. Thermal printers communicate over serial, so with the right code, it's possible to talk directly to a device like an Arduino. Adafruit stocks one such printer that []{#c08.xhtml#Page_174 .pagebreak role="doc-pagebreak" title="174"}is easy to integrate into your own Arduino projects (go to [[`www.adafruit.com/products/597`]{.Code-within-text}](https://www.adafruit.com/products/597)).

The printer itself is powered but talks wirelessly to the BERG Cloud Bridge, a small device that handles all data in a way similar to your home router. Data is then sent and received using a wired Internet connection, the same as that used on the Arduino Ethernet shield.

In early prototypes, XBee wireless modules --- the same as those used on the Arduino wireless shield --- handled communication between the Little Printer and the BERG Cloud Bridge.

Much of the complexity of this product is handled in the BERG Cloud, where data is gathered, sorted, and then sent to the printer as requested.

The Little Printer is a great example of a product that has used Arduino to develop and refine the idea, before being developed further into a product with its own custom hardware. It also shows that it is possible for your Arduino project to make use of the abundance of data on the Internet.
:::

::: {.section}
[]{#c08.xhtml#c08-sec-0022}

### Further reading {#c08.xhtml#h3-14 .Heading-2}

Sadly, Little Printer is no more, but it remains a textbook example of what's possible with Arduino. To find out more about their journey, head over to [[`littleprinterblog.tumblr.com`]{.Code-within-text}](http://littleprinterblog.tumblr.com/).
:::
:::

::: {.section}
[]{#c08.xhtml#c08-sec-0023}

## Flap to Freedom {#c08.xhtml#h2-8 .Heading-1}

Flap to Freedom was a game by ICO, a London-based design consultancy created as part of the V&A Village Fete, described by the V&A as a "contemporary take on the British Summer Fete." It took the form of a game where two players would race, head-to-head, to help a chicken to escape from its battery farm (as shown in [Figure 8-9](#c08.xhtml#c08-fig-0009){#c08.xhtml#rc08-fig-0009}). If a player flaps his arms, the chicken does also, but if he flaps too quickly, the chicken tires out. Each race was timed and put on the "pecking order" leader board to determine the winner.

::: {#c08.xhtml#c08-fig-0009 .figure}
![9781119489542-fg0809.png](https://i.imgur.com/omBZeFK.jpeg){.center}
:::

::: {.section}
[]{#c08.xhtml#c08-sec-0024}

### How it works {#c08.xhtml#h3-15 .Heading-2}

For the Arduino-related project, the existing toy chickens used in this race were taken apart and given new custom circuits that communicated wirelessly with software on a computer. The circuits inside the chickens were remade to give an Arduino control of the various motors that moved the wings, beak, and feet. These were each told what to do by using wireless modules, similar to the XBee modules on the Arduino wireless shield, which communicated with a piece of custom software on a computer.

The software used was openFrameworks. Using a hidden webcam, the program analyzed people's movements to determine how fast the chickens should waddle and then sent the appropriate signal to each chicken.

[]{#c08.xhtml#Page_176 .pagebreak role="doc-pagebreak" title="176"}This fun and engaging application for Arduino allows people of all ages to play a game and have instant physical feedback from the toy chickens. The program also illustrates how to hack an existing toy to give it a different use and can be applied to other products.
:::

::: {.section}
[]{#c08.xhtml#c08-sec-0025}

### Further reading {#c08.xhtml#h3-16 .Heading-2}

You can find much more to read on the ICO project page at [[`icoex.co.uk/work/project/flap-for-freedom`]{.Code-within-text}](http://icoex.co.uk/work/project/flap-for-freedom). Benjamin Tomlinson and Chris O'Shea worked on the technical side of the project; for a more technical description, go to Chris O'Shea's project page at [[`www.chrisoshea.org/flap-to-freedom`]{.Code-within-text}](http://www.chrisoshea.org/flap-to-freedom).
:::
:::

[]{#c09.xhtml}

[]{#c09.xhtml#Page_177 .pagebreak role="doc-pagebreak" title="177"}Chapter 9

# Soldering On {#c09.xhtml#a1 .Chap-Title}

::: {.section}
[]{#c09.xhtml#c09-sec-0001}[]{#c09.xhtml#c09-feafxd-0001}

IN THIS CHAPTER

![check.png](https://i.imgur.com/O7gvRLc.jpeg) **Learning all about soldering**

![check.png](https://i.imgur.com/9YIOZ1Z.jpeg) **Getting all the right kits for the job**

![check.png](https://i.imgur.com/2XtTXv6.jpeg) **Assembling a shield**

![check.png](https://i.imgur.com/eske6ZF.jpeg) **Moving from the breadboard to strip board**

![check.png](https://i.imgur.com/4tw1wqS.jpeg) **Preparing your project for the real world**

In previous chapters, I cover in great detail how to assemble circuits on a breadboard. If you read those chapters, you most likely already have a few ideas that build on or combine a few of the basic examples, so you may be asking, "What do I do next?"

This chapter takes you through the process, or art, of soldering. You discover all the tools you need to get your project ready for the real world. No more precariously balanced breadboards or flailing wires. From this point on, you\'ll know what you need to solder circuit boards that last.
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0002}

## Understanding Soldering {#c09.xhtml#h2-1 .Heading-1}

*Soldering* is a technique for joining metals. By melting metal with a much lower melting point than the metal you're joining, you can link pieces of metal to form your circuit. Mechanical joints are great for prototyping, allowing you to change your mind and quickly change your circuit, but after you're sure of what you're making, it's time to commit.

You use a soldering iron or solder gun to melt *solder,* a metal alloy (mixture of metals) with a low melting point, and apply it to the joint. When the solder has cooled around the pieces that are being connected, it forms a secure chemical bond []{#c09.xhtml#Page_178 .pagebreak role="doc-pagebreak" title="178"}rather than a mechanical bond. This method is a far superior way to fix components in place, and bonded areas can still be melted and resoldered, if needed.

But why do you need to mess with soldering at all? Picture this: You have your circuit on a breadboard and you're ready to use it, but every time you do, the wires fall out. You could persevere and keep replacing the wires, but you risk replacing the wrong wire and damaging the Arduino or yourself. The best solution is to make a soldered circuit board that's robust and can survive in the real world.

A solderless breadboard allows you to quickly and easily build and change your circuit, but after you know that it works, you need to solder the circuit to keep it intact.

Creating your own circuit board is also an opportunity to refine your circuit by making circuit boards that fit the components. After you know what you want to do, the process of miniaturization can start and you're eventually left with a circuit board that takes up only the required space and no more.
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0003}

## Gathering What You Need for Soldering {#c09.xhtml#h2-2 .Heading-1}

Before you dive in to soldering, make sure that you have what you need to get the job done. Read on to find out more.

::: {.section}
[]{#c09.xhtml#c09-sec-0004}

### Creating a workspace {#c09.xhtml#h3-1 .Heading-2}

For your soldering adventures, what you need above all is a good workspace. Having a good workspace can make all the difference between a successful project and hours spent on your hands and knees, swearing at cracks in the floorboards. A large desk or workbench would be perfect, but even the kitchen table, if clear, will work. Because you're dealing with hot soldering irons and molten metal, it's a good idea to cover the surface with something you don't mind damaging. A cutting mat, piece of wood, or piece of cardboard will do fine for this purpose.

Your workspace should be well lit as well. Make sure that you have ample daylight by day and a good work light at night to help find those tiny components.

It's also good to have easy access to a power source. If your soldering iron functions at a fixed temperature and with a short lead connected directly to a plug, it can be especially important to have a plug nearby. If you overstretch your lead, you run the risk of pulling the iron off the table and burning anything it touches. A tabletop power strip or multi-plug is the best solution because it provides power for your laptop, your lamp, and your soldering iron.

[]{#c09.xhtml#Page_179 .pagebreak role="doc-pagebreak" title="179"}A comfortable chair is always important. Also remember to stand up every half hour or so to prevent back cramp. You can easily get drawn into soldering and forget what a horrible posture you're in.

Solder fumes, although not lethal, are not good for your lungs, so make every attempt to avoid breathing them. Always work in a well-ventilated area. It's also advisable to work with lead-free solder, as mentioned later in this section.

![tip.png](https://i.imgur.com/gU7z7FG.jpeg) If you're working at home and are under pressure from other people in your house to not cover every surface with bits of metal, you should designate a soldering surface. This surface could be a rigid, wooden surface that can fit all your kit and can be moved, neatly packed away, or covered when not in use. This arrangement saves you the chore of unboxing and packing up every time you want to solder --- and keeps everyone else happy as well.
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0005}

### Choosing a soldering iron {#c09.xhtml#h3-2 .Heading-2}

The most important tool for soldering is, obviously, a soldering iron or solder station. You have a huge variety to choose from, but they\'re generally divided into four types: fixed temperature, portable, and temperature-controlled soldering irons, and complete solder stations. I describe each type in the following sections and provide a rough price from my local retailers. When you have an idea of what you want, shop around locally to see what deals you can find. If you're lucky, you may even find some high-quality second-hand gear on eBay!

::: {.section}
[]{#c09.xhtml#c09-sec-0006}

#### Fixed-temperature soldering iron {#c09.xhtml#h4-1 .Heading-3}

A *fixed-temperature soldering iron* (see an example in [Figure 9-1](#c09.xhtml#c09-fig-0001){#c09.xhtml#rc09-fig-0001}) is normally sold as just an iron on a piece of electrical cable with a plug at the other end. They are usually sold with a sponge and a flimsy piece of bent metal as a stand. Others that are slightly better have a plastic stand with a place to put your sponge and a decent spring-like holster for your iron.

::: {#c09.xhtml#c09-fig-0001 .figure}
![9781119489542-fg0901.png](https://i.imgur.com/QI8j9TZ.jpeg){.center}
:::

Fixed-temperature irons are adequate but offer no control over the temperature of your iron. They are sold with a power rating or wattage, which is of little help to most people. On these fixed-temperature irons, a higher wattage means a higher temperature, although that can vary wildly from manufacturer to manufacturer.

![warning.png](https://i.imgur.com/9esVniw.jpeg) This variation can cause trouble with more delicate components because a high temperature is quickly conducted and melts integrated circuits and plastic components.

[]{#c09.xhtml#Page_180 .pagebreak role="doc-pagebreak" title="180"}A quick study of RadioShack shows soldering irons in a range of powers, from 15W to 60W, which could cover a temperature range of approximately 400° F to 750° F. The difficulty is in finding an iron that is hot enough so that it heats the part that you want to heat quickly and allows you to melt the solder before the heat spreads. For this reason, a low-temperature iron can often do more damage than a higher temperature one. If you go too high, you encounter other problems, such as having the tips erode faster and running a higher risk of overheating parts.

If you want to go with a fixed-temperature iron, my advice is to start with a midrange iron. I recommend a 25W iron as a good starter, which costs in the region of \$22 from RadioShack.
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0007}

#### Portable soldering iron {#c09.xhtml#h4-2 .Heading-3}

A *portable soldering iron* does away with cables and electricity in favor of gas power. It burns butane gas (more commonly known as lighter fuel) to produce its heat. A portable iron has a wattage rating to allow comparison with other irons, but unlike the fixed-temperature ones described in the preceding section, this rating indicates the maximum temperature, which can be lowered by use of a valve.

![warning.png](https://i.imgur.com/IGa3BlS.jpeg) The flames burn around the edge of the iron, which can make them awkward to use on precise joints, so I recommend using a portable iron only if necessary.

A portable iron (shown in [Figure 9-2](#c09.xhtml#c09-fig-0002){#c09.xhtml#rc09-fig-0002}) is great for tight situations when an extension lead just won't reach, but it's a bit too expensive and wasteful to be used often. It's also considered a lot more dangerous than conventional irons by most airport security because of the use of gas. So if you're planning on doing any soldering abroad, take an electric iron.

::: {#c09.xhtml#c09-fig-0002 .figure}
![9781119489542-fg0902.png](https://i.imgur.com/mznAhIP.jpeg){.center}
:::

Butane soldering irons vary in price, but you can usually find them in the range of \$45 to \$90. You also need to buy additional butane refill cans for \$7.50 each.
:::

::: {.section}
[]{#c09.xhtml#Page_181 .pagebreak role="doc-pagebreak" title="181"}[]{#c09.xhtml#c09-sec-0008}

#### Temperature-controlled soldering iron {#c09.xhtml#h4-3 .Heading-3}

A *temperature-controlled soldering iron,* shown in [Figure 9-3](#c09.xhtml#c09-fig-0003){#c09.xhtml#rc09-fig-0003}, is preferable to the fixed-temperature variety because it gives you more control at a reasonable price. This increase in control can make all the difference between melting and burning. Temperature-controlled irons should have a wattage rating, but it will be the maximum power possible. For this type of iron, a higher wattage is preferable because it should give you a better range of higher temperatures.

::: {#c09.xhtml#c09-fig-0003 .figure}
![9781119489542-fg0903.png](https://i.imgur.com/DxtxOnV.jpeg){.center}
:::

A temperature control dial allows you to scale your temperature range up or down as needed. The difference between this type of temperature control and the control when using more accurate solder stations is that you don\'t have a reading of the current temperature. Most temperature-controlled irons have a color wheel []{#c09.xhtml#Page_182 .pagebreak role="doc-pagebreak" title="182"}indicating warm to hot, so a bit of trial and error may be necessary to get just the right temperature.

You can get an affordable temperature-controlled soldering iron for around \$30. Because you have more control over the temperature of the iron, you have greater control and more longevity than you have with a fixed-temperature iron.
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0009}

#### Solder stations {#c09.xhtml#h4-4 .Heading-3}

After you gain some experience (and can justify the expense), a solder station is what you'll want. A *solder station* is usually made up of an iron, a stand or cage for the iron, a temperature display, a dial or buttons for temperature adjustment, and a tray for a sponge. It can also include various other accessories for de-soldering or reworking, such as a hot air gun or vacuum pickup tool, but these are generally for more professional applications and not immediately necessary.

You can find many available brands of solder stations, but one of the most reputable and widely used is Weller (see [Figure 9-4](#c09.xhtml#c09-fig-0004){#c09.xhtml#rc09-fig-0004}). Of that company's stations, I recommend the WES51 (120V AC), the WESD51 (120V AC), or the WESD51D (240V AC). My WES51 is still performing excellently after four years of use. Note that the 120V irons need a transformer to step the voltage down in countries that use 240V AC; the transformer can often be heavier than the iron itself!

::: {#c09.xhtml#c09-fig-0004 .figure}
![9781119489542-fg0904.png](https://i.imgur.com/W83g08v.jpeg){.center}
:::

Before using a Weller solder station, I owned a cheaper temperature-controlled soldering iron that did very well for a number of years. As I cover in more detail later in this chapter, the best way to maintain and get the most out of your iron is []{#c09.xhtml#Page_183 .pagebreak role="doc-pagebreak" title="183"}to use it correctly. Leave a little melted solder on the tip to protect it when it\'s not in use. Then, before using the iron again, use the sponge to remove the solder.
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0010}

#### Soldering iron tips {#c09.xhtml#h4-5 .Heading-3}

Regardless of which iron you buy, I also recommend buying a few spare tips because they eventually degrade. You'll find a variety of tips for different purposes, too, so it's good to have a selection to cover different needs.
:::
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0011}

### Solder {#c09.xhtml#h3-3 .Heading-2}

Solder is what you use to join your circuits. Although many different types of solder are used with different combinations of metals, they commonly fall into two categories: lead and lead free. Many people prefer lead solder, finding it easier to work with, perhaps because it has a lower melting point, so your iron can be cooler and less likely to damage components.

Lead poisoning has been known about for a long time, and attitudes about using it have begun to change. Lead pipes were switched to copper as recently as the 1980s, and the use of lead solder in consumer electronics was addressed in 1996, when the Restriction of Hazardous Substances Directive (RoHS) and the European Union Waste Electrical and Electronic Equipment Directive (WEEE) addressed the use and disposal of certain materials in electronics.

You commonly find RoHS on components that comply with their guidelines, which should, therefore, be better for the environment when disposed of. Commercially, US and European companies enjoy tax benefits for using lead-free solder (shown in [Figure 9-5](#c09.xhtml#c09-fig-0005){#c09.xhtml#rc09-fig-0005}), but lead is still widely used in the rest of the world. Steven Tai, a colleague of mine, visited China to complete a project we were working on. When he asked where he could buy lead-free solder, he was laughed at outright because lead-free solder was not only was unheard of in most cases but not even available! For the more conscientious Arduinists, most electronics supplier and shops offer lead-free solder that contains other metals, such as tin, copper, silver, and zinc. From my experience, lead-free solder works just fine for any Arduino projects, so if you want to do your bit for the environment and avoid using lead in your work, please do!

::: {#c09.xhtml#c09-fig-0005 .figure}
![9781119489542-fg0905.png](https://i.imgur.com/AB0LpDH.jpeg){.center}
:::

Another variety of solder is flux-cored solder. *Flux* is used to reduce oxidization, the reaction on the surface of a metal when it reacts with the air (oxygen), as with rust on an iron anchor. Reducing the oxidization allows a better, more reliable connection on your solder joint and allows the solder to flow more easily and fill the joint. Some solders have flux in the core of the solder, dispensing flux to the joint as the solder is melted. You sometimes see smoke as you melt your solder; in most cases, the smoke is from the flux burning off. You can be sure that you have flux core if, when you cut the solder, you see a black center surrounded by a tube of solder.

[]{#c09.xhtml#Page_184 .pagebreak role="doc-pagebreak" title="184"}Always work in a well-ventilated area and avoid breathing the solder fumes no matter which solder you\'re using. Solder fumes are not good for you, and neither is eating solder. Always wash your hands and face thoroughly after soldering. Sometimes the flux in solder can spit, so wear clothes that are not precious --- and definitely use eye protection.
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0012}

### Third hand (helping hand) {#c09.xhtml#h3-4 .Heading-2}

Sometimes you just don't have enough hands to hold the fiddly electronics that you're trying to solder. It would be great to have someone nearby with asbestos hands to hold the tiny red-hot pieces of metal, but failing that, you can use a little device known as a *third hand* or a *helping hand,* as shown in [Figure 9-6](#c09.xhtml#c09-fig-0006){#c09.xhtml#rc09-fig-0006}. A third hand is a set of crocodile clips on an adjustable arm. You can arrange the clips to help you get your component, circuit board, and solder into place.

::: {#c09.xhtml#c09-fig-0006 .figure}
![9781119489542-fg0906.png](https://i.imgur.com/KOGWEEi.jpeg){.center}
:::

A third hand costs from \$5 to \$50 and can be extremely useful for holding circuit board at an angle or holding components together while you work on the soldering. The drawback is that setting it up can be tricky. If you're doing lots of solder joints, you may spend a lot of time loosening, adjusting, and retightening. If you do purchase a third hand, make sure that the parts are all metal. Plastic parts, such as the grips on the vices, will not stand up to much use.
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0013}

### Adhesive putty {#c09.xhtml#h3-5 .Heading-2}

A good alternative to a third hand is adhesive putty, such as Bostik's Blu-Tack, UHU's White Tack, or Locktite's Fun-Tak. Rather than use a mechanical device to grip a component or a circuit board, you use the adhesive putty to hold the objects []{#c09.xhtml#Page_185 .pagebreak role="doc-pagebreak" title="185"}you're soldering in place on one side of the board, leaving you free to work on the other side of the board without the components or circuit board moving. You can also use the adhesive putty to tack your work to your work surface, stopping it from moving around the surface as you solder. After the solder joints are done, you remove the adhesive putty, which you can reuse. Note that putty goes extremely soft if it is heated and takes a while to return to its usual tackiness. After it cools, you can roll the ball of putty along the circuit board to remove any remaining bits.
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0014}

### Wire cutters {#c09.xhtml#h3-6 .Heading-2}

A good pair of wire cutters or snips is invaluable. Many pairs of wire cutters have a rounded, claw-like shape. These are tough but can be difficult to use when cutting in confined spaces or pinpointing a specific wire. Precision wire cutters have a more precise, pointed shape that is far more useful for the vast majority of electronics work.

Note that wire cutters are good for soft metal such as copper but do not stand up to tougher metals such as paper clips or staples. [Figure 9-7](#c09.xhtml#c09-fig-0007){#c09.xhtml#rc09-fig-0007} shows a pair of pointed wire cutters.

::: {#c09.xhtml#c09-fig-0007 .figure}
![9781119489542-fg0907.png](https://i.imgur.com/71ETZtK.jpeg){.center}
:::
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0015}

### Wire strippers {#c09.xhtml#h3-7 .Heading-2}

To connect wires to your project, you need to strip back the plastic insulation. You can do this stripping with a knife if you're careful or don't value your fingertips, but the quickest, easiest, and safest way to strip a wire is to use a wire stripper. The two kinds of wire strippers are manual and mechanical (see [Figure 9-8](#c09.xhtml#c09-fig-0008){#c09.xhtml#rc09-fig-0008}). Manual wire strippers are like clippers but have semicircular notches made to various diameters. When the wire stripper is closed on wire, it cuts just deep enough to cut through the plastic sheath but stops before it hits the wire. Mechanical wire strippers work with a trigger action to remove the insulation on the wire without any need to pull on the wire.

::: {#c09.xhtml#c09-fig-0008 .figure}
![9781119489542-fg0908.png](https://i.imgur.com/UY2dadR.jpeg){.center}
:::

Mechanical wire stripers are a great timesaver but can be less reliable in the long run because the mechanisms are more likely to fail than are those in the simple manual ones.
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0016}

### Needle-nosed pliers {#c09.xhtml#h3-8 .Heading-2}

Needle-nose pliers, as with a solderless breadboard, are a great help for getting to those hard-to-reach places. They're especially useful when soldering because they spare your fingers from any excess heat. I cover needle-nosed pliers in more detail in [Chapter 4](#c04.xhtml).
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0017}

### Multimeter {#c09.xhtml#h3-9 .Heading-2}

A multimeter is a great help for testing your circuits. When you're soldering connections, the continuity-testing function can be a great help for verifying that the solder joints are as they should be and are connected to the right places. See [Chapter 4](#c04.xhtml) for more about working with a multimeter.

![remember.png](https://i.imgur.com/0RHSePN.jpeg) When testing the continuity, always unplug any power supplies connected to your circuit to avoid false bleeps.
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0018}

### Solder sucker {#c09.xhtml#h3-10 .Heading-2}

Everyone makes mistakes, and they can be more difficult to undo when you're dealing with hot metal. One tool to keep handy for fixing mistakes is a solder sucker, shown in [Figure 9-9](#c09.xhtml#c09-fig-0009){#c09.xhtml#rc09-fig-0009}, or a de-soldering gun. Each of these tools is a pneumatic pump that sucks molten solder straight off the surface of a circuit board. Most have a piston that can be pressed down and will lock when all the air is pressed out. When you hit the trigger, a spring pushes the piston back out and sucks any molten solder into the piston chamber. Next time you press the piston down, it pushes out any solder that was removed. Using this type of tool takes a bit of practice because you need to heat the solder with your soldering iron in one hand and suck it away with the sucker in the other.

::: {#c09.xhtml#c09-fig-0009 .figure}
![9781119489542-fg0909.png](https://i.imgur.com/HXb75uv.jpeg){.center}
:::
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0019}

### Solder wick {#c09.xhtml#h3-11 .Heading-2}

Another method of removing solder is to use solder wick (see [Figure 9-10](#c09.xhtml#c09-fig-0010){#c09.xhtml#rc09-fig-0010}), also known as copper braid or de-soldering wire. Solder wick is a copper wire that has been braided, and you buy it in reels. It provides lots of surface area for solder to grip into, to remove it from other surfaces. Place the braid on the joint or hole that has too much solder, and hold your soldering iron on top of it to heat the solder wick. Apply some pressure, and the solder continues to melt and fill the gaps in between the braids of the copper wire. Remove the wick and the soldering iron []{#c09.xhtml#Page_188 .pagebreak role="doc-pagebreak" title="188"}together, and the solder should be cleared. If it's not, repeat as necessary. After the solder is cleared, you can cut off the used solder wick and dispose of it.

::: {#c09.xhtml#c09-fig-0010 .figure}
![9781119489542-fg0910.png](https://i.imgur.com/dAs4Ctq.jpeg){.center}
:::

![warning.png](https://i.imgur.com/gZFrpjX.jpeg) Do not pull the solder wick away if the solder has cooled. You risk pulling off the metal pads on your board, making it unusable, because the solder wick is attached to the board.

![tip.png](https://i.imgur.com/WNFuyNw.jpeg) Solder suckers and solder wick are both equally effective at removing solder, but they are each suited to different situations and require an element of dexterity and skill to use. If you're worried about overheating components, a solder sucker is more suitable; if you can't remove all the solder with the sucker or can't get close enough to the components with it, the solder wick may be a better option. I advise getting both to prepare yourself for any situation.
:::

::: {.section}
[]{#c09.xhtml#Page_189 .pagebreak role="doc-pagebreak" title="189"}[]{#c09.xhtml#c09-sec-0020}

### Equipment wire {#c09.xhtml#h3-12 .Heading-2}

Equipment wire is the general name given to electronics wire. It's the same as the jump wires you may have in your kit but is unfinished. You buy it in reels. Equipment wire can be either single-core or multicore. Single-core wire is made up of one solid piece of wire and is malleable, so it holds its shape if bent, but it snaps if it is bent too much. Multicore wire is made up of many fine wires and can withstand a great deal more flexing than single core, but it does not keep its shape if bent. To use equipment wire, you need to cut it to length and strip the insulation off the ends of to reveal the wire underneath.

Wire also comes in different diameters, indicated with numbers such as 7/0.2 or 1/0.6. In this format, the first digit is the number of wires in the bundle and the second is the diameter of those individual wires. So 7/0.2 is a bundle of 7 wires, each measuring 0.2 mm, making it multicore; 1/0.6 is one single-core wire with a diameter of 0.6mm.

When you're starting out, it can be difficult to know what type of wire to invest in. Wire is cheaper when bought by the reel, but you don't want to be stuck with wire that isn't fit for your purposes. As a general guideline, I have found that multicore wire is the most versatile and robust for most applications. The 7/0.2 diameter should fit most PCB holes. I also recommend having three colors --- red, black, and a color to signify your signal wires. With three reels of this type and size, you should be able to complete most projects. Some hobby electronic shops also supply lengths in various colors, such as the ones by Oomlout shown in [Figure 9-11](#c09.xhtml#c09-fig-0011){#c09.xhtml#rc09-fig-0011}.

::: {#c09.xhtml#c09-fig-0011 .figure}
![9781119489542-fg0911.png](https://i.imgur.com/YcePuKd.jpeg){.center}
:::
:::
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0021}

## Staying Safe while Soldering {#c09.xhtml#h2-3 .Heading-1}

With a few simple precautions, you can solder safely. Remember that soldering is not dangerous if you take proper care --- but it can be if you don't. Please keep the tips in this section in mind whenever you're soldering.

::: {.section}
[]{#c09.xhtml#Page_190 .pagebreak role="doc-pagebreak" title="190"}[]{#c09.xhtml#c09-sec-0022}

### Handling your soldering iron {#c09.xhtml#h3-13 .Heading-2}

A soldering iron is safe if used correctly but is still potentially dangerous. The iron has two ends, the hot end and the handle. Don't hold it by the hot end! The correct way to hold a soldering iron is like a pen, between your thumb and index finder, resting on your middle finger. When you're not using the iron, keep it in its holster or cage, which helps to dissipate heat and prevent accidental burns.
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0023}

### Keeping your eyes protected {#c09.xhtml#h3-14 .Heading-2}

You must wear proper eye protection when soldering. Solder, especially the flux-cored kind, has a tendency to spit when heated. In addition, when you use clippers to neaten your circuit board, the small bits of metal you cut off often shoot around the room if they're not held down. Also, if you're working in a group, you need to protect yourself from the person next to you. Safety goggles are relatively inexpensive depending on the amount of comfort you want, and they're a lot cheaper than eye surgery.
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0024}

### Working in a ventilated environment {#c09.xhtml#h3-15 .Heading-2}

Breathing in fumes of any kind is bad for you, so it's important to always solder in a well-ventilated environment. Also make sure that you're not working under any smoke alarms because the fumes from soldering can set them off.
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0025}

### Cleaning your iron {#c09.xhtml#h3-16 .Heading-2}

Your soldering iron should come with a sponge, which you use to wipe away excess solder. You should dampen the sponge but not use it soaking wet, so make sure to squeeze out excess water. When you're heating solder, it oxidizes on the tip of the iron. If the tip itself oxidizes, it can degrade over time. To prevent oxidizing the tip, leave a blob of solder on the end of the iron while it's in its cage. Doing so makes the blob of solder oxidize rather than the tip, and you just wipe off it off using the sponge the next time you need the iron.
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0026}

### Don't eat the solder! {#c09.xhtml#h3-17 .Heading-2}

Although the chemicals and metals in solder are not deadly, they are definitely not healthy and can cause irritation. While soldering, avoid touching your face and getting solder around your eyes and mouth. It's also a good idea to wash your hands (and face if needed) after soldering.
:::
:::

::: {.section}
[]{#c09.xhtml#Page_191 .pagebreak role="doc-pagebreak" title="191"}[]{#c09.xhtml#c09-sec-0027}

## Assembling a Shield {#c09.xhtml#h2-4 .Heading-1}

Soldering requires learning a great amount of technique, and you develop good technique with practice. In this example, you find out how to assemble an Arduino shield. A *shield* is a specific printed circuit board (PCB) that sits on top of the Arduino to give it a function. (You learn more about shields in [Chapter 12](#c12.xhtml).)

There are different shields for different functions. The one used in the example is the proto shield kit (shown assembled in [Figure 9-12](#c09.xhtml#c09-fig-0012){#c09.xhtml#rc09-fig-0012}), which is essentially a blank canvas to solder your project onto, after prototyping it on a breadboard. In this example, you see how to assemble the bare minimum of the kit to attach it to your Arduino and then how to build a simple circuit on it.

::: {#c09.xhtml#c09-fig-0012 .figure}
![9781119489542-fg0912.png](https://i.imgur.com/LXCxi8X.jpeg){.center}
:::

As with many Arduino kits, you need to assemble this shield yourself. The basic principles of soldering remain the same but may vary in difficulty as you encounter smaller or more sensitive components.

```{=html}
<aside>
```
::: {#c09.xhtml#c09-fea-0001 .sidebar}
# []{#c09.xhtml#Page_192 .pagebreak role="doc-pagebreak" title="192"}USING STRIPBOARD RATHER THAN A PCB {.SB-Head}

[]{#c09.xhtml#c09-sec-0028}

Specially designed shields are made to fit your Arduino perfectly but can often be relatively expensive. Stripboard, or perfboard as it's sometimes known, provides a cheap and highly versatile alternative. *Stripboard* is a circuit board with strips of copper and a grid of perforated holes that you can use to lay out your circuit in a similar way as on a breadboard. An example of stripboard appears in the following figure.

The pitch of the holes and the layout of the copper strips can vary. The most useful pitch for Arduino-related applications is the same as the pitch on the Arduino pins, 0.1 inches (2.54mm), because that pitch allows you to build on the layout of your Arduino to make your own custom shields. You can buy stripboard in various arrangements of copper strip as well, commonly either long copper columns that run the length of the board or sets of columns three rows deep (usually called tri-board).

::: {#c09.xhtml#c09-blkfxd-0001 .figure}
![9781119489542-sb0901.png](https://i.imgur.com/rxBxOi3.jpeg){.center}
:::
:::

```{=html}
</aside>
```
::: {.section}
[]{#c09.xhtml#c09-sec-0029}

### Laying out all the pieces of the circuit {#c09.xhtml#h3-18 .Heading-2}

When assembling a circuit, your first step should always be to lay out all the pieces to check that you have everything you need. Your work surface should be clear and have a solid-colored cover to make things easy to find.

[[]{#c09.xhtml#Page_193 .pagebreak role="doc-pagebreak" title="193"}Figure 9-13](#c09.xhtml#c09-fig-0013){#c09.xhtml#rc09-fig-0013} shows the Arduino proto kit laid out in an orderly fashion. It contains the following:

-   [Header pins (40x1)]{#c09.xhtml#c09-li-0006}
-   [Header sockets (3x2)]{#c09.xhtml#c09-li-0007}
-   [Pushbuttons]{#c09.xhtml#c09-li-0008}
-   [LEDs (various)]{#c09.xhtml#c09-li-0009}
-   [Resistors (various)]{#c09.xhtml#c09-li-0010}

::: {#c09.xhtml#c09-fig-0013 .figure}
![9781119489542-fg0913.png](https://i.imgur.com/hh06JLU.jpeg){.center}
:::

Some kits may ship the PCB only and leave you to choose the headers that are connected. Remember that there is no right or wrong way as long as the assembly suits your purpose.

To assemble this shield, you can work from a picture to see the layout of the components, but for more difficult ones, you usually have instructions. In this example, I walk you through the construction of this shield step by step and point out various techniques for soldering along the way
:::

::: {.section}
[]{#c09.xhtml#Page_194 .pagebreak role="doc-pagebreak" title="194"}[]{#c09.xhtml#c09-sec-0030}

### Assembly {#c09.xhtml#h3-19 .Heading-2}

To assemble this kit, you need to solder the header pins and the pushbutton. Soldering these pieces allows the shield to sit in the header sockets on your Arduino, extending all the pin connections to the proto shield. Note that some versions of the proto board have header sockets (or stackable headers) rather than header pins. Header sockets have long legs so that they can sit on top of an Arduino in the same way as header pins but also allow sockets for another shield to be placed on top. The benefit of header pins is that your shield is shorter and needs less space for any enclosure. Header sockets are used in the assembled shield shown in [Figure 9-12](#c09.xhtml#c09-fig-0012). They are the black sockets that run down either side on the top of the board, with pins extending underneath.

In this example, I use header pins and do not connect the ICSP (in-circuit serial programming) connector, which is the 3x2 connector in the center right of the Uno (refer to the first figure in [Chapter 2](#c02.xhtml)). The ICSP is used as an alternative for uploading sketches with an external programmer as opposed to the Arduino and is for advanced users.
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0031}

### Header pins {#c09.xhtml#h3-20 .Heading-2}

First you will need to cut the header pins to length ([Figure 9-14](#c09.xhtml#c09-fig-0014){#c09.xhtml#rc09-fig-0014}). This kit uses a length of 1 x 40, which is 1 row of 40 pins. The plastic strip has a notch between each pair of pins that you can cut to divide the pins neatly. To secure the shield, you need lengths of 6 pins (for the analog-in pins), 8 pins (for the power pins), 8 pins (for the shorter row of digital pins), and 10 pins (for the longer row of digital pins). Use your clippers to cut the header pins to the correct length; you should have 8 pins remaining. (Put these in a box for future use!) The pins should fit exactly because there is a 2.54mm (0.1 inch) pitch between them, which matches the board. You need to look for this same pitch if you\'re buying header pins of any other connectors separately.

::: {#c09.xhtml#c09-fig-0014 .figure}
![9781119489542-fg0914.png](https://i.imgur.com/JTPPWdi.jpeg){.center}
:::

Now that you know where the header pins go, you can solder them in place. In the next section, I talk you through soldering technique. Have a read through before you start.
:::
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0032}

## Acquiring Your Soldering Technique {#c09.xhtml#h2-5 .Heading-1}

The first step with soldering is to make sure that your components are secure. It's common to try balancing your circuit board on whatever objects are closest to hand to arrange it in an accessible position. But if you do, the board is destined to fall over at some point, most likely when you have a hot soldering iron in your hand.

As mentioned in the "[Gathering What You Need for Soldering](#c09.xhtml#c09-sec-0003)" section, earlier in this chapter, two good ways to secure your work are to use a third hand or adhesive putty. You can use the crocodile clips on the third hand to grip the plastic of the pins and the circuit board as well, holding them firmly at 90 degrees from one another. Similarly, you can hold the pins at 90 degrees and press adhesive putty into the underside to hold them together. You can then press them into a rigid, weighty support to bring the board closer to you. I sometimes use a big reel of solder for the support.

![warning.png](https://i.imgur.com/ARdTITg.jpeg) A third way to secure your components might occur to you, and because it's tempting, I describe it here so that you won't do it! You might think that the perfect way to lay out the pins would be to place them in the Arduino itself (with the long ends sticking into the sockets) and then place the circuit board on top. This approach holds everything at 90 degrees; however, because the pins are designed to connect to the Arduino and conduct electrical current, they can also conduct other things, such as heat. If they conduct the heat of your soldering iron, that heat can be passed through the board to the legs of the very sensitive microcontroller chip and damage it irreparably.

When you have your circuit board supported and ready, you can rotate it to a comfortable working angle, most likely the same angle as your iron, as shown in [Figure 9-15](#c09.xhtml#c09-fig-0015){#c09.xhtml#rc09-fig-0015}.

::: {#c09.xhtml#c09-fig-0015 .figure}
![9781119489542-fg0915.png](https://i.imgur.com/ZaL4jTl.jpeg){.center}
:::

Fire up your soldering iron. My Weller WES51 has a temperature range of 35--85 and the units show this as °F x 10, so the real range is 350--850 °F! The hotter you set it, the quicker it will melt solder to make joints, but it will also melt everything else faster, such as plastic parts and silicon chips. Always set your iron to the lowest convenient temperature. A good way to test the temperature of the iron is to melt some solder. If it's taking a long time to melt, make sure that you have a good amount of the surface area of the soldering iron's tip in contact with the solder. If it's still not working, increase the temperature gradually, allowing time for it to get up to temperature. I normally set it to 650 °F (340 °C), which is hot enough but not too hot.

[]{#c09.xhtml#Page_196 .pagebreak role="doc-pagebreak" title="196"}Some quality soldering irons have a thermostat that tells you when the iron is up to temperature. The really fancy ones have a digital display. With the cheaper ones, you have to use your best judgment.

While your iron is getting up to temperature, you can wet your sponge. On some irons, the sponge is stuck down for convenience, but it's particularly inconvenient when you need to wet it. I recommend unsticking it and taking it over to a basin rather than spilling water over your soldering iron and the surrounding area. The sponge should be damp but not full of water. The dampness stops the sponge from burning when you pass your iron across it. If the sponge is too wet, however, it can lower the temperature of the iron and the solder, meaning that the solder hardens or solidifies and can't be removed until it's up to temperature again.

Now you're ready you can start soldering. Follow these steps:

1.  ::: {#c09.xhtml#c09-li-0011}
    **Melt a small amount of solder on the tip of your iron (called *tinning the tip*); see** [**Figure 9-16**](#c09.xhtml#c09-fig-0016){#c09.xhtml#rc09-fig-0016}**.**

    The solder should stick to the edge and smoke. Generally, with a new or well-maintained iron, the solder latches onto the tip with no problem. If it doesn\'t stick to the edge of the tip, you may need to try rotating it to find a good patch that isn't oxidized. Failing that, you can use some tip cleaner to remove any built-up layer. By pressing your hot iron into the tip cleaner and wiping away any buildup as it loosens, you can restore your iron to its former glory.

    ![warning.png](https://i.imgur.com/KvKrO64.jpeg) Tip cleaner is generally a nasty, toxic substance. Make sure you do not ingest or inhale any of it.
    :::

2.  ::: {#c09.xhtml#c09-li-0012}
    **[]{#c09.xhtml#Page_197 .pagebreak role="doc-pagebreak" title="197"}When you have a blob of solder on your iron, wipe it off on a sponge to reveal a bright metallic tip on your iron.**

    The aim is to apply this freshly tinned edge (not the point) to the area that you\'re joining. Using the edge gives you more surface area and allows the joint to heat up faster. It's also important to note that a variety of tips are available for soldering irons, and if you choose good ones, they are easily interchangeable, allowing you to suit them to different situations. Some are pointed, as in [Figure 9-16](#c09.xhtml#c09-fig-0016); others are screwdriver tips, chisel tips, and beveled tips to provide different amounts of surface area for different situations.
    :::

3.  ::: {#c09.xhtml#c09-li-0013}
    **Starting on the first pin in one of the rows, apply the iron to the metal plate on the circuit board and the pin connecting to it.**

    This step heats the board and pin, preparing them for the solder.
    :::

4.  ::: {#c09.xhtml#c09-li-0014}
    **With your other hand (the one not holding the iron), apply the solder to the point where the iron, the pin, and the metal plate all meet.**

    As the solder is heated, it melts and spreads to fill the gap, sealing the pin and the board together. To apply more solder, press it into the joint where it is melting; to apply less, simply pull it back out. You may need only a few millimeters of solder for small joints.
    :::

5.  ::: {#c09.xhtml#c09-li-0015}
    **When the solder has filled the area, remove it, but keep your iron there for a second or two longer.**

    This extra time allows the solder to melt fully and fill any gaps for a solid joint.
    :::

6.  ::: {#c09.xhtml#c09-li-0016}
    **Remove your soldering iron by wiping it up the leg of the pin.**

    Any excess solder is directed upward into a point that can be cut off rather than sitting in a blob.
    :::

::: {#c09.xhtml#c09-fig-0016 .figure}
![9781119489542-fg0916.png](https://i.imgur.com/pd7zTmA.jpeg){.center}
:::

This entire process should take around 2--3 seconds. That probably sounds impossible, but after you get used to the rhythm, it's totally achievable. All it requires is practice.

[]{#c09.xhtml#Page_198 .pagebreak role="doc-pagebreak" title="198"}Following the preceding steps should leave you with a neat, pyramid-shaped solder joint, with the metal pad on the circuit board completely covered. If you can see the hole that the pin has come through or have a blob of solder on the pin that is not connected to the circuit board, you need to reapply heat using the soldering iron, and maybe reapply a little solder as well.

After you solder the first pin, it's a good idea to do the pin at the other end of the row. By doing these two, you secure the row in place, and if it is not level or at 90 degrees, you can still straighten the row by heating up the solder at either end. If you find that you have too much solder, first try reapplying heat. Watch as the solder melts, and you should see it filling all the gaps. If you still have too much solder, you can use a solder sucker or copper braid (described in "Gathering What You Need to Solder," earlier in this chapter) to remove any excess and try again.

For examples of well-soldered joints versus bad ones, see the image at [[`learn.sparkfun.com/tutorials/how-to-solder-through-hole-soldering#soldering-your-first-component-`]{.Code-within-text}](https://learn.sparkfun.com/tutorials/how-to-solder-through-hole-soldering#soldering-your-first-component-).

When you are happy with the row, you can solder every pin in place and repeat this process for each section of header pins. For the pushbutton, simply place it in the position indicated on the top side of the circuit board; it should clip in because of the design of the pushbutton legs. Secure with adhesive putty if necessary and then turn the board over and repeat the same soldering technique as before. When you are finished, do one last visual check to make sure that no solder joints are touching. Having two pins connected could cause a short circuit and damage your board, so check carefully. If in doubt, you can use the continuity test function on your multimeter to check consecutive pins. You shouldn't hear any beeps on pins that should not be joined.

Place the shield on top of your Arduino and check that it fits correctly. If it does, you're ready to solder your first circuit, which you find out about next.
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0033}

## Building Your Circuit {#c09.xhtml#h2-6 .Heading-1}

After you have a shield to work on (see "[Assembling a Shield](#c09.xhtml#c09-sec-0027)," earlier in this chapter), you can think about what circuit you want to build on it. Before you actually build that circuit, though, you should do some proper planning to avoid having to undo what you've done, which can be difficult. The best way to start is by prototyping the circuit on a solder-less breadboard. This process is quick, easy, and --- more importantly --- not permanent. As covered in [Chapters 6](#c06.xhtml) and [7](#c07.xhtml), []{#c09.xhtml#Page_199 .pagebreak role="doc-pagebreak" title="199"}throwing together a circuit and making sure that it works are simple tasks. For this example, I use the AnalogInOutSerial example (see [Chapter 6](#c06.xhtml)) to demonstrate how you can transform a solderless breadboard into a soldered one.

::: {.section}
[]{#c09.xhtml#c09-sec-0034}

### Knowing your circuit {#c09.xhtml#h3-21 .Heading-2}

First, recreate the AnalogInOutSerial circuit on the breadboard as shown at the end of [Chapter 6](#c06.xhtml). Upload the sketch by choosing File ⇒ Examples ⇒ 03.Analog ⇒ AnalogInOutSerial. This should give you an LED that can be faded by twisting the potentiometer.

When you have this circuit working, take a look at the AnalogInOutSerial circuit again on the breadboard. One difference that you can immediately see is that the proto shield doesn\'t have the same rows and columns as the breadboard, except in one corner. This corner area is designed for ICs (integrated circuits) or chips but can be used for anything. The rest of the proto shield has individual holes into which components can be soldered. You can connect these with wires to join the various components.

The easiest way to convert the circuit to one that will work on the shield is to look at the circuit diagram. The lines that connect the components can be substituted for real wires and soldered directly to the correct pins. For the potentiometer, you need three wires: 5V, GND, and analog 0. For the LED and resistor, you need two more: GND and pin 9. It's always a good idea to draw the circuit first for clarity. It doesn't need to be as neat as the circuit diagram in the examples, but planning your circuit will save a lot of painful de-soldering later. As the old carpentry saying goes, *measure twice, cut once* (or in this case, *sketch twice, solder once)*.

Note that the wires all go to holes next to the wire with which they need to connect. Because you don't have enough space to comfortably fit the wires and the component legs in one hole, you need to get them close and then bridge the gap by using the ends of the wire or the legs of the components.
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0035}

### Laying out your circuit {#c09.xhtml#h3-22 .Heading-2}

Now that you've drawn the circuit, you should lay it out so that you know what length to cut your wires. To secure the components to the board, insert them and bend to 45 degrees the parts of the legs that protrude through the board. They should look something like that shown in [Figure 9-17](#c09.xhtml#c09-fig-0017){#c09.xhtml#rc09-fig-0017}.

::: {#c09.xhtml#c09-fig-0017 .figure}
![9781119489542-fg0917.png](https://i.imgur.com/sPX2u3X.jpeg){.center}
:::
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0036}

### Preparing your wire {#c09.xhtml#h3-23 .Heading-2}

You can see that the lengths of wire required are relatively short. If you have solid-core wire, you can bend it neatly into shape to sit flat on the circuit board by using needle-nose pliers. If you have multicore wire, making an arc of wire up out of one hole and into the next is easier. Remember to measure or estimate the distance and add a small amount on each end to fit into the hole before you cut your lengths. Strip back the wire and sit it in place to make sure that the length is correct. Note that sometimes the end of multicore wire can become frayed. If this happens, grip it between your thumb and forefinger and twist the end into a point. If you lightly coat the end in solder, you can prevent the wire from unravelling and tin it in preparation for soldering. When you\'re happy with the length, place the wires to one side.
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0037}

### Soldering your circuit {#c09.xhtml#h3-24 .Heading-2}

Now that you have all the components and wires, it's time to solder them in place. Earlier, you bent the component leg at 45 degrees, so the wires should still be hanging on. Because the resistor and LED are next to each other, you can use their legs to connect them, avoiding the use of another wire. Remember to check that your LED is the right way around. If required, use adhesive putty to further secure the components in place and then solder them as with the pin headers.

When all the components are in place, you can solder the wire. Insert the wire and bend to 45 degrees as before. When it is secured, solder it in place or bend it further to meet the component legs, bridging the gap as with the resistor and LED. As always, there is no right or wrong in the appearance of your result; it depends how neat you []{#c09.xhtml#Page_201 .pagebreak role="doc-pagebreak" title="201"}want to be. Some people prefer to wind the wire around the legs of the component to get a good grip; others prefer to join them side by side to get a clean joint. The choice is yours. As long as you have a good connection, you're in good shape.
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0038}

### Cleaning up {#c09.xhtml#h3-25 .Heading-2}

When you finish soldering, give the board a good check for any loose connections. If all seems well, you can start neatening the board. Using your clippers, carefully remove the legs of the components from just above the solder joint, at the top of the pyramid. You can cut lower, but the solder is thicker and you risk tearing the metal contacts off the circuit board, which cannot be fixed. Remember, always hold or cover the piece of metal that you\'re clipping. If you don't, it can fly a great distance and seriously injure someone.
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0039}

### Testing your shield {#c09.xhtml#h3-26 .Heading-2}

Now that you have your shield with a completed circuit assembled on it, it's time to plug it in and try it. If everything is working correctly, you should have a neatly packaged dimmer circuit shield resembling something like [Figure 9-18](#c09.xhtml#c09-fig-0018){#c09.xhtml#rc09-fig-0018}.

::: {#c09.xhtml#c09-fig-0018 .figure}
![9781119489542-fg0918.png](https://i.imgur.com/sZK49xN.jpeg){.center}
:::
:::
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0040}

## Packaging Your Project {#c09.xhtml#h2-7 .Heading-1}

Now that your circuit is no longer at risk of falling apart, it's a good idea to look at protecting it from the outside world by boxing it up.

::: {.section}
[]{#c09.xhtml#c09-sec-0041}

### Enclosures {#c09.xhtml#h3-27 .Heading-2}

The simplest way to protect your circuit is by putting it in a box. In electronics terms, such a box is called an enclosure or a project box. You can find a variety of plastic or metal enclosures in a vast array of shapes, sizes, and finishes. The only task is to find the one that's right for you.

Many of the online suppliers (RS, Farnell, Digi-Key, and others) have huge lists of possible enclosures, but you can't tell whether it's right without holding it in your hands. Many enclosures have accurate measurements for internal and external dimensions, but even with that information there are usually omissions, such as the molded plastic for the screw fixings. My advice is to find a retail store, such as Radio Shack, and take an Arduino with you to see whether it will fit correctly with enough space for wires and any shields. Then you\'ll know what works and what to order next time.

Keep the following considerations in mind when boxing up your project.

-   [**The ability to access the USB for code changes:** You may have to unscrew your enclosure to update the code. If this process is too time consuming, you may need to drill a hole big enough to plug the USB in from the outside.]{#c09.xhtml#c09-li-0017}
-   [**Power to run the Arduino:** If your Arduino is not powered by USB, how is it powered? It could be an external power supply that plugs into the power jack, which needs a big enough hole for the plug. You could remove the plug and solder the bare wires to the Vin and Gnd pins if you're looking for something more permanent. Or you could even run it off a battery pack and only open it every week or so to charge it.]{#c09.xhtml#c09-li-0018}
-   [**The ability to access the inputs and outputs:** What use is an LED or a button if it's inside the box? Most projects need some contact with the outside world, if only to tell you that they're still working, and most components are designed with this need in mind. The lip on an LED means that you can drill a 1.9-inch (5 mm) hole and push the front end through without it going all the way; if you take the plastic or metal knob off a radio, you\'ll see a similar fitting too.]{#c09.xhtml#c09-li-0019}

[]{#c09.xhtml#Page_203 .pagebreak role="doc-pagebreak" title="203"}Always think carefully about the needs of your circuit before soldering it in place and boxing it up. Examine other cheap electronics around you to see what tricks the industry has been using. For example, you may be surprised to find out that most remote controls for remote control cars that give you forward, backward, left, and right are just a few simple pushbuttons underneath those complex-looking control sticks.
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0042}

### Wiring {#c09.xhtml#h3-28 .Heading-2}

To give you more flexibility with your wiring, consider attaching inputs, outputs, or power to flexible lengths of cable by using terminal blocks, which are sometimes also known as connector strips, screw terminals, or chocolate (choc) blocks. By doing this, you can fix the inputs and outputs to the enclosure rather than to the circuit board. This approach gives you more flexibility --- and if you drill a hole slightly out of alignment, you won't need to de-solder or re-solder your circuit.

Following is a little more detail on adding wires to your project and selecting terminal blocks, which adds flexibility to your project and makes assembling and disassembling your project a lot easier.

::: {.section}
[]{#c09.xhtml#c09-sec-0043}

#### Twisting and braiding {#c09.xhtml#h4-6 .Heading-3}

When you make wire connectors, I recommend twisting or braiding the wires together. The braiding gives the wires extra strength if pulled on and, as a bonus, looks nice! To twist two wires together, cut them to length and grip one end in a power drill. Hold onto the other end of the two wires with your hand or a vice. Pull the wire taut enough to have no slack but not too tight. Spin the drill until the wires are neatly twisted together, and you should be left with one twisted wire.

If you have three wires, you can braid them in the same way that you braid hair. With three wires in your hand, hold them at one end facing forward. Pass the leftmost wire over the middle and under the rightmost. Keep repeating this process with the new left wire until you have braided the full length. Your project will be more robust and look extra professional. I advise you to use different colors for the wires; if you use the same color wire for all three, you need to use the continuity tester on your multimeter to figure out which is which.
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0044}

#### Terminal blocks {#c09.xhtml#h4-7 .Heading-3}

Terminal blocks come in a variety of sizes, depending on the amount of current passing through them, and are usually marked with the upper limit that they can maintain. When selecting one for your power supply, always read the current []{#c09.xhtml#Page_204 .pagebreak role="doc-pagebreak" title="204"}rating and choose a size with a bit of tolerance. If you have a 3A supply, choose a 5A terminal block. When connecting wires, especially multicore wires, you should tin the tip of the wire with a small amount of solder or fold the wire back under the insulation layer so that the screw grips the insulated side. This technique prevents the screw from cutting any of the strands of wire as it is tightened.
:::
:::

::: {.section}
[]{#c09.xhtml#c09-sec-0045}

### Securing the board and other elements {#c09.xhtml#h3-29 .Heading-2}

When you're happy with your cabling and have all the required holes, it's a good idea to secure your items so that they don't rattle around inside the box. To secure your Arduino, screw terminals, or stripboard, you can use Velcro-type tape or hot glue. If you have any loose wires, you can use cable ties to neatly tie them together.
:::
:::

[]{#c10.xhtml}

[]{#c10.xhtml#Page_205 .pagebreak role="doc-pagebreak" title="205"}Chapter 10

# Getting Clever with Code {#c10.xhtml#a1 .Chap-Title}

::: {.section}
[]{#c10.xhtml#c10-sec-0001}[]{#c10.xhtml#c10-feafxd-0001}

IN THIS CHAPTER

![check.png](https://i.imgur.com/0gdDHZQ.jpeg) **Understanding timers**

![check.png](https://i.imgur.com/nOl9kZt.jpeg) **Debouncing your buttons**

![check.png](https://i.imgur.com/d947jOM.jpeg) **Getting more from your buttons**

![check.png](https://i.imgur.com/gpswxr0.jpeg) **Averaging your results**

![check.png](https://i.imgur.com/6D7eOZV.jpeg) **Adjusting the sensitivity of sensors**

As you find different uses and needs for Arduino, you can refine your code to make it more accurate, responsive, and efficient. Also, by thinking about the code in your project, you may be able to avoid or minimize many of the unexpected results that can occur when dealing with physical hardware and the real world. In this chapter, you look at a few sketches that will help you fine-tune your project.
:::

::: {.section}
[]{#c10.xhtml#c10-sec-0002}

## Blinking Better {#c10.xhtml#h2-1 .Heading-1}

Blink is most likely the first sketch you encountered. It's a magical moment when that first LED lights up, isn't it? But what if I told you that it can get even better? The basic Blink sketch presented in [Chapter 3](#c03.xhtml) performs its task well, with one significant drawback: It can't do anything else while blinking.

Take a look at the Blink sketch again:

[]{#c10.xhtml#c10-code-0001}[]{#c10.xhtml#c10-lntxt-0001}

`void setup() {`{#c10.xhtml#c10-line-0001}

`  // initialize digital pin LED_BUILTIN as an output.`{#c10.xhtml#c10-line-0002}

`  pinMode(LED_BUILTIN, OUTPUT);`{#c10.xhtml#c10-line-0003}

`}`{#c10.xhtml#c10-line-0004}

``{#c10.xhtml#c10-line-0005} 

`// the loop function runs over and over again forever`{#c10.xhtml#c10-line-0006}

`void loop() {`{#c10.xhtml#c10-line-0007}

`  digitalWrite(LED_BUILTIN, HIGH);   // turn the LED on (HIGH is the voltage level)`{#c10.xhtml#c10-line-0008}

`  delay(1000);                       // wait for a second`{#c10.xhtml#c10-line-0009}

`  digitalWrite(LED_BUILTIN, LOW);    // turn the LED off by making the voltage LOW`{#c10.xhtml#c10-line-0010}

`  delay(1000);                       // wait for a second`{#c10.xhtml#c10-line-0011}

`}`{#c10.xhtml#c10-line-0012}

The loops can be summarized this way:

1.  [Turn on the LED.]{#c10.xhtml#c10-li-0006}
2.  [Wait for a second.]{#c10.xhtml#c10-li-0007}
3.  [Turn off the LED.]{#c10.xhtml#c10-li-0008}
4.  [Wait for a second.]{#c10.xhtml#c10-li-0009}

This delay, or waiting, can be problematic for many people when they try to integrate the Blink sketch with another bit of code. When the sketch uses the delay function, it waits for the amount of time specified (in this case, a second), during which it doesn't do anything else. Effectively, the sketch is twiddling its thumbs.

If you wanted to change something --- for example, you wanted the LED to blink only when a light sensor was dark --- you might think of writing the code in the loop section something like this:

[]{#c10.xhtml#c10-code-0002}[]{#c10.xhtml#c10-lntxt-0002}

`void loop() {`{#c10.xhtml#c10-line-0013}

``{#c10.xhtml#c10-line-0014} 

`sensorValue = analogRead(sensorPin);`{#c10.xhtml#c10-line-0015}

``{#c10.xhtml#c10-line-0016} 

`if (sensorValue < darkValue) {`{#c10.xhtml#c10-line-0017}

`  digitalWrite(LED_BUILTIN, HIGH);   // turn the LED on (HIGH is the voltage level)`{#c10.xhtml#c10-line-0018}

`  delay(1000);                       // wait for a second`{#c10.xhtml#c10-line-0019}

`  digitalWrite(LED_BUILTIN, LOW);    // turn the LED off by making the voltage LOW`{#c10.xhtml#c10-line-0020}

`  delay(1000);                       // wait for a second`{#c10.xhtml#c10-line-0021}

`           }`{#c10.xhtml#c10-line-0022}

`}`{#c10.xhtml#c10-line-0023}

This code almost works. When the value threshold for [`darkValue`]{.Code-within-text} is crossed, the [`if`]{.Code-within-text} loop starts and turns on the LED, waits for one second, and then turns it off and waits for one second. But because the sketch is occupied doing this blink for two []{#c10.xhtml#Page_207 .pagebreak role="doc-pagebreak" title="207"}seconds, the sketch can\'t check to see if the light level becomes brighter again until the blink has finished.

The solution is to use a timer rather than pause the program. A timer or counter is like a clock that can be used to time events. For example, the timer can count from 0 to 1,000, and when it reaches 1,000 it can *do something*, and then start counting from 0 again. Timers can be especially useful for regularly timed events, such as checking a sensor every second --- or in this case triggering an LED every second.

::: {.section}
[]{#c10.xhtml#c10-sec-0003}

### Setting up the BlinkWithoutDelay sketch {#c10.xhtml#h3-1 .Heading-2}

To complete this project, you need:

-   [An Arduino Uno]{#c10.xhtml#c10-li-0010}
-   [An LED]{#c10.xhtml#c10-li-0011}

Place the legs of the LED between pin 13 (long leg) and GND (short leg), as shown in [Figures 10-1](#c10.xhtml#c10-fig-0001){#c10.xhtml#rc10-fig-0001} and [10-2](#c10.xhtml#c10-fig-0002){#c10.xhtml#rc10-fig-0002}. This placement makes it a bit easier to see the blink in action. If you don\'t have an LED, look for the one fixed to your Arduino marked L. Upload the sketch to the correct serial port to see the LED blinking away as it would with the standard Blink sketch.

::: {#c10.xhtml#c10-fig-0001 .figure}
![9781119489542-fg1001.png](https://i.imgur.com/RjKwyVn.jpeg){.center}
:::

::: {#c10.xhtml#c10-fig-0002 .figure}
![9781119489542-fg1002.png](https://i.imgur.com/TrH6myn.jpeg){.center}
:::

Find the BlinkWithoutDelay sketch by choosing File ⇒   Examples ⇒   02.Digital ⇒   BlinkWithoutDelay and then open it.

[]{#c10.xhtml#Page_208 .pagebreak role="doc-pagebreak" title="208"}The complete code for the BlinkWithoutDelay sketch is as follows:

[]{#c10.xhtml#c10-code-0003}[]{#c10.xhtml#c10-lntxt-0003}

`/*`{#c10.xhtml#c10-line-0024}

`  Blink without Delay`{#c10.xhtml#c10-line-0025}

``{#c10.xhtml#c10-line-0026} 

`  Turns on and off a light emitting diode (LED) connected to a digital pin,`{#c10.xhtml#c10-line-0027}

`  without using the delay() function. This means that other code can run at the`{#c10.xhtml#c10-line-0028}

`  same time without being interrupted by the LED code.`{#c10.xhtml#c10-line-0029}

``{#c10.xhtml#c10-line-0030} 

`  The circuit:`{#c10.xhtml#c10-line-0031}

`  - Use the onboard LED.`{#c10.xhtml#c10-line-0032}

`  - Note: Most Arduinos have an on-board LED you can control. On the UNO, MEGA`{#c10.xhtml#c10-line-0033}

`    and ZERO it is attached to digital pin 13, on MKR1000 on pin 6. LED_BUILTIN`{#c10.xhtml#c10-line-0034}

`    is set to the correct LED pin independent of which board is used.`{#c10.xhtml#c10-line-0035}

`    If you want to know what pin the on-board LED is connected to on your`{#c10.xhtml#c10-line-0036}

`    Arduino model, check the Technical Specs of your board at:`{#c10.xhtml#c10-line-0037}

`    https://www.arduino.cc/en/Main/Products`{#c10.xhtml#c10-line-0038}

``{#c10.xhtml#c10-line-0039} 

`  created 2005`{#c10.xhtml#c10-line-0040}

`  by David A. Mellis`{#c10.xhtml#c10-line-0041}

`  modified 8 Feb 2010`{#c10.xhtml#c10-line-0042}

`  by Paul Stoffregen`{#c10.xhtml#c10-line-0043}

`  modified 11 Nov 2013`{#c10.xhtml#c10-line-0044}

`  by Scott Fitzgerald`{#c10.xhtml#c10-line-0045}

`  modified 9 Jan 2017`{#c10.xhtml#c10-line-0046}

`  by Arturo Guadalupi`{#c10.xhtml#c10-line-0047}

``{#c10.xhtml#c10-line-0048} 

`  This example code is in the public domain.`{#c10.xhtml#c10-line-0049}

``{#c10.xhtml#c10-line-0050} 

`  http://www.arduino.cc/en/Tutorial/BlinkWithoutDelay`{#c10.xhtml#c10-line-0051}

`*/`{#c10.xhtml#c10-line-0052}

``{#c10.xhtml#c10-line-0053} 

`// constants won't change. Used here to set a pin number:`{#c10.xhtml#c10-line-0054}

`const int ledPin =  LED_BUILTIN;// the number of the LED pin`{#c10.xhtml#c10-line-0055}

``{#c10.xhtml#c10-line-0056} 

`// Variables will change:`{#c10.xhtml#c10-line-0057}

`int ledState = LOW;             // ledState used to set the LED`{#c10.xhtml#c10-line-0058}

``{#c10.xhtml#c10-line-0059} 

`// Generally, you should use "unsigned long" for variables that hold time`{#c10.xhtml#c10-line-0060}

`// The value will quickly become too large for an int to store`{#c10.xhtml#c10-line-0061}

`unsigned long previousMillis = 0;        // will store last time LED was updated`{#c10.xhtml#c10-line-0062}

``{#c10.xhtml#c10-line-0063} 

`// constants won't change:`{#c10.xhtml#c10-line-0064}

`const long interval = 1000;           // interval at which to blink (milliseconds)`{#c10.xhtml#c10-line-0065}

``{#c10.xhtml#c10-line-0066} 

`void setup() {`{#c10.xhtml#c10-line-0067}

`  // set the digital pin as output:`{#c10.xhtml#c10-line-0068}

`  pinMode(ledPin, OUTPUT);`{#c10.xhtml#c10-line-0069}

`}`{#c10.xhtml#c10-line-0070}

``{#c10.xhtml#c10-line-0071} 

`void loop() {`{#c10.xhtml#c10-line-0072}

`  // here is where you'd put code that needs to be running all the time.`{#c10.xhtml#c10-line-0073}

``{#c10.xhtml#c10-line-0074} 

`  // check to see if it's time to blink the LED; that is, if the difference`{#c10.xhtml#c10-line-0075}

`  // between the current time and last time you blinked the LED is bigger than`{#c10.xhtml#c10-line-0076}

`  // the interval at which you want to blink the LED.`{#c10.xhtml#c10-line-0077}

`  unsigned long currentMillis = millis();`{#c10.xhtml#c10-line-0078}

``{#c10.xhtml#c10-line-0079} 

`  if (currentMillis - previousMillis >= interval) {`{#c10.xhtml#c10-line-0080}

`    // save the last time you blinked the LED`{#c10.xhtml#c10-line-0081}

`    previousMillis = currentMillis;`{#c10.xhtml#c10-line-0082}

``{#c10.xhtml#c10-line-0083} 

`    // if the LED is off turn it on and vice-versa:`{#c10.xhtml#c10-line-0084}

`    if (ledState == LOW) {`{#c10.xhtml#c10-line-0085}

`      ledState = HIGH;`{#c10.xhtml#c10-line-0086}

`    } else {`{#c10.xhtml#c10-line-0087}

`      ledState = LOW;`{#c10.xhtml#c10-line-0088}

`    }`{#c10.xhtml#c10-line-0089}

``{#c10.xhtml#c10-line-0090} 

`    // set the LED with the ledState of the variable:`{#c10.xhtml#c10-line-0091}

`    digitalWrite(ledPin, ledState);`{#c10.xhtml#c10-line-0092}

`  }`{#c10.xhtml#c10-line-0093}

`}`{#c10.xhtml#c10-line-0094}

This sketch is quite a bit longer than Blink and may seem more confusing, so we\'ll walk through it one line at a time to see what\'s happening.
:::

::: {.section}
[]{#c10.xhtml#c10-sec-0004}

### Understanding the BlinkWithoutDelay sketch {#c10.xhtml#h3-2 .Heading-2}

First, in the declarations, a [`const`]{.Code-within-text}[`int`]{.Code-within-text} is used to set [`ledPin`]{.Code-within-text} to the built-in LED (also known as pin 13) because it is a constant integer and does not change:

[]{#c10.xhtml#c10-code-0004}[]{#c10.xhtml#c10-lntxt-0004}

`const int ledPin =  LED_BUILTIN;`{#c10.xhtml#c10-line-0095}

Next are the variables. [`ledState`]{.Code-within-text} is set to [`LOW`]{.Code-within-text} so that our LED starts the sketch in an off state:

[]{#c10.xhtml#c10-code-0005}[]{#c10.xhtml#c10-lntxt-0005}

`int ledState = LOW;`{#c10.xhtml#c10-line-0096}

Then there is a new variable referred to as a [`long`]{.Code-within-text} rather than an [`int`]{.Code-within-text}. See the "[Long and Unsigned Long](#c10.xhtml#c10-fea-0001)" sidebar later in this chapter for more about [`long`]{.Code-within-text}s. The first instance, [`previousMillis`]{.Code-within-text}, stores the time in milliseconds so that you can monitor how much time has passed each time you do a loop:

[]{#c10.xhtml#c10-code-0006}[]{#c10.xhtml#c10-lntxt-0006}

`unsigned long previousMillis = 0;        `{#c10.xhtml#c10-line-0097}

The second value, a constant named [`interval`]{.Code-within-text}, is the time in milliseconds between each blink, which is set to 1000 milliseconds, or 1 second:

[]{#c10.xhtml#c10-code-0007}[]{#c10.xhtml#c10-lntxt-0007}

`const long interval = 1000;           `{#c10.xhtml#c10-line-0098}

```{=html}
<aside>
```
::: {#c10.xhtml#c10-fea-0001 .sidebar}
# LONG AND UNSIGNED LONG {.SB-Head}

[]{#c10.xhtml#c10-sec-0005}

[`Longs`]{.Code-within-text} are for extra-long number storage and can store a value from -2,147,483,648 to 2,147,483,647, whereas an [`int`]{.Code-within-text} can store only -32,768 to 32,767. When measuring time in milliseconds, you need access to big numbers because every second is stored as 1,000 milliseconds. To get an idea of just how big a [`long`]{.Code-within-text} value is, imagine the maximum amount of time that it could store: 2,147,483.6 seconds or 35791.4 minutes or 596.5 hours or approximately 24.9 days!

In some cases, you have no need for a negative range, so to avoid unnecessary calculations, use an [`unsigned long`]{.Code-within-text} instead. An [`unsigned long`]{.Code-within-text} is similar to a regular [`long`]{.Code-within-text} but has no negative values, which gives your [`unsigned long`]{.Code-within-text} a whopping range of 0 to 4,294,967,295.
:::

```{=html}
</aside>
```
In the [`setup`]{.Code-within-text} function, you have only one pin to define as [`OUTPUT`]{.Code-within-text}. Pin 13 is referred to as [`ledPin,`]{.Code-within-text} just as it is in the declarations:

[]{#c10.xhtml#c10-code-0008}[]{#c10.xhtml#c10-lntxt-0008}

`void setup() {`{#c10.xhtml#c10-line-0099}

`  // set the digital pin as output:`{#c10.xhtml#c10-line-0100}

`  pinMode(ledPin, OUTPUT);`{#c10.xhtml#c10-line-0101}

`}`{#c10.xhtml#c10-line-0102}

[]{#c10.xhtml#Page_211 .pagebreak role="doc-pagebreak" title="211"} In the loop, things start to get more complicated. Because the code for the timer can be run at the end of every loop, you can add your own code at the start of the loop so that it doesn\'t interfere with the timer. Following your code, the timer code begins, which declares another variable: an [`unsigned long`]{.Code-within-text} to store the current value of the timer in milliseconds. The timer code uses the function [`millis()`]{.Code-within-text}, which returns the number of milliseconds since the current Arduino program began running. After approximately 50 days, this value resets to 0, but this is more than enough time for most applications.

[]{#c10.xhtml#c10-code-0009}[]{#c10.xhtml#c10-lntxt-0009}

`unsigned long currentMillis = millis();`{#c10.xhtml#c10-line-0103}

![tip.png](https://i.imgur.com/MUj1sjX.jpeg) Variables declared inside a loop or other functions are known as *local* variables. They exist only within the function in which they are declared (and other sub-functions contained inside), and cease to exist after the function is completed. They are re-declared the next time the function is called. If you have a variable that needs to be either read or written to by other functions or pieces of code, you should use a *global* variable and declare it at the start of the sketch before the [`setup`]{.Code-within-text} function.

Next you need to check the current [`millis()`]{.Code-within-text} value to see how much time has passed. You do so by using a simple [`if`]{.Code-within-text} loop that subtracts the previous value from the current value to get the difference. If that difference is greater than the interval value, the sketch knows that it\'s time to blink. It's important that you also tell the code to reset [`previousMillis`]{.Code-within-text}; otherwise, it will measure the interval only once. This is what setting [`previousMillis = currentMillis`]{.Code-within-text} does:

[]{#c10.xhtml#c10-code-0010}[]{#c10.xhtml#c10-lntxt-0010}

`  if(currentMillis - previousMillis > interval) {`{#c10.xhtml#c10-line-0104}

`    // save the last time you blinked the LED`{#c10.xhtml#c10-line-0105}

`    previousMillis = currentMillis;`{#c10.xhtml#c10-line-0106}

[]{#c10.xhtml#Page_212 .pagebreak role="doc-pagebreak" title="212"} Because the LED could already be on or off, the code needs to check the state of the LED to know what to do. The state is stored in [`ledState`]{.Code-within-text}, so another simple [`if`]{.Code-within-text} statement can check the state and do the opposite. If [`LOW`]{.Code-within-text}, make [`HIGH`]{.Code-within-text}; or if [`HIGH`]{.Code-within-text}, make [`LOW`]{.Code-within-text}. The following code updates the variable [`ledState`]{.Code-within-text}:

[]{#c10.xhtml#c10-code-0011}[]{#c10.xhtml#c10-lntxt-0011}

`// if the LED is off turn it on and vice-versa:`{#c10.xhtml#c10-line-0107}

`    if (ledState == LOW){`{#c10.xhtml#c10-line-0108}

`      ledState = HIGH;`{#c10.xhtml#c10-line-0109}

`    } else {`{#c10.xhtml#c10-line-0110}

`      ledState = LOW;`{#c10.xhtml#c10-line-0111}

`    }`{#c10.xhtml#c10-line-0112}

Now, all that is left to do is to write the newly updated state to the LED by using [`digitalWrite`]{.Code-within-text}:

[]{#c10.xhtml#c10-code-0012}[]{#c10.xhtml#c10-lntxt-0012}

`    // set the LED with the ledState of the variable:`{#c10.xhtml#c10-line-0113}

`    digitalWrite(ledPin, ledState);`{#c10.xhtml#c10-line-0114}

`}`{#c10.xhtml#c10-line-0115}

This code allows you to happily blink your LED while performing any number of other functions.
:::
:::

::: {.section}
[]{#c10.xhtml#c10-sec-0006}

## Taking the Bounce Out of Your Button {#c10.xhtml#h2-2 .Heading-1}

A strange occurrence that happens with pushbuttons is bouncing. The microcontroller on your Arduino can read a switch thousands of times per second, much faster than you can operate it. This speed ensures that the reading is instantaneous (as far as human perception can tell), but sometimes there is a moment of fuzziness when the contact on a switch is neither fully down nor fully up, which causes it to read on and off rapidly in quick succession until it reaches the correct state. This behavior is called bouncing. To remove this peculiarity, you have to ignore any sudden changes when the switch state changes by using a timer. It\'s relatively simple and can greatly improve the reliability of your buttons. Using timers works for your inputs as well as outputs, as noted in the preceding section, \"[Blinking Better](#c10.xhtml#c10-sec-0002).\"

::: {.section}
[]{#c10.xhtml#c10-sec-0007}

### Setting up the Debounce sketch {#c10.xhtml#h3-3 .Heading-2}

Complete the circuit in [Figure 10-3](#c10.xhtml#c10-fig-0003){#c10.xhtml#rc10-fig-0003} to try out the Debounce sketch. You need:

-   [An Arduino Uno]{#c10.xhtml#c10-li-0012}
-   [A breadboard]{#c10.xhtml#c10-li-0013}
-   [[]{#c10.xhtml#Page_213 .pagebreak role="doc-pagebreak" title="213"}A pushbutton]{#c10.xhtml#c10-li-0014}
-   [An LED]{#c10.xhtml#c10-li-0015}
-   [A 10k ohm resistor]{#c10.xhtml#c10-li-0016}
-   [Jump wires]{#c10.xhtml#c10-li-0017}

::: {#c10.xhtml#c10-fig-0003 .figure}
![9781119489542-fg1003.png](https://i.imgur.com/biKo09P.jpeg){.center}
:::

Complete the circuit shown in [Figures 10-3](#c10.xhtml#c10-fig-0003) and [10-4](#c10.xhtml#c10-fig-0004){#c10.xhtml#rc10-fig-0004}, using a breadboard to mount the pushbutton part of the circuit. The LED can be inserted straight into pin 13 and its neighboring GND pin.

::: {#c10.xhtml#c10-fig-0004 .figure}
![9781119489542-fg1004.png](https://i.imgur.com/fOku1mC.jpeg){.center}
:::

Build the circuit and choose File ⇒   Examples ⇒   02.Digital ⇒   Debounce to find the pushbutton Debounce sketch and open it. The complete code for the Debounce sketch is as follows:

[]{#c10.xhtml#c10-code-0013}[]{#c10.xhtml#c10-lntxt-0013}

`/*`{#c10.xhtml#c10-line-0116}

`  Debounce`{#c10.xhtml#c10-line-0117}

``{#c10.xhtml#c10-line-0118} 

`  Each time the input pin goes from LOW to HIGH (e.g. because of a push-button`{#c10.xhtml#c10-line-0119}

`  press), the output pin is toggled from LOW to HIGH or HIGH to LOW. There's a`{#c10.xhtml#c10-line-0120}

`  minimum delay between toggles to debounce the circuit (i.e. to ignore noise).`{#c10.xhtml#c10-line-0121}

``{#c10.xhtml#c10-line-0122} 

`  The circuit:`{#c10.xhtml#c10-line-0123}

`  - LED attached from pin 13 to ground`{#c10.xhtml#c10-line-0124}

`  - pushbutton attached from pin 2 to +5V`{#c10.xhtml#c10-line-0125}

`  - 10 kilohm resistor attached from pin 2 to ground`{#c10.xhtml#c10-line-0126}

``{#c10.xhtml#c10-line-0127} 

`  - Note: On most Arduino boards, there is already an LED on the board connected`{#c10.xhtml#c10-line-0128}

`    to pin 13, so you don't need any extra components for this example.`{#c10.xhtml#c10-line-0129}

``{#c10.xhtml#c10-line-0130} 

`  created 21 Nov 2006`{#c10.xhtml#c10-line-0131}

`  by David A. Mellis`{#c10.xhtml#c10-line-0132}

`  modified 30 Aug 2011`{#c10.xhtml#c10-line-0133}

`  by Limor Fried`{#c10.xhtml#c10-line-0134}

`  modified 28 Dec 2012`{#c10.xhtml#c10-line-0135}

`  by Mike Walters`{#c10.xhtml#c10-line-0136}

`  modified 30 Aug 2016`{#c10.xhtml#c10-line-0137}

`  by Arturo Guadalupi`{#c10.xhtml#c10-line-0138}

``{#c10.xhtml#c10-line-0139} 

`  This example code is in the public domain.`{#c10.xhtml#c10-line-0140}

``{#c10.xhtml#c10-line-0141} 

`  http://www.arduino.cc/en/Tutorial/Debounce`{#c10.xhtml#c10-line-0142}

`*/`{#c10.xhtml#c10-line-0143}

``{#c10.xhtml#c10-line-0144} 

`// constants won't change. They're used here to`{#c10.xhtml#c10-line-0145}

`// set pin numbers:`{#c10.xhtml#c10-line-0146}

`const int buttonPin = 2;     // the number of the pushbutton pin`{#c10.xhtml#c10-line-0147}

`const int ledPin =  13;      // the number of the LED pin`{#c10.xhtml#c10-line-0148}

``{#c10.xhtml#c10-line-0149} 

`// Variables will change:`{#c10.xhtml#c10-line-0150}

`int ledState = HIGH;         // the current state of the output pin`{#c10.xhtml#c10-line-0151}

`int buttonState;             // the current reading from the input pin`{#c10.xhtml#c10-line-0152}

`int lastButtonState = LOW;   // the previous reading from the input pin`{#c10.xhtml#c10-line-0153}

``{#c10.xhtml#c10-line-0154} 

`// the following variables are long's because the time, measured in miliseconds,`{#c10.xhtml#c10-line-0155}

`// will quickly become a bigger number than can be stored in an int.`{#c10.xhtml#c10-line-0156}

`long lastDebounceTime = 0;  // the last time the output pin was toggled`{#c10.xhtml#c10-line-0157}

`long debounceDelay = 50;    // the debounce time; increase if the output`{#c10.xhtml#c10-line-0158}

`                            // flickers`{#c10.xhtml#c10-line-0159}

``{#c10.xhtml#c10-line-0160} 

`void setup() {`{#c10.xhtml#c10-line-0161}

`  pinMode(buttonPin, INPUT);`{#c10.xhtml#c10-line-0162}

`  pinMode(ledPin, OUTPUT);`{#c10.xhtml#c10-line-0163}

`}`{#c10.xhtml#c10-line-0164}

``{#c10.xhtml#c10-line-0165} 

`void loop() {`{#c10.xhtml#c10-line-0166}

`  // read the state of the switch into a local variable:`{#c10.xhtml#c10-line-0167}

`  int reading = digitalRead(buttonPin);`{#c10.xhtml#c10-line-0168}

``{#c10.xhtml#c10-line-0169} 

`  // check to see if you just pressed the button`{#c10.xhtml#c10-line-0170}

`  // (i.e. the input went from LOW to HIGH), and you've waited`{#c10.xhtml#c10-line-0171}

`  // long enough since the last press to ignore any noise:`{#c10.xhtml#c10-line-0172}

``{#c10.xhtml#c10-line-0173} 

`  // If the switch changed, due to noise or pressing:`{#c10.xhtml#c10-line-0174}

`  if (reading != lastButtonState) {`{#c10.xhtml#c10-line-0175}

`    // reset the debouncing timer`{#c10.xhtml#c10-line-0176}

`    lastDebounceTime = millis();`{#c10.xhtml#c10-line-0177}

`  }`{#c10.xhtml#c10-line-0178}

``{#c10.xhtml#c10-line-0179} 

`  if ((millis() - lastDebounceTime) > debounceDelay) {`{#c10.xhtml#c10-line-0180}

`    // whatever the reading is at, it's been there for longer`{#c10.xhtml#c10-line-0181}

`    // than the debounce delay, so take it as the actual current state:`{#c10.xhtml#c10-line-0182}

`    buttonState = reading;`{#c10.xhtml#c10-line-0183}

`  }`{#c10.xhtml#c10-line-0184}

``{#c10.xhtml#c10-line-0185} 

`  // set the LED using the state of the button:`{#c10.xhtml#c10-line-0186}

`  digitalWrite(ledPin, buttonState);`{#c10.xhtml#c10-line-0187}

``{#c10.xhtml#c10-line-0188} 

`  // save the reading.  Next time through the loop,`{#c10.xhtml#c10-line-0189}

`  // it'll be the lastButtonState:`{#c10.xhtml#c10-line-0190}

`  lastButtonState = reading;`{#c10.xhtml#c10-line-0191}

`}`{#c10.xhtml#c10-line-0192}

When you\'ve uploaded the sketch, you should have a reliable, debounced button. It can be difficult to see the effects --- when everything's working correctly, you see just accurate button presses and responses from your LED.
:::

::: {.section}
[]{#c10.xhtml#c10-sec-0008}

### Understanding the Debounce sketch {#c10.xhtml#h3-4 .Heading-2}

The Debounce sketch starts by declaring two constants that are used to define the input and output pins:

[]{#c10.xhtml#c10-code-0014}[]{#c10.xhtml#c10-lntxt-0014}

`// constants won't change. They're used here to`{#c10.xhtml#c10-line-0193}

`// set pin numbers:`{#c10.xhtml#c10-line-0194}

`const int buttonPin = 2;     // the number of the pushbutton pin`{#c10.xhtml#c10-line-0195}

`const int ledPin =  13;      // the number of the LED pin`{#c10.xhtml#c10-line-0196}

The next set of variables hold details about the button state. [`ledState`]{.Code-within-text} is set to [`HIGH`]{.Code-within-text} so that the LED starts as being turned on; [`buttonState`]{.Code-within-text} is left empty and holds the current state; [`lastButtonState`]{.Code-within-text} holds the previous button state so that it can be compared with the current state:

[]{#c10.xhtml#c10-code-0015}[]{#c10.xhtml#c10-lntxt-0015}

`// Variables will change:`{#c10.xhtml#c10-line-0197}

`int ledState = HIGH;         // the current state of the output pin`{#c10.xhtml#c10-line-0198}

`int buttonState;             // the current reading from the input pin`{#c10.xhtml#c10-line-0199}

`int lastButtonState = LOW;   // the previous reading from the input pin`{#c10.xhtml#c10-line-0200}

Finally, two [`long`]{.Code-within-text} variables store time values. These are used in a timer to monitor the time between readings and prevent any sudden changes in values, such as those that occur during bounces:

[]{#c10.xhtml#c10-code-0016}[]{#c10.xhtml#c10-lntxt-0016}

`// the following variables are long's because the time, measured in miliseconds,`{#c10.xhtml#c10-line-0201}

`// will quickly become a bigger number than can be stored in an int.`{#c10.xhtml#c10-line-0202}

`long lastDebounceTime = 0;  // the last time the output pin was toggled`{#c10.xhtml#c10-line-0203}

`long debounceDelay = 50;    // the debounce time; increase if the output`{#c10.xhtml#c10-line-0204}

`                            // flickers`{#c10.xhtml#c10-line-0205}

[]{#c10.xhtml#Page_217 .pagebreak role="doc-pagebreak" title="217"} The [`setup`]{.Code-within-text} function is straightforward and sets only the input and output pins:

[]{#c10.xhtml#c10-code-0017}[]{#c10.xhtml#c10-lntxt-0017}

`void setup() {`{#c10.xhtml#c10-line-0206}

`  pinMode(buttonPin, INPUT);`{#c10.xhtml#c10-line-0207}

`  pinMode(ledPin, OUTPUT);`{#c10.xhtml#c10-line-0208}

`}`{#c10.xhtml#c10-line-0209}

In the [`loop,`]{.Code-within-text} a reading is taken from the button pin and stored in the [`reading`]{.Code-within-text} variable:

[]{#c10.xhtml#c10-code-0018}[]{#c10.xhtml#c10-lntxt-0018}

`void loop() {`{#c10.xhtml#c10-line-0210}

`  // read the state of the switch into a local variable:`{#c10.xhtml#c10-line-0211}

`  int reading = digitalRead(buttonPin);`{#c10.xhtml#c10-line-0212}

The [`reading`]{.Code-within-text} variable is then checked against [`lastButtonState`]{.Code-within-text}. The first time this runs, [`lastButtonState`]{.Code-within-text} is [`LOW`]{.Code-within-text} because it was set in the variable declarations at the beginning of the sketch. In the [`if`]{.Code-within-text} statement, the comparison symbol [`!=`]{.Code-within-text} is used. This means: "If [`reading`]{.Code-within-text}*is not* equal to [`lastButtonState`]{.Code-within-text}, do something." If this change has occurred, [`lastDebounceTime`]{.Code-within-text} is updated so that a fresh comparison can be made the next time the loop runs:

[]{#c10.xhtml#c10-code-0019}[]{#c10.xhtml#c10-lntxt-0019}

`  // If the switch changed, due to noise or pressing:`{#c10.xhtml#c10-line-0213}

`  if (reading != lastButtonState) {`{#c10.xhtml#c10-line-0214}

`    // reset the debouncing timer`{#c10.xhtml#c10-line-0215}

`    lastDebounceTime = millis();`{#c10.xhtml#c10-line-0216}

`  }`{#c10.xhtml#c10-line-0217}

If [`reading`]{.Code-within-text} has been the same for longer than the debounce delay of 50 milliseconds, it can be assumed that the value is not erratic and can be forwarded to the [`buttonState`]{.Code-within-text} variable:

[]{#c10.xhtml#c10-code-0020}[]{#c10.xhtml#c10-lntxt-0020}

`  if ((millis() - lastDebounceTime) > debounceDelay) {`{#c10.xhtml#c10-line-0218}

`    // whatever the reading is at, it's been there for longer`{#c10.xhtml#c10-line-0219}

`    // than the debounce delay, so take it as the actual current state:`{#c10.xhtml#c10-line-0220}

`    buttonState = reading;`{#c10.xhtml#c10-line-0221}

`  }`{#c10.xhtml#c10-line-0222}

The trusted value can then be used to trigger the LED directly. In this case, if the button is [`HIGH`]{.Code-within-text}, it is closed, so the same [`HIGH`]{.Code-within-text} value can be written to the LED to turn it on:

[]{#c10.xhtml#c10-code-0021}[]{#c10.xhtml#c10-lntxt-0021}

`  digitalWrite(ledPin, buttonState);`{#c10.xhtml#c10-line-0223}

[]{#c10.xhtml#Page_218 .pagebreak role="doc-pagebreak" title="218"} The current [`buttonState`]{.Code-within-text} becomes [`lastButtonState`]{.Code-within-text} for the next loop, and then the code returns to the start of the [`loop`]{.Code-within-text} function:

[]{#c10.xhtml#c10-code-0022}[]{#c10.xhtml#c10-lntxt-0022}

`  lastButtonState = reading;`{#c10.xhtml#c10-line-0224}

`}`{#c10.xhtml#c10-line-0225}

Some pushbuttons and triggers can be more or less reliable than others, depending on the way they\'re made or used. By using bits of code like this, you can sort out any inconsistencies and create more reliable results.
:::
:::

::: {.section}
[]{#c10.xhtml#c10-sec-0009}

## Making a Better Button {#c10.xhtml#h2-3 .Heading-1}

Buttons are usually simple things. They are either on or off, depending on whether or not you\'re pressing them. You can monitor these changes and interpret them to make a button more intelligent. If you can tell when a button has been pressed, you don't need to constantly read its value and can instead just look for this change of state. This practice is much better when connecting your Arduino to a computer, because it efficiently sends the appropriate data as it is needed, rather than hogging the serial port.

::: {.section}
[]{#c10.xhtml#c10-sec-0010}

### Setting up the StateChangeDetection sketch {#c10.xhtml#h3-5 .Heading-2}

To build the StateChangeDetection circuit, you need the following:

-   [An Arduino Uno]{#c10.xhtml#c10-li-0018}
-   [A breadboard]{#c10.xhtml#c10-li-0019}
-   [A pushbutton]{#c10.xhtml#c10-li-0020}
-   [A 10k ohm resistor]{#c10.xhtml#c10-li-0021}
-   [An LED]{#c10.xhtml#c10-li-0022}
-   [Jump wires]{#c10.xhtml#c10-li-0023}

Using the layout and circuit diagrams shown in [Figures 10-5](#c10.xhtml#c10-fig-0005){#c10.xhtml#rc10-fig-0005} and [10-6](#c10.xhtml#c10-fig-0006){#c10.xhtml#rc10-fig-0006}, you can lay out a simple button circuit with an LED as an output. The hardware in this circuit is the same as the basic Button sketch, but with the use of some simple code, you can make a button a lot more intelligent.[]{#c10.xhtml#Page_219 .pagebreak role="doc-pagebreak" title="219"}

::: {#c10.xhtml#c10-fig-0005 .figure}
![9781119489542-fg1005.png](https://i.imgur.com/4xPYJlf.jpeg){.center}
:::

::: {#c10.xhtml#c10-fig-0006 .figure}
![9781119489542-fg1006.png](https://i.imgur.com/kOJUoC3.jpeg){.center}
:::

Complete the circuit and choose File ⇒   Examples ⇒   02.Digital ⇒   StateChangeDetection from the Arduino menu to load the sketch:

[]{#c10.xhtml#c10-code-0023}[]{#c10.xhtml#c10-lntxt-0023}

`/*`{#c10.xhtml#c10-line-0226}

`  State change detection (edge detection)`{#c10.xhtml#c10-line-0227}

``{#c10.xhtml#c10-line-0228} 

`  Often, you don't need to know the state of a digital input all the time, but`{#c10.xhtml#c10-line-0229}

`  you just need to know when the input changes from one state to another.`{#c10.xhtml#c10-line-0230}

`  For example, you want to know when a button goes from OFF to ON. This is called`{#c10.xhtml#c10-line-0231}

`  state change detection, or edge detection.`{#c10.xhtml#c10-line-0232}

``{#c10.xhtml#c10-line-0233} 

`  This example shows how to detect when a button or button changes from off to on`{#c10.xhtml#c10-line-0234}

`  and on to off.`{#c10.xhtml#c10-line-0235}

``{#c10.xhtml#c10-line-0236} 

`  The circuit:`{#c10.xhtml#c10-line-0237}

`  - pushbutton attached to pin 2 from +5V`{#c10.xhtml#c10-line-0238}

`  - 10 kilohm resistor attached to pin 2 from ground`{#c10.xhtml#c10-line-0239}

`  - LED attached from pin 13 to ground (or use the built-in LED on most`{#c10.xhtml#c10-line-0240}

`    Arduino boards)`{#c10.xhtml#c10-line-0241}

``{#c10.xhtml#c10-line-0242} 

`  created  27 Sep 2005`{#c10.xhtml#c10-line-0243}

`  modified 30 Aug 2011`{#c10.xhtml#c10-line-0244}

`  by Tom Igoe`{#c10.xhtml#c10-line-0245}

``{#c10.xhtml#c10-line-0246} 

`  This example code is in the public domain.`{#c10.xhtml#c10-line-0247}

``{#c10.xhtml#c10-line-0248} 

`  http://www.arduino.cc/en/Tutorial/ButtonStateChange`{#c10.xhtml#c10-line-0249}

`*/`{#c10.xhtml#c10-line-0250}

``{#c10.xhtml#c10-line-0251} 

`// this constant won't change:`{#c10.xhtml#c10-line-0252}

`const int  buttonPin = 2;    // the pin that the pushbutton is attached to`{#c10.xhtml#c10-line-0253}

`const int ledPin = 13;       // the pin that the LED is attached to`{#c10.xhtml#c10-line-0254}

``{#c10.xhtml#c10-line-0255} 

`// Variables will change:`{#c10.xhtml#c10-line-0256}

`int buttonPushCounter = 0;   // counter for the number of button presses`{#c10.xhtml#c10-line-0257}

`int buttonState = 0;           // current state of the button`{#c10.xhtml#c10-line-0258}

`int lastButtonState = 0;     // previous state of the button`{#c10.xhtml#c10-line-0259}

``{#c10.xhtml#c10-line-0260} 

`void setup() {`{#c10.xhtml#c10-line-0261}

`  // initialize the button pin as a input:`{#c10.xhtml#c10-line-0262}

`  pinMode(buttonPin, INPUT);`{#c10.xhtml#c10-line-0263}

`  // initialize the LED as an output:`{#c10.xhtml#c10-line-0264}

`  pinMode(ledPin, OUTPUT);`{#c10.xhtml#c10-line-0265}

`  // initialize serial communication:`{#c10.xhtml#c10-line-0266}

`  Serial.begin(9600);`{#c10.xhtml#c10-line-0267}

`}`{#c10.xhtml#c10-line-0268}

``{#c10.xhtml#c10-line-0269} 

``{#c10.xhtml#c10-line-0270} 

`void loop() {`{#c10.xhtml#c10-line-0271}

`  // read the pushbutton input pin:`{#c10.xhtml#c10-line-0272}

`  buttonState = digitalRead(buttonPin);`{#c10.xhtml#c10-line-0273}

``{#c10.xhtml#c10-line-0274} 

`  // compare the buttonState to its previous state`{#c10.xhtml#c10-line-0275}

`  if (buttonState != lastButtonState) {`{#c10.xhtml#c10-line-0276}

`    // if the state has changed, increment the counter`{#c10.xhtml#c10-line-0277}

`    if (buttonState == HIGH) {`{#c10.xhtml#c10-line-0278}

`      // if the current state is HIGH then the button`{#c10.xhtml#c10-line-0279}

`      // wend from off to on:`{#c10.xhtml#c10-line-0280}

`      buttonPushCounter++;`{#c10.xhtml#c10-line-0281}

`      Serial.println("on");`{#c10.xhtml#c10-line-0282}

`      Serial.print("number of button pushes:  ");`{#c10.xhtml#c10-line-0283}

`      Serial.println(buttonPushCounter);`{#c10.xhtml#c10-line-0284}

`    }`{#c10.xhtml#c10-line-0285}

`    else {`{#c10.xhtml#c10-line-0286}

`      // if the current state is LOW then the button went from on to off:`{#c10.xhtml#c10-line-0287}

`      Serial.println("off");`{#c10.xhtml#c10-line-0288}

`    }`{#c10.xhtml#c10-line-0289}

`  }`{#c10.xhtml#c10-line-0290}

`  // save the current state as the last state, for next time through the loop`{#c10.xhtml#c10-line-0291}

`  lastButtonState = buttonState;`{#c10.xhtml#c10-line-0292}

``{#c10.xhtml#c10-line-0293} 

` `{#c10.xhtml#c10-line-0294}

`  // turns on the LED every four button pushes by`{#c10.xhtml#c10-line-0295}

`  // checking the modulo of the button push counter.`{#c10.xhtml#c10-line-0296}

`  // the modulo function gives you the remainder of`{#c10.xhtml#c10-line-0297}

`  // the division of two numbers:`{#c10.xhtml#c10-line-0298}

`  if (buttonPushCounter % 4 == 0) {`{#c10.xhtml#c10-line-0299}

`    digitalWrite(ledPin, HIGH);`{#c10.xhtml#c10-line-0300}

`  } else {`{#c10.xhtml#c10-line-0301}

`   digitalWrite(ledPin, LOW);`{#c10.xhtml#c10-line-0302}

`  }`{#c10.xhtml#c10-line-0303}

` `{#c10.xhtml#c10-line-0304}

`}`{#c10.xhtml#c10-line-0305}

[]{#c10.xhtml#Page_222 .pagebreak role="doc-pagebreak" title="222"} Press the Compile button to check your code. Compiling should highlight any grammatical errors and display a red text box if any are discovered. If the sketch compiles correctly, click Upload to send the sketch to your board. When the sketch has finished uploading, choose the serial monitor, and you should be presented with a readout showing when the button was turned on and off as well as how many times it was pressed. Also, the LED should illuminate every four button pushes to show that it's counting.

If nothing happens, try the following:

-   [Double-check your wiring.]{#c10.xhtml#c10-li-0024}
-   [Make sure that you're using the correct pin number.]{#c10.xhtml#c10-li-0025}
-   [Check the connections on the breadboard. If the jump wires or components are not connected using the correct rows in the breadboard, they will not work.]{#c10.xhtml#c10-li-0026}
:::

::: {.section}
[]{#c10.xhtml#c10-sec-0011}

### Understanding the StateChangeDetection sketch {#c10.xhtml#h3-6 .Heading-2}

In the StateChangeDetection sketch, the first action is to declare the constants for the sketch. The input and output pins won't change, so they are declared as constant integers, pin 2 for the pushbutton and pin 13 for the LED.\\:

[]{#c10.xhtml#c10-code-0024}[]{#c10.xhtml#c10-lntxt-0024}

`// this constant won't change:`{#c10.xhtml#c10-line-0306}

`const int buttonPin = 2;    // the pin that the pushbutton is attached to`{#c10.xhtml#c10-line-0307}

`const int ledPin = 13;       // the pin that the LED is attached to`{#c10.xhtml#c10-line-0308}

Other variables are needed to keep track of the pushbutton's behavior. One variable is a counter that keeps a running total of the number of button presses, and two other variables track the current and previous states of the pushbutton. These are used to monitor the button presses as the signal goes from [`HIGH`]{.Code-within-text} to [`LOW`]{.Code-within-text} or [`LOW`]{.Code-within-text} to [`HIGH`]{.Code-within-text}:

[]{#c10.xhtml#c10-code-0025}[]{#c10.xhtml#c10-lntxt-0025}

`// Variables will change:`{#c10.xhtml#c10-line-0309}

`int buttonPushCounter = 0;   // counter for the number of button presses`{#c10.xhtml#c10-line-0310}

`int buttonState = 0;           // current state of the button`{#c10.xhtml#c10-line-0311}

`int lastButtonState = 0;     // previous state of the button`{#c10.xhtml#c10-line-0312}

In the [`setup`]{.Code-within-text} function, the pins are set to [`INPUT`]{.Code-within-text} and [`OUTPUT`]{.Code-within-text} accordingly. The serial port is opened for communication to display changes in the pushbutton:

[]{#c10.xhtml#c10-code-0026}[]{#c10.xhtml#c10-lntxt-0026}

`void setup() {`{#c10.xhtml#c10-line-0313}

`  // initialize the button pin as a input:`{#c10.xhtml#c10-line-0314}

`  pinMode(buttonPin, INPUT);`{#c10.xhtml#c10-line-0315}

`  // initialize the LED as an output:`{#c10.xhtml#c10-line-0316}

`  pinMode(ledPin, OUTPUT);`{#c10.xhtml#c10-line-0317}

`  // initialize serial communication:`{#c10.xhtml#c10-line-0318}

`  Serial.begin(9600);`{#c10.xhtml#c10-line-0319}

`}`{#c10.xhtml#c10-line-0320}

The first stage in the main loop is to read the state of the pushbutton:

[]{#c10.xhtml#c10-code-0027}[]{#c10.xhtml#c10-lntxt-0027}

`void loop() {`{#c10.xhtml#c10-line-0321}

`  // read the pushbutton input pin:`{#c10.xhtml#c10-line-0322}

`  buttonState = digitalRead(buttonPin);`{#c10.xhtml#c10-line-0323}

If this state is not equal to the previous value, which happens when the pushbutton is pressed, the program progresses to the next [`if ()`]{.Code-within-text} statement.

[]{#c10.xhtml#c10-code-0028}[]{#c10.xhtml#c10-lntxt-0028}

`  // compare the buttonState to its previous state`{#c10.xhtml#c10-line-0324}

`  if (buttonState != lastButtonState) {`{#c10.xhtml#c10-line-0325}

The next condition is to check whether the button is [`HIGH`]{.Code-within-text} or [`LOW`]{.Code-within-text}. If it is [`HIGH`]{.Code-within-text}, the pushbutton has changed to on:

[]{#c10.xhtml#c10-code-0029}[]{#c10.xhtml#c10-lntxt-0029}

`    // if the state has changed, increment the counter`{#c10.xhtml#c10-line-0326}

`    if (buttonState == HIGH) {`{#c10.xhtml#c10-line-0327}

`      // if the current state is HIGH then the button`{#c10.xhtml#c10-line-0328}

`      // wend from off to on:`{#c10.xhtml#c10-line-0329}

This bit of code increments the counter and then prints a line on the serial monitor to show the state and the number of pushes. The counter is incremented on the downward part of the button press rather than the release:

[]{#c10.xhtml#c10-code-0030}[]{#c10.xhtml#c10-lntxt-0030}

`      buttonPushCounter++;`{#c10.xhtml#c10-line-0330}

`      Serial.println("on");`{#c10.xhtml#c10-line-0331}

`      Serial.print("number of button pushes:  ");`{#c10.xhtml#c10-line-0332}

`      Serial.println(buttonPushCounter);`{#c10.xhtml#c10-line-0333}

`    }`{#c10.xhtml#c10-line-0334}

If the pushbutton went from [`HIGH`]{.Code-within-text} to [`LOW`]{.Code-within-text}, the button state is off, and this change of state is printed on the serial monitor, as shown in [Figure 10-7](#c10.xhtml#c10-fig-0007){#c10.xhtml#rc10-fig-0007}.

::: {#c10.xhtml#c10-fig-0007 .figure}
![9781119489542-fg1007.png](https://i.imgur.com/Jg0M1r1.jpeg){.center}
:::

[]{#c10.xhtml#c10-code-0031}[]{#c10.xhtml#c10-lntxt-0031}

`    else {`{#c10.xhtml#c10-line-0335}

`      // if the current state is LOW then the button`{#c10.xhtml#c10-line-0336}

`      // went from on to off:`{#c10.xhtml#c10-line-0337}

`      Serial.println("off");`{#c10.xhtml#c10-line-0338}

`    }`{#c10.xhtml#c10-line-0339}

`  }`{#c10.xhtml#c10-line-0340}

[]{#c10.xhtml#Page_224 .pagebreak role="doc-pagebreak" title="224"} This piece of code allows you to click a pushbutton rather than hold down on it; the code also leaves plenty of room to add your own functionality.

Because a change has occurred, the current state becomes the last state in preparation for the next loop:

[]{#c10.xhtml#c10-code-0032}[]{#c10.xhtml#c10-lntxt-0032}

`  // save the current state as the last state,`{#c10.xhtml#c10-line-0341}

`  //for next time through the loop`{#c10.xhtml#c10-line-0342}

`  lastButtonState = buttonState;`{#c10.xhtml#c10-line-0343}

At the end of the loop, a check is done to make sure that four button presses have occurred. If the total number of presses divided by four gives a remainder of 0, the LED pin is set to [`HIGH`]{.Code-within-text}; if not the pin is set to [`LOW`]{.Code-within-text} again:

[]{#c10.xhtml#c10-code-0033}[]{#c10.xhtml#c10-lntxt-0033}

`  // turns on the LED every four button pushes by`{#c10.xhtml#c10-line-0344}

`  // checking the modulo of the button push counter.`{#c10.xhtml#c10-line-0345}

`  // the modulo function gives you the remainder of`{#c10.xhtml#c10-line-0346}

`  // the division of two numbers:`{#c10.xhtml#c10-line-0347}

`  if (buttonPushCounter % 4 == 0) {`{#c10.xhtml#c10-line-0348}

`    digitalWrite(ledPin, HIGH);`{#c10.xhtml#c10-line-0349}

`  } else {`{#c10.xhtml#c10-line-0350}

`   digitalWrite(ledPin, LOW);`{#c10.xhtml#c10-line-0351}

`  }`{#c10.xhtml#c10-line-0352}

` `{#c10.xhtml#c10-line-0353}

`}`{#c10.xhtml#c10-line-0354}

![tip.png](https://i.imgur.com/MhE6rLm.jpeg) You may find that the counter in this sketch can occasionally jump up, depending on the type and quality of pushbutton that you\'re using, causing you to quite rightly ask, "Why doesn't this sketch include debouncing?" The sketches in the Arduino examples are designed to help you understand many individual principles []{#c10.xhtml#Page_225 .pagebreak role="doc-pagebreak" title="225"}easily, to equip you for any situation. To include two or more techniques in one sketch may be good for the application, but would make it more difficult for you, the person learning, to understand how each element works.

It is possible to combine numerous examples to reap the benefits of each, but this topic is beyond the scope of this book. If you want to try your hand at including two techniques in a single sketch, open two sketch examples side by side and combine them into one sketch, one line at a time, checking as you go that there are no repetitions of variables or omissions. The Compile shortcut (Ctrl+R or cmd+R) is helpful for this task. Good luck!
:::
:::

::: {.section}
[]{#c10.xhtml#c10-sec-0012}

## Smoothing Your Sensors {#c10.xhtml#h2-4 .Heading-1}

Analog sensors measure light levels or distance to a high degree of accuracy. Sometimes, however, they can be overly sensitive and flinch at the slightest change. If that's what you're looking for, great. If not, you may want to smooth the results to compensate for any erroneous readings. Smoothing is effectively averaging your results so that any of these anomalies don't affect your reading as much. In [Chapter 14](#c14.xhtml) you also learn about showing these results on a bar graph, using Processing, which can be a great help for spotting inconsistencies.

::: {.section}
[]{#c10.xhtml#c10-sec-0013}

### Setting up the Smoothing sketch {#c10.xhtml#h3-7 .Heading-2}

For this example, you try smoothing on a light sensor.

For the Smoothing sketch, you need the following:

-   [An Arduino Uno]{#c10.xhtml#c10-li-0027}
-   [A breadboard]{#c10.xhtml#c10-li-0028}
-   [An LED]{#c10.xhtml#c10-li-0029}
-   [A light sensor]{#c10.xhtml#c10-li-0030}
-   [A 10k ohm resistor]{#c10.xhtml#c10-li-0031}
-   [A 220 ohm resistor]{#c10.xhtml#c10-li-0032}
-   [Jump wires]{#c10.xhtml#c10-li-0033}

Complete the circuit for reading a light-dependent resistor (LDR) as shown in [Figures 10-8](#c10.xhtml#c10-fig-0008){#c10.xhtml#rc10-fig-0008} and [10-9](#c10.xhtml#c10-fig-0009){#c10.xhtml#rc10-fig-0009}.

::: {#c10.xhtml#c10-fig-0008 .figure}
![9781119489542-fg1008.png](https://i.imgur.com/LcyAFbW.jpeg){.center}
:::

::: {#c10.xhtml#c10-fig-0009 .figure}
![9781119489542-fg1009.png](https://i.imgur.com/7NGgbnC.jpeg){.center}
:::

Choose File ⇒   Examples ⇒   03.Analog ⇒   Smoothing to find the sketch and upload it.[]{#c10.xhtml#Page_226 .pagebreak role="doc-pagebreak" title="226"}

[]{#c10.xhtml#Page_227 .pagebreak role="doc-pagebreak" title="227"}![tip.png](https://i.imgur.com/NUznOy2.jpeg) The sketch indicates that a potentiometer works for testing. This is true, but it is more difficult to see the effects of smoothing with a potentiometer because the mechanics of the device already provide a smooth analog input. Light, distance, and movement sensors are far more likely to need smoothing.

[]{#c10.xhtml#c10-code-0034}[]{#c10.xhtml#c10-lntxt-0034}

`/*`{#c10.xhtml#c10-line-0355}

`Smoothing`{#c10.xhtml#c10-line-0356}

``{#c10.xhtml#c10-line-0357} 

`  Reads repeatedly from an analog input, calculating a running average and`{#c10.xhtml#c10-line-0358}

`  printing it to the computer. Keeps ten readings in an array and continually`{#c10.xhtml#c10-line-0359}

`  averages them.`{#c10.xhtml#c10-line-0360}

``{#c10.xhtml#c10-line-0361} 

`  The circuit:`{#c10.xhtml#c10-line-0362}

`  - analog sensor (potentiometer will do) attached to analog input 0`{#c10.xhtml#c10-line-0363}

``{#c10.xhtml#c10-line-0364} 

`  created 22 Apr 2007`{#c10.xhtml#c10-line-0365}

`  by David A. Mellis  <dam@mellis.org>`{#c10.xhtml#c10-line-0366}

`  modified 9 Apr 2012`{#c10.xhtml#c10-line-0367}

`  by Tom Igoe`{#c10.xhtml#c10-line-0368}

``{#c10.xhtml#c10-line-0369} 

`  This example code is in the public domain.`{#c10.xhtml#c10-line-0370}

``{#c10.xhtml#c10-line-0371} 

`  http://www.arduino.cc/en/Tutorial/Smoothing`{#c10.xhtml#c10-line-0372}

`*/`{#c10.xhtml#c10-line-0373}

``{#c10.xhtml#c10-line-0374} 

``{#c10.xhtml#c10-line-0375} 

`// Define the number of samples to keep track of.  The higher the number,`{#c10.xhtml#c10-line-0376}

`// the more the readings will be smoothed, but the slower the output will`{#c10.xhtml#c10-line-0377}

`// respond to the input.  Using a constant rather than a normal variable lets`{#c10.xhtml#c10-line-0378}

`// use this value to determine the size of the readings array.`{#c10.xhtml#c10-line-0379}

`const int numReadings = 10;`{#c10.xhtml#c10-line-0380}

`int readings[numReadings];      // the readings from the analog input`{#c10.xhtml#c10-line-0381}

`int readIndex = 0;              // the index of the current reading`{#c10.xhtml#c10-line-0382}

`int total = 0;                  // the running total`{#c10.xhtml#c10-line-0383}

`int average = 0;                // the average`{#c10.xhtml#c10-line-0384}

``{#c10.xhtml#c10-line-0385} 

`int inputPin = A0;`{#c10.xhtml#c10-line-0386}

``{#c10.xhtml#c10-line-0387} 

`void setup() {`{#c10.xhtml#c10-line-0388}

`  // initialize serial communication with computer:`{#c10.xhtml#c10-line-0389}

`  Serial.begin(9600);`{#c10.xhtml#c10-line-0390}

`  // initialize all the readings to 0:`{#c10.xhtml#c10-line-0391}

`  for (int thisReading = 0; thisReading < numReadings; thisReading++)`{#c10.xhtml#c10-line-0392}

`    readings[thisReading] = 0;`{#c10.xhtml#c10-line-0393}

`}`{#c10.xhtml#c10-line-0394}

``{#c10.xhtml#c10-line-0395} 

`void loop() {`{#c10.xhtml#c10-line-0396}

`  // subtract the last reading:`{#c10.xhtml#c10-line-0397}

`  total= total - readings[index];`{#c10.xhtml#c10-line-0398}

`  // read from the sensor: `{#c10.xhtml#c10-line-0399}

`  readings[index] = analogRead(inputPin);`{#c10.xhtml#c10-line-0400}

`  // add the reading to the total:`{#c10.xhtml#c10-line-0401}

`  total= total + readings[index];`{#c10.xhtml#c10-line-0402}

`  // advance to the next position in the array:`{#c10.xhtml#c10-line-0403}

`  index = index + 1;`{#c10.xhtml#c10-line-0404}

``{#c10.xhtml#c10-line-0405} 

`  // if we're at the end of the array…`{#c10.xhtml#c10-line-0406}

`  if (index >= numReadings)`{#c10.xhtml#c10-line-0407}

`    // …wrap around to the beginning:`{#c10.xhtml#c10-line-0408}

`    index = 0;`{#c10.xhtml#c10-line-0409}

``{#c10.xhtml#c10-line-0410} 

`  // calculate the average:`{#c10.xhtml#c10-line-0411}

`  average = total / numReadings;`{#c10.xhtml#c10-line-0412}

`  // send it to the computer as ASCII digits`{#c10.xhtml#c10-line-0413}

`  Serial.println(average);`{#c10.xhtml#c10-line-0414}

`  delay(1);        // delay in between reads for stability`{#c10.xhtml#c10-line-0415}

`}`{#c10.xhtml#c10-line-0416}

This sketch gives you a nicely smoothed reading based on what the sensor is detecting. The smoothing is achieved by averaging a number of readings. The averaging process may slow the number of readings per second, but because the Arduino is capable of reading these changes far faster than you are, the slowness doesn't affect how the sensor works in any noticeable way.
:::

::: {.section}
[]{#c10.xhtml#c10-sec-0014}

### Understanding the Smoothing sketch {#c10.xhtml#h3-8 .Heading-2}

The start of the Smoothing sketch declares the constants and variables. First is the number of readings to average, declared as [`numReadings`]{.Code-within-text} with a value of 10:

[]{#c10.xhtml#c10-code-0035}[]{#c10.xhtml#c10-lntxt-0035}

`const int numReadings = 10;`{#c10.xhtml#c10-line-0417}

The next four variables keep track of how many readings have been stored and average them. These sensor readings are added to an array (or list), which is defined here as [`readings`]{.Code-within-text}. The number of items in the [`readings`]{.Code-within-text} array is defined in the square brackets. Because [`numReadings`]{.Code-within-text} has already been declared, it can be used to set the array length to 10 (which is numbered, or indexed, from 0 to 9):

[]{#c10.xhtml#c10-code-0036}[]{#c10.xhtml#c10-lntxt-0036}

`int readings[numReadings];      // the readings from the analog input`{#c10.xhtml#c10-line-0418}

*Index* is the common term for the current value and is used to keep track of how many loops or readings are taken. Because the index increases every time a []{#c10.xhtml#Page_229 .pagebreak role="doc-pagebreak" title="229"}reading is taken, it can be used to store the results of that reading in the correct place in your array, before increasing to store the next reading in the next position in the array:

[]{#c10.xhtml#c10-code-0037}[]{#c10.xhtml#c10-lntxt-0037}

`int readIndex = 0;                  // the index of the current reading`{#c10.xhtml#c10-line-0419}

The [`total`]{.Code-within-text} variable provides a running total that is added to as readings are made. When the total is processed, the average value is stored in the [`average`]{.Code-within-text} variable:

[]{#c10.xhtml#c10-code-0038}[]{#c10.xhtml#c10-lntxt-0038}

`int total = 0;                  // the running total`{#c10.xhtml#c10-line-0420}

`int average = 0;                // the average`{#c10.xhtml#c10-line-0421}

The last variable is [`inputPin`]{.Code-within-text}, the analog in pin that is being read:

[]{#c10.xhtml#c10-code-0039}[]{#c10.xhtml#c10-lntxt-0039}

`int inputPin = A0;`{#c10.xhtml#c10-line-0422}

In the [`setup`]{.Code-within-text} function, the serial port is initialized to allow you to view the readings from the light sensor:

[]{#c10.xhtml#c10-code-0040}[]{#c10.xhtml#c10-lntxt-0040}

`void setup()`{#c10.xhtml#c10-line-0423}

`{`{#c10.xhtml#c10-line-0424}

`  // initialize serial communication with computer:`{#c10.xhtml#c10-line-0425}

`  Serial.begin(9600);`{#c10.xhtml#c10-line-0426}

Next in the code is a [`for`]{.Code-within-text} loop, which is used to effectively reset the array. In the loop, [`thisReading`]{.Code-within-text}, a new local variable, is initialized and made equal to zero. The [`thisReading`]{.Code-within-text} variable is then compared to the length of the array. If it\'s less than the length of the array, the current reading of the value in that part of the array is made equal to zero:

[]{#c10.xhtml#c10-code-0041}[]{#c10.xhtml#c10-lntxt-0041}

`// initialize all the readings to 0:`{#c10.xhtml#c10-line-0427}

`  for (int thisReading = 0; thisReading < numReadings; thisReading++)`{#c10.xhtml#c10-line-0428}

`    readings[thisReading] = 0;`{#c10.xhtml#c10-line-0429}

`}`{#c10.xhtml#c10-line-0430}

In layman's terms, the code reads like this: "Make a variable equal to 0, and if that variable is less than 10, make that same value in the array equal to 0; then increase the variable by 1." As you can see, the code works through all the numbers (0 to 9) and sets that same position in the array to a 0 value. After it reaches 10, the [`for`]{.Code-within-text} loop ceases running and the code moves on to the main loop.

![tip.png](https://i.imgur.com/PmqErKz.jpeg) This type of automation is great for setting arrays. The alternative is to write all the numbers in the array as individual integer variables, which is a lot less efficient, both for you and the Arduino.

[]{#c10.xhtml#Page_230 .pagebreak role="doc-pagebreak" title="230"}The first line of code in the main loop subtracts any reading in the current index of the array from the total. That value is replaced in this loop, so it is essential to remove it from the total first:

[]{#c10.xhtml#c10-code-0042}[]{#c10.xhtml#c10-lntxt-0042}

`void loop() {`{#c10.xhtml#c10-line-0431}

`  // subtract the last reading:`{#c10.xhtml#c10-line-0432}

`  total= total - readings[index];`{#c10.xhtml#c10-line-0433}

The next line obtains a new reading using [`analogRead`]{.Code-within-text}, which is stored in the current index of the array, overwriting the previous value:

[]{#c10.xhtml#c10-code-0043}[]{#c10.xhtml#c10-lntxt-0043}

`  // read from the sensor: `{#c10.xhtml#c10-line-0434}

`  readings[index] = analogRead(inputPin);`{#c10.xhtml#c10-line-0435}

This reading is then added to the total to correct it:

[]{#c10.xhtml#c10-code-0044}[]{#c10.xhtml#c10-lntxt-0044}

`  // add the reading to the total:`{#c10.xhtml#c10-line-0436}

`  total= total + readings[index];`{#c10.xhtml#c10-line-0437}

`  // advance to the next position in the array: `{#c10.xhtml#c10-line-0438}

`  index = index + 1;`{#c10.xhtml#c10-line-0439}

It\'s important to check when the end of the array is reached so that the program doesn't loop forever without telling you your results. You can do this check with a simple [`if`]{.Code-within-text} statement: If the index value is greater than or equal to the number of readings that the sketch is looking for, set [`index`]{.Code-within-text} back to 0. This [`if`]{.Code-within-text} statement counts the index value from 0 to 9, as in [`setup`]{.Code-within-text}, and then resets as soon as it reaches 10:

[]{#c10.xhtml#c10-code-0045}[]{#c10.xhtml#c10-lntxt-0045}

`// if we're at the end of the array…`{#c10.xhtml#c10-line-0440}

`  if (index >= numReadings)`{#c10.xhtml#c10-line-0441}

`    // …wrap around to the beginning:`{#c10.xhtml#c10-line-0442}

`    index = 0;`{#c10.xhtml#c10-line-0443}

To get the average from all the data in the array, the total is simply divided by the number of readings. The average is then displayed on the serial monitor for you to check. Because of the command used to display the message, this action could also be referred to as "printing to the serial port." A 1-millisecond delay at the end slows the program considerably as well as helps to prevent erratic readings:

[]{#c10.xhtml#c10-code-0046}[]{#c10.xhtml#c10-lntxt-0046}

`  // calculate the average:`{#c10.xhtml#c10-line-0444}

`  average = total / numReadings;`{#c10.xhtml#c10-line-0445}

`  // send it to the computer as ASCII digits`{#c10.xhtml#c10-line-0446}

`  Serial.println(average);`{#c10.xhtml#c10-line-0447}

`  delay(1);        // delay in between reads for stability`{#c10.xhtml#c10-line-0448}

`}`{#c10.xhtml#c10-line-0449}

Using simple procedures like this to average your results helps control unpredictable behavior in your projects. Averaging is especially useful if the sensor readings are directly linked to your output.
:::
:::

::: {.section}
[]{#c10.xhtml#c10-sec-0015}

## Calibrating Your Inputs {#c10.xhtml#h2-5 .Heading-1}

Think of calibrating your circuit as setting the thermostat in your home. Your furnace or boiler is capable of a range of temperatures, but depending on where you are in the world, different temperatures are appropriate. If you\'re in a mild climate, you may have the heating on only infrequently for a few months, but if you're in a cold climate, you may have the heating on every night for most of the year.

By calibrating the sensors on your Arduino project, you can tailor the sensor to its location. In this example, you learn how to calibrate a light sensor. Light, of course, is highly variable, whether you're inside, outside, in a well-lit room, or working by candlelight. Despite the huge variation, all these ranges of light can be sensed and interpreted by your Arduino as long as it knows the range. The following sketch shows you how to calibrate a light sensor to its surroundings.

::: {.section}
[]{#c10.xhtml#c10-sec-0016}

### Setting up the Calibration sketch {#c10.xhtml#h3-9 .Heading-2}

To try the Calibration example, complete the circuit shown in [Figures 10-10](#c10.xhtml#c10-fig-0010){#c10.xhtml#rc10-fig-0010} and [10-11](#c10.xhtml#c10-fig-0011){#c10.xhtml#rc10-fig-0011} to calibrate your light sensor automatically.

::: {#c10.xhtml#c10-fig-0010 .figure}
![9781119489542-fg1010.png](https://i.imgur.com/WkejzcE.jpeg){.center}
:::

::: {#c10.xhtml#c10-fig-0011 .figure}
![9781119489542-fg1011.png](https://i.imgur.com/Zw7BNw5.jpeg){.center}
:::

You need:

-   [An Arduino Uno]{#c10.xhtml#c10-li-0034}
-   [A breadboard]{#c10.xhtml#c10-li-0035}
-   [An LED]{#c10.xhtml#c10-li-0036}
-   [A light sensor]{#c10.xhtml#c10-li-0037}
-   [A 10k ohm resistor]{#c10.xhtml#c10-li-0038}
-   [A 220 ohm resistor]{#c10.xhtml#c10-li-0039}
-   [Jump wires[]{#c10.xhtml#Page_232 .pagebreak role="doc-pagebreak" title="232"}]{#c10.xhtml#c10-li-0040}

[]{#c10.xhtml#Page_233 .pagebreak role="doc-pagebreak" title="233"}Build the circuit and go to File ⇒   Examples ⇒   03.Analog ⇒   Calibration to find the sketch. The code for this example is as follows:

[]{#c10.xhtml#c10-code-0047}[]{#c10.xhtml#c10-lntxt-0047}

`/*`{#c10.xhtml#c10-line-0450}

`Calibration`{#c10.xhtml#c10-line-0451}

``{#c10.xhtml#c10-line-0452} 

`Demonstrates one technique for calibrating sensor input. The sensor readings`{#c10.xhtml#c10-line-0453}

`during the first five seconds of the sketch execution define the minimum and`{#c10.xhtml#c10-line-0454}

`maximum of expected values attached to the sensor pin.`{#c10.xhtml#c10-line-0455}

``{#c10.xhtml#c10-line-0456} 

`The sensor minimum and maximum initial values may seem backwards. Initially,`{#c10.xhtml#c10-line-0457}

`you set the minimum high and listen for anything lower, saving it as the new`{#c10.xhtml#c10-line-0458}

`minimum. Likewise, you set the maximum low and listen for anything higher as`{#c10.xhtml#c10-line-0459}

`the new maximum.`{#c10.xhtml#c10-line-0460}

``{#c10.xhtml#c10-line-0461} 

`The circuit:`{#c10.xhtml#c10-line-0462}

`- analog sensor (potentiometer will do) attached to analog input 0`{#c10.xhtml#c10-line-0463}

`- LED attached from digital pin 9 to ground`{#c10.xhtml#c10-line-0464}

``{#c10.xhtml#c10-line-0465} 

`created 29 Oct 2008`{#c10.xhtml#c10-line-0466}

`by David A Mellis`{#c10.xhtml#c10-line-0467}

`modified 30 Aug 2011`{#c10.xhtml#c10-line-0468}

`by Tom Igoe`{#c10.xhtml#c10-line-0469}

``{#c10.xhtml#c10-line-0470} 

`This example code is in the public domain.`{#c10.xhtml#c10-line-0471}

``{#c10.xhtml#c10-line-0472} 

`http://www.arduino.cc/en/Tutorial/Calibration`{#c10.xhtml#c10-line-0473}`</span>`{=html}`</a>`{=html}`</code>`{=html}

` */`{#c10.xhtml#c10-line-0474}

``{#c10.xhtml#c10-line-0475} 

`// These constants won't change:`{#c10.xhtml#c10-line-0476}

`const int sensorPin = A0;    // pin that the sensor is attached to`{#c10.xhtml#c10-line-0477}

`const int ledPin = 9;        // pin that the LED is attached to`{#c10.xhtml#c10-line-0478}

``{#c10.xhtml#c10-line-0479} 

`// variables:`{#c10.xhtml#c10-line-0480}

`int sensorValue = 0;         // the sensor value`{#c10.xhtml#c10-line-0481}

`int sensorMin = 1023;        // minimum sensor value`{#c10.xhtml#c10-line-0482}

`int sensorMax = 0;           // maximum sensor value`{#c10.xhtml#c10-line-0483}

``{#c10.xhtml#c10-line-0484} 

``{#c10.xhtml#c10-line-0485} 

`void setup() {`{#c10.xhtml#c10-line-0486}

`  // turn on LED to signal the start of the calibration period:`{#c10.xhtml#c10-line-0487}

`  pinMode(13, OUTPUT);`{#c10.xhtml#c10-line-0488}

`  digitalWrite(13, HIGH);`{#c10.xhtml#c10-line-0489}

``{#c10.xhtml#c10-line-0490} 

`  // calibrate during the first five seconds`{#c10.xhtml#c10-line-0491}

`  while (millis() < 5000) {`{#c10.xhtml#c10-line-0492}

`    sensorValue = analogRead(sensorPin);`{#c10.xhtml#c10-line-0493}

``{#c10.xhtml#c10-line-0494} 

`    // record the maximum sensor value`{#c10.xhtml#c10-line-0495}

`    if (sensorValue > sensorMax) {`{#c10.xhtml#c10-line-0496}

`      sensorMax = sensorValue;`{#c10.xhtml#c10-line-0497}

`    }`{#c10.xhtml#c10-line-0498}

``{#c10.xhtml#c10-line-0499} 

`    // record the minimum sensor value`{#c10.xhtml#c10-line-0500}

`    if (sensorValue < sensorMin) {`{#c10.xhtml#c10-line-0501}

`      sensorMin = sensorValue;`{#c10.xhtml#c10-line-0502}

`    }`{#c10.xhtml#c10-line-0503}

`  }`{#c10.xhtml#c10-line-0504}

``{#c10.xhtml#c10-line-0505} 

`  // signal the end of the calibration period`{#c10.xhtml#c10-line-0506}

`  digitalWrite(13, LOW);`{#c10.xhtml#c10-line-0507}

`}`{#c10.xhtml#c10-line-0508}

``{#c10.xhtml#c10-line-0509} 

`void loop() {`{#c10.xhtml#c10-line-0510}

`  // read the sensor:`{#c10.xhtml#c10-line-0511}

`  sensorValue = analogRead(sensorPin);`{#c10.xhtml#c10-line-0512}

``{#c10.xhtml#c10-line-0513} 

`  // apply the calibration to the sensor reading`{#c10.xhtml#c10-line-0514}

`  sensorValue = map(sensorValue, sensorMin, sensorMax, 0, 255);`{#c10.xhtml#c10-line-0515}

``{#c10.xhtml#c10-line-0516} 

`  // in case the sensor value is outside the range seen during calibration`{#c10.xhtml#c10-line-0517}

`  sensorValue = constrain(sensorValue, 0, 255);`{#c10.xhtml#c10-line-0518}

``{#c10.xhtml#c10-line-0519} 

`  // fade the LED using the calibrated value:`{#c10.xhtml#c10-line-0520}

`  analogWrite(ledPin, sensorValue);`{#c10.xhtml#c10-line-0521}

`}`{#c10.xhtml#c10-line-0522}

Upload the sketch, and let your Arduino settle with your normal ambient light levels for five seconds. Then try moving your hand over the light sensor. You should find it a lot more responsive than it is when it's just reading the analog value normally, and the LED should have a range from fully on when the light sensor is uncovered to fully off when the light sensor is covered.
:::

::: {.section}
[]{#c10.xhtml#c10-sec-0017}

### Understanding the Calibration sketch {#c10.xhtml#h3-10 .Heading-2}

The first part of the Calibration sketch lays out all the constants and variables. The constants are the pins for the light sensor and the LED. Note that the LED should fade up and down, so it must use a PWM pin: []{#c10.xhtml#Page_235 .pagebreak role="doc-pagebreak" title="235"}

[]{#c10.xhtml#c10-code-0048}[]{#c10.xhtml#c10-lntxt-0048}

`// These constants won't change:`{#c10.xhtml#c10-line-0523}

`const int sensorPin = A0;    // pin that the sensor is attached to`{#c10.xhtml#c10-line-0524}

`const int ledPin = 9;        // pin that the LED is attached to`{#c10.xhtml#c10-line-0525}

The variables are used for the current sensor value and the minimum and maximum values of the sensor. You can see that [`sensorMin`]{.Code-within-text} is initially set to a high value and [`sensorMax`]{.Code-within-text} is set to a low one because they must work down and up, respectively, to set the minimum and maximum values:

[]{#c10.xhtml#c10-code-0049}[]{#c10.xhtml#c10-lntxt-0049}

`// variables:`{#c10.xhtml#c10-line-0526}

`int sensorValue = 0;         // the sensor value`{#c10.xhtml#c10-line-0527}

`int sensorMin = 1023;        // minimum sensor value`{#c10.xhtml#c10-line-0528}

`int sensorMax = 0;           // maximum sensor value`{#c10.xhtml#c10-line-0529}

In [`setup`]{.Code-within-text}, quite a bit is going on. First, the usual [`pinMode`]{.Code-within-text} sets pin 13 as an [`OUTPUT`]{.Code-within-text}. Next is a [`digitalWrite`]{.Code-within-text} to pin 13 to set it [`HIGH`]{.Code-within-text}, which signals that the sensor is in its calibration phase:

[]{#c10.xhtml#c10-code-0050}[]{#c10.xhtml#c10-lntxt-0050}

`void setup() {`{#c10.xhtml#c10-line-0530}

`  // turn on LED to signal the start of the calibration period:`{#c10.xhtml#c10-line-0531}

`  pinMode(13, OUTPUT);`{#c10.xhtml#c10-line-0532}

`  digitalWrite(13, HIGH);`{#c10.xhtml#c10-line-0533}

For the first 5 seconds the sensor will calibrate. Because [`millis()`]{.Code-within-text} starts counting the (milli)second that the program starts, the easiest way to count for 5 seconds is to use a [`while`]{.Code-within-text} loop. The following code continues to check the value of [`millis()`]{.Code-within-text}. As long as this value is less than 5000 (5 seconds), it carries out the code inside the curly brackets:

[]{#c10.xhtml#c10-code-0051}[]{#c10.xhtml#c10-lntxt-0051}

`// calibrate during the first five seconds`{#c10.xhtml#c10-line-0534}

`  while (millis() < 5000) {`{#c10.xhtml#c10-line-0535}

The brackets contain the calibration code. [`sensorValue`]{.Code-within-text} stores the current sensor reading. If this reading is more than the maximum or less than the minimum (or both), the values are updated. Because this happens during five seconds, you get a number of readings, and they all help to better define the expected range:

[]{#c10.xhtml#c10-code-0052}[]{#c10.xhtml#c10-lntxt-0052}

`sensorValue = analogRead(sensorPin);`{#c10.xhtml#c10-line-0536}

``{#c10.xhtml#c10-line-0537} 

`    // record the maximum sensor value`{#c10.xhtml#c10-line-0538}

`    if (sensorValue > sensorMax) {`{#c10.xhtml#c10-line-0539}

`      sensorMax = sensorValue;`{#c10.xhtml#c10-line-0540}

`    }`{#c10.xhtml#c10-line-0541}

``{#c10.xhtml#c10-line-0542} 

`    // record the minimum sensor value`{#c10.xhtml#c10-line-0543}

`    if (sensorValue < sensorMin) {`{#c10.xhtml#c10-line-0544}

`      sensorMin = sensorValue;`{#c10.xhtml#c10-line-0545}

`    }`{#c10.xhtml#c10-line-0546}

`  }`{#c10.xhtml#c10-line-0547}

The LED pin is then written [`LOW`]{.Code-within-text} to indicate that the calibration phase is over:

[]{#c10.xhtml#c10-code-0053}[]{#c10.xhtml#c10-lntxt-0053}

`  // signal the end of the calibration period`{#c10.xhtml#c10-line-0548}

`  digitalWrite(13, LOW);`{#c10.xhtml#c10-line-0549}

`}`{#c10.xhtml#c10-line-0550}

Now that the range is known, it just needs to be applied to the output LED. A reading is taken from [`sensorPin`]{.Code-within-text}. Because the reading is in the range 0 to 1023, it must be mapped to the LED\'s range of 0 to 255. [`sensorValue`]{.Code-within-text} is converted to this new range by using the [`map()`]{.Code-within-text} function, which uses the [`sensorMin`]{.Code-within-text} and [`sensorMax`]{.Code-within-text} values from the calibration to specify the current range rather than using the full range of 0 to 1023:

[]{#c10.xhtml#c10-code-0054}[]{#c10.xhtml#c10-lntxt-0054}

`void loop() {`{#c10.xhtml#c10-line-0551}

`  // read the sensor:`{#c10.xhtml#c10-line-0552}

`  sensorValue = analogRead(sensorPin);`{#c10.xhtml#c10-line-0553}

``{#c10.xhtml#c10-line-0554} 

`  // apply the calibration to the sensor reading`{#c10.xhtml#c10-line-0555}

`  sensorValue = map(sensorValue, sensorMin, sensorMax, 0, 255);`{#c10.xhtml#c10-line-0556}

It is still possible for the sensor to read values outside those of the calibration, so [`sensorValue`]{.Code-within-text} must be restricted by using the [`constrain ()`]{.Code-within-text} function. Any values outside 0 to 255 are ignored. The calibration gives a good idea of the range of values, so any larger or smaller values are likely to be anomalies:

[]{#c10.xhtml#c10-code-0055}[]{#c10.xhtml#c10-lntxt-0055}

`  // in case the sensor value is outside the range seen during calibration`{#c10.xhtml#c10-line-0557}

`  sensorValue = constrain(sensorValue, 0, 255);`{#c10.xhtml#c10-line-0558}

All that is left to do is to update the LED with the mapped and constrained value by using the [`analogWrite`]{.Code-within-text} function on [`ledPin`]{.Code-within-text}:

[]{#c10.xhtml#c10-code-0056}[]{#c10.xhtml#c10-lntxt-0056}

`// fade the LED using the calibrated value:`{#c10.xhtml#c10-line-0559}

`  analogWrite(ledPin, sensorValue);`{#c10.xhtml#c10-line-0560}

`}`{#c10.xhtml#c10-line-0561}

This code should give you a better representation of your sensor's changing values relative to your environment. The calibration runs only once when the program is started, so if the range still seems off, it's best to restart it or calibrate over a longer period. Calibration is designed to remove *noise* --- erratic variations in the readings --- so you should also make sure that the environment being measured doesn\'t have anything in it that you don't want to measure.
:::
:::

[]{#c11.xhtml}

[]{#c11.xhtml#Page_237 .pagebreak role="doc-pagebreak" title="237"}Chapter 11

# Common Sense with Common Sensors {#c11.xhtml#a1 .Chap-Title}

::: {.section}
[]{#c11.xhtml#c11-sec-0001}[]{#c11.xhtml#c11-feafxd-0001}

IN THIS CHAPTER

![check.png](https://i.imgur.com/5hJskPx.jpeg) **Learning about sensors**

![check.png](https://i.imgur.com/LGas4V8.jpeg) **Understanding the complexities of different inputs**

![check.png](https://i.imgur.com/FtAKZju.jpeg) **Paying the right amount**

![check.png](https://i.imgur.com/R3mmQaE.jpeg) **Knowing where to use sensors**

![check.png](https://i.imgur.com/njdzCYd.jpeg) **Wiring some examples**

In my experience of teaching, I often find that when people first have an idea, they get caught up in how to carry it out using a specific piece of hardware they've found instead of focusing on what they want to achieve. If Arduino is a toolbox with the potential of solving numerous problems, using the right tool for the right job is key.

If you go to any Arduino-related site, you're likely to see a list of sensors, and finding the right ones for your project can be a baffling. A common next step is to search the web for projects similar to the one you want to do to see what other people have built. Their efforts and successes can be a great source of inspiration and knowledge, but they can also plunge you into a black hole of too many possible solutions as well as solutions that are overkill for your needs.

In this chapter, you discover not only more about different sensors and how to use them but also --- and more important --- *why* to use them.

Note that all prices are approximate for buying an individual sensor to give you a rough idea of the cost. If you buy in bulk or do some thorough shopping around, you should be able to make considerable savings. And to find some places to start shopping, read [Chapter 16](#c16.xhtml).
:::

::: {.section}
[]{#c11.xhtml#Page_238 .pagebreak role="doc-pagebreak" title="238"}[]{#c11.xhtml#c11-sec-0002}

## Making Buttons Easier {#c11.xhtml#h2-1 .Heading-1}

The first sensor described in this book (in [Chapter 6](#c06.xhtml)), and arguably the best, is the pushbutton. Many kinds of pushbuttons are available. Note that switches are also included in this category. Generally, switches stick in their position in the same way that a light switch does, whereas buttons pop back. Some exceptions to this general rule are microswitches and toggle buttons. They are essentially the same electrically, and only differ mechanically.

If you plan to use a button for your project, run through the following considerations:

-   ::: {#c11.xhtml#c11-li-0006}
    **Complexity:** In its simplest form, a pushbutton can be two metal contacts that are pushed together. At its most complex, it can be a set of carefully engineered contacts in an enclosed pushbutton. Pushbuttons tend to be mounted in enclosures designed for different uses. A pushbutton like the one in your kit is perfect for breadboard layouts and suited to prototyping. If it were used in the real world, it would need protecting. Take apart an old game console controller and you may well find an enclosed pushbutton inside. If you need a more industrial button, such as an emergency stop button, the switch may be larger and more robust, and may even contain a bigger spring to handle the force of someone hitting or kicking it.

    ![tip.png](https://i.imgur.com/ogzjZGY.jpeg) The great thing about pushbuttons is that they never get complicated. However, the right spring or click to a button can make all the difference in the quality of your project, so choose wisely.
    :::

-   [**Cost:** The cost of a pushbutton varies greatly depending on the quality of the enclosure and the materials used. The prices for RS Components range from 10 cents for a microswitch to around \$150 for an industrial stop button in an enclosure. It's possible to use cheaper buttons for most applications.]{#c11.xhtml#c11-li-0007}

-   ::: {#c11.xhtml#c11-li-0008}
    **Location:** You can use buttons to detect presses from intentional human contact (or even unintentional, if you are clever with how you house the buttons). Museum exhibits are a great example of using buttons to register intentional human contact. People "get" how to use buttons. They're everywhere, and people use them every day without thinking. Sometimes it may seem clever to use subtler methods, but if in doubt, a button is always a safe option.

    Also consider how you might apply the use of a button to what's already in place. For example, maybe you're monitoring how often a door is opened in your house. If you put a highly sensitive microswitch against the door when it's closed, that switch tells you every time the door moves away from it.
    :::

[]{#c11.xhtml#Page_239 .pagebreak role="doc-pagebreak" title="239"}In [Chapters 6](#c06.xhtml) and [10](#c10.xhtml), you learn how to wire a button circuit and how to refine it, respectively. In the example in the following section, you learn how to simplify the hardware of your button. By using a hidden feature of your Arduino, you can use a button with no additional hardware.

::: {.section}
[]{#c11.xhtml#c11-sec-0003}

### Implementing the DigitalInputPullup sketch {#c11.xhtml#h3-1 .Heading-2}

The basic button circuit is a simple one, but it can be made simpler still by using a little-known function on your microcontroller. On the basic button example in [Chapter 6](#c06.xhtml), a *pull-down* resistor is connected to ground to make the button pin read [`LOW`]{.Code-within-text}. Whenever pressed, the button is connects to 5V and goes [`HIGH`]{.Code-within-text}. This behavior allows you to read the button\'s state as an input.

In the microcontroller, an internal *pull-up* resistor can be activated to give you a constant [`HIGH`]{.Code-within-text} value. When a button connected to ground is pressed, it grounds the current and sets the pin to [`LOW`]{.Code-within-text}. This design gives you the same functionality as the basic example from [Chapter 6](#c06.xhtml), but the logic is inverted: [`HIGH`]{.Code-within-text} is an open switch, and [`LOW`]{.Code-within-text} is a closed switch. The wiring is, therefore, simpler because you eliminate the need for an extra wire and resistor.

To complete this example, you need the following:

-   [An Arduino Uno]{#c11.xhtml#c11-li-0009}
-   [A breadboard]{#c11.xhtml#c11-li-0010}
-   [A pushbutton]{#c11.xhtml#c11-li-0011}
-   [An LED (optional)]{#c11.xhtml#c11-li-0012}
-   [Jump wires]{#c11.xhtml#c11-li-0013}

Complete the circuit shown in [Figures 11-1](#c11.xhtml#c11-fig-0001){#c11.xhtml#rc11-fig-0001} and [11-2](#c11.xhtml#c11-fig-0002){#c11.xhtml#rc11-fig-0002} to try the new, simpler pushbutton using the DigitalInputPullup sketch.

::: {#c11.xhtml#c11-fig-0001 .figure}
![9781119489542-fg1101.png](https://i.imgur.com/btsqpmy.jpeg){.center}
:::

::: {#c11.xhtml#c11-fig-0002 .figure}
![9781119489542-fg1102.png](https://i.imgur.com/JsqoiQt.jpeg){.center}
:::

![remember.png](https://i.imgur.com/XpCnpm6.jpeg) An LED on the board is already linked to pin 13, but if you want to accentuate the output, you can insert an LED straight into pin 13 and its neighboring GND pin.[]{#c11.xhtml#Page_240 .pagebreak role="doc-pagebreak" title="240"}

[]{#c11.xhtml#Page_241 .pagebreak role="doc-pagebreak" title="241"}Complete the circuit and choose File ⇒   Examples ⇒   02.Digital ⇒    DigitalInputPullup to find the DigitalInputPullup sketch.

[]{#c11.xhtml#c11-code-0001}[]{#c11.xhtml#c11-lntxt-0001}

`/*`{#c11.xhtml#c11-line-0001}

` `{#c11.xhtml#c11-line-0002}

`Input Pull-up Serial`{#c11.xhtml#c11-line-0003}

` `{#c11.xhtml#c11-line-0004}

`This example demonstrates the use of pinMode(INPUT_PULLUP). It reads a`{#c11.xhtml#c11-line-0005}

`Digital input on pin 2 and prints the results to the Serial Monitor.`{#c11.xhtml#c11-line-0006}

` `{#c11.xhtml#c11-line-0007}

`The circuit:`{#c11.xhtml#c11-line-0008}

`- momentary switch attached from pin 2 to ground`{#c11.xhtml#c11-line-0009}

`- built-in LED on pin 13`{#c11.xhtml#c11-line-0010}

` `{#c11.xhtml#c11-line-0011}

`Unlike pinMode(INPUT), there is no pull-down resistor necessary. An internal`{#c11.xhtml#c11-line-0012}

`20K-ohm resistor is pulled to 5V. This configuration causes the input to`{#c11.xhtml#c11-line-0013}

`read HIGH when the switch is open, and LOW when it is closed.`{#c11.xhtml#c11-line-0014}

` `{#c11.xhtml#c11-line-0015}

`created 14 Mar 2012`{#c11.xhtml#c11-line-0016}

`by Scott Fitzgerald`{#c11.xhtml#c11-line-0017}

` `{#c11.xhtml#c11-line-0018}

`This example code is in the public domain.`{#c11.xhtml#c11-line-0019}

` `{#c11.xhtml#c11-line-0020}

`http://www.arduino.cc/en/Tutorial/InputPullupSerial`{#c11.xhtml#c11-line-0021}

`*/`{#c11.xhtml#c11-line-0022}

` `{#c11.xhtml#c11-line-0023}

`void setup(){`{#c11.xhtml#c11-line-0024}

`  //start serial connection`{#c11.xhtml#c11-line-0025}

`  Serial.begin(9600);`{#c11.xhtml#c11-line-0026}

`  //configure pin2 as an input and enable the internal pull-up resistor`{#c11.xhtml#c11-line-0027}

`  pinMode(2, INPUT_PULLUP);`{#c11.xhtml#c11-line-0028}

`  pinMode(13, OUTPUT);`{#c11.xhtml#c11-line-0029}

` `{#c11.xhtml#c11-line-0030}

`}`{#c11.xhtml#c11-line-0031}

` `{#c11.xhtml#c11-line-0032}

`void loop(){`{#c11.xhtml#c11-line-0033}

`  //read the pushbutton value into a variable`{#c11.xhtml#c11-line-0034}

`  int sensorVal = digitalRead(2);`{#c11.xhtml#c11-line-0035}

`  //print out the value of the pushbutton`{#c11.xhtml#c11-line-0036}

`  Serial.println(sensorVal);`{#c11.xhtml#c11-line-0037}

` `{#c11.xhtml#c11-line-0038}

`  // Keep in mind the pullup means the pushbutton's`{#c11.xhtml#c11-line-0039}

`  // logic is inverted. It goes HIGH when it's open,`{#c11.xhtml#c11-line-0040}

`  // and LOW when it's pressed. Turn on pin 13 when the`{#c11.xhtml#c11-line-0041}

`  // button's pressed, and off when it's not:`{#c11.xhtml#c11-line-0042}

`  if (sensorVal == HIGH) {`{#c11.xhtml#c11-line-0043}

`    digitalWrite(13, LOW);`{#c11.xhtml#c11-line-0044}

`  }`{#c11.xhtml#c11-line-0045}

`  else {`{#c11.xhtml#c11-line-0046}

`    digitalWrite(13, HIGH);`{#c11.xhtml#c11-line-0047}

`  }`{#c11.xhtml#c11-line-0048}

`}`{#c11.xhtml#c11-line-0049}
:::

::: {.section}
[]{#c11.xhtml#c11-sec-0004}

### Understanding the DigitalInputPullup sketch {#c11.xhtml#h3-2 .Heading-2}

The DigitalInputPullup sketch is similar to the standard button sketch but with a few changes. In [`setup`]{.Code-within-text}, serial communication is started to monitor the state of the button. Next, the [`pinMode`]{.Code-within-text} of the inputs and outputs is set. Pin 2 is your button pin, but instead of setting it to [`INPUT`]{.Code-within-text}, you use [`INPUT`]{.Code-within-text}[[`_`]{.Code-within-text}]{style="text-decoration:underline"}[`PULLUP`]{.Code-within-text}. Doing so activates the internal pull-up resistor. Pin 13 is set to be an output as an LED control pin:

[]{#c11.xhtml#c11-code-0002}[]{#c11.xhtml#c11-lntxt-0002}

`void setup(){`{#c11.xhtml#c11-line-0050}

`  //start serial connection`{#c11.xhtml#c11-line-0051}

`  Serial.begin(9600);`{#c11.xhtml#c11-line-0052}

`  //configure pin2 as an input and enable the internal pull-up resistor`{#c11.xhtml#c11-line-0053}

`  pinMode(2, INPUT_PULLUP);`{#c11.xhtml#c11-line-0054}

`  pinMode(13, OUTPUT);`{#c11.xhtml#c11-line-0055}

` `{#c11.xhtml#c11-line-0056}

`}`{#c11.xhtml#c11-line-0057}

In the main loop, you read the value of the pull-up pin and store it in the [`sensorVal`]{.Code-within-text} variable. You then print the variable to the serial monitor to show you what value is being read:

[]{#c11.xhtml#c11-code-0003}[]{#c11.xhtml#c11-lntxt-0003}

`void loop(){`{#c11.xhtml#c11-line-0058}

`  //read the pushbutton value into a variable`{#c11.xhtml#c11-line-0059}

`  int sensorVal = digitalRead(2);`{#c11.xhtml#c11-line-0060}

`  //print out the value of the pushbutton`{#c11.xhtml#c11-line-0061}

`  Serial.println(sensorVal);`{#c11.xhtml#c11-line-0062}

But because the logic is inverted, you need to invert your [`if ()`]{.Code-within-text} statement to make it correct. A [`HIGH`]{.Code-within-text} value is open and a [`LOW`]{.Code-within-text} value is closed. Inside the [`if ()`]{.Code-within-text} statement, you can write any actions to perform. In this case, the LED is being turned off, or set [`LOW`]{.Code-within-text}, whenever the button pin is open, or pulled [`HIGH`]{.Code-within-text}: []{#c11.xhtml#Page_243 .pagebreak role="doc-pagebreak" title="243"}

[]{#c11.xhtml#c11-code-0004}[]{#c11.xhtml#c11-lntxt-0004}

`  // Keep in mind the pullup means the pushbutton's`{#c11.xhtml#c11-line-0063}

`  // logic is inverted. It goes HIGH when it's open,`{#c11.xhtml#c11-line-0064}

`  // and LOW when it's pressed. Turn on pin 13 when the`{#c11.xhtml#c11-line-0065}

`  // button's pressed, and off when it's not:`{#c11.xhtml#c11-line-0066}

`  if (sensorVal == HIGH) {`{#c11.xhtml#c11-line-0067}

`    digitalWrite(13, LOW);`{#c11.xhtml#c11-line-0068}

`  }`{#c11.xhtml#c11-line-0069}

`  else {`{#c11.xhtml#c11-line-0070}

`    digitalWrite(13, HIGH);`{#c11.xhtml#c11-line-0071}

`  }`{#c11.xhtml#c11-line-0072}

`}`{#c11.xhtml#c11-line-0073}

This method is great when you don\'t have enough spare components, because it allows you to make a switch with only a couple of wires, if necessary. This functionality can be used on any digital pin, but only for inputs.
:::
:::

::: {.section}
[]{#c11.xhtml#c11-sec-0005}

## Exploring Piezo Sensors {#c11.xhtml#h2-2 .Heading-1}

In [Chapter 7](#c07.xhtml), you learn how to make sound using a piezo buzzer, but you should know that you have another way to use the same hardware as an input rather than as an output. To make a sound with a piezo, you put a current through it and it vibrates, so it follows that if you vibrate the same piezo, you generate a small amount of electrical current. Using a piezo in this way allows you to create a *knock sensor* and is used to measure vibrations on the surface to which it is fixed.

Piezos vary in size, and that determines the scale of the vibrations that they can detect. Small piezos are extremely sensitive to vibrations and need little to max out their range. Bigger piezos have a broader range, but more vibration is necessary to register a reading. In addition, specialized piezo sensors can act as inputs to detect flex, touch, vibration, and shock. These cost slightly more than a basic piezo element, and are usually made from a flexible film, which makes them a lot more robust.

When using a piezo, consider the following:

-   [**Complexity:** Piezos are relatively simple to wire, needing only a resistor to function in a circuit. Because the top half is made of a fragile ceramic, it is often enclosed in a plastic case, which makes it easy to mount and avoids any direct contact with the fragile solder joints on the surface of the piezo.]{#c11.xhtml#c11-li-0014}

-   ::: {#c11.xhtml#c11-li-0015}
    **[]{#c11.xhtml#Page_244 .pagebreak role="doc-pagebreak" title="244"}Cost:** Piezo elements are inexpensive, costing from around 20 cents for the cheapest elements without a casing to \$15 for high-power piezo buzzers. As an input, a piezo element is preferable to the more specific piezo buzzer. The usual difference is a smaller form factor for buzzers, whereas elements usually have a broader base. The latter is preferable for the knock sensor because it gives you more area on the piezo as well as more contact with the surface being monitored.

    Piezos are much cheaper to purchase from the major electronics companies, but because these require you to browse their vast online catalogues, you might find it more useful to buy a selection from retail stores first, such as RadioShack, where you can see the product in real life and get a feel for the different shapes, styles, and housings.
    :::

-   [**Location:** Knock sensors are not usually used as a direct input. Because they are so fragile, having people tapping on them all the time is risky. Instead, fix your piezo to a rigid surface such as wood, plastic, or metal, and let that surface take the punishment. For example, a knock sensor mounted on a staircase could be discreet and unobtrusive but still give highly accurate readings.]{#c11.xhtml#c11-li-0016}

Piezos are simple and inexpensive sensors with a large variety of uses. You can use them to detect vibrations or more directly in a homemade electric drum kit. This section's example shows you how to wire your own set of piezo knock sensors.

::: {.section}
[]{#c11.xhtml#c11-sec-0006}

### Implementing the Knock sketch {#c11.xhtml#h3-3 .Heading-2}

Knock sensors use a piezo element to measure vibration. When a piezo vibrates, it produces a voltage that can be interpreted by your Arduino as an analog signal. Piezo elements are more commonly used as buzzers, which inversely make a vibration when a current is passed through them.

You need the following:

-   [An Arduino Uno]{#c11.xhtml#c11-li-0017}
-   [A breadboard]{#c11.xhtml#c11-li-0018}
-   [A piezo]{#c11.xhtml#c11-li-0019}
-   [A 1M ohm resistor]{#c11.xhtml#c11-li-0020}
-   [Jump wires]{#c11.xhtml#c11-li-0021}

Using the layout and circuit diagrams in [Figures 11-3](#c11.xhtml#c11-fig-0003){#c11.xhtml#rc11-fig-0003} and [11-4](#c11.xhtml#c11-fig-0004){#c11.xhtml#rc11-fig-0004}, assemble the circuit for the knock sensor. The hardware in this circuit is similar to the piezo buzzer sketch in [Chapter 7](#c07.xhtml), but with a few changes you can make this piezo element into an input as well.[]{#c11.xhtml#Page_245 .pagebreak role="doc-pagebreak" title="245"}

::: {#c11.xhtml#c11-fig-0003 .figure}
![9781119489542-fg1103.png](https://i.imgur.com/rxka2VI.jpeg){.center}
:::

::: {#c11.xhtml#c11-fig-0004 .figure}
![9781119489542-fg1104.png](https://i.imgur.com/6oOFitx.jpeg){.center}
:::

Complete the circuit and choose File ⇒   Examples ⇒   06.Sensors ⇒   Knock from the Arduino menu to load the sketch.

[]{#c11.xhtml#c11-code-0005}[]{#c11.xhtml#c11-lntxt-0005}

`/*`{#c11.xhtml#c11-line-0074}

`Knock Sensor`{#c11.xhtml#c11-line-0075}

` `{#c11.xhtml#c11-line-0076}

`This sketch reads a piezo element to detect a knocking sound.`{#c11.xhtml#c11-line-0077}

`It reads an analog pin and compares the result to a set threshold.`{#c11.xhtml#c11-line-0078}

`If the result is greater than the threshold, it writes "knock" to the serial`{#c11.xhtml#c11-line-0079}

`port, and toggles the LED on pin 13.`{#c11.xhtml#c11-line-0080}

` `{#c11.xhtml#c11-line-0081}

`The circuit:`{#c11.xhtml#c11-line-0082}

`- positive connection of the piezo attached to analog in 0`{#c11.xhtml#c11-line-0083}

`- negative connection of the piezo attached to ground`{#c11.xhtml#c11-line-0084}

`- 1 megohm resistor attached from analog in 0 to ground`{#c11.xhtml#c11-line-0085}

` `{#c11.xhtml#c11-line-0086}

`created 25 Mar 2007`{#c11.xhtml#c11-line-0087}

`by David Cuartielles <http://www.0j0.org>`{#c11.xhtml#c11-line-0088}

`modified 30 Aug 2011`{#c11.xhtml#c11-line-0089}

`by Tom Igoe`{#c11.xhtml#c11-line-0090}

` `{#c11.xhtml#c11-line-0091}

`This example code is in the public domain.`{#c11.xhtml#c11-line-0092}

` `{#c11.xhtml#c11-line-0093}

`http://www.arduino.cc/en/Tutorial/Knock`{#c11.xhtml#c11-line-0094}

`*/`{#c11.xhtml#c11-line-0095}

` `{#c11.xhtml#c11-line-0096}

` `{#c11.xhtml#c11-line-0097}

`// these constants won't change:`{#c11.xhtml#c11-line-0098}

`const int ledPin = 13;      // led connected to digital pin 13`{#c11.xhtml#c11-line-0099}

`const int knockSensor = A0; // the piezo is connected to analog pin 0`{#c11.xhtml#c11-line-0100}

`const int threshold = 100;  // threshold value to decide when the detected`{#c11.xhtml#c11-line-0101}

`                            // sound is a knock or not`{#c11.xhtml#c11-line-0102}

` `{#c11.xhtml#c11-line-0103}

` `{#c11.xhtml#c11-line-0104}

`// these variables will change:`{#c11.xhtml#c11-line-0105}

`int sensorReading = 0;      // variable to store the value read from the`{#c11.xhtml#c11-line-0106}

`                            // sensor pin`{#c11.xhtml#c11-line-0107}

`int ledState = LOW;         // variable used to store the last LED status,`{#c11.xhtml#c11-line-0108}

`                            // to toggle the light`{#c11.xhtml#c11-line-0109}

` `{#c11.xhtml#c11-line-0110}

`void setup() {`{#c11.xhtml#c11-line-0111}

` pinMode(ledPin, OUTPUT); // declare the ledPin as OUTPUT`{#c11.xhtml#c11-line-0112}

` Serial.begin(9600);       // use the serial port`{#c11.xhtml#c11-line-0113}

`}`{#c11.xhtml#c11-line-0114}

` `{#c11.xhtml#c11-line-0115}

`void loop() {`{#c11.xhtml#c11-line-0116}

`  // read the sensor and store it in the variable sensorReading:`{#c11.xhtml#c11-line-0117}

`  sensorReading = analogRead(knockSensor);`{#c11.xhtml#c11-line-0118}

` `{#c11.xhtml#c11-line-0119}

`  // if the sensor reading is greater than the threshold:`{#c11.xhtml#c11-line-0120}

`  if (sensorReading >= threshold) {`{#c11.xhtml#c11-line-0121}

`    // toggle the status of the ledPin:`{#c11.xhtml#c11-line-0122}

`    ledState = !ledState;`{#c11.xhtml#c11-line-0123}

`    // update the LED pin itself:`{#c11.xhtml#c11-line-0124}

`    digitalWrite(ledPin, ledState);`{#c11.xhtml#c11-line-0125}

`    // send the string "Knock!" back to the computer, followed by newline`{#c11.xhtml#c11-line-0126}

`    Serial.println("Knock!");`{#c11.xhtml#c11-line-0127}

`  }`{#c11.xhtml#c11-line-0128}

`  delay(100);  // delay to avoid overloading the serial port buffer`{#c11.xhtml#c11-line-0129}

`}`{#c11.xhtml#c11-line-0130}

Press the Compile button to check your code. Doing so highlights any grammatical errors and lights them up in red. If the sketch compiles correctly, click Upload to send the sketch to your board. When it is finished uploading, choose the serial monitor and give the surface that your piezo is on a good knock. If it's working, *Knock!* appears on the serial monitor and the LED changes with each successful knock.

If nothing happens, double-check your wiring:

-   [Make sure that you're using the correct pin number.]{#c11.xhtml#c11-li-0022}
-   [Check the connections on the breadboard. If the jump wires or components are not connected using the correct rows in the breadboard, they will not work.]{#c11.xhtml#c11-li-0023}
:::

::: {.section}
[]{#c11.xhtml#c11-sec-0007}

### Understanding the Knock sketch {#c11.xhtml#h3-4 .Heading-2}

In the Knock sketch, the first declarations are constant values, the LED pin number, the knock sensor pin number, and the threshold for a knock value. These are set and don't change throughout the sketch:

[]{#c11.xhtml#c11-code-0006}[]{#c11.xhtml#c11-lntxt-0006}

`// these constants won't change:`{#c11.xhtml#c11-line-0131}

`const int ledPin = 13;      // led connected to digital pin 13`{#c11.xhtml#c11-line-0132}

`const int knockSensor = A0; // the piezo is connected to analog pin 0`{#c11.xhtml#c11-line-0133}

`const int threshold = 100;  // threshold value to decide when the`{#c11.xhtml#c11-line-0134}

`                            // detected sound is a knock or not`{#c11.xhtml#c11-line-0135}

[]{#c11.xhtml#Page_248 .pagebreak role="doc-pagebreak" title="248"} Two variables do change --- the current sensor reading and the state of the LED:

[]{#c11.xhtml#c11-code-0007}[]{#c11.xhtml#c11-lntxt-0007}

`// these variables will change:`{#c11.xhtml#c11-line-0136}

`int sensorReading = 0;      // variable to store the value read from the sensor pin`{#c11.xhtml#c11-line-0137}

`int ledState = LOW;         // variable used to store the last LED status,`{#c11.xhtml#c11-line-0138}

`                            // to toggle the light`{#c11.xhtml#c11-line-0139}

In [`setup`]{.Code-within-text}, the LED pin is set to be an output and the serial port is opened for communication:

[]{#c11.xhtml#c11-code-0008}[]{#c11.xhtml#c11-lntxt-0008}

`void setup() {`{#c11.xhtml#c11-line-0140}

` pinMode(ledPin, OUTPUT); // declare the ledPin as OUTPUT`{#c11.xhtml#c11-line-0141}

` Serial.begin(9600);       // use the serial port`{#c11.xhtml#c11-line-0142}

`}`{#c11.xhtml#c11-line-0143}

The first line in the loop reads the analog value from the knock sensor pin:

[]{#c11.xhtml#c11-code-0009}[]{#c11.xhtml#c11-lntxt-0009}

`void loop() {`{#c11.xhtml#c11-line-0144}

`  // read the sensor and store it in the variable sensorReading:`{#c11.xhtml#c11-line-0145}

`  sensorReading = analogRead(knockSensor);`{#c11.xhtml#c11-line-0146}

This value is compared to the threshold value:

[]{#c11.xhtml#c11-code-0010}[]{#c11.xhtml#c11-lntxt-0010}

`  // if the sensor reading is greater than the threshold:`{#c11.xhtml#c11-line-0147}

`  if (sensorReading >= threshold) {`{#c11.xhtml#c11-line-0148}

If the value of [`sensorReading`]{.Code-within-text} is greater than or equal to the [`threshold`]{.Code-within-text} value, the LED\'s state is switched between 0 and 1 using [`!`]{.Code-within-text}, the NOT symbol. The [`!`]{.Code-within-text} in this case is used to return the opposite Boolean value of the [`ledState`]{.Code-within-text} variable\'s current value. As you know, Booleans are either 1 or 0 (true or false), the same as the possible values of [`ledState`]{.Code-within-text}. This line of code could be written as "make [`ledState`]{.Code-within-text} equal to whatever value it is not:"

[]{#c11.xhtml#c11-code-0011}[]{#c11.xhtml#c11-lntxt-0011}

`    // toggle the status of the ledPin:`{#c11.xhtml#c11-line-0149}

`    ledState = !ledState;`{#c11.xhtml#c11-line-0150}

The [`ledState`]{.Code-within-text} value is then sent to the LED pin using [`digitalWrite`]{.Code-within-text}. The digitalWrite function interprets a value of 0 as [`LOW`]{.Code-within-text} and 1 as [`HIGH`]{.Code-within-text}:

[]{#c11.xhtml#c11-code-0012}[]{#c11.xhtml#c11-lntxt-0012}

`    // update the LED pin itself:`{#c11.xhtml#c11-line-0151}

`    digitalWrite(ledPin, ledState);`{#c11.xhtml#c11-line-0152}

[]{#c11.xhtml#Page_249 .pagebreak role="doc-pagebreak" title="249"} Finally, *Knock!* is sent to the serial port with a short delay, for stability:

[]{#c11.xhtml#c11-code-0013}[]{#c11.xhtml#c11-lntxt-0013}

`// send the string "Knock!" back to the computer, followed by newline`{#c11.xhtml#c11-line-0153}

`    Serial.println("Knock!");`{#c11.xhtml#c11-line-0154}

`  }`{#c11.xhtml#c11-line-0155}

`  delay(100);  // delay to avoid overloading the serial port buffer`{#c11.xhtml#c11-line-0156}

`}`{#c11.xhtml#c11-line-0157}
:::
:::

::: {.section}
[]{#c11.xhtml#c11-sec-0008}

## Utilizing Pressure, Force, and Load Sensors {#c11.xhtml#h2-3 .Heading-1}

Three closely related kinds of sensors are commonly confused: pressure, force, and load sensors. These three sensors are extremely different in how they behave and what data they can give you, so it\'s important to know the difference so that you choose the one that's right for your situation. In this section, you learn about the different definitions of each of these sensors, as well as where you use them and why you use one over the other.

Consider the following as you plan:

-   [**Complexity:** As you might expect, complexity increases depending on how accurate you need to be:]{#c11.xhtml#c11-li-0024}
    -   [*Pressure pads* are designed to detect when pressure is applied to an area, and they come in a variety of both quality and accuracy. The simplest pressure pads are often misnamed and are really the equivalent of big switches. Inside a simple pressure pad are two layers of foil separated by a layer of foam with holes in it. When the foam is squashed, the metal contacts touch through the foam and complete the circuit. Instead of measuring pressure or weight, the pad is detecting when there is enough weight to squash the foam. These pads do a fine job and are similar to the mechanisms found inside dance mats --- ample proof that you don't need to overthink your sensors!]{#c11.xhtml#c11-li-0025}
    -   [For more precision, you may want to use *force sensors*, which measure the force applied by whatever is put on them within their range. Although force sensors are accurate enough to detect a change in weight, they are not accurate enough to provide a precise measurement. Force sensors are usually flexible, force-sensitive resistors --- that is, resistors made on a flexible PCB that change their resistance when force is applied. The resistor itself is on the flexible circuit board, and although the board can tolerate extremely high forces and loads, protecting it from direct contact is a good idea to prevent it from bending, folding, or tearing.]{#c11.xhtml#c11-li-0026}
    -   [[]{#c11.xhtml#Page_250 .pagebreak role="doc-pagebreak" title="250"}With pressure pads at one end of the spectrum, at the other are load sensors. An example of a load sensor is found in your bathroom scale. *Load sensors* can accurately measure weight up to their limit. They work in much the same way as force sensors by changing resistance as they bend. In most cases, a load sensor is fixed to a rigid piece of metal and monitors changes as the metal is put under strain. The changes are so minute that they often require an amplification circuit known as a Wheatstone bridge. Incorporating this kind of sensor is more complex than the others, but you can find material on the Internet that will walk you thorough the process.]{#c11.xhtml#c11-li-0027}

-   [**Cost:** The cost of each sensor is relatively low, even for the most sensitive ones. All the materials to make a cheap pressure pad will set you back \$3; the cost for an inexpensive, entry-level pressure mat available from most electronics stores and suppliers is \$12. Force-sensitive resistors range from \$8 to \$23, but cover a much smaller area than a pressure pad, so you may need quite a few of them to cover a large area. At around \$11, load sensors are also relatively cheap, most likely because they are so widespread that mass production has knocked the price down. There may be an extra cost in time to plan and make the additional circuitry.]{#c11.xhtml#c11-li-0028}

-   ::: {#c11.xhtml#c11-li-0029}
    **Location:** The challenge with all these sensors is housing them to prevent damage. In the case of the pressure pad and force-sensitive resistors, placing a thick layer of upholstery foam on the side that the force is coming from is a good idea. Depending on the density of the foam, it should dampen enough of the force to protect the sensor but still compress it enough for a good reading. Underneath the sensors, you want to have a solid base to give you something to push against. This base could be the floor or surface that the sensor is placed on, or you could attach a piece of MDF/plywood to the underside of the sensor. It's a good idea to protect the exterior of your pressure sensor as well, so consider something a bit sturdier than foam on the exterior. For a soft finish, upholstery vinyl is a great option. If you plan to have people walk on the surface, for example, a layer of wood on the top to sandwich the foam will spread the load and can easily be replaced, if needed.

    Load sensors require little movement and should be connected to or placed in direct contact with a ridged surface. If you use a load sensor in a bathroom scale, it may take some trial and error to place the sensor in the correct location to get an accurate reading. Sometimes multiple sensors are used to get an average reading across the surface.
    :::

After you choose a sensor, you need to figure out how to use it:

-   [*Pressure pads* are an extremely simple circuit, the same as for a pushbutton. The hardware of a pressure pad is also easy enough that you can make one yourself using two sheets of foil (or the more flexible conductive fabric or conductive thread), a sheet of foam, a cover, and a couple of wires.]{#c11.xhtml#c11-li-0030}
-   [*[]{#c11.xhtml#Page_251 .pagebreak role="doc-pagebreak" title="251"}Force sensors* are also relatively easy to use and can take the place of other analog sensors, such as light or temperature sensors, in simple Arduino circuits. The ranges of force may vary, but whatever the range, scaling the force to your needs in the code is simple.]{#c11.xhtml#c11-li-0031}
-   [*Load sensors* are probably the most complex sensor if they\'re being used for accurate reading, as with a set of weight scales. They require extra circuitry and an amplifier for the Arduino to read the minute changes in resistance. This topic is outside the scope of this book, so if you want to know more, get friendly with Google.]{#c11.xhtml#c11-li-0032}

Force sensors are just like any other variable resistor and can easily be switched with potentiometer or light-dependent resistors as needed. In this section's example, you use force-sensitive resistors and the toneKeyboard sketch to make an Arduino piano keyboard.

::: {.section}
[]{#c11.xhtml#c11-sec-0009}

### Implementing the toneKeyboard sketch {#c11.xhtml#h3-5 .Heading-2}

You may think of pushbuttons as the perfect input for a keyboard, but force-sensitive resistors give you much more touch sensitivity. Rather than detect just a press, you can detect also the intensity of the keypress, in the same way as on a traditional piano.

You need the following:

-   [An Arduino Uno]{#c11.xhtml#c11-li-0033}
-   [A breadboard]{#c11.xhtml#c11-li-0034}
-   [Three force-sensitive resistors]{#c11.xhtml#c11-li-0035}
-   [Three 10k ohm resistors]{#c11.xhtml#c11-li-0036}
-   [One 100 ohm resistor]{#c11.xhtml#c11-li-0037}
-   [A piezo element]{#c11.xhtml#c11-li-0038}
-   [Jump wires]{#c11.xhtml#c11-li-0039}

Using the layout and circuit diagrams in [Figures 11-5](#c11.xhtml#c11-fig-0005){#c11.xhtml#rc11-fig-0005} and [11-6](#c11.xhtml#c11-fig-0006){#c11.xhtml#rc11-fig-0006}, lay out the force-sensitive resistors and the piezo to make your own keyboard.[]{#c11.xhtml#Page_252 .pagebreak role="doc-pagebreak" title="252"}

::: {#c11.xhtml#c11-fig-0005 .figure}
![9781119489542-fg1105.png](https://i.imgur.com/w44xWci.jpeg){.center}
:::

::: {#c11.xhtml#c11-fig-0006 .figure}
![9781119489542-fg1106.png](https://i.imgur.com/xPcw79i.jpeg){.center}
:::

Complete the circuit and choose File ⇒   Examples ⇒   02.Digital ⇒   toneKeyboard from the Arduino menu to load the sketch.

[]{#c11.xhtml#c11-code-0014}[]{#c11.xhtml#c11-lntxt-0014}

`/*`{#c11.xhtml#c11-line-0158}

`  Keyboard`{#c11.xhtml#c11-line-0159}

` `{#c11.xhtml#c11-line-0160}

`  Plays a pitch that changes based on a changing analog input`{#c11.xhtml#c11-line-0161}

` `{#c11.xhtml#c11-line-0162}

`  circuit:`{#c11.xhtml#c11-line-0163}

`  - three force-sensing resistors from +5V to analog in 0 through 5`{#c11.xhtml#c11-line-0164}

`  - three 10 kilohm resistors from analog in 0 through 5 to ground`{#c11.xhtml#c11-line-0165}

`  - 8 ohm speaker on digital pin 8`{#c11.xhtml#c11-line-0166}

` `{#c11.xhtml#c11-line-0167}

`  created 21 Jan 2010`{#c11.xhtml#c11-line-0168}

`  modified 9 Apr 2012`{#c11.xhtml#c11-line-0169}

`  by Tom Igoe`{#c11.xhtml#c11-line-0170}

` `{#c11.xhtml#c11-line-0171}

`  This example code is in the public domain.`{#c11.xhtml#c11-line-0172}

` `{#c11.xhtml#c11-line-0173}

`  http://www.arduino.cc/en/Tutorial/Tone3`{#c11.xhtml#c11-line-0174}

`*/`{#c11.xhtml#c11-line-0175}

` `{#c11.xhtml#c11-line-0176}

`#include "pitches.h"`{#c11.xhtml#c11-line-0177}

` `{#c11.xhtml#c11-line-0178}

`const int threshold = 10;        // minimum reading of the sensors that`{#c11.xhtml#c11-line-0179}

`                             // generates a note`{#c11.xhtml#c11-line-0180}

` `{#c11.xhtml#c11-line-0181}

`// notes to play, corresponding to the 3 sensors:`{#c11.xhtml#c11-line-0182}

`int notes[] = {`{#c11.xhtml#c11-line-0183}

`  NOTE_A4, NOTE_B4,NOTE_C3`{#c11.xhtml#c11-line-0184}

`};`{#c11.xhtml#c11-line-0185}

` `{#c11.xhtml#c11-line-0186}

`void setup() {`{#c11.xhtml#c11-line-0187}

` `{#c11.xhtml#c11-line-0188}

`}`{#c11.xhtml#c11-line-0189}

` `{#c11.xhtml#c11-line-0190}

`void loop() {`{#c11.xhtml#c11-line-0191}

`  for (int thisSensor = 0; thisSensor < 3; thisSensor++) {`{#c11.xhtml#c11-line-0192}

`    // get a sensor reading:`{#c11.xhtml#c11-line-0193}

`    int sensorReading = analogRead(thisSensor);`{#c11.xhtml#c11-line-0194}

` `{#c11.xhtml#c11-line-0195}

`    // if the sensor is pressed hard enough:`{#c11.xhtml#c11-line-0196}

`    if (sensorReading > threshold) {`{#c11.xhtml#c11-line-0197}

`      // play the note corresponding to this sensor:`{#c11.xhtml#c11-line-0198}

`      tone(8, notes[thisSensor], 20);`{#c11.xhtml#c11-line-0199}

`    }`{#c11.xhtml#c11-line-0200}

`  }`{#c11.xhtml#c11-line-0201}

`}`{#c11.xhtml#c11-line-0202}

Press the Compile button to check your code. The compiler should highlight any grammatical errors and light them up in red. If the sketch compiles correctly, click Upload to send the sketch to your board. When it has finished uploading, try the keys to make sure they're working. If they are, you're ready to play.

If nothing happens, double-check your wiring:

-   [Make sure that you're using the correct pin number.]{#c11.xhtml#c11-li-0040}
-   [Check the connections on the breadboard. If the jump wires or components are not connected using the correct rows in the breadboard, they won't work.]{#c11.xhtml#c11-li-0041}
:::

::: {.section}
[]{#c11.xhtml#c11-sec-0010}

### Understanding the toneKeyboard sketch {#c11.xhtml#h3-6 .Heading-2}

The toneKeyboard sketch uses the same table of notes as the Melody sketch in [Chapter 7](#c07.xhtml). The first line includes [`pitches.h`]{.Code-within-text}, which should be open in a separate tab next to the main sketch:

[]{#c11.xhtml#c11-code-0015}[]{#c11.xhtml#c11-lntxt-0015}

`#include "pitches.h"`{#c11.xhtml#c11-line-0203}

A low threshold of 10 (out of a possible 1024) is set to avoid any low readings resulting from background vibrations:

[]{#c11.xhtml#c11-code-0016}[]{#c11.xhtml#c11-lntxt-0016}

`const int threshold = 10;    // minimum reading of the sensors that`{#c11.xhtml#c11-line-0204}

`                         // generates a note`{#c11.xhtml#c11-line-0205}

The notes for each sensor are stored in an array with values (0, 1, and 2) that correspond to the analog input pin numbers (A0, A1, and A2). You can change the note values in the array manually by using the look-up table on [`pitches.h`]{.Code-within-text}. Simply copy and paste new note values in the change the note of each sensor.

[]{#c11.xhtml#c11-code-0017}[]{#c11.xhtml#c11-lntxt-0017}

`// notes to play, corresponding to the 3 sensors:`{#c11.xhtml#c11-line-0206}

`int notes[] = {`{#c11.xhtml#c11-line-0207}

`  NOTE_A4, NOTE_B4,NOTE_C3`{#c11.xhtml#c11-line-0208}

`};`{#c11.xhtml#c11-line-0209}

[]{#c11.xhtml#Page_255 .pagebreak role="doc-pagebreak" title="255"} In [`setup`]{.Code-within-text}, you have nothing to define because the analog input pins are set to be inputs by default:

[]{#c11.xhtml#c11-code-0018}[]{#c11.xhtml#c11-lntxt-0018}

`void setup() {`{#c11.xhtml#c11-line-0210}

`}`{#c11.xhtml#c11-line-0211}

In the main loop, a [`for ()`]{.Code-within-text} loop cycles through the numbers 0 to 2:

[]{#c11.xhtml#c11-code-0019}[]{#c11.xhtml#c11-lntxt-0019}

`void loop() {`{#c11.xhtml#c11-line-0212}

`  for (int thisSensor = 0; thisSensor < 3; thisSensor++) {`{#c11.xhtml#c11-line-0213}

The value of the [`for ()`]{.Code-within-text} loop, which is used as the pin number, is stored temporarily to [`sensorReading`]{.Code-within-text}:

[]{#c11.xhtml#c11-code-0020}[]{#c11.xhtml#c11-lntxt-0020}

`    // get a sensor reading:`{#c11.xhtml#c11-line-0214}

`    int sensorReading = analogRead(thisSensor);`{#c11.xhtml#c11-line-0215}

If the reading is greater than the threshold, it is used to trigger the correct note assigned to that input:

[]{#c11.xhtml#c11-code-0021}[]{#c11.xhtml#c11-lntxt-0021}

`    // if the sensor is pressed hard enough:`{#c11.xhtml#c11-line-0216}

`    if (sensorReading > threshold) {`{#c11.xhtml#c11-line-0217}

`      // play the note corresponding to this sensor:`{#c11.xhtml#c11-line-0218}

`      tone(8, notes[thisSensor], 20);`{#c11.xhtml#c11-line-0219}

`    }`{#c11.xhtml#c11-line-0220}

`  }`{#c11.xhtml#c11-line-0221}

`}`{#c11.xhtml#c11-line-0222}

Because the loop happens so quickly, any delay in reading each sensor is unnoticeable.
:::
:::

::: {.section}
[]{#c11.xhtml#c11-sec-0011}

## Sensing with Style {#c11.xhtml#h2-4 .Heading-1}

*Capacitive sensors* detect changes in electromagnetic fields. Every living thing --- even you --- has an electromagnetic field. Capacitive sensors are extremely useful because they can detect human contact and ignore other environmental factors. You\'re probably familiar with high-end capacitive sensors because they are present in nearly all smartphones, but they have been around since the late 1920s. You can find Arduino kits with capacitive sensors that you can hook up easily, such as capacitive touch keypads. But it\'s just as easy to make your own capacitive sensors with an Arduino and an antenna.

[]{#c11.xhtml#Page_256 .pagebreak role="doc-pagebreak" title="256"}Consider the following in your plans:

-   ::: {#c11.xhtml#c11-li-0042}
    **Complexity:** Because all that is required is an antenna, you can be creative with what the antenna is and where it is placed. Short pieces of wire or copper tape are great for simple touch sensors. The piece of copper tape suddenly becomes a touch switch, meaning that you don't even need a pushbutton to get the same functionality. You could even connect the antenna to a bigger metal object such as a lamp, turning it into a touch lamp.

    If the antenna is made from a reel of wire or a piece of foil, you can extend the range of the sensor beyond touch, which is known as a *projected capacitive sensor.* Using a capacitive sensor you can detect a person's hand a few inches away from the antenna, which creates a lot of new possibilities for hiding sensors behind other materials. These discreet capacitive sensors are now commonly seen in many recent consumer electronics to remove physical buttons and maintain the sleek shape of the product. The electronics can also be placed under layers of other material, protected from the outside world.

    Capacitive touch sensors are easy to make. The difficulty with projected field sensors to determine the range of the field. The best way to determine this range is by experimentation, testing to see whether the field that you\'re generating is far-reaching enough.
    :::

-   ::: {#c11.xhtml#c11-li-0043}
    **Cost:** A capacitive touch kit designed for a specific purpose costs around \$15 to \$25. The kit should perform its job well, but it will be limited to the design of the interface. A capacitive sensor breakout board from SparkFun for around \$10 lets you control up to 12 capacitive sensors. You have to wire your own touchpads, but you're free to design an interface that suits your purpose.

    The cheapest option is to use the CapSense library for Arduino, which allows you to make a capacitive sensor with an antenna and no additional hardware! You can spend a few cents for an antenna or repurpose an old one.
    :::

-   [**Location:** Capacitive touch sensors can work with any conductive metal, so if you can design an attractive metal exterior, the only work will be to connect that exterior to your Arduino. If you're looking for something more discreet, you may want to experiment with different layers of wood or plastic to hide your metal antenna. A thin layer of plywood allows the metal to be close to the surface, able to trigger the sensor. By covering the antenna with a non-conductive surface, you also give it a seemingly magical property, ensuring that people are left guessing at how it works.]{#c11.xhtml#c11-li-0044}

The easiest way to make a capacitive sensor is to use the CapSense library by Paul Badger. By using the CapSense library (I explain how in the "[Getting the CapSense Library](#c11.xhtml#c11-fea-0001)" sidebar), you can replace the mechanical switches with highly robust capacitive touch sensors or capacitive presence detectors.[]{#c11.xhtml#Page_257 .pagebreak role="doc-pagebreak" title="257"}

```{=html}
<aside>
```
::: {#c11.xhtml#c11-fea-0001 .sidebar}
# []{#c11.xhtml#Page_258 .pagebreak role="doc-pagebreak" title="258"}GETTING THE CapSense LIBRARY {.SB-Head}

[]{#c11.xhtml#c11-sec-0012}

The CapSense library is available from GitHub, an online repository of software that manages different versions and allows you to see who has updated the software, and how. It's an excellent system for sharing and collaborating on code projects. You can find the Arduino platform on GitHub; check it out if you're curious about any changes. To get the library:

1.  [**Point your web browser to the GitHub CapSense page at** [[`github.com/moderndevice/CapSense`]{.Code-within-text}](https://github.com/moderndevice/CapSense)**.**]{#c11.xhtml#c11-li-0045}

2.  [**On the CapSense page, click the Clone button or download and then click Download ZIP, as shown in the figure.**]{#c11.xhtml#c11-li-0046}

    The latest version of the library is downloaded to your downloads folder or a folder you specify.

    ::: {#c11.xhtml#c11-blkfxd-0001 .figure}
    ![9781119489542-sb1101.png](https://i.imgur.com/ZvaT1yL.jpeg){.center}
    :::

3.  [**Rename the folder CapSense.**]{#c11.xhtml#c11-li-0047}

    Inside the folder, you should see a number of files ending in [`.h`]{.Code-within-text} and [`.cpp`]{.Code-within-text} as well as an Examples folder.

4.  [**Move the entire folder to your Arduino libraries directory.**]{#c11.xhtml#c11-li-0048}

    This directory should be the same as the one that your sketches are saved to, for example: Username/Documents/Arduino/libraries. If you don\'t have a libraries directory, create one.

    Your can find your Arduino Save directory by choosing Arduino ⇒   Preferences from the Arduino menu bar. After the CapSense library is inside this folder, it will be available the next time you run Arduino.

5.  [**Start or restart Arduino and go to Sketch ⇒   Include Library in the Arduino menu.**]{#c11.xhtml#c11-li-0049}

    Look for CapSense under the Contributed libraries section. If you don't find it, check your directories and spelling and then restart Arduino.

::: {#c11.xhtml#c11-blkfxd-0002 .figure}
![9781119489542-sb1102.png](https://i.imgur.com/WEUw0aq.jpeg){.center}
:::
:::

```{=html}
</aside>
```
::: {.section}
[]{#c11.xhtml#c11-sec-0013}

### Implementing the CapPinSketch sketch {#c11.xhtml#h3-7 .Heading-2}

For this project, you need the following:

-   [An Arduino Uno]{#c11.xhtml#c11-li-0050}
-   [A wire antenna]{#c11.xhtml#c11-li-0051}
-   [Crocodile clips (optional)]{#c11.xhtml#c11-li-0052}

As you can see from the photo in [Figure 11-7](#c11.xhtml#c11-fig-0007){#c11.xhtml#rc11-fig-0007}, little work is needed. You can simply have a wire antenna connected to pin 5, and you can enlarge your antenna by connecting it to any other conductive surface. Crocodile clips are useful to latch onto different antennas quickly and easily.

::: {#c11.xhtml#c11-fig-0007 .figure}
![9781119489542-fg1107.png](https://i.imgur.com/bXtNGJ0.jpeg){.center}
:::

Build the CapSense circuit, and choose File ⇒   Examples ⇒   CapSense ⇒   Examples ⇒   CapPinSketch from the Arduino menu to load the sketch.

[]{#c11.xhtml#c11-code-0022}[]{#c11.xhtml#c11-lntxt-0022}

`#include <CapPin.h>`{#c11.xhtml#c11-line-0223}

` `{#c11.xhtml#c11-line-0224}

`/* CapPin`{#c11.xhtml#c11-line-0225}

` * Capacitive Library CapPin Demo Sketch`{#c11.xhtml#c11-line-0226}

` * Paul Badger 2011`{#c11.xhtml#c11-line-0227}

` * This class uses the built-in pullup resistors read the capacitance`{#c11.xhtml#c11-line-0228}

` * on a pin.`{#c11.xhtml#c11-line-0229}

` * The pin is set to input and then the pullup is set,`{#c11.xhtml#c11-line-0230}

` * A loop times how long the pin takes to go HIGH.`{#c11.xhtml#c11-line-0231}

` * The readPin method is fast and can be read 1000 times in under 10 mS.`{#c11.xhtml#c11-line-0232}

` * By reading the pin repeated you can sense "hand pressure"`{#c11.xhtml#c11-line-0233}

` * at close range with a small sensor. A larger sensor (piece of foil/metal)`{#c11.xhtml#c11-line-0234}

` * will yield`{#c11.xhtml#c11-line-0235}

` * larger return values and be able to sense at more distance. For`{#c11.xhtml#c11-line-0236}

` * a more sensitive method of sensing pins see CapTouch`{#c11.xhtml#c11-line-0237}

` * Hook up a wire with or without a piece of foil attached to the pin.`{#c11.xhtml#c11-line-0238}

` * I suggest covering the sensor with mylar, packing tape, paper or other`{#c11.xhtml#c11-line-0239}

` * insulator to avoid having users directly touch the pin.`{#c11.xhtml#c11-line-0240}

` */`{#c11.xhtml#c11-line-0241}

` `{#c11.xhtml#c11-line-0242}

`CapPin cPin_5 = CapPin(5);   // read pin 5`{#c11.xhtml#c11-line-0243}

` `{#c11.xhtml#c11-line-0244}

`float smoothed;`{#c11.xhtml#c11-line-0245}

` `{#c11.xhtml#c11-line-0246}

`void setup() {`{#c11.xhtml#c11-line-0247}

` `{#c11.xhtml#c11-line-0248}

`  Serial.begin(115200);`{#c11.xhtml#c11-line-0249}

`  Serial.println("start");`{#c11.xhtml#c11-line-0250}

`  // slider_2_7.calibrateSlider();`{#c11.xhtml#c11-line-0251}

` `{#c11.xhtml#c11-line-0252}

`}`{#c11.xhtml#c11-line-0253}

` `{#c11.xhtml#c11-line-0254}

`void loop() {`{#c11.xhtml#c11-line-0255}

` `{#c11.xhtml#c11-line-0256}

`  delay(1);`{#c11.xhtml#c11-line-0257}

`  long total1 = 0;`{#c11.xhtml#c11-line-0258}

`  long start = millis();`{#c11.xhtml#c11-line-0259}

`  long total =  cPin_5.readPin(2000);`{#c11.xhtml#c11-line-0260}

` `{#c11.xhtml#c11-line-0261}

`  // simple lowpass filter to take out some of the jitter`{#c11.xhtml#c11-line-0262}

`  // change parameter (0 is min, .99 is max) or eliminate to suit`{#c11.xhtml#c11-line-0263}

`  smoothed = smooth(total, .8, smoothed);`{#c11.xhtml#c11-line-0264}

` `{#c11.xhtml#c11-line-0265}

`Serial.print( millis() - start);      // time to execute in mS`{#c11.xhtml#c11-line-0266}

`Serial.print("\t");`{#c11.xhtml#c11-line-0267}

`Serial.print(total);                  // raw total`{#c11.xhtml#c11-line-0268}

`Serial.print("\t");`{#c11.xhtml#c11-line-0269}

`Serial.println((int) smoothed);       // smoothed`{#c11.xhtml#c11-line-0270}

`delay(5);`{#c11.xhtml#c11-line-0271}

`}`{#c11.xhtml#c11-line-0272}

` `{#c11.xhtml#c11-line-0273}

`// simple lowpass filter`{#c11.xhtml#c11-line-0274}

`// requires recycling the output in the "smoothedVal" param`{#c11.xhtml#c11-line-0275}

`int smooth(int data, float filterVal, float smoothedVal){`{#c11.xhtml#c11-line-0276}

` `{#c11.xhtml#c11-line-0277}

`  if (filterVal > 1){      // check to make sure param's are within range`{#c11.xhtml#c11-line-0278}

`    filterVal = .999999;`{#c11.xhtml#c11-line-0279}

`  }`{#c11.xhtml#c11-line-0280}

`  else if (filterVal <= 0){`{#c11.xhtml#c11-line-0281}

`    filterVal = 0;`{#c11.xhtml#c11-line-0282}

`  }`{#c11.xhtml#c11-line-0283}

` `{#c11.xhtml#c11-line-0284}

`  smoothedVal = (data * (1 - filterVal)) + (smoothedVal * filterVal);`{#c11.xhtml#c11-line-0285}

` `{#c11.xhtml#c11-line-0286}

`  return (int)smoothedVal;`{#c11.xhtml#c11-line-0287}

`}`{#c11.xhtml#c11-line-0288}

Press the Compile button to check your code. Compiling highlights any grammatical errors, which light up in red. If the sketch compiles correctly, click Upload to send the sketch to your board. When it has finished uploading, open the serial monitor, set the baud rate to 115200, and touch or approach the antenna. You should see two values racing down the screen. On the left is the raw value being read; on the right is the same reading after smoothing.

If nothing happens, double-check your wiring:

-   [Make sure that you're using the correct pin number.]{#c11.xhtml#c11-li-0053}
-   [Check the connections on the breadboard. If the jump wires or components are not connected using the correct rows in the breadboard, they will not work.]{#c11.xhtml#c11-li-0054}
:::

::: {.section}
[]{#c11.xhtml#c11-sec-0014}

### Understanding the CapPinSketch sketch {#c11.xhtml#h3-8 .Heading-2}

At the start of the CapPinSketch sketch in the declarations, a new [`CapPin`]{.Code-within-text} object is named. Note that [`cPin_5`]{.Code-within-text} is the name and it is assigned to pin 5 using [`CapPin(5)`]{.Code-within-text}:

[]{#c11.xhtml#c11-code-0023}[]{#c11.xhtml#c11-lntxt-0023}

`CapPin cPin_5 = CapPin(5);   // read pin 5`{#c11.xhtml#c11-line-0289}

A float named [`smoothed`]{.Code-within-text} is declared to store the processed value of the sensor:

[]{#c11.xhtml#c11-code-0024}[]{#c11.xhtml#c11-lntxt-0024}

`float smoothed;`{#c11.xhtml#c11-line-0290}

```{=html}
<aside>
```
::: {#c11.xhtml#c11-fea-0002 .sidebar}
# []{#c11.xhtml#Page_262 .pagebreak role="doc-pagebreak" title="262"}WHAT IS A FLOAT? {.SB-Head}

[]{#c11.xhtml#c11-sec-0015}

A *float,* or floating-point number, is any number with a decimal point. Variables can be set to floating-point numbers instead of integers. This is preferable in some situations, such as when you\'re taking extremely precise readings of capacitance. However, floats take much more time to process than integers and, therefore, should be avoided if possible.
:::

```{=html}
</aside>
```
In [`setup`]{.Code-within-text}, serial communication is started on a baud rate of 115200, and the message *start* is sent to indicate to you that the serial port is connected:

[]{#c11.xhtml#c11-code-0025}[]{#c11.xhtml#c11-lntxt-0025}

`void setup()`{#c11.xhtml#c11-line-0291}

`{`{#c11.xhtml#c11-line-0292}

` `{#c11.xhtml#c11-line-0293}

`  Serial.begin(115200);`{#c11.xhtml#c11-line-0294}

`  Serial.println("start");`{#c11.xhtml#c11-line-0295}

This commented line is not used in this sketch but is referenced in some of the other CapSense examples. It can be uncommented to include further calibration functions that are in the library but is not be covered in this example:

[]{#c11.xhtml#c11-code-0026}[]{#c11.xhtml#c11-lntxt-0026}

`// slider_2_7.calibrateSlider();`{#c11.xhtml#c11-line-0296}

` `{#c11.xhtml#c11-line-0297}

`}`{#c11.xhtml#c11-line-0298}

In this sketch, many variables are declared locally. Because they\'re not needed outside the loop, they\'re removed after each loop and redeclared at the start of the next loop.

First, a one-millisecond delay occurs to help improve the stability of the reading:

[]{#c11.xhtml#c11-code-0027}[]{#c11.xhtml#c11-lntxt-0027}

`void loop()`{#c11.xhtml#c11-line-0299}

`{`{#c11.xhtml#c11-line-0300}

` `{#c11.xhtml#c11-line-0301}

` `{#c11.xhtml#c11-line-0302}

`  delay(1);`{#c11.xhtml#c11-line-0303}

Next, the long variable [`total1`]{.Code-within-text} is declared. This variable can look confusing because the lowercase *L* and the numeral 1 look the same in most fonts. Incidentally, this variable is not used in this sketch. It may well be left over from a previous version:

[]{#c11.xhtml#c11-code-0028}[]{#c11.xhtml#c11-lntxt-0028}

`  long total1 = 0;`{#c11.xhtml#c11-line-0304}

The next long variable is set to the current [`millis ()`]{.Code-within-text} value. Because this variable is local, the value is reset on each loop:

[]{#c11.xhtml#c11-code-0029}[]{#c11.xhtml#c11-lntxt-0029}

`  long start = millis();`{#c11.xhtml#c11-line-0305}

The specific function [`.readPin()`]{.Code-within-text} reads your capacitive pin:

[]{#c11.xhtml#c11-code-0030}[]{#c11.xhtml#c11-lntxt-0030}

`  long total =  cPin_5.readPin(2000);`{#c11.xhtml#c11-line-0306}

If you want to explore in more depth what\'s happening, look at [`CapPin.cpp`]{.Code-within-text} in the CapSense library. At first, the CapPin.cpp file looks baffling, but by reading the []{#c11.xhtml#Page_263 .pagebreak role="doc-pagebreak" title="263"}line that follows, you can see that the value relates to the number of samples that the Arduino is taking of the capacitance reading:

[]{#c11.xhtml#c11-code-0031}[]{#c11.xhtml#c11-lntxt-0031}

`long CapPin::readPin(unsigned int samples)`{#c11.xhtml#c11-line-0307}

![tip.png](https://i.imgur.com/O7t6pNx.jpeg) Editing the inner workings of libraries is not advised for beginners, but it is good to have a look at them to know what's happening in your code and try to gain a better understanding of them.

A smoothing function is also included in the sketch. This function takes the raw reading from the sensor, the smoothing value, and then the output variable. At present, the smoothing value is set to 0.8, but go ahead and experiment with this value to find the appropriate amount of smoothing for your application. This amount is dependent on how fast the loop is completed and how many readings are made in that time, so bear that in mind if you expect to add a lot of other controls or outputs:

[]{#c11.xhtml#c11-code-0032}[]{#c11.xhtml#c11-lntxt-0032}

`// simple lowpass filter to take out some of the jitter`{#c11.xhtml#c11-line-0308}

`  // change parameter (0 is min, .99 is max) or eliminate to suit`{#c11.xhtml#c11-line-0309}

`  smoothed = smooth(total, .8, smoothed);`{#c11.xhtml#c11-line-0310}

Finally, the values are printed to the serial port to be monitored. [`millis() – start`]{.Code-within-text} gives the time that is taken to carry out the reading. If more samples are taken or any delays are added to the code, these activities increase the time to complete the loop and, therefore, the reaction time of the sensor:

[]{#c11.xhtml#c11-code-0033}[]{#c11.xhtml#c11-lntxt-0033}

`Serial.print( millis() - start);      // time to execute in mS`{#c11.xhtml#c11-line-0311}

Tabs are used to neatly space the values. The total and smoothed values are both printed for comparison. You may notice a slight delay in the response time of the smoothed value. This delay shows you that your Arduino is reading many more values to do the smoothing, which takes time. This delay is barely noticeable when the sensor is in use because the baud rate is so high:

[]{#c11.xhtml#c11-code-0034}[]{#c11.xhtml#c11-lntxt-0034}

`Serial.print("\t");`{#c11.xhtml#c11-line-0312}

`Serial.print(total);                  // raw total`{#c11.xhtml#c11-line-0313}

`Serial.print("\t");`{#c11.xhtml#c11-line-0314}

`Serial.println((int) smoothed);       // smoothed`{#c11.xhtml#c11-line-0315}

`  delay(5);`{#c11.xhtml#c11-line-0316}

`}`{#c11.xhtml#c11-line-0317}

At the bottom of the sketch outside the main loop is an additional function, referred to as a *lowpass filter,* which gives you the smoothed result. You can see that rather than starting with [`void`]{.Code-within-text}, as is the case in [`setup ()`]{.Code-within-text} and [`loop ()`]{.Code-within-text}, the function starts with [`int`]{.Code-within-text}, which means that an integer value is returned. Starting with [`int`]{.Code-within-text} indicates that this function returns an integer value rather than a floating-point value. []{#c11.xhtml#Page_264 .pagebreak role="doc-pagebreak" title="264"}

[]{#c11.xhtml#c11-code-0035}[]{#c11.xhtml#c11-lntxt-0035}

`// simple lowpass filter`{#c11.xhtml#c11-line-0318}

`// requires recycling the output in the "smoothedVal" param`{#c11.xhtml#c11-line-0319}

`int smooth(int data, float filterVal, float smoothedVal){`{#c11.xhtml#c11-line-0320}

` `{#c11.xhtml#c11-line-0321}

`  if (filterVal > 1){      // check to make sure param's are within range`{#c11.xhtml#c11-line-0322}

`    filterVal = .999999;`{#c11.xhtml#c11-line-0323}

`  }`{#c11.xhtml#c11-line-0324}

`  else if (filterVal <= 0){`{#c11.xhtml#c11-line-0325}

`    filterVal = 0;`{#c11.xhtml#c11-line-0326}

`  }`{#c11.xhtml#c11-line-0327}

` `{#c11.xhtml#c11-line-0328}

`  smoothedVal = (data * (1 - filterVal)) + (smoothedVal  *  filterVal);`{#c11.xhtml#c11-line-0329}

` `{#c11.xhtml#c11-line-0330}

`  return (int)smoothedVal;`{#c11.xhtml#c11-line-0331}

`}`{#c11.xhtml#c11-line-0332}
:::
:::

::: {.section}
[]{#c11.xhtml#c11-sec-0016}

## Tripping Along with Lasers {#c11.xhtml#h2-5 .Heading-1}

*Laser trip wires* are made up of two parts, a laser light source and a light sensor. As you know from the movies, when the beam is broken, an alarm sounds and the henchmen come running. With an Arduino, you can make a laser trip wire simply and trigger anything you want from it. Rather than buy a state-of-the-art security system, you can build one yourself using a few simple components. You\'re on your own for the henchmen, though.

-   ::: {#c11.xhtml#c11-li-0055}
    **Complexity:** Lasers are a difficult subject area because of the potential risks of working with them. But rather than risk your eyesight or spend a few years studying, why not use something that's already been tested, certified, and turned into a product? Laser pens or laser pointers are widely available and relatively cheap. These are usually Class 1 lasers, the lowest class, and are visible and safe under all conditions of normal use, but you're still advised to check the specifications of your laser to ensure that it\'s appropriate for the audience and the environment. Adults are normally sensible enough not to look directly into the laser, but with children, you want to err on the side of caution and find another sensor.

    Because a laser beam is so precise, it's best to choose a large sensor to detect it so that you have a large area to aim for. The only added complexity of this sensor may be powering the laser. A laser pointer is usually battery powered (because it's not much use with a huge plug on the end), so you may need to replace the batteries every few days or wire a power supply of equal value to the battery compartment.

    []{#c11.xhtml#Page_265 .pagebreak role="doc-pagebreak" title="265"}To make the laser and the light sensor useful in the outside world, I recommend that you house them both in enclosures. A nice touch is to mount the enclosures on mini tripods to give you some flexibility when aligning them.
    :::

-   [**Cost:** For around \$15 you can purchase a small, discreet laser pointer from RadioShack. Battery life and beam color are the main differences between pointers. The light sensor costs around \$0.75 to \$2.50, depending on the size. If you opt for an enclosure, it may cost around \$6. A mini tripod is around \$10.]{#c11.xhtml#c11-li-0056}

-   [**Location:** If you have a fixed location for your trip wire, mounting the enclosure on either side of a doorway is simple. The best position is as low to the floor as possible to avoid eye contact with the laser. If you're not sure where you want the trip wire or want to try a few ideas, keep it mobile and take your tripod-mounted trip wire with you wherever it's needed. Laser trip wires make especially good camera triggers, which you can read more about in the "Hacking Other Hardware" bonus chapter at [[`www.dummies.com/go/arduinofd`]{.Code-within-text}](http://www.dummies.com/go/arduinofd).]{#c11.xhtml#c11-li-0057}

The laser trip wire is a refinement of a conventional light sensor. By providing a more intense, controlled light source, you can increase the accuracy of a simple light sensor.

In this example, you use a laser to make your light sensor achieve its full potential. By using the AnalogInOutSerial circuit, you can monitor the levels of your sensor when the laser is hitting it and look for the change when the laser is obscured. From this reading, you can trigger any number of outputs.

::: {.section}
[]{#c11.xhtml#c11-sec-0017}

### Implementing the AnalogInOutSerial sketch {#c11.xhtml#h3-9 .Heading-2}

To implement the AnalogInOutSerial sketch, you need the following:

-   [An Arduino Uno]{#c11.xhtml#c11-li-0058}
-   [A breadboard]{#c11.xhtml#c11-li-0059}
-   [A light sensor]{#c11.xhtml#c11-li-0060}
-   [An LED]{#c11.xhtml#c11-li-0061}
-   [A 10k ohm resistor]{#c11.xhtml#c11-li-0062}
-   [A 220 ohm resistor]{#c11.xhtml#c11-li-0063}
-   [Jump wires]{#c11.xhtml#c11-li-0064}

Complete the circuit shown in [Figures 11-8](#c11.xhtml#c11-fig-0008){#c11.xhtml#rc11-fig-0008} and [11-9](#c11.xhtml#c11-fig-0009){#c11.xhtml#rc11-fig-0009} to make the receiver side of the circuit. The laser pen can be battery powered or wired to a power supply of equal voltage as the batteries.[]{#c11.xhtml#Page_266 .pagebreak role="doc-pagebreak" title="266"}

::: {#c11.xhtml#c11-fig-0008 .figure}
![9781119489542-fg1108.png](https://i.imgur.com/OR4AuN2.jpeg){.center}
:::

::: {#c11.xhtml#c11-fig-0009 .figure}
![9781119489542-fg1109.png](https://i.imgur.com/XpA5o4m.jpeg){.center}
:::

Choose File ⇒   Examples ⇒   03.Analog ⇒   AnalogInOutSerial from the Arduino menu to load the sketch.

[]{#c11.xhtml#c11-code-0036}[]{#c11.xhtml#c11-lntxt-0036}

`/*`{#c11.xhtml#c11-line-0333}

`  Analog input, analog output, serial output`{#c11.xhtml#c11-line-0334}

` `{#c11.xhtml#c11-line-0335}

`  Reads an analog input pin, maps the result to a range from 0 to 255 and`{#c11.xhtml#c11-line-0336}

`  uses the result to set the pulse width modulation (PWM) of an output pin.`{#c11.xhtml#c11-line-0337}

`  Also prints the results to the Serial Monitor.`{#c11.xhtml#c11-line-0338}

` `{#c11.xhtml#c11-line-0339}

`  The circuit:`{#c11.xhtml#c11-line-0340}

`  - potentiometer connected to analog pin 0.`{#c11.xhtml#c11-line-0341}

`    Center pin of the potentiometer goes to the analog pin.`{#c11.xhtml#c11-line-0342}

`    side pins of the potentiometer go to +5V and ground`{#c11.xhtml#c11-line-0343}

`  - LED connected from digital pin 9 to ground`{#c11.xhtml#c11-line-0344}

` `{#c11.xhtml#c11-line-0345}

`  created 29 Dec. 2008`{#c11.xhtml#c11-line-0346}

`  modified 9 Apr 2012`{#c11.xhtml#c11-line-0347}

`  by Tom Igoe`{#c11.xhtml#c11-line-0348}

` `{#c11.xhtml#c11-line-0349}

`  This example code is in the public domain.`{#c11.xhtml#c11-line-0350}

` `{#c11.xhtml#c11-line-0351}

`  http://www.arduino.cc/en/Tutorial/AnalogInOutSerial`{#c11.xhtml#c11-line-0352}

`*/`{#c11.xhtml#c11-line-0353}

` `{#c11.xhtml#c11-line-0354}

`// These constants won't change.  They're used to give names`{#c11.xhtml#c11-line-0355}

`// to the pins used:`{#c11.xhtml#c11-line-0356}

`const int analogInPin = A0;   // Analog input pin that the potentiometer is`{#c11.xhtml#c11-line-0357}

`                              // attached to`{#c11.xhtml#c11-line-0358}

`const int analogOutPin = 9;   // Analog output pin that the LED is attached to`{#c11.xhtml#c11-line-0359}

` `{#c11.xhtml#c11-line-0360}

`int sensorValue = 0;          // value read from the pot`{#c11.xhtml#c11-line-0361}

`int outputValue = 0;          // value output to the PWM (analog out)`{#c11.xhtml#c11-line-0362}

` `{#c11.xhtml#c11-line-0363}

`void setup() {`{#c11.xhtml#c11-line-0364}

`  // initialize serial communications at 9600 bps:`{#c11.xhtml#c11-line-0365}

`  Serial.begin(9600);`{#c11.xhtml#c11-line-0366}

`}`{#c11.xhtml#c11-line-0367}

` `{#c11.xhtml#c11-line-0368}

`void loop() {`{#c11.xhtml#c11-line-0369}

`  // read the analog in value:`{#c11.xhtml#c11-line-0370}

`  sensorValue = analogRead(analogInPin);`{#c11.xhtml#c11-line-0371}

`  // map it to the range of the analog out:`{#c11.xhtml#c11-line-0372}

`  outputValue = map(sensorValue, 0, 1023, 0, 255);`{#c11.xhtml#c11-line-0373}

`  // change the analog out value:`{#c11.xhtml#c11-line-0374}

`  analogWrite(analogOutPin, outputValue);`{#c11.xhtml#c11-line-0375}

` `{#c11.xhtml#c11-line-0376}

`  // print the results to the serial monitor:`{#c11.xhtml#c11-line-0377}

`  Serial.print("sensor = " );`{#c11.xhtml#c11-line-0378}

`  Serial.print(sensorValue);`{#c11.xhtml#c11-line-0379}

`  Serial.print("\t output = ");`{#c11.xhtml#c11-line-0380}

`  Serial.println(outputValue);`{#c11.xhtml#c11-line-0381}

` `{#c11.xhtml#c11-line-0382}

`  // wait 2 milliseconds before the next loop`{#c11.xhtml#c11-line-0383}

`  // for the analog-to-digital converter to settle`{#c11.xhtml#c11-line-0384}

`  // after the last reading:`{#c11.xhtml#c11-line-0385}

`  delay(2);`{#c11.xhtml#c11-line-0386}

`}`{#c11.xhtml#c11-line-0387}

Press the Compile button to check your code. The compiler highlights any grammatical errors, which light up in red. If the sketch compiles correctly, click Upload to send the sketch to your board. When it has finished uploading, mount your laser so that it hits the center of the light sensor. Set the serial monitor to a baud rate of 9600 and you should see analog values at the high end of the range (1024 max). When you obstruct the beam, the range should drop and the LED should show the change. Experiment with the values in the [`map`]{.Code-within-text} function to determine the best range of values.

When the value drops below a certain threshold, you can trigger a variety of actions --- you have a highly sensitive trip wire sensor.

If nothing happens, double-check your wiring:

-   [Make sure that you\'re using the correct pin number.]{#c11.xhtml#c11-li-0065}
-   [Check the connections on the breadboard. If the jump wires or components are not connected using the correct rows in the breadboard, they do not work.]{#c11.xhtml#c11-li-0066}
:::

::: {.section}
[]{#c11.xhtml#c11-sec-0018}

### Understanding the AnalogInOutSerial sketch {#c11.xhtml#h3-10 .Heading-2}

For more details on the workings of this sketch, see the notes in AnalogInOutSerial in [Chapter 6](#c06.xhtml). You can also find suggestions for different sketches to provide smoothing and calibration in [Chapter 10](#c10.xhtml).
:::
:::

::: {.section}
[]{#c11.xhtml#Page_269 .pagebreak role="doc-pagebreak" title="269"}[]{#c11.xhtml#c11-sec-0019}

## Detecting Movement {#c11.xhtml#h2-6 .Heading-1}

A *passive infrared (PIR) sensor* is a common sensor in some homes and most commercial buildings. You may have seen this sensor in the corner of a room, blinking red every once in a while. It registers heat given off by people, animals, or other heat sources as infrared radiation. Infrared radiation is invisible to the human eye but is easy for the sensor to distinguish. The sensor itself is similar to the sensor found in a digital camera but without the complex lenses to capture a detailed picture. Essentially, a PIR sensor is somewhere between a high-resolution light sensor and a low-resolution camera. Simple lenses are usually fitted to PIR sensors to give them a wider viewing angle.

Most commonly, this type of sensor is used for motion detection in burglar alarms. Rather than detect motion, however, it detects changes in temperature. Temperature changes can trigger an alarm system or something more interesting (henchmen!), but the sensor is purely a way of monitoring changes in an environment.

You have two ways to get a PIR sensor. The first is to take apart a PIR burglar alarm, which is likely prepackaged with a lens and a sensor, which may be difficult to identify. The second method is to buy one specifically intended for microcontroller projects. This sensor most often comes with a basic, ping-pong-ball-styled lens and a bare circuit board underneath. The latter is easier to work with because all the details are known and it is described later in this section.

Consider the following during planning:

-   ::: {#c11.xhtml#c11-li-0067}
    **Complexity:** It can be tricky to hack an existing PIR sensor made for a specific system. Because it needs to communicate with that system, however, the sensor usually has clearly marked connections on the back. One of the benefits of using an existing sensor is that it is prepackaged, which reduces the amount of time you have to spend putting components together. Prepackaged systems are designed to be easy to install, so you may also be able to use manual calibration, by way of a potentiometer or a screwdriver slot, which can be a huge benefit for on-the-fly calibration rather than having to re-upload.

    If you're using a PIR sensor that is not prepackaged, it should be a lot more straightforward on the hardware and software side but requires careful thought concerning the housing. Some PIR sensors have their own on-board logic and operate like a switch, going [`HIGH`]{.Code-within-text} when movement occurs over the threshold. This kind of sensor needs calibration to identify change from the norm.
    :::

-   [**[]{#c11.xhtml#Page_270 .pagebreak role="doc-pagebreak" title="270"}Cost:** A household PIR sensor costs between \$15 and \$45. The main expense is the housing, which is usually designed to be discreet or look suitably high-tech. Bare PIR sensors cost a fraction of the price at around \$10, but need a suitable housing to be of any real use.]{#c11.xhtml#c11-li-0068}

-   [**Location:** Many housings allow you to neatly fit the sensor against a wall. Or you might consider using mini tripods for direction, as suggested in the previous section. Some of the tripod mounts also come with a suction-cup mount, which is perfect for fixing your sensor to smooth surfaces such as glass.]{#c11.xhtml#c11-li-0069}

Most PIR sensors come ready for action, needing only power. They calibrate themselves based on what they can see and then send a [`HIGH`]{.Code-within-text} or [`LOW`]{.Code-within-text} value when they detect change. This makes them easy to program because you\'re dealing with the same signals as with a pushbutton.

::: {.section}
[]{#c11.xhtml#c11-sec-0020}

### Implementing the DigitalReadSerial sketch {#c11.xhtml#h3-11 .Heading-2}

In the DigitalReadSerial sketch example, you learn how to use the SE-10, a PIR sensor available from all major Arduino retailers. This PIR sensor has three wires: red, brown, and black. The red wire is the power source and should be connected to 5V. Oddly, the black wire is the signal wire and not the ground (see [Figure 11-10](#c11.xhtml#c11-fig-0010){#c11.xhtml#rc11-fig-0010}; the black is the leftmost wire, brown is in the middle, and red is on the right). Brown should be wired to ground and black to pin 2.

::: {#c11.xhtml#c11-fig-0010 .figure}
![9781119489542-fg1110.png](https://i.imgur.com/dcdPQHd.jpeg){.center}
:::

The signal pin is known as an open collector and needs to be pulled [`HIGH`]{.Code-within-text} to start with. To do so, you use a 10k resistor to connect it to 5V as well. The pin, therefore, reads [`HIGH`]{.Code-within-text} when no motion occurs and is pulled to [`LOW`]{.Code-within-text} when there is motion.

You need the following:

-   [An Arduino Uno]{#c11.xhtml#c11-li-0070}
-   [A breadboard]{#c11.xhtml#c11-li-0071}
-   [An SE-10 PIR motion sensor]{#c11.xhtml#c11-li-0072}
-   [A 10k ohm resistor]{#c11.xhtml#c11-li-0073}
-   [Jump wires]{#c11.xhtml#c11-li-0074}

Lay out the circuit as in the layout and circuit diagrams shown in [Figures 11-11](#c11.xhtml#c11-fig-0011){#c11.xhtml#rc11-fig-0011} and [11-12](#c11.xhtml#c11-fig-0012){#c11.xhtml#rc11-fig-0012}.

::: {#c11.xhtml#c11-fig-0011 .figure}
![9781119489542-fg1111.png](https://i.imgur.com/qHh2DxG.jpeg){.center}
:::

::: {#c11.xhtml#c11-fig-0012 .figure}
![9781119489542-fg1112.png](https://i.imgur.com/CWOKx4P.jpeg){.center}
:::

Complete the circuit and choose File ⇒   Examples ⇒   01.Basics ⇒   DigitalReadSerial from the Arduino menu to load the sketch. This sketch is intended for a pushbutton, not a PIR sensor, but follows the same principles. If you want to make the sketch more specific, save it with a more appropriate file name and variable names.

[]{#c11.xhtml#c11-code-0037}[]{#c11.xhtml#c11-lntxt-0037}

`/*`{#c11.xhtml#c11-line-0388}

`  DigitalReadSerial`{#c11.xhtml#c11-line-0389}

` `{#c11.xhtml#c11-line-0390}

`  Reads a digital input on pin 2, prints the result to the Serial Monitor`{#c11.xhtml#c11-line-0391}

` `{#c11.xhtml#c11-line-0392}

`  This example code is in the public domain.`{#c11.xhtml#c11-line-0393}

` `{#c11.xhtml#c11-line-0394}

`  http://www.arduino.cc/en/Tutorial/DigitalReadSerial`{#c11.xhtml#c11-line-0395}

`*/`{#c11.xhtml#c11-line-0396}

` `{#c11.xhtml#c11-line-0397}

`// digital pin 2 has a pushbutton attached to it. Give it a name:`{#c11.xhtml#c11-line-0398}

`int pushButton = 2;`{#c11.xhtml#c11-line-0399}

` `{#c11.xhtml#c11-line-0400}

`// the setup routine runs once when you press reset:`{#c11.xhtml#c11-line-0401}

`void setup() {`{#c11.xhtml#c11-line-0402}

`  // initialize serial communication at 9600 bits per second:`{#c11.xhtml#c11-line-0403}

`  Serial.begin(9600);`{#c11.xhtml#c11-line-0404}

`  // make the pushbutton's pin an input:`{#c11.xhtml#c11-line-0405}

`  pinMode(pushButton, INPUT);`{#c11.xhtml#c11-line-0406}

`}`{#c11.xhtml#c11-line-0407}

` `{#c11.xhtml#c11-line-0408}

`// the loop routine runs over and over again forever:`{#c11.xhtml#c11-line-0409}

`void loop() {`{#c11.xhtml#c11-line-0410}

`  // read the input pin:`{#c11.xhtml#c11-line-0411}

`  int buttonState = digitalRead(pushButton);`{#c11.xhtml#c11-line-0412}

`  // print out the state of the button:`{#c11.xhtml#c11-line-0413}

`  Serial.println(buttonState);`{#c11.xhtml#c11-line-0414}

`  delay(1);        // delay in between reads for stability`{#c11.xhtml#c11-line-0415}

`}`{#c11.xhtml#c11-line-0416}

Press the Compile button to check your code. Doing so highlights any grammatical errors and turns them red. If the sketch compiles correctly, click Upload to send the sketch to your board. When it has finished uploading, affix the PIR sensor to a surface that is free of movement. Then open the serial monitor, which resets the sketch. The sensor calibrates itself in the first 1 to 2 seconds. When movement is detected, you should see the [`buttonState`]{.Code-within-text} value change from 1 (no movement) to 0 (movement).

If nothing happens, double-check your wiring:

-   [Make sure that you\'re using the correct pin number.]{#c11.xhtml#c11-li-0075}
-   [Check the connections on the breadboard. If the jump wires or components are not connected using the correct rows in the breadboard, they will not work.]{#c11.xhtml#c11-li-0076}
-   [Try restarting the PIR sensor by disconnecting and reconnecting the GND wire, and be sure that it does not move during or after calibration.]{#c11.xhtml#c11-li-0077}
:::

::: {.section}
[]{#c11.xhtml#c11-sec-0021}

### Understanding the DigitalReadSerial sketch {#c11.xhtml#h3-12 .Heading-2}

The only variable to declare is pin 2, the [`pushButton`]{.Code-within-text} pin, or in this case the [`pirSensor`]{.Code-within-text} pin:

[]{#c11.xhtml#c11-code-0038}[]{#c11.xhtml#c11-lntxt-0038}

`// digital pin 2 has a pushbutton attached to it. Give it a name:`{#c11.xhtml#c11-line-0417}

`int pushButton = 2;`{#c11.xhtml#c11-line-0418}

In [`setup`]{.Code-within-text}, the serial port is opened and set to a baud rate of 9600; the input pin is set to an output:

[]{#c11.xhtml#c11-code-0039}[]{#c11.xhtml#c11-lntxt-0039}

`// the setup routine runs once when you press reset:`{#c11.xhtml#c11-line-0419}

`void setup() {`{#c11.xhtml#c11-line-0420}

`  // initialize serial communication at 9600 bits per second:`{#c11.xhtml#c11-line-0421}

`  Serial.begin(9600);`{#c11.xhtml#c11-line-0422}

`  // make the pushbutton's pin an input:`{#c11.xhtml#c11-line-0423}

`  pinMode(pushButton, INPUT);`{#c11.xhtml#c11-line-0424}

`}`{#c11.xhtml#c11-line-0425}

[]{#c11.xhtml#Page_274 .pagebreak role="doc-pagebreak" title="274"} In [`loop ()`]{.Code-within-text}, the input pin is read and its value stored in [`buttonState`]{.Code-within-text}. This value reads [`HIGH`]{.Code-within-text} when no movement is occurring because the pull-up resistor is providing a voltage from the 5V pin. When there is movement, the open collector grounds the voltage and reads [`LOW`]{.Code-within-text}:

[]{#c11.xhtml#c11-code-0040}[]{#c11.xhtml#c11-lntxt-0040}

`// the loop routine runs over and over again forever:`{#c11.xhtml#c11-line-0426}

`void loop() {`{#c11.xhtml#c11-line-0427}

`  // read the input pin:`{#c11.xhtml#c11-line-0428}

`  int buttonState = digitalRead(pushButton);`{#c11.xhtml#c11-line-0429}

The value of the input is then printed to the serial monitor:

[]{#c11.xhtml#c11-code-0041}[]{#c11.xhtml#c11-lntxt-0041}

`  // print out the state of the button:`{#c11.xhtml#c11-line-0430}

`  Serial.println(buttonState);`{#c11.xhtml#c11-line-0431}

`  delay(1);        // delay in between reads for stability`{#c11.xhtml#c11-line-0432}

`}`{#c11.xhtml#c11-line-0433}

![technicalstuff.png](https://i.imgur.com/Hc916Jm.jpeg) This is one example of how to use existing code for different hardware. From this point, it is possible to trigger different outputs based on the [`HIGH`]{.Code-within-text} or [`LOW`]{.Code-within-text} signal of the PIR sensor. For ease of use and the clarity of other people who might use your code, rename variables to more appropriate names, add your own comments, and save the sketch so that you can easily distinguish it from the pushbutton sketch.
:::
:::

::: {.section}
[]{#c11.xhtml#c11-sec-0022}

## Measuring Distance {#c11.xhtml#h2-7 .Heading-1}

Two sensors for measuring distance that are extremely popular are the infrared proximity sensor and the ultrasonic range finder. They work in similar ways and achieve pretty much the same thing, but it\'s important to choose the right sensor for the environment you're in. An *infrared proximity sensor* has a light source and a sensor. The light source bounces infrared light off an object and back to the sensor, and the time it takes the light to return is measured to indicate the object\'s distance.

An *ultrasonic range finder* fires out high-frequency sound waves and listens for an echo when they hit a solid surface. By measuring the time it takes a signal to bounce back, the ultrasonic range finder can determine the distance traveled.

Infrared proximity sensors are not as accurate and have a much shorter range than ultrasonic range finders.

[]{#c11.xhtml#Page_275 .pagebreak role="doc-pagebreak" title="275"}Consider the following during planning:

-   [**Complexity:** Both sensors are designed to be easy to integrate with Arduino projects. In the real world, they're used for similar electronics applications, such as proximity meters on the back of cars that beep as you approach the curb. Again, the main complexity is housing them effectively. Infrared proximity sensors such as those made by Shape have useful screw holes on the outside of the body of the sensor. MaxBotix makes ultrasonic range finders that don\'t have these mounts, but their cylindrical shape makes them simple to mount by drilling a hole through a surface or housing.]{#c11.xhtml#c11-li-0078}
-   [**Cost:** Infrared proximity sensors cost in the region of \$15 and have a range up to about 59 inches (150 cm). Ultrasonic range finders have a far greater possible range and accuracy but an equally great price, costing between \$25 for a sensor that can read up to 254 inches (645 cm) and \$100 for a more weather-resistant model that can read up to 301 inches (765 cm).]{#c11.xhtml#c11-li-0079}
-   [**Location:** A common application for these sensors is monitoring the presence of a person or an object in a particular floor space, especially when a pressure pad would be too obvious or easy to avoid, or when a PIR sensor would measure too widely. Using a proximity sensor lets you know where someone is in a straight line from that sensor, making it a useful tool.]{#c11.xhtml#c11-li-0080}

IR proximity sensors are okay in dark environments but perform terribly in direct sunlight. The MaxBotix ultrasonic range finder is one of my favorite and most reliable sensors. When using ultrasonic range finders, you can also choose how wide or narrow a beam you want. A large, teardrop-shaped sensor is perfect for detecting large objects moving in a general direction, whereas narrow beams are great for precision measurements.

::: {.section}
[]{#c11.xhtml#c11-sec-0023}

### Implementing the MaxSonar sketch {#c11.xhtml#h3-13 .Heading-2}

In this example, you learn how to measure precise distances using a MaxBotix LV-EZ0. The EZ0, EZ1, EZ2, EZ3, and EZ4 all work the same way, but each has a slightly narrower beam, so choose the appropriate one for your project.

The range finder needs some minor assembly. To use the range finder in your circuit, you need to solder on either header pins (to use the range finder on a breadboard) or lengths of wire.

You can connect your range finder by using analog, pulse width, or serial communication. In this example, you learn how to measure the pulse width and convert that to distance. The analog output can be read straight into your analog input pins, but it provides less accurate results than pulse width. This example does not cover serial communication.

[]{#c11.xhtml#Page_276 .pagebreak role="doc-pagebreak" title="276"}You need the following for the MaxSonar sketch:

-   [An Arduino Uno]{#c11.xhtml#c11-li-0081}
-   [An LV-EZ0 ultrasonic range finder]{#c11.xhtml#c11-li-0082}
-   [Jump wires]{#c11.xhtml#c11-li-0083}

Complete the circuit from the layout and circuit diagrams in [Figures 11-13](#c11.xhtml#c11-fig-0013){#c11.xhtml#rc11-fig-0013} and [11-14](#c11.xhtml#c11-fig-0014){#c11.xhtml#rc11-fig-0014}. The connections for the range finder are clearly marked on the underside of the PCB. The 5V and GND connections provide power for the sensor and should be connected to the 5V and GND supplies on your Arduino. The PW connection is the pulse-width signal that will be read by pin 7 on your Arduino. Make sure that your distance sensor is affixed to some sort of base pointed in the direction that you want to measure.

::: {#c11.xhtml#c11-fig-0013 .figure}
![9781119489542-fg1113.png](https://i.imgur.com/oP4fbS3.jpeg){.center}
:::

::: {#c11.xhtml#c11-fig-0014 .figure}
![9781119489542-fg1114.png](https://i.imgur.com/rzjy8dD.jpeg){.center}
:::

You can find the MaxSonar code by Bruce Allen, along with some additional notes and functions, in the Arduino playground at [[`www.arduino.cc/playground/Main/MaxSonar`]{.Code-within-text}](http://www.arduino.cc/playground/Main/MaxSonar). Create a new sketch, copy or type the code into it, and save it with a memorable name, such as [`myMaxSonar`]{.Code-within-text}:

[]{#c11.xhtml#c11-code-0042}[]{#c11.xhtml#c11-lntxt-0042}

`//Feel free to use this code.`{#c11.xhtml#c11-line-0434}

`//Please be respectful by acknowledging the author in the code if you use or modify it.`{#c11.xhtml#c11-line-0435}

`//Author: Bruce Allen`{#c11.xhtml#c11-line-0436}

`//Date: 23/07/09`{#c11.xhtml#c11-line-0437}

`//Digital pin 7 for reading in the pulse width from the MaxSonar device.`{#c11.xhtml#c11-line-0438}

`//This variable is a constant because the pin will not change throughout execution of this code.`{#c11.xhtml#c11-line-0439}

`const int pwPin = 7;`{#c11.xhtml#c11-line-0440}

`//variables needed to store values`{#c11.xhtml#c11-line-0441}

`long pulse, inches, cm;`{#c11.xhtml#c11-line-0442}

` `{#c11.xhtml#c11-line-0443}

`void setup() {`{#c11.xhtml#c11-line-0444}

`  //This opens up a serial connection to shoot the results back to the PC console`{#c11.xhtml#c11-line-0445}

`  Serial.begin(9600);`{#c11.xhtml#c11-line-0446}

`}`{#c11.xhtml#c11-line-0447}

` `{#c11.xhtml#c11-line-0448}

`void loop() {`{#c11.xhtml#c11-line-0449}

` `{#c11.xhtml#c11-line-0450}

`  pinMode(pwPin, INPUT);`{#c11.xhtml#c11-line-0451}

` `{#c11.xhtml#c11-line-0452}

`    //Used to read in the pulse that is being sent by the MaxSonar device.`{#c11.xhtml#c11-line-0453}

`  //Pulse Width representation with a scale factor of 147 uS per Inch.`{#c11.xhtml#c11-line-0454}

` `{#c11.xhtml#c11-line-0455}

`  pulse = pulseIn(pwPin, HIGH);`{#c11.xhtml#c11-line-0456}

`  //147uS per inch`{#c11.xhtml#c11-line-0457}

`  inches = pulse/147;`{#c11.xhtml#c11-line-0458}

`  //change inches to centimetres`{#c11.xhtml#c11-line-0459}

`  cm = inches * 2.54;`{#c11.xhtml#c11-line-0460}

` `{#c11.xhtml#c11-line-0461}

`  Serial.print(inches);`{#c11.xhtml#c11-line-0462}

`  Serial.print("in, ");`{#c11.xhtml#c11-line-0463}

`  Serial.print(cm);`{#c11.xhtml#c11-line-0464}

`  Serial.print("cm");`{#c11.xhtml#c11-line-0465}

`  Serial.println();`{#c11.xhtml#c11-line-0466}

` `{#c11.xhtml#c11-line-0467}

`  delay(500);`{#c11.xhtml#c11-line-0468}

` `{#c11.xhtml#c11-line-0469}

`}`{#c11.xhtml#c11-line-0470}

Press the Compile button to check your code. The compiler highlights any grammatical errors, turning them red. If the sketch compiles correctly, click Upload to send the sketch to your board. When it has finished uploading, open the serial monitor to see the distance measured in inches and centimeters. If the value is fluctuating, try using an object with a bigger surface.

This sketch allows you to accurately measure distance in a straight line. Check the results with a tape measure and make adjustments to the code if you find discrepancies.

If nothing happens, double-check your wiring:

-   [Make sure that you\'re using the correct pin number.]{#c11.xhtml#c11-li-0084}
-   [Check the connections on the breadboard. If the jump wires or components are not connected using the correct rows in the breadboard, they will not work.]{#c11.xhtml#c11-li-0085}
:::

::: {.section}
[]{#c11.xhtml#c11-sec-0024}

### Understanding the MaxSonar sketch {#c11.xhtml#h3-14 .Heading-2}

In the declarations, pin 7 is defined as the [`pwPin`]{.Code-within-text}:

[]{#c11.xhtml#c11-code-0043}[]{#c11.xhtml#c11-lntxt-0043}

`//This variable is a constant because the pin will not change throughout execution of this code.`{#c11.xhtml#c11-line-0471}

`const int pwPin = 7;`{#c11.xhtml#c11-line-0472}

[]{#c11.xhtml#Page_279 .pagebreak role="doc-pagebreak" title="279"} [`long`]{.Code-within-text} variables are used to store the pulse width and distances in inches and centimeters. Note that you can declare all three in a list if they have no value:

[]{#c11.xhtml#c11-code-0044}[]{#c11.xhtml#c11-lntxt-0044}

`//variables needed to store values`{#c11.xhtml#c11-line-0473}

`long pulse, inches, cm;`{#c11.xhtml#c11-line-0474}

In [`setup`]{.Code-within-text}, the serial connection is opened to print the results:

[]{#c11.xhtml#c11-code-0045}[]{#c11.xhtml#c11-lntxt-0045}

`void setup() {`{#c11.xhtml#c11-line-0475}

`  //This opens up a serial connection to shoot the results back to the PC console`{#c11.xhtml#c11-line-0476}

`  Serial.begin(9600);`{#c11.xhtml#c11-line-0477}

`}`{#c11.xhtml#c11-line-0478}

In the main [`loop ()`]{.Code-within-text},[`pwPin`]{.Code-within-text} is set as an input. You can set the input in [`loop ()`]{.Code-within-text} or move it to [`setup ()`]{.Code-within-text}:

[]{#c11.xhtml#c11-code-0046}[]{#c11.xhtml#c11-lntxt-0046}

`void loop() {`{#c11.xhtml#c11-line-0479}

` `{#c11.xhtml#c11-line-0480}

`  pinMode(pwPin, INPUT);`{#c11.xhtml#c11-line-0481}

You use the [`pulseIn`]{.Code-within-text} function to return the length of time it takes the pulse to return to the sensor in microseconds, or μS:

[]{#c11.xhtml#c11-code-0047}[]{#c11.xhtml#c11-lntxt-0047}

`    //Used to read in the pulse that is being sent by the MaxSonar device.`{#c11.xhtml#c11-line-0482}

`  //Pulse Width representation with a scale factor of 147 uS per Inch.`{#c11.xhtml#c11-line-0483}

` `{#c11.xhtml#c11-line-0484}

`  pulse = pulseIn(pwPin, HIGH);`{#c11.xhtml#c11-line-0485}

A pulse travels 1 inch every 147 μS, so you can calculate the number of inches based on the time. From this information, a simple conversion outputs the distance in different units:

[]{#c11.xhtml#c11-code-0048}[]{#c11.xhtml#c11-lntxt-0048}

`  //147uS per inch`{#c11.xhtml#c11-line-0486}

`  inches = pulse/147;`{#c11.xhtml#c11-line-0487}

`  //change inches to centimetres`{#c11.xhtml#c11-line-0488}

`  cm = inches * 2.54;`{#c11.xhtml#c11-line-0489}

The results are printed to the serial monitor, with [`Serial.println`]{.Code-within-text} at the end to start a new line in between each reading:

[]{#c11.xhtml#c11-code-0049}[]{#c11.xhtml#c11-lntxt-0049}

`  Serial.print(inches);`{#c11.xhtml#c11-line-0490}

`  Serial.print("in, ");`{#c11.xhtml#c11-line-0491}

`  Serial.print(cm);`{#c11.xhtml#c11-line-0492}

`  Serial.print("cm");`{#c11.xhtml#c11-line-0493}

`  Serial.println();`{#c11.xhtml#c11-line-0494}

A delay is added to slow the readings for legibility, but you can remove the delay if responsiveness is more important:

[]{#c11.xhtml#c11-code-0050}[]{#c11.xhtml#c11-lntxt-0050}

`  delay(500);`{#c11.xhtml#c11-line-0495}

` `{#c11.xhtml#c11-line-0496}

`}`{#c11.xhtml#c11-line-0497}

The preceding code provides you with an accurate distance reading that you can incorporate into your own projects. A simple way to make use of this reading is with an [`if`]{.Code-within-text} statement. For example:

[]{#c11.xhtml#c11-code-0051}[]{#c11.xhtml#c11-lntxt-0051}

`if (cm < 50) {`{#c11.xhtml#c11-line-0498}

`// do something!`{#c11.xhtml#c11-line-0499}

`}`{#c11.xhtml#c11-line-0500}
:::
:::

::: {.section}
[]{#c11.xhtml#c11-sec-0025}

## Testing, Testing ... Can Anybody Hear This? {#c11.xhtml#h2-8 .Heading-1}

Sound is another way to detect presence, and the best way to do it is with an electret microphone. It's common to think of sounds in their analog form as recognizable noises, but a lot of the sounds you hear every day have undergone an analog-to-digital conversion. By converting sound into a digital signal, it's possible to interpret it on a computer or an Arduino. An *electret microphone* is similar to the microphones found in computer headsets and is extremely sensitive, but it needs an amplifier for the Arduino to register the readings.

Consider the following during your planning:

-   [**Complexity:** You can choose from plenty of electret mics, but by far the easiest is SparkFun's electret microphone breakout. It comes preassembled with the mic mounted on a circuit board and with an amplifier, and can be easily wired to an Arduino as an analog input. It\'s possible to use electret mics from other headsets or desktop microphones, but these need their own []{#c11.xhtml#Page_281 .pagebreak role="doc-pagebreak" title="281"}amplifier to be of any use. Some work is involved to make the correct housing for the mic to protect it from the environment or human contact, but this housing could be a simple enclosure with a hole.]{#c11.xhtml#c11-li-0086}
-   [**Cost:** The microphone itself is extremely cheap at 90 cents from SparkFun (or distributors of their products). The breakout board costs \$5.95, which is not a huge expense for the amount of labor saved.]{#c11.xhtml#c11-li-0087}
-   [**Location:** As an ambient sensor, the mic could be placed just about anywhere to map the noise levels in a room. If you're listening for a specific noise such as a door slamming, it may be best to place the microphone near that source to get a clear reading.]{#c11.xhtml#c11-li-0088}

One unusual use for a mic is monitoring someone's breath. Because the mic measures the amplitude or volume of the sound, it's perfect for this application. By placing the mic at the end of a tube, it's even possible to monitor the length and intensity of breaths as the air rushes past the mic.

Electret mics are great for measuring the amplitude or volume of noise, which can be used to trigger a variety of outputs.

::: {.section}
[]{#c11.xhtml#c11-sec-0026}

### Implementing the AnalogInOutSerial sketch {#c11.xhtml#h3-15 .Heading-2}

In this example, you monitor sound levels wherever you are using an electret mic. This simple sensor can be read as an analog input into your Arduino.

You need the following:

-   [An Arduino Uno]{#c11.xhtml#c11-li-0089}
-   [An electret microphone breakout board]{#c11.xhtml#c11-li-0090}
-   [Jump wires]{#c11.xhtml#c11-li-0091}

Complete the circuit from the layout and circuit diagrams in [Figures 11-15](#c11.xhtml#c11-fig-0015){#c11.xhtml#rc11-fig-0015} and [11-16](#c11.xhtml#c11-fig-0016){#c11.xhtml#rc11-fig-0016} to connect the mic as your input. The electret microphone breakout board requires a small amount of soldering to use it on a breadboard or connect it to your Arduino. You can solder on either a set of three header pins or a length of wire, depending on your situation.[]{#c11.xhtml#Page_282 .pagebreak role="doc-pagebreak" title="282"}

::: {#c11.xhtml#c11-fig-0015 .figure}
![9781119489542-fg1115.png](https://i.imgur.com/CnhunRT.jpeg){.center}
:::

::: {#c11.xhtml#c11-fig-0016 .figure}
![9781119489542-fg1116.png](https://i.imgur.com/RnNSCpq.jpeg){.center}
:::

Choose File ⇒   Examples ⇒   03.Analog ⇒   AnalogInOutSerial from the Arduino menu to load the sketch.

[]{#c11.xhtml#c11-code-0052}[]{#c11.xhtml#c11-lntxt-0052}

`/*`{#c11.xhtml#c11-line-0501}

`  Analog input, analog output, serial output`{#c11.xhtml#c11-line-0502}

` `{#c11.xhtml#c11-line-0503}

`  Reads an analog input pin, maps the result to a range from 0 to 255 and`{#c11.xhtml#c11-line-0504}

`  uses the result to set the pulse width modulation (PWM) of an output pin.`{#c11.xhtml#c11-line-0505}

`  Also prints the results to the Serial Monitor.`{#c11.xhtml#c11-line-0506}

` `{#c11.xhtml#c11-line-0507}

`  The circuit:`{#c11.xhtml#c11-line-0508}

`  - potentiometer connected to analog pin 0.`{#c11.xhtml#c11-line-0509}

`    Center pin of the potentiometer goes to the analog pin.`{#c11.xhtml#c11-line-0510}

`    side pins of the potentiometer go to +5V and ground`{#c11.xhtml#c11-line-0511}

`  - LED connected from digital pin 9 to ground`{#c11.xhtml#c11-line-0512}

` `{#c11.xhtml#c11-line-0513}

`  created 29 Dec. 2008`{#c11.xhtml#c11-line-0514}

`  modified 9 Apr 2012`{#c11.xhtml#c11-line-0515}

`  by Tom Igoe`{#c11.xhtml#c11-line-0516}

` `{#c11.xhtml#c11-line-0517}

`  This example code is in the public domain.`{#c11.xhtml#c11-line-0518}

` `{#c11.xhtml#c11-line-0519}

`  http://www.arduino.cc/en/Tutorial/AnalogInOutSerial`{#c11.xhtml#c11-line-0520}

`*/`{#c11.xhtml#c11-line-0521}

` `{#c11.xhtml#c11-line-0522}

`// These constants won't change.  They're used to give names`{#c11.xhtml#c11-line-0523}

`// to the pins used:`{#c11.xhtml#c11-line-0524}

`const int analogInPin = A0;  // Analog input pin that the potentiometer is attached to`{#c11.xhtml#c11-line-0525}

`const int analogOutPin = 9; // Analog output pin that the LED is attached to`{#c11.xhtml#c11-line-0526}

` `{#c11.xhtml#c11-line-0527}

`int sensorValue = 0;        // value read from the pot`{#c11.xhtml#c11-line-0528}

`int outputValue = 0;        // value output to the PWM (analog out)`{#c11.xhtml#c11-line-0529}

` `{#c11.xhtml#c11-line-0530}

`void setup() {`{#c11.xhtml#c11-line-0531}

`  // initialize serial communications at 9600 bps:`{#c11.xhtml#c11-line-0532}

`  Serial.begin(9600);`{#c11.xhtml#c11-line-0533}

`}`{#c11.xhtml#c11-line-0534}

` `{#c11.xhtml#c11-line-0535}

`void loop() {`{#c11.xhtml#c11-line-0536}

`  // read the analog in value:`{#c11.xhtml#c11-line-0537}

`  sensorValue = analogRead(analogInPin);`{#c11.xhtml#c11-line-0538}

`  // map it to the range of the analog out:`{#c11.xhtml#c11-line-0539}

`  outputValue = map(sensorValue, 0, 1023, 0, 255);`{#c11.xhtml#c11-line-0540}

`  // change the analog out value:`{#c11.xhtml#c11-line-0541}

`  analogWrite(analogOutPin, outputValue);`{#c11.xhtml#c11-line-0542}

` `{#c11.xhtml#c11-line-0543}

`  // print the results to the serial monitor:`{#c11.xhtml#c11-line-0544}

`  Serial.print("sensor = " );`{#c11.xhtml#c11-line-0545}

`  Serial.print(sensorValue);`{#c11.xhtml#c11-line-0546}

`  Serial.print("\t output = ");`{#c11.xhtml#c11-line-0547}

`  Serial.println(outputValue);`{#c11.xhtml#c11-line-0548}

` `{#c11.xhtml#c11-line-0549}

`  // wait 2 milliseconds before the next loop`{#c11.xhtml#c11-line-0550}

`  // for the analog-to-digital converter to settle`{#c11.xhtml#c11-line-0551}

`  // after the last reading:`{#c11.xhtml#c11-line-0552}

`  delay(2);`{#c11.xhtml#c11-line-0553}

`}`{#c11.xhtml#c11-line-0554}

Press the Compile button to check your code. Doing so highlights any grammatical errors and turns them red. If the sketch compiles correctly, click Upload to send the sketch to your board. When it has finished uploading, open the serial monitor to see analog values in the range of 0 to 1024.

If nothing happens, double-check your wiring:

-   [Make sure that you're using the correct pin number.]{#c11.xhtml#c11-li-0092}
-   [Check the connections on the breadboard. If the jump wires or components are not connected using the correct rows in the breadboard, they will not work.]{#c11.xhtml#c11-li-0093}

See what range of values you get from different noises in your environment and how sensitive or overly sensitive the mic is. Another sketch to consider is the Smoothing sketch in [Chapter 10](#c10.xhtml).
:::

::: {.section}
[]{#c11.xhtml#c11-sec-0027}

### Understanding the AnalogInOutSerial sketch {#c11.xhtml#h3-16 .Heading-2}

For more details on the workings of this sketch, see the notes in AnalogInOutSerial in [Chapter 6](#c06.xhtml). You can also find suggestions for different sketches to provide smoothing and calibration in [Chapter 10](#c10.xhtml).
:::
:::

[]{#c12.xhtml}

[]{#c12.xhtml#Page_285 .pagebreak role="doc-pagebreak" title="285"}Chapter 12

# Becoming a Specialist with Shields and Libraries {#c12.xhtml#a1 .Chap-Title}

::: {.section}
[]{#c12.xhtml#c12-sec-0001}[]{#c12.xhtml#c12-feafxd-0001}

IN THIS CHAPTER

![check.png](https://i.imgur.com/rewCpQN.jpeg) **Finding out about shields**

![check.png](https://i.imgur.com/oH5yvc4.jpeg) **Looking at the range of shields available**

![check.png](https://i.imgur.com/NuuBsi9.jpeg) **Understanding libraries**

The further you progress in learning about Arduino, the more you want to do, and it's natural to want to run before you can walk. The areas that interest you may be highly specialized in themselves and require a huge investment of time to understand. Perhaps the most important thing about Arduino is the Arduino community, which is where you can get help when you want go further.

The traditional viewpoint that is hammered into us in education is to protect our ideas for dear life. Thankfully, many people in the Arduino community have seen past that limitation and are kind enough to share their hard work. By sharing this knowledge, the Arduino community helps the hardware and software become available to more people, who find new and interesting uses for it. If these people in turn share their results, the community continues to grow and eventually makes even the most difficult projects achievable. In this chapter, you discover the power of shared resources such as shields and libraries, even for beginners.
:::

::: {.section}
[]{#c12.xhtml#Page_286 .pagebreak role="doc-pagebreak" title="286"}[]{#c12.xhtml#c12-sec-0002}

## Looking at Shields {#c12.xhtml#h2-1 .Heading-1}

*Shields* are pieces of hardware that sit on top of your Arduino, often to give it a specific purpose. For example, you can use a shield to make it easier to connect and control motors or even to turn your Arduino into something as complex as a mobile phone. A shield may start out as an interesting bit of hardware that an enthusiast has been experimenting with and wants to share with the community. Or an enterprising individual (or company) may design a shield to make an application easier based on demand from the Arduino community.

Shields can be simple or complex. They are sold preassembled or as kits. Kits allow you more freedom to assemble the shield as you need it to be. Some kits require you to assemble the circuitry of the boards, although more complex shields may already be largely assembled, needing only header pins.

Shields enable you to use your Arduino for more than one purpose and to change that purpose easily. They neatly package the electronics for that circuit in the same footprint as an Arduino, and are stackable to combine different functionalities. But they all have to use the same pins on the Arduino, so if you stack shields, watch out for those that need to use the same pins. They always connect the GND pins, too, because any communication by your Arduino and another device needs a common GND.

::: {.section}
[]{#c12.xhtml#c12-sec-0003}

### Considering combinations {#c12.xhtml#h3-1 .Heading-2}

In theory, shields could be stacked on top of each other forever, but you should take some points into consideration before combining them:

-   [**Physical size:** Some shields just don't fit on top of one another. Components that are higher than the header sockets may touch the underside of any board on top of it. This situation, which can cause short circuits if a connection is made that shouldn't be, can seriously damage your boards.]{#c12.xhtml#c12-li-0004}
-   [**Obstruction of inputs and outputs:** If an input or output is obstructed by another shield, it becomes redundant. For example, there's no point having a joystick shield or an LCD shield under another shield because no more than one can be used.]{#c12.xhtml#c12-li-0005}
-   [**Power requirements:** Some hardware requires a lot of power. Although it is all right for shields to use the same power and ground pins, there is a limit to the amount of current that can flow through the other input/output (I/O) pins: 40mA per pin and 200mA max between all I/O pins. Exceed this, and you run the risk of seriously damaging your board and any other attached shield. In most cases, you can easily remedy this problem by powering your Arduino []{#c12.xhtml#Page_287 .pagebreak role="doc-pagebreak" title="287"}and shields from an external power supply so that the current isn't passed through the Arduino. Make sure to use a common GND if you're communicating between a board using I2C, SPI, or serial.]{#c12.xhtml#c12-li-0006}
-   [**Pins:** Some shields require the use of certain pins. It's important to make sure that shields aren't doubling up on the same pins. In the best case, the hardware will just be confused; in the worst case, you can send voltage to the wrong place and damage your board.]{#c12.xhtml#c12-li-0007}
-   [**Software:** Some of these shields need specific libraries to work. There can be conflicts in libraries calling on the same functions, so make sure to read up on what's required for your shield.]{#c12.xhtml#c12-li-0008}
-   [**Interference with radio/Wi-Fi/GPS/GSM:** Wireless devices need space to work. Move antennas or aerials away from the board to get a clear signal. If an antenna is mounted on the board, it's generally a bad idea to cover it. Always try to place wireless shields at the top of the stack.]{#c12.xhtml#c12-li-0009}
:::

::: {.section}
[]{#c12.xhtml#c12-sec-0004}

### Reviewing the field {#c12.xhtml#h3-2 .Heading-2}

To give you an idea of available shields, this section covers some of the most interesting and useful shields on the market and shows you where to look for more information.

![tip.png](https://i.imgur.com/kl3j0s9.jpeg) Note that all prices were current at the time this book was written and are liable to change, but I've included them to give you an idea of the cost. Links to products may also change, so always try searching for the product if the link is broken. Technical information is gathered from the manufacturers\' websites, but you should always check the details yourself to make sure that you\'re buying what you need. Boards are revised occasionally, so always keep an eye out for the latest versions.

Finally, a lot of feedback on all of these products is available online, so always read the comments and forums to get a good understanding of what you're buying.

This range of shields covers a vast number of different uses and the huge potential of Arduino projects. For many projects, a shield is all you need, but a shield is also an excellent stepping-stone for proving a concept before refining or miniaturizing your project.

![remember.png](https://i.imgur.com/jnJLdxz.jpeg) Prices provided are from a range of distributors to show the approximate value of the items. If you are a savvy shopper or are looking to buy in bulk, you may be able to reduce the cost.

::: {.section}
[]{#c12.xhtml#Page_288 .pagebreak role="doc-pagebreak" title="288"}[]{#c12.xhtml#c12-sec-0005}

#### Proto shield kit Rev3 {#c12.xhtml#h4-1 .Heading-3}

Made by: Arduino

Price: \$9.90 from Arduino Store

Pins used: None

The Proto shield (shown in [Figure 12-1](#c12.xhtml#c12-fig-0001){#c12.xhtml#rc12-fig-0001}) is a platform for building custom circuits on your Arduino. Many shields listed in this chapter add a specific function to your Arduino, but with a Proto Shield, you can decide how to use it. Take your existing breadboard layouts and solder them to the surface of the Proto shield to make your project more durable. Proto shields also come in a larger size to match the Arduino Mega's footprint. Another handy feature of these shields is the space to attach SMD parts, which can be difficult to do otherwise.

::: {#c12.xhtml#c12-fig-0001 .figure}
![9781119489542-fg1201.png](https://i.imgur.com/RCgyRYb.jpeg){.center}
:::

The Proto shield is sold either fully assembled or as a kit that requires soldering.

You can find details about the shield on the Arduino product page ([[`store.arduino.cc/usa/proto-shield-rev3-uno-size`]{.Code-within-text}](https://store.arduino.cc/usa/proto-shield-rev3-uno-size)).
:::

::: {.section}
[]{#c12.xhtml#Page_289 .pagebreak role="doc-pagebreak" title="289"}[]{#c12.xhtml#c12-sec-0006}

#### ProtoScrew shield {#c12.xhtml#h4-2 .Heading-3}

Made by: WingShield Industries

Price: \$14.95 from Adafruit

Pins used: None

ProtoScrew shield is similar to the regular Proto shield but has large screw terminals connected to the pins as well. This feature is great for applications that have lots of inputs that may need changing or swapping, or just for easier assembly and disassembly. Changing a piece of wire is much easier with screw terminals than with soldering, so bear this in mind when planning your next project.

ProtoScrew shield is sold as a kit and requires soldering. You can find more details on the SparkFun products page ([[`adafruit.com/product/196`]{.Code-within-text}](https://www.adafruit.com/product/196)).
:::

::: {.section}
[]{#c12.xhtml#c12-sec-0007}

#### Adafruit Wave shield v1.1 {#c12.xhtml#h4-3 .Heading-3}

Made by: Adafruit

Price: \$22.00 from Adafruit

Pins used: 13, 12, 11, 10, 5, 4, 3, 2 on the Uno R3

The Wave shield (see [Figure 12-2](#c12.xhtml#c12-fig-0002){#c12.xhtml#rc12-fig-0002}) is a relatively cheap kit that allows you to play sounds or music with your Arduino. The Wave shield allows you to play WAV files directly from an SD card, making it easy to upload and change the sound files from your computer. To use the shield, you need the WaveHC library, which is available from the product page and Google Code ([[`http://code.google.com/p/wavehc/`]{.Code-within-text}](http://code.google.com/p/wavehc/)).

::: {#c12.xhtml#c12-fig-0002 .figure}
![9781119489542-fg1202.png](https://i.imgur.com/runO6mk.jpeg){.center}
:::

The Wave shield is sold as a kit and requires soldering. The SD card reader must use pins 13, 12, and 11 because they support a high-speed Serial Peripheral Interface (SPI), which is a protocol needed to transfer data quickly. Pin 10 is used to communicate with the SD card reader, and pins 5, 4, 3, and 2 are used to talk to the digital-to-analog converter (DAC), which converts a digital music signal into an analog voltage.

For more details, visit the product page on Adafruit's website ([[`www.adafruit.com/products/94`]{.Code-within-text}](https://www.adafruit.com/products/94)).
:::

::: {.section}
[]{#c12.xhtml#Page_290 .pagebreak role="doc-pagebreak" title="290"}[]{#c12.xhtml#c12-sec-0008}

#### MP3 player shield {#c12.xhtml#h4-4 .Heading-3}

Made by: SparkFun

Price: \$24.95 from SparkFun

Pins used: 13, 12, 11, 9, 8, 7, 6, 5, 4, 3, 2 on the Uno R3

Turn your Arduino into an MP3 player with the easy-to-assemble MP3 player shield from SparkFun! Not only can it decode MP3 files, it's also capable of decoding Ogg Vorbis, AAC, WMA, and MIDI. The MP3 shield (shown in [Figure 12-3](#c12.xhtml#c12-fig-0003){#c12.xhtml#rc12-fig-0003}) also has a microSD card reader for ease of uploading files, and it has a 3.5mm mini jack that you can connect to most speaker systems.

::: {#c12.xhtml#c12-fig-0003 .figure}
![9781119489542-fg1203.png](https://i.imgur.com/Ya0pisY.jpeg){.center}
:::

The MP3 player shield is assembled but requires minor soldering to attach the header pins or header sockets. The SD card reader uses pins 13, 12, and 11. You use pin 9 to talk with the SD card reader. Use pins 8, 7, 6, and 2 talk to MP3 audio decoder VS1053B, and use pins 4 and 3 for additional MIDI functionality.

For more details, visit the SparkFun products page at [[`www.sparkfun.com/products/10628`]{.Code-within-text}](https://www.sparkfun.com/products/10628). Also see the tutorial page at [[`learn.sparkfun.com/tutorials/mp3-player-shield-hookup-guide-v15`]{.Code-within-text}](https://learn.sparkfun.com/tutorials/mp3-player-shield-hookup-guide-v15). The comments below the tutorial address many of the issues with this guide. One user has even written a library to make your life easier --- a great example of the Arduino community supporting existing products.

[]{#c12.xhtml#Page_291 .pagebreak role="doc-pagebreak" title="291"}![remember.png](https://i.imgur.com/52SWm3R.jpeg) Always read the comments and forum entries on products and kits. These comments often contain a lot of detail on the ease of (or difficulty with) a product. This is also the place to voice your own problems. Just be sure that you're not repeating something that's solved further down the page; otherwise, you'll be advised to read the manual!
:::

::: {.section}
[]{#c12.xhtml#c12-sec-0009}

#### MIDI shield {#c12.xhtml#h4-5 .Heading-3}

Made by: SparkFun

Price: \$19.95 from SparkFun

Pins used: Uses pins 2, 3, 4, 6, 7, A1, A0 on the Uno R3

MIDI (Music Instrument Digital Interface) revolutionized the music industry in the 1980s and is still widely used now to connect instruments, computer, stage effects, and other hardware. With the MIDI shield, you can interface with anything that can send or receive MIDI data and incorporate it into your Arduino project.

The MIDI shield is sold as a kit and requires soldering. For more details, visit the SparkFun product page ([[`www.sparkfun.com/products/12898`]{.Code-within-text}](https://www.sparkfun.com/products/12898)). You can find some excellent general tutorials on MIDI at [[`arduino.cc/en/Tutorial/Midi`]{.Code-within-text}](https://arduino.cc/en/Tutorial/Midi) and [[`itp.nyu.edu/physcomp/Labs/MIDIOutput`]{.Code-within-text}](http://itp.nyu.edu/physcomp/Labs/MIDIOutput) and a lot of excellent reference material at [[`www.tigoe.net/pcomp/code/communication/midi/`]{.Code-within-text}](http://www.tigoe.net/pcomp/code/communication/midi/) and [[`hinton-instruments.co.uk/reference/midi/protocol/`]{.Code-within-text}](http://hinton-instruments.co.uk/reference/midi/protocol/).
:::

::: {.section}
[]{#c12.xhtml#Page_292 .pagebreak role="doc-pagebreak" title="292"}[]{#c12.xhtml#c12-sec-0010}

#### RGB LCD shield with 16 x 2 character display {#c12.xhtml#h4-6 .Heading-3}

Made by: Adafruit

Price: \$24.95 from Adafruit

Pins used: Uses pins A4 and A5 on the Uno R3

This handy LCD (liquid crystal display) shield packages everything you need onto one board. LCDs are found in older mobile phones and Nintendo GameBoys (wow, that sounds old). They use a film that sits over a solid-colored, usually backlit surface. The pixels of this film can be turned on or off to make shapes, text, or graphics, and this is what you control with your Arduino. At the center of the shield is an RGB LCD display, so instead of being stuck with just one color, you can choose from *any* RGB color.

The RGB backlight is controlled directly from your Arduino. The display is a 16 x 2 character display (no graphics), which means you can write two rows of 16 characters. You can choose from two displays: colored text on a dark background (negative) or dark text on a colored background (positive). A variety of LCD character displays with various backlighting and dimensions is available, so be sure to shop around.

The RGB LCD shield is sold as a kit and requires soldering. Instead of using nine pins or more, the LCD, backlight, and buttons together use just two. By using the I2C to communicate with the shield, you can use only analog pin 4, which is the data (SDA) line, and analog pin 5, which is the clock (SCL) line. This protocol is used in many devices, so it is extremely useful to know about it. For more details on I2C, check John Boxall's excellent tutorial at [[`tronixstuff.wordpress.com/2010/10/20/tutorial-arduino-and-the-i2c-bus/`]{.Code-within-text}](http://tronixstuff.wordpress.com/2010/10/20/tutorial-arduino-and-the-i2c-bus/).

For more details, check out the Adafruit product page at [[`adafruit.com/products/714`]{.Code-within-text}](https://adafruit.com/products/714) and tutorial at [[`learn.adafruit.com/rgb-lcd-shield`]{.Code-within-text}](https://learn.adafruit.com/rgb-lcd-shield).

Shields are also available that use the same technology but don't limit you to letters and numbers. If you're looking to display your own graphics, you might want to use the SparkFun color LCD shield, which uses a Nokia 6100 screen, or the larger TFT touch shield.
:::

::: {.section}
[]{#c12.xhtml#c12-sec-0011}

#### 2.8" TFT touch shield with capacitive touch {#c12.xhtml#h4-7 .Heading-3}

Made by: Adafruit

Price: \$44.95 from Adafruit

Pins used: 4, 8, 9, 10, 11, 12, 13, A4, A5

[]{#c12.xhtml#Page_293 .pagebreak role="doc-pagebreak" title="293"}If an LCD display isn't enough for you, try the TFT touch shield to add full color and touch input to your project. This display is a TFT LCD screen --- a variation on a standard LCD screen that uses thin-film transistor (TFT) technology to improve the image quality --- with a resolution of 240 x 320 pixels and 18-bit colors, giving you 262,144 shades. The screen is also fitted with a resistive touchscreen to register finger presses anywhere on the surface of the screen.

The TFT touch shield is sold fully assembled and requires no soldering, so you can simply plug it on top of your Arduino. The touch shield needs a lot of pins to function and leaves you with only digital pins 2 and 3 and analog pins 4 and 5. Pin 12 is also available if you\'re not using the microSD reader.

Check out the products page at [[`www.adafruit.com/products/1947`]{.Code-within-text}](https://www.adafruit.com/product/1947) and the full tutorial at [[`learn.adafruit.com/adafruit-2-8-tft-touch-shield-v2`]{.Code-within-text}](https://learn.adafruit.com/adafruit-2-8-tft-touch-shield-v2). Adafruit has also kindly written a complete library for the TFT to draw pixels, shapes, and text ([[`github.com/adafruit/TFTLCD-Library`]{.Code-within-text}](https://github.com/adafruit/TFTLCD-Library)) and a library for the touchscreen that detects x, y, and z horizontal movement, vertical movement, and pressure ([[`github.com/adafruit/Adafruit_TouchScreen`]{.Code-within-text}](https://github.com/adafruit/Adafruit_TouchScreen)).
:::

::: {.section}
[]{#c12.xhtml#c12-sec-0012}

#### Joystick shield {#c12.xhtml#h4-8 .Heading-3}

Made by: SparkFun

Price: \$12.95 from SparkFun

Pins used: 2, 3, 4, 5, 6, A0, A1

The joystick shield (shown in [Figure 12-4](#c12.xhtml#c12-fig-0004){#c12.xhtml#rc12-fig-0004}) has all the functions of a modern game controller on a single Arduino-compatible board. It provides not only four pushbuttons to assign to various functions but also a hidden button in the control stick itself. With the ergonomic control stick, you can smoothly transition between x and y axes to perform movements with great accuracy.

::: {#c12.xhtml#c12-fig-0004 .figure}
![9781119489542-fg1204.png](https://i.imgur.com/Sv5bdB9.jpeg){.center}
:::

The joystick shield is sold as a kit and requires soldering. It uses only five digital pins and two analog pins, leaving many other Arduino pins free for other uses. It has five pushbuttons, using digital pins 2 to 6. The movement of the joystick is measured using two potentiometers: analog 0 maps the *x,* or horizontal, movement; analog 1 maps the *y,* or vertical, movement.

You can find more details on the SparkFun product page ([[`www.sparkfun.com/products/9760`]{.Code-within-text}](https://www.sparkfun.com/products/9760)). You can also see in-depth assembly tutorial ([[`www.sparkfun.com/tutorials/161`]{.Code-within-text}](https://www.sparkfun.com/tutorials/161)) and quick-start guide ([[`www.sparkfun.com/tutorials/171`]{.Code-within-text}](https://www.sparkfun.com/tutorials/171)).
:::

::: {.section}
[]{#c12.xhtml#Page_294 .pagebreak role="doc-pagebreak" title="294"}[]{#c12.xhtml#c12-sec-0013}

#### Adafruit motor/stepper/servo shield kit v2.3 {#c12.xhtml#h4-9 .Heading-3}

Made by: Adafruit

Price: \$19.95 from Adafruit

Pins used: 9, 10, A4, A5

Love motors? Want to try them all? Then the Adafruit motor/stepper/servo shield is the one for you. The shield is aptly named, enabling you to run all those motors you love. You can connect up to two 5V hobby servos, two stepper motors, or four bidirectional DC motors. The screw terminals make attaching and switching motors easy. When dealing with motors, it's always important to make sure that you have enough current to drive them all, so a handy screw terminal on the shield allows you to power your motors independently of your Arduino.

The Adafruit motor/stepper/servo shield is sold as a kit and requires soldering. Pins A4 and A5 control any connected DC or stepper motors, and pins 9 and 10 control any connected servos. This leaves you with a lot of pins free to be used for other inputs or outputs.

You can find many details on the Adafruit product page ([[`www.adafruit.com/product/1438`]{.Code-within-text}](https://www.adafruit.com/product/1438)) and in the in-depth tutorial ([[`learn.adafruit.com/adafruit-motor-shield-v2-for-arduino/`]{.Code-within-text}](https://learn.adafruit.com/adafruit-motor-shield-v2-for-arduino/)). Be aware of how much load is on the motor because the shield is designed to provide up to 600 mA per motor, with 1.2A peak current. If you're approaching 1A, include a heat sink on the motor driver to dissipate the heat.

[]{#c12.xhtml#Page_295 .pagebreak role="doc-pagebreak" title="295"}Also, the nice people at Adafruit provide an easy-to-use library for your motor project ([[`github.com/adafruit/Adafruit_Motor_Shield_V2_Library`]{.Code-within-text}](https://github.com/adafruit/Adafruit_Motor_Shield_V2_Library)). Happy motoring!
:::

::: {.section}
[]{#c12.xhtml#c12-sec-0014}

#### LiPower shield {#c12.xhtml#h4-10 .Heading-3}

Made by: SparkFun

Price: \$29.95 from SparkFun

Pins used: 3

If you want to make your Arduino project more mobile, batteries are the answer. Rather than use bulky AA or AAA battery packs, the LiPower shield allows you to use rechargeable lithium batteries instead. Although lithium batteries are rated as only 3.7V, some clever hardware steps them up to 5V to make them sufficient to power your Arduino.

The LiPower shield is assembled but requires minor soldering to attach the header pins or header sockets. Because the LiPower shield is there to provide power and not consume it, only one pin is in use. Pin 3 can be configured as an alert interrupt pin to signal whenever the battery drops to 32 percent or lower.

For more details, check out the SparkFun product page ([[`www.sparkfun.com/products/13158`]{.Code-within-text}](https://www.sparkfun.com/products/13158)). You find interesting notes on the hardware regarding the difficulties with charging lithium batteries, so make sure to read all the comments below the product description.

Many other smaller lithium breakout boards are available that supply the standard 3.7V, such as the SparkFun USB LiPoly charger ([[`www.sparkfun.com/products/12711`]{.Code-within-text}](https://www.sparkfun.com/products/12711)) and the Adafruit micro Lipo ([[`www.adafruit.com/product/1904`]{.Code-within-text}](https://www.adafruit.com/product/1904)). These breakout boards are perfect when paired with an appropriate low-voltage Arduino, such as the Arduino MKR1000 ([[`store.arduino.cc/usa/arduino-mkr1000`]{.Code-within-text}](https://store.arduino.cc/usa/arduino-mkr1000)). Boards such as the Arduino MRK1000 are useful when trying to reduce the size of your Arduino project.
:::

::: {.section}
[]{#c12.xhtml#c12-sec-0015}

#### Adafruit Ultimate GPS logger shield {#c12.xhtml#h4-11 .Heading-3}

Made by: Adafruit

Price: \$44.95 from Adafruit

Pins used: 7, 8, 10, 11, 12, 13, A4, A5

[]{#c12.xhtml#Page_296 .pagebreak role="doc-pagebreak" title="296"}The Adafruit Ultimate GPS logger shield lets you track and store location information using the Global Positioning System. You can find your location within a few meters. Use it to create GPS art or to map all your movements over the month. It's also great for giving you an extremely accurate time. Data is stored on a microSD card as a TXT file, which can then be overlaid onto Google Maps or visualized in some other way.

With the ever-increasing storage capacity of SD cards, you can store much more data on an SD card than your Arduino can on its own internal memory. This extra capacity is especially useful because it keeps your data-logging device mobile without the need for a computer, so you can leave that bulky laptop at home and send your GPS device out into the world!

The Adafruit Ultimate GPS logger shield is sold without attached header pins and requires soldering. Pins 10, 11, 12, and 13 are used for communication with the SD card. The GPS module uses either the hardware serial connection (pins 0 and 1) or two pins for a software serial connection (pins 7 and 8). You can enable other optional functions, such as a signaling LED to indicate when data is logged, a pin to monitor the pulse from the GPS synchronization clock, and a pin to detect when an SD card is in the slot.

Get the shield and more information on Adafruit ([[`www.adafruit.com/product/1272`]{.Code-within-text}](https://www.adafruit.com/product/1272)). You can view an in-depth tutorial on Adafruit's site ([[`learn.adafruit.com/adafruit-ultimate-gps-logger-shield/`]{.Code-within-text}](https://learn.adafruit.com/adafruit-ultimate-gps-logger-shield/)), which details everything from construction of the kit to the Arduino code, along with uses for the GPS data.
:::

::: {.section}
[]{#c12.xhtml#c12-sec-0016}

#### Adafruit FONA 800 shield {#c12.xhtml#h4-12 .Heading-3}

Made by: Adafruit

Price: \$39.95 from Adafruit

Pin requirements: 2, 3, 4

The Adafruit FONA 800 shield turns your modest Arduino into a functional mobile phone. With this shield, you can send and receive calls, text messages, and even data. All you need is a prepaid SIM card and an antenna, and you're ready to communicate with the world. By using serial commands you can send codes to talk to the SIM800L module.

The Adafruit FONA 800 shield is sold without attached header pins. You also need to purchase an antenna with an SMA connector; Adafruit offers a Slim Sticker-type GSM/Cellular quad-band antenna ([[`www.adafruit.com/product/3237`]{.Code-within-text}](https://www.adafruit.com/product/3237)). The Arduino talks with the SIM800L via pins 2 and 3 using the SoftwareSerial library.

[]{#c12.xhtml#Page_297 .pagebreak role="doc-pagebreak" title="297"}The SIM card should have enough credit to perform the actions you're trying to do. Those offering unlimited text messages are especially useful. Other optional extras are a mic and a speaker; without them, you won\'t be able to do anything more than call and hang up.

You can view an in-depth tutorial on Adafruit's site ([[`learn.adafruit.com/adafruit-fona-800-shield`]{.Code-within-text}](https://learn.adafruit.com/adafruit-fona-800-shield)).
:::

::: {.section}
[]{#c12.xhtml#c12-sec-0017}

#### Geiger counter -- radiation sensor board shield {#c12.xhtml#h4-13 .Heading-3}

Made by: Liberium

Price: \$170 from Cooking Hacks

Pin requirements: 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13

The radiation sensor board is probably one of the most impressive Arduino shields. It allows you to monitor radiation levels in the environment. This board was made to help the people of Japan monitor radiation levels following the radiation leakages in Fukushima in March 2011. The Geiger counter can use various Geiger tubes to detect different types and levels of radiation. There is also an LCD display, an LED, and a piezo speaker for feedback.

![warning.png](https://i.imgur.com/eEcYIT6.jpeg) This shield uses Geiger tubes that operate at dangerously high voltages (400V--1000V), so it requires extreme care. It is best to keep the radiation sensor board in an enclosure to keep it out of human contact. Radiation is dangerous, but so is electricity. If you don't know what you're doing, don't mess around.

The piezo speaker and LED are connected to pin 2, which triggers an interrupt with every pulse that the Geiger tube generates. Depending on the tube used and the number of pulses or counts per minute (cpm), you can determine the radiation level in Sieverts per hour. Pins 3 to 8 are used for the LCD display to generate the sensor readings in detail. Pins 9 to 13 are used for the LED bar to give clear visual feedback of the radiation level. The first three LEDs are green. The last two are red, showing that a high and potentially dangerous level of radiation is being approached.

More details on this project can be found on the Cooking Hacks product page at [[`www.cooking-hacks.com/index.php/documentation/tutorials/geiger-counter-arduino-radiation-sensor-board`]{.Code-within-text}](https://www.cooking-hacks.com/index.php/documentation/tutorials/geiger-counter-arduino-radiation-sensor-board).
:::
:::

::: {.section}
[]{#c12.xhtml#c12-sec-0018}

### Staying current {#c12.xhtml#h3-3 .Heading-2}

Many other great shields are available, and new and improved ones are released all the time. You can take some actions to keep up to date, though.

[]{#c12.xhtml#Page_298 .pagebreak role="doc-pagebreak" title="298"}Check the stores regularly for the latest products. It's a bit like browsing in a DIY shop; you never know what you'll find:

-   [**Arduino Store** ([[`store.arduino.cc`]{.Code-within-text}](http://store.arduino.cc/))]{#c12.xhtml#c12-li-0010}
-   [**Adafruit** ([[`www.adafruit.com`]{.Code-within-text}](https://www.adafruit.com/))]{#c12.xhtml#c12-li-0011}
-   [**Maker Shed** ([[`www.makershed.com`]{.Code-within-text}](https://www.makershed.com))]{#c12.xhtml#c12-li-0012}
-   [**Seeed Studio** ([[`www.seeedstudio.com`]{.Code-within-text}](https://www.seeedstudio.com/))]{#c12.xhtml#c12-li-0013}
-   [**SparkFun** ([[`www.sparkfun.com`]{.Code-within-text}](https://www.sparkfun.com/))]{#c12.xhtml#c12-li-0014}

Also, check Arduino-related blogs regularly. Blogs and news pages on Arduino-related sites often show off new kits or new and interesting applications of older hardware, so they're always worth checking for inspiration:

-   [**Arduino Blog** ([[`arduino.cc/blog`]{.Code-within-text}](https://arduino.cc/blog))]{#c12.xhtml#c12-li-0015}
-   [**Adafruit** ([[`www.adafruit.com/blog`]{.Code-within-text}](https://www.adafruit.com/blog))]{#c12.xhtml#c12-li-0016}
-   [**Hack A Day** ([[`hackaday.com`]{.Code-within-text}](https://hackaday.com/))]{#c12.xhtml#c12-li-0017}
-   [**Make** ([[`blog.makezine.com`]{.Code-within-text}](https://blog.makezine.com/))]{#c12.xhtml#c12-li-0018}
-   [**Seeed Studio** ([[`www.seeedstudio.com/blog`]{.Code-within-text}](https://www.seeedstudio.com/blog))]{#c12.xhtml#c12-li-0019}
-   [**SparkFun** ([[`www.sparkfun.com/news`]{.Code-within-text}](https://www.sparkfun.com/news))]{#c12.xhtml#c12-li-0020}

Some people have made efforts to document the various shields. Check the Arduino shield list at [[`http://shieldlist.org`]{.Code-within-text}](http://shieldlist.org/).
:::
:::

::: {.section}
[]{#c12.xhtml#c12-sec-0019}

## Browsing the Libraries {#c12.xhtml#h2-2 .Heading-1}

Basic sketches can get you quite a long way, but when you become more advanced you need to know about libraries. *Libraries* provide extra functionality to your sketch, either to use specific hardware or to incorporate more complex functions in software. In the same way that you'd go to a physical library to learn something new, you include libraries in your code to teach your Arduino something new. By including a library in a sketch, you can quickly and easily access functions to help you achieve your goals.

Getting started with complex hardware or software can be difficult. Luckily, a lot of people have taken the time to document their progress and have released libraries, often with examples, that you can easily integrate into your own sketches. From this, it's possible to get something working and gain a better understanding []{#c12.xhtml#Page_299 .pagebreak role="doc-pagebreak" title="299"}of it. This learn-by-doing approach of Arduino allows you to make a lot of progress quickly and easily with hardware or software that would otherwise be a huge challenge.

::: {.section}
[]{#c12.xhtml#c12-sec-0020}

### Reviewing the standard libraries {#c12.xhtml#h3-4 .Heading-2}

This section covers a selection of the libraries included in the current release of Arduino at the time of writing (1.8.5). The standard libraries cover a wide range of subject areas and are usually popular topics that have been heavily documented. You can find these libraries by choosing Sketch ⇒   Include Library ⇒   Manage Libraries.

Choosing a library includes one line at the top of your current sketch, such as [`#include <EEPROM.h>`]{.Code-within-text}. Before you attempt to understand a library, you should try an example of it. You\'ll find examples at the bottom of the menu that appears at when you choose File ⇒   Examples.

Here is a brief description of what each library does:

-   [**EEPROM (**[[`arduino.cc/en/Reference/EEPROM`]{.Code-within-text}](https://arduino.cc/en/Reference/EEPROM)**):** Your Arduino has electronically erasable programmable read-only memory (EEPROM), which is permanent storage similar to the hard drive in a computer. Data stored in this location stays there even if your Arduino is powered down. Using the EEPROM library, you can read from and write to this memory.]{#c12.xhtml#c12-li-0021}
-   [**Ethernet (**[[`arduino.cc/en/Reference/Ethernet`]{.Code-within-text}](https://arduino.cc/en/Reference/Ethernet)**):** After you have your Ethernet shield, the Ethernet library allows you to quickly and easily start talking to the Internet. When you use this library, your Arduino can act either as a server that is accessible to other devices or as a client that requests data.]{#c12.xhtml#c12-li-0022}
-   [**Firmata (**[[`arduino.cc/en/Reference/Firmata`]{.Code-within-text}](https://arduino.cc/en/Reference/Firmata)**):** Firmata is one way to control your Arduino from software on a computer. It is a standard communication protocol, so you can use the library to allow easy communication between hardware and software rather than write your own communication software.]{#c12.xhtml#c12-li-0023}
-   [**LiquidCrystal (**[[`arduino.cc/en/Reference/LiquidCrystal`]{.Code-within-text}](https://arduino.cc/en/Reference/LiquidCrystal)**):** The LiquidCrystal library helps your Arduino talk to most liquid crystal displays (LCDs). The library is based on the Hitachi HD44780 driver, and you can usually identify these displays by their 16-pin interface.]{#c12.xhtml#c12-li-0024}
-   [**SD (**[[`arduino.cc/en/Reference/SD`]{.Code-within-text}](https://arduino.cc/en/Reference/SD)**):** The SD library allows you to read from and write to SD and microSD cards connected to your Arduino. SD cards need to use SPI to transfer data quickly, which happens on pins 11, 12, and 13. You also need to have another pin to select the SD card when it's needed.]{#c12.xhtml#c12-li-0025}
-   [**[]{#c12.xhtml#Page_300 .pagebreak role="doc-pagebreak" title="300"}Servo (**[[`arduino.cc/en/Reference/Servo`]{.Code-within-text}](https://arduino.cc/en/Reference/Servo)**):** The Servo library allows you to control up to 12 servo motors on the Uno R3 (and up to 48 on the Mega). Most hobby servos turn 180 degrees, and using this library, you can specify the degree that you want your servo(s) to turn to.]{#c12.xhtml#c12-li-0026}
-   [**SPI (**[[`arduino.cc/en/Reference/SPI`]{.Code-within-text}](https://arduino.cc/en/Reference/SPI)**):** The Serial Peripheral Interface (SPI) is a method of communication that allows your Arduino to communicate very quickly with one or more devices over a short distance. Example of this communication include receiving data from sensors, talking to peripherals such as an SD card reader, and communicating with another microcontroller.]{#c12.xhtml#c12-li-0027}
-   [**SoftwareSerial (**[[`arduino.cc/en/Reference/SoftwareSerial`]{.Code-within-text}](https://arduino.cc/en/Reference/SoftwareSerial)**):** The SoftwareSerial library allows you to use any digital pins to send and receive serial messages instead of, or in addition to, the usual hardware pins (0 and 1). This capability is great if you want to keep the hardware pins free for communication to a computer, allowing you to have a permanent debug connection to your project while still being able to upload new sketches or to send duplicate data to multiple serial devices.]{#c12.xhtml#c12-li-0028}
-   [**Stepper (**[[`arduino.cc/en/Reference/Stepper`]{.Code-within-text}](https://arduino.cc/en/Reference/Stepper)**):** The Stepper library allows you to control stepper motors from your Arduino. This code also requires the appropriate hardware to work, so make sure to read Tom Igoe's notes on the subject at [[`www.tigoe.net/pcomp/code/circuits/motors/stepper-motors/`]{.Code-within-text}](http://www.tigoe.net/pcomp/code/circuits/motors/stepper-motors/).]{#c12.xhtml#c12-li-0029}
-   [**Wi-Fi (**[[`arduino.cc/en/Reference/WiFi`]{.Code-within-text}](https://arduino.cc/en/Reference/WiFi)**):** The WiFi library is based on the Ethernet library listed previously, but with alterations specific to the Wi-Fi shield to allow you to wirelessly connect to the Internet. The WiFi library also works well with the SD library, allowing you to store data on the shield.]{#c12.xhtml#c12-li-0030}
-   [**Wire (**[[`arduino.cc/en/Reference/Wire`]{.Code-within-text}](https://arduino.cc/en/Reference/Wire)**):** The Wire library allows your Arduino to communicate with I2C devices (also known as TWI, or two-wire interface). Such devices could be addressable LEDs or a Wii Nunchuk, for example.]{#c12.xhtml#c12-li-0031}
:::

::: {.section}
[]{#c12.xhtml#c12-sec-0021}

### Installing additional libraries {#c12.xhtml#h3-5 .Heading-2}

Many libraries aren't included in the Arduino software by default. Some libraries are for unique applications such as specific hardware or functions; others are refinements or adaptations of existing libraries. Luckily, Arduino makes including these easy, so you can quickly try them all to see which are right for your needs.

Most libraries are easily installed by choosing Sketch ⇒   Include Library ⇒   Manage Libraries from the Arduino IDE menu. The Library Manager dialog box displays an easily searchable list of libraries submitted to the Arduino servers and approved for release.

[]{#c12.xhtml#Page_301 .pagebreak role="doc-pagebreak" title="301"}Libraries may also be distributed as ZIP files that have the same name as the library; for example, the capacitive sensing library CapSense should be distributed as [`CapSense.zip`]{.Code-within-text} and should contain a folder of the same name when unzipped.

Inside the folder there are files ending in [`.h`]{.Code-within-text} and [`.cpp`]{.Code-within-text}, such as [`CapPin.h`]{.Code-within-text} and [`CapPin.cpp`]{.Code-within-text}, and maybe even an Examples folder. If your [`.zip`]{.Code-within-text} file contains only loose [`.h`]{.Code-within-text} and [`.cpp`]{.Code-within-text} files, you should place them in a folder with a library name. Sometimes you may find many [`.h`]{.Code-within-text} and [`.cpp`]{.Code-within-text} files that all perform different functions in the library, so make sure they\'re all inside the folder.

In the latest release of Arduino (1.8.5 at the time of this writing), it's easy to include libraries distributed as ZIP files. Simply choose Sketch ⇒   Include Library ⇒   Add .ZIP Library and select the ZIP file containing the library.

After the library is installed, restart Arduino and choose Sketch ⇒   Include Library to check that your library is in the list, as shown in [Figure 12-5](#c12.xhtml#c12-fig-0005){#c12.xhtml#rc12-fig-0005}.

::: {#c12.xhtml#c12-fig-0005 .figure}
![9781119489542-fg1205.png](https://i.imgur.com/aFTN4zm.jpeg){.center}
:::

If the library has an Examples folder, you should also be able to see the examples by choosing File ⇒   Examples and then choosing the name of the library, as shown in [Figure 12-6](#c12.xhtml#c12-fig-0006){#c12.xhtml#rc12-fig-0006}.

::: {#c12.xhtml#c12-fig-0006 .figure}
![9781119489542-fg1206.png](https://i.imgur.com/jNxCYB6.jpeg){.center}
:::

That's all there is to installing a library. Removing a library is as simple: just take the library folder out of the Arduino Sketch folder.
:::

::: {.section}
[]{#c12.xhtml#Page_302 .pagebreak role="doc-pagebreak" title="302"}[]{#c12.xhtml#c12-sec-0022}

### Obtaining contributed libraries {#c12.xhtml#h3-6 .Heading-2}

A long list of community-contributed libraries appears on the Arduino libraries page ([[`arduino.cc/en/Reference/Libraries`]{.Code-within-text}](https://arduino.cc/en/Reference/Libraries)) and an exhaustive list appears on the Arduino Playground ([[`arduino.cc/playground/Main/LibraryList`]{.Code-within-text}](https://arduino.cc/playground/Main/LibraryList)).

To become familiar with contributed libraries, start with CapSense and TimerOne, two commonly used and helpful libraries:

-   ::: {#c12.xhtml#c12-li-0032}
    **CapSense (**[[`www.arduino.cc/playground/Main/CapSense`]{.Code-within-text}](https://www.arduino.cc/playground/Main/CapSense)**):** The CapSense library allows you to make one or many pins on your Arduino into capacitive sensors. This feature allows you to make simple touch, pressure, or presence detection sensors quickly and easily with little hardware.

    The Arduino Playground page has a lot of useful information, but a more recent version of the code can be found on GitHub ([[`github.com/moderndevice/CapSense`]{.Code-within-text}](https://github.com/moderndevice/CapSense)).
    :::

-   [**TimerOne (**[[`playground.arduino.cc//Code/Timer1`]{.Code-within-text}](https://playground.arduino.cc/Code/Timer1)**):** TimerOne (also called Timer1) uses a hardware timer on your Arduino to perform timed events at regular intervals. It's a great library for reading sensor data regularly without interrupting what's going on in the main loop. You can find a TimerOne page on the Arduino Playground and an up-to-date version of the library on Google Code ([[`code.google.com/p/arduino-timerone/`]{.Code-within-text}](https://code.google.com/p/arduino-timerone/)).]{#c12.xhtml#c12-li-0033}

If you're keen to understand libraries more and maybe even write your own, check out the introduction to writing your own libraries on the Arduino GitHub page at [[`github.com/arduino/Arduino/wiki/Library-Manager-FAQ`]{.Code-within-text}](https://github.com/arduino/Arduino/wiki/Library-Manager-FAQ).
:::
:::

[]{#p04.xhtml}

::: {.section}
[]{#p04.xhtml#Page_303 .pagebreak role="doc-pagebreak" title="303"}Part 4

# Sussing Out Software {#p04.xhtml#a1 .Part-Title}

::: {.section}
[]{#p04.xhtml#p04-sec-0001}

[]{#p04.xhtml#Page_304 .pagebreak role="doc-pagebreak" title="304"}IN THIS PART ...

Combine your knowledge of electronics with computer software to create stunning interactive visuals in the virtual world that exists on your computer.

Use data from software, your computer, or the Internet to create light, sound, and motion in the real world.
:::
:::

[]{#c13.xhtml}

[]{#c13.xhtml#Page_305 .pagebreak role="doc-pagebreak" title="305"}Chapter 13

# Getting to Know Processing {#c13.xhtml#a1 .Chap-Title}

::: {.section}
[]{#c13.xhtml#c13-sec-0001}[]{#c13.xhtml#c13-feafxd-0001}

IN THIS CHAPTER

![check.png](https://i.imgur.com/hyrJcqa.jpeg) **Getting excited about Processing**

![check.png](https://i.imgur.com/BuzBATh.jpeg) **Making shapes of all sizes and colors**

In the previous chapters, you learn all about using Arduino as a stand-alone device. A program is uploaded to the Arduino and carries out its task ad infinitum, until it is told to stop or powered down. You are affecting the Arduino by simple, clear electrical signals, and as long as no outside influences or coding errors exist and if the components last, the Arduino reliably repeats its function. This simplicity is useful for many applications and allows the Arduino to not only serve as a great prototyping platform but also work as a reliable tool for interactive products and installations for many years, as it already does in many museums.

Although this simplicity is something to admire, many applications are outside the scope of an Arduino's capabilities. Although the Arduino is basically a computer, it's not capable of running comparably large and complex computer programs in the same way as your desktop or laptop. Many of these programs are highly specialized depending on the task you're doing. You could benefit hugely if only you could link this software to the physical world in the same way your Arduino can.

Because the Arduino can connect to your computer and be monitored over the serial port, other programs may also be able to do this, in the same way that your computer talks to printers, scanners, or cameras. So by combining the physical []{#c13.xhtml#Page_306 .pagebreak role="doc-pagebreak" title="306"}world interaction capabilities of your Arduino with the data-crunching software capabilities of your computer, you can create projects with an enormous variety of inputs, outputs, and processes.

Many specific programs are made for specific tasks, but until you want to specify, it's best to find software that you can experiment with --- that is, be a jack-of-all-trades in the same way that your Arduino is for the physical world. Processing is a great place to start.

In this chapter, you learn about Processing, the sister project that was in the first stages of development around the same time as Arduino. Processing is a software environment that you can use to sketch programs quickly, in the same way that you use an Arduino to test circuits quickly. Processing is a great piece of open source software, and its similarities to Arduino make it easy to learn.
:::

::: {.section}
[]{#c13.xhtml#c13-sec-0002}

## Looking Under the Hood {#c13.xhtml#h2-1 .Heading-1}

An Arduino can communicate over its serial port as a serial device, which can be read by any program that can talk serial. Many programs are available, but Processing is one of the most popular.

Processing has an enormous breadth of applications ranging from visualizing data to creating generative artwork to performing motion capture using your webcam for digital performances. These are just a few niches; you can find a wealth of examples at [[`processing.org/exhibition`]{.Code-within-text}](http://processing.org/exhibition/).

Processing is written in a Java-based language that looks similar to C (on which Arduino code is based) and C++. It is available for Windows, macOS, and Linux. Ben Fry and Casey Reas developed Processing to allow anyone, not just developers and engineers, to experiment with code. In the same way that ideas are sketched out, Processing is designed to sketch software. Programs can be quickly developed and adapted without a huge investment of time.

Processing uses a text-based IDE (integrated development environment) similar to that of Arduino. (In fact, it was "borrowed" by the Arduino team when the Arduino IDE was in development). A window displays the Java applet that the code creates, as shown in [Figure 13-1](#c13.xhtml#c13-fig-0001){#c13.xhtml#rc13-fig-0001}. As with Arduino, the strength of Processing is the vast community that shares and comments on sketches, allowing the many participants to benefit from a diverse array of creative applications Processing is open source and allows users to modify the software as well as use it.

::: {#c13.xhtml#c13-fig-0001 .figure}
![9781119489542-fg1301.png](https://i.imgur.com/l7tCpxe.jpeg){.center}
:::

In this chapter, you learn how to get started with Processing. For more information, head over to the Processing site at [[`processing.org`]{.Code-within-text}](http://processing.org/).

![](interfacing) Many other programming languages exist that can interface with Arduino. I describe Max/Pure Data and OpenFrameworks in sidebars in this chapter. For a list of even the most obscure languages, check the Arduino Playground at [[`arduino.cc/playground/main/interfacing`]{.Code-within-text}](http://arduino.cc/playground/main/interfacing).

```{=html}
<aside>
```
::: {#c13.xhtml#c13-fea-0001 .sidebar}
# MAX/Pure Data {.SB-Head}

[]{#c13.xhtml#c13-sec-0003}

Max (also previously known as Max/MSP) is a visual programming language with a vast variety of uses, but it is most commonly used for audio, music, and sound synthesis applications. Max is available for Windows, macOS, Linux, and other more obscure operating systems.

Unlike traditional text-based programming languages, Max uses a graphical user interface to connect visual objects to one another in the same way that traditional synthesizers can be "patched" using wires to connect the various functions of the instrument. Software company Cycling '74 released the commercial software Max in 1990 based on earlier work by Miller Puckette to create a system for interactive computer music. Although the software is not open source, the application programming interface (API) allows third parties to make their own extensions to the software for specific uses. Miller Puckette also developed a redesigned, free, and open source version called PureData (Max).

::: {#c13.xhtml#c13-blkfxd-0001 .figure}
![9781119489542-sb1301.png](https://i.imgur.com/svdoKsB.jpeg){.center}
:::

You can find more information about Max and PureData (Max) on their respective web pages: [[`cycling74.com/products/max`]{.Code-within-text}](https://cycling74.com/products/max/) and [[`puredata.info`]{.Code-within-text}](http://puredata.info/). To start communicating between Max and Arduino, check out the aptly named Maxuino ([[`www.maxuino.org/archives/category/updates`]{.Code-within-text}](http://www.maxuino.org/archives/category/updates)), and for PureData (Max) and Arduino, check out Pduino ([[`at.or.at/hans/pd/objects.html`]{.Code-within-text}](https://at.or.at/hans/pd/objects.html)).

Other helpful links are on the Arduino playground at ([[`www.arduino.cc/playground/interfacing/MaxMSP`]{.Code-within-text}](http://www.arduino.cc/playground/interfacing/MaxMSP)  and  [[`www.arduino.cc/playground/interfacing/PD`]{.Code-within-text}](http://www.arduino.cc/playground/Interfacing/PD)).
:::

```{=html}
</aside>
```
```{=html}
<aside>
```
::: {#c13.xhtml#c13-fea-0002 .sidebar}
# OPENFRAMEWORKS {.SB-Head}

[]{#c13.xhtml#c13-sec-0004}

OpenFrameworks, an open source C++ tool kit for experimenting with code, is actively developed by Zachary Lieberman, Theo Watson, and Arturo Castro, as well as other members of the openFrameworks community. OpenFrameworks runs on Windows, macOS, Linux, iOS, and Android. OpenFrameworks, unlike Processing, is not based on Java. Instead, OpenFrameworks is a C++ library designed to be the bare bones for getting started with audio-visual applications.

OpenFrameworks is especially powerful with graphics, allowing you to easily use OpenGL for intensive rendering or video applications. In contrast to Processing, Max, and PureData (Max), OpenFrameworks is not its own language; it is a collection of open source libraries, known as a *software framework* --- hence the name. Because OpenFrameworks does not have its own IDE, the software used to write and compile the code depends on the platform. This feature can make getting started difficult because no centrally controlled IDE exists for continuity. The benefit is that C++ is highly versatile and can be used on almost any platform you can think of, including mobile operating systems.

::: {#c13.xhtml#c13-blkfxd-0002 .figure}
![9781119489542-sb1302.png](https://i.imgur.com/qrj79Dy.jpeg){.center}
:::

You can find details and tutorials at [[`www.openframeworks.cc/`]{.Code-within-text}](https://www.openframeworks.cc/) and [[`www.openframeworks.cc/learning`]{.Code-within-text}](https://www.openframeworks.cc/learning). SparkFun also has a great Arduino tutorial for using OpenFrameworks with Arduino on Windows at [[`www.sparkfun.com/tutorials/318`]{.Code-within-text}](https://www.sparkfun.com/tutorials/318).
:::

```{=html}
</aside>
```
::: {.section}
[]{#c13.xhtml#c13-sec-0005}

### Installing Processing {#c13.xhtml#h3-1 .Heading-2}

Processing is free to download from [[`https://processing.org/download/`]{.Code-within-text}](https://processing.org/download/) and supported on macOS, Windows 32-bit and 64-bit, and Linux 32-bit, 64-bit, and ARM. At the time of writing, Processing was version 3.3.7. Remember that things may have changed between when I wrote these words and when you get started.

To install Processing:

-   [**On a Mac:** The ZIP file unzips automatically, revealing the Processing app, which you can then drag to the Applications folder. From there you can drag Processing to the dock for easy access or create a desktop alias.]{#c13.xhtml#c13-li-0003}
-   [**On Windows:** Unzip the ZIP file and place the Processing folder on your desktop or in a sensible location such as your Program Files folder: [`C:/Program Files/Processing/`]{.Code-within-text}. Create a shortcut to [`Processing.exe`]{.Code-within-text} and place it somewhere convenient, such as on your desktop or in the Start menu.[]{#c13.xhtml#Page_308 .pagebreak role="doc-pagebreak" title="308"}]{#c13.xhtml#c13-li-0004}
:::

::: {.section}
[]{#c13.xhtml#Page_309 .pagebreak role="doc-pagebreak" title="309"}[]{#c13.xhtml#c13-sec-0006}

### Taking a look at Processing {#c13.xhtml#h3-2 .Heading-2}

After you have installed Processing, run the application. Processing opens with a blank sketch (see [Figure 13-2](#c13.xhtml#c13-fig-0002){#c13.xhtml#rc13-fig-0002}) similar to the Arduino window, divided into five main areas:

-   [Toolbar with buttons]{#c13.xhtml#c13-li-0005}
-   [Tabs]{#c13.xhtml#c13-li-0006}
-   [Text editor]{#c13.xhtml#c13-li-0007}
-   [Message area]{#c13.xhtml#c13-li-0008}
-   [Console]{#c13.xhtml#c13-li-0009}

::: {#c13.xhtml#c13-fig-0002 .figure}
![9781119489542-fg1302.png](https://i.imgur.com/a4s9m5R.jpeg){.center}
:::

The blank sketch also contains a menu bar for the main Processing application, which gives you drop-down menus to access the preferences of the processing application, load recent sketches and import libraries, and perform many other functions.[]{#c13.xhtml#Page_310 .pagebreak role="doc-pagebreak" title="310"}

[]{#c13.xhtml#Page_311 .pagebreak role="doc-pagebreak" title="311"}Here\'s an overview of the Processing toolbar:

-   [**Run:** Executes or runs the code in the text editor as an applet (small application) in a new window. The keyboard shortcuts for this command are Ctrl+R for Windows and Cmd+R for macOS.]{#c13.xhtml#c13-li-0010}
-   [**Stop:** Stops the code from running and closes the applet window.]{#c13.xhtml#c13-li-0011}
-   [**Debug:** A tool to help you identify errors and debug your code.]{#c13.xhtml#c13-li-0012}
-   [**Mode:** Changes mode between Java (standard), Android (mobile and tables), and JavaScript (online applications). This capability is a new development in the latest release. You can find more details on these modes at [[`github.com/processing/processing-android/wiki`]{.Code-within-text}](https://github.com/processing/processing-android/wiki) and [[`github.com/fjenett/javascript-mode-processing/wiki`]{.Code-within-text}](https://github.com/fjenett/javascript-mode-processing/wiki).]{#c13.xhtml#c13-li-0013}
-   [**Tabs:** Organizes multiple files in a Processing sketch. Use tabs in larger programs to separate objects from the main sketch or to incorporate look-up tables of data into a sketch.]{#c13.xhtml#c13-li-0014}
-   [**Text editor:** Enters code into the sketch. Recognized terms or functions are highlighted in appropriate colors for clarity. The text editor is the same as that in the Arduino IDE.]{#c13.xhtml#c13-li-0015}
-   [**Message area:** Displays errors, feedback, or information about the current task. You might see a notification that the sketch saved successfully, but more often than not, the message shows where errors are flagged.]{#c13.xhtml#c13-li-0016}
-   [**Console:** Displays more details on your sketch. You can use the [`println()`]{.Code-within-text} function here to display the values in your sketch; additional detail on errors is also shown.]{#c13.xhtml#c13-li-0017}
:::
:::

::: {.section}
[]{#c13.xhtml#c13-sec-0007}

## Trying Your First Processing Sketch {#c13.xhtml#h2-2 .Heading-1}

Unlike with Arduino, you don\'t need an extra kit to get going with Processing. This feature makes Processing useful for learning about coding because you can enter a line or two of code, click Run, and see what the results.

Start your first sketch with these steps:

1.  [**Press Ctrl+N (in Windows) or Cmd+N (on a Mac) to open a new sketch**.]{#c13.xhtml#c13-li-0018}

2.  [**Click in the text editor and enter this line of code:**[]{#c13.xhtml#c13-code-0001}[]{#c13.xhtml#c13-lntxt-0001}]{#c13.xhtml#c13-li-0019}

    []{#c13.xhtml#Page_312 .pagebreak role="doc-pagebreak" title="312"}`ellipse(50,50,10,10);`{#c13.xhtml#c13-line-0001}

3.  ::: {#c13.xhtml#c13-li-0020}
    **Click the Run button.**

    A new applet window opens, showing a white circle in the middle of a gray box, as in [Figure 13-3](#c13.xhtml#c13-fig-0003){#c13.xhtml#rc13-fig-0003}.
    :::

::: {#c13.xhtml#c13-fig-0003 .figure}
![9781119489542-fg1303.png](https://i.imgur.com/7emrlSC.jpeg){.center}
:::

Well done! You've just written your first Processing program.

Have you finished admiring your circle? That line of code draws an ellipse. An ellipse normally is not circular, but you gave it the parameters to make a circle.

The word *ellipse* is highlighted in turquoise in the text editor, indicating that it is a recognized function. The first two numbers are the coordinates of the ellipse, which in this case are 50, 50. The unit of the numbers is in pixels. Because the default window is 100 x 100 pixels, coordinates of 50, 50 put the ellipse in the center. The 10, 10 values indicate the width and height of the ellipse, giving you a circle. You could write the function also as

[]{#c13.xhtml#c13-code-0002}[]{#c13.xhtml#c13-lntxt-0002}

`ellipse(x,y,width,height)`{#c13.xhtml#c13-line-0002}

The coordinates for the ellipse (or any shape or point, for that matter) are written as x and y. These indicate a point in two-dimensional (2D) space, which in this case is a point measured in pixels on your screen. Horizontal positions are referred to as the x coordinate; vertical positions are the y coordinate. Depth used in 3D space is referred to as z. Add the following line of code, just above the [`ellipse()`]{.Code-within-text} statement:

[]{#c13.xhtml#c13-code-0003}[]{#c13.xhtml#c13-lntxt-0003}

`size(300,200);`{#c13.xhtml#c13-line-0003}

Click the Run button and you get a rectangular window with the ellipse in the top left, as shown in [Figure 13-4](#c13.xhtml#c13-fig-0004){#c13.xhtml#rc13-fig-0004}. The [`size()`]{.Code-within-text} function is used to define the size of the applet window in pixels, which in this case is 300 pixels wide and 200 pixels high. If your screen isn\'t like [Figure 13-4](#c13.xhtml#c13-fig-0004), you may have put the statements in the []{#c13.xhtml#Page_313 .pagebreak role="doc-pagebreak" title="313"}wrong order. The lines of code are read in order, so if the ellipse code is first, the blank window is drawn over the ellipse. And with a rectangular window, you see that the coordinates are measured from the top left.

::: {#c13.xhtml#c13-fig-0004 .figure}
![9781119489542-fg1304.png](https://i.imgur.com/s52q6H4.jpeg){.center}
:::

Coordinates are measured on an invisible a grid with the center point at 0, 0 for 2D (or 0, 0, 0 for 3D), which is referred to as the *origin*. This way of referencing locations is based on the Cartesian coordinate system, which you may have studied in school. Numbers can be positive or negative, depending on which side of the origin they are on. On computer screens, the origin is at the top left because pixels are drawn from top left to bottom right, one row at a time (check out [Figure 13-5](#c13.xhtml#c13-fig-0005){#c13.xhtml#rc13-fig-0005}). Therefore, the statement [`size(300,200)`]{.Code-within-text} draws a window 300 pixels from left to right on the screen and then 200 pixels from top to bottom.

::: {#c13.xhtml#c13-fig-0005 .figure}
![9781119489542-fg1305.png](https://i.imgur.com/FvrMTZt.jpeg){.center}
:::

::: {.section}
[]{#c13.xhtml#c13-sec-0008}

### Drawing shapes {#c13.xhtml#h3-3 .Heading-2}

To gain a better understanding of the possibilities you have in drawing shapes, look at a few basic shapes: point, line, rectangle, and ellipse.

::: {.section}
[]{#c13.xhtml#c13-sec-0009}

#### Point {#c13.xhtml#h4-1 .Heading-3}

A single point is the most basic shape and is useful for creating more complex shapes. Write the following code and then click the Run button. Look closely and you\'ll see a single black pixel in the center of the display window (see [Figure 13-6](#c13.xhtml#c13-fig-0006){#c13.xhtml#rc13-fig-0006}). That is the point that your code drew.

[]{#c13.xhtml#c13-code-0004}[]{#c13.xhtml#c13-lntxt-0004}

`size(300,200);`{#c13.xhtml#c13-line-0004}

`point(150,100);`{#c13.xhtml#c13-line-0005}

::: {#c13.xhtml#c13-fig-0006 .figure}
![9781119489542-fg1306.png](https://i.imgur.com/4dxd7Mz.jpeg){.center}
:::

The [`point`]{.Code-within-text} function can also be written as follows:

[]{#c13.xhtml#c13-code-0005}[]{#c13.xhtml#c13-lntxt-0005}

`point(x,y);`{#c13.xhtml#c13-line-0006}
:::

::: {.section}
[]{#c13.xhtml#c13-sec-0010}

#### Line {#c13.xhtml#h4-2 .Heading-3}

A line is made by connecting two points, which is done by defining the start and end points. Write the code to generate a screen like the one in [Figure 13-7](#c13.xhtml#c13-fig-0007){#c13.xhtml#rc13-fig-0007}:

[]{#c13.xhtml#c13-code-0006}[]{#c13.xhtml#c13-lntxt-0006}

`size(300,200);`{#c13.xhtml#c13-line-0007}

`line(50,50,250,150);`{#c13.xhtml#c13-line-0008}

::: {#c13.xhtml#c13-fig-0007 .figure}
![9781119489542-fg1307.png](https://i.imgur.com/udjeAW8.jpeg){.center}
:::

You can also write a line written as follows:

[]{#c13.xhtml#c13-code-0007}[]{#c13.xhtml#c13-lntxt-0007}

`line(x1,y1,x2,y2);`{#c13.xhtml#c13-line-0009}
:::

::: {.section}
[]{#c13.xhtml#c13-sec-0011}

#### []{#c13.xhtml#Page_315 .pagebreak role="doc-pagebreak" title="315"}Rectangle {#c13.xhtml#h4-3 .Heading-3}

You can draw a rectangle a number of different ways. In this first example, a rectangle is drawn by identifying the starting point and then the width and height of the rectangle. Write the following code to draw a rectangle in the center of your display window:

[]{#c13.xhtml#c13-code-0008}[]{#c13.xhtml#c13-lntxt-0008}

`size(300,200);`{#c13.xhtml#c13-line-0010}

`rect(150,100,50,50);`{#c13.xhtml#c13-line-0011}

In this case, you have a rectangle that starts in at point 150,100 in the center of the display window. That is the top-left corner of the rectangle, and from there it has a width of 50, which extends the rectangle toward the right of the window, and a height of 50, which extends toward the bottom of the window. This function is particularly useful if you want the size of the rectangle to remain constant but change the position of the rectangle. You could also write the code as follows:

[]{#c13.xhtml#c13-code-0009}[]{#c13.xhtml#c13-lntxt-0009}

`rect(x,y,width,height);`{#c13.xhtml#c13-line-0012}

When drawing rectangles, you can choose among different modes (see [Figure 13-8](#c13.xhtml#c13-fig-0008){#c13.xhtml#rc13-fig-0008}). If the mode is set to center, the rectangle is drawn centered around a point instead of being drawn from that point. Write the following code and you see that the same values display a different position when [`rectMode`]{.Code-within-text} is changed to [`CENTER`]{.Code-within-text}:

[]{#c13.xhtml#c13-code-0010}[]{#c13.xhtml#c13-lntxt-0010}

`rectMode(CENTER);`{#c13.xhtml#c13-line-0013}

`size(300,200);`{#c13.xhtml#c13-line-0014}

`rect(150,100,50,50);`{#c13.xhtml#c13-line-0015}

::: {#c13.xhtml#c13-fig-0008 .figure}
![9781119489542-fg1308.png](https://i.imgur.com/i40gsE0.jpeg){.center}
:::

You can see that the rectangle is now centered in the display window. The shape extends equally from the center point both left to right and top to bottom.

[]{#c13.xhtml#Page_316 .pagebreak role="doc-pagebreak" title="316"}You can also draw a rectangle by declaring two diagonally opposite corners. Write the following code, this time with [`rectMode`]{.Code-within-text} set to [`CORNERS`]{.Code-within-text}:

[]{#c13.xhtml#c13-code-0011}[]{#c13.xhtml#c13-lntxt-0011}

`rectMode(CORNERS);`{#c13.xhtml#c13-line-0016}

`size(300,200);`{#c13.xhtml#c13-line-0017}

`rect(150,100,50,50);`{#c13.xhtml#c13-line-0018}

You see a rectangle that is quite different from the others because it starts at the same point in the center, 150,100, but ends at point 50,50, creating a rectangle positioned above and to the left of the starting point. You can also write the code as follows:

[]{#c13.xhtml#c13-code-0012}[]{#c13.xhtml#c13-lntxt-0012}

`rect(x1,y1,x2,y2);`{#c13.xhtml#c13-line-0019}
:::

::: {.section}
[]{#c13.xhtml#c13-sec-0012}

#### Ellipse {#c13.xhtml#h4-4 .Heading-3}

The first item covered in this chapter was [`ellipse`]{.Code-within-text}, which can be used to simply draw an ellipse. Write the following code to draw an ellipse in the center of the display window:

[]{#c13.xhtml#c13-code-0013}[]{#c13.xhtml#c13-lntxt-0013}

`ellipse(150,100,50,50);`{#c13.xhtml#c13-line-0020}

The default mode for [`ellipse`]{.Code-within-text} is CENTER, whereas the default mode for [`rect`]{.Code-within-text} is [`CORNER`]{.Code-within-text}. The preceding line of code can also be written as follows:

[]{#c13.xhtml#c13-code-0014}[]{#c13.xhtml#c13-lntxt-0014}

`ellipse(x,y,width,height);`{#c13.xhtml#c13-line-0021}

As with [`rectMode()`]{.Code-within-text} it\'s possible to set different modes (see [Figure 13-9](#c13.xhtml#c13-fig-0009){#c13.xhtml#rc13-fig-0009}) for drawing ellipses using [`ellipseMode()`]{.Code-within-text}. Write the following code to draw an ellipse from its corner instead of its center: []{#c13.xhtml#Page_317 .pagebreak role="doc-pagebreak" title="317"}

[]{#c13.xhtml#c13-code-0015}[]{#c13.xhtml#c13-lntxt-0015}

`ellipseMode(CORNER);`{#c13.xhtml#c13-line-0022}

`size(300,200);`{#c13.xhtml#c13-line-0023}

`ellipse(150,100,50,50);`{#c13.xhtml#c13-line-0024}

::: {#c13.xhtml#c13-fig-0009 .figure}
![9781119489542-fg1309.png](https://i.imgur.com/uuGuIle.jpeg){.center}
:::

This draws an ellipse from starting from its top-left corner with a width of 50 and a height of 50.

It is also possible to draw an ellipse by specifying multiple corners. Write the following code to change the [`ellipseMode`]{.Code-within-text} to [`CORNERS`]{.Code-within-text}:

[]{#c13.xhtml#c13-code-0016}[]{#c13.xhtml#c13-lntxt-0016}

`ellipseMode(CORNERS);`{#c13.xhtml#c13-line-0025}

`size(300,200);`{#c13.xhtml#c13-line-0026}

`ellipse(150,100,50,50);`{#c13.xhtml#c13-line-0027}

Similarly to [`rectMode(CORNERS)`]{.Code-within-text}, the [`ellipseMode(CORNERS)`]{.Code-within-text} creates an ellipse positioned above and to the left of the starting point. The first corner is the center point of the sketch and the second is at point 50,50.
:::
:::

::: {.section}
[]{#c13.xhtml#c13-sec-0013}

### Changing color and opacity {#c13.xhtml#h3-4 .Heading-2}

Now that you have an understanding of shapes, it\'s time to affect their appearance. The simplest way to change a shape\'s appearance is to change the color. By using the [`background`]{.Code-within-text} and [`fill`]{.Code-within-text} functions, you can change the color of the shapes on your screen to any one of 16,777,216 colors. You can also set the opacity of the objects you draw, allowing you to mix colors by layering semitransparent shapes.

::: {.section}
[]{#c13.xhtml#Page_318 .pagebreak role="doc-pagebreak" title="318"}[]{#c13.xhtml#c13-sec-0014}

#### Background {#c13.xhtml#h4-5 .Heading-3}

The [`background`]{.Code-within-text} function changes the background of your sketch. You can choose grayscale values or color. You\'ll start by changing grayscale values.

Open a new sketch, and type the following code to change the default gray window to black:

[]{#c13.xhtml#c13-code-0017}[]{#c13.xhtml#c13-lntxt-0017}

`background(0);`{#c13.xhtml#c13-line-0028}

Change 0 to 255 to change the color to white:

[]{#c13.xhtml#c13-code-0018}[]{#c13.xhtml#c13-lntxt-0018}

`background(255);`{#c13.xhtml#c13-line-0029}

[]{#c13.xhtml#Page_319 .pagebreak role="doc-pagebreak" title="319"} Any value between 0 (black) and 255 (white) is a grayscale value. The reason that this range is 0 to 255 is that there are 8 bits of data in a byte, meaning that you need one byte to store a grayscale color value.

```{=html}
<aside>
```
::: {#c13.xhtml#c13-tblfxd-0001 .sidebar}
# MAKING SENSE OF BINARY, BITS, AND BYTES {.SB-Head}

[]{#c13.xhtml#c13-sec-0015}

The binary number system, also known as base-2, uses only two values: 0 or 1. Decimal numbers use 0 to 9 and are usually referred to as base-10. Hexadecimal numbers use 0 to 9 and A to F and are referred to as base-16.

But how is binary useful when you\'re trying to talk to lots of things and have only two options? The answer is that you use a lot of binary values.

For example, if you have a base-2 binary number such as 10101101, you can determine its value in base-10 with a simple lookup table. Binary is typically read from right to left. Because binary is base-2, each value is the binary value multiplied by 2 to the power of (2^x^), where *x* is equal to the order of the bit, starting at 0 on the right. For example, as shown in the following, the fourth binary value is equal to 1x(2x2x2) = 8.

```{=html}
<figure>
```
  ------------- -------- -------- -------- -------- -------- -------- -------- -------- -------
  Binary        1        0        1        0        1        1        0        1        
  Calculation   1×2^7^   0×2^6^   1×2^5^   0×2^4^   1×2^3^   1×2^2^   0×2^1^   1×2^0^   Total
  Decimal       128      0        32       0        8        4        0        1        173
  ------------- -------- -------- -------- -------- -------- -------- -------- -------- -------

```{=html}
</figure>
```
As you can see, extremely large numbers can be formed using only zeros and ones. In this case, you have eight binary values with a total decimal value of 255. When talking about memory, each binary value takes one *bit* of memory, and each group of eight bits is referred to as a *byte*. To give you an idea of scale, a blank Arduino sketch uses 466 bytes; an Uno can store a maximum of 32,256 bytes, and a Mega can store a maximum of 258,048 bytes.
:::

```{=html}
</aside>
```
To liven things up a bit, you can add color to your sketch background. Instead of 8-bit grayscale, you use 24-bit color, which is 8-bit red, 8-bit green, and 8-bit blue. The color of the background is defined with three values instead of one:

[]{#c13.xhtml#c13-code-0019}[]{#c13.xhtml#c13-lntxt-0019}

`background(200,100,0);`{#c13.xhtml#c13-line-0030}

This line of code gives you an orange background, which is comprised of a red value of 200, a green value of 100, and a blue value of 0. There are several color modes, but in this case this line of code can be interpreted as follows:

[]{#c13.xhtml#c13-code-0020}[]{#c13.xhtml#c13-lntxt-0020}

`background(red,green,blue);`{#c13.xhtml#c13-line-0031}
:::

::: {.section}
[]{#c13.xhtml#c13-sec-0016}

#### Fill {#c13.xhtml#h4-6 .Heading-3}

Want to change the color of the shapes you draw? Use [`fill`]{.Code-within-text} to both set color and control the shape's opacity.

[`fill`]{.Code-within-text} sets the color for any shape that is drawn after it. By calling [`fill`]{.Code-within-text} multiple times, you can change the color of several different shapes. Write the following code to draw three ellipses with different colors, as shown in [Figure 13-10](#c13.xhtml#c13-fig-0010){#c13.xhtml#rc13-fig-0010}:

[]{#c13.xhtml#c13-code-0021}[]{#c13.xhtml#c13-lntxt-0021}

`background(255);`{#c13.xhtml#c13-line-0032}

`noStroke();`{#c13.xhtml#c13-line-0033}

` `{#c13.xhtml#c13-line-0034}

`// Bright red`{#c13.xhtml#c13-line-0035}

`fill(255,0,0);`{#c13.xhtml#c13-line-0036}

`ellipse(50,35,40,40);`{#c13.xhtml#c13-line-0037}

` `{#c13.xhtml#c13-line-0038}

`// Bright green`{#c13.xhtml#c13-line-0039}

`fill(0,255,0);`{#c13.xhtml#c13-line-0040}

`ellipse(38,55,40,40);`{#c13.xhtml#c13-line-0041}

` `{#c13.xhtml#c13-line-0042}

`// Bright blue`{#c13.xhtml#c13-line-0043}

`fill(0,0,255);`{#c13.xhtml#c13-line-0044}

`ellipse(62,55,40,40);`{#c13.xhtml#c13-line-0045}

::: {#c13.xhtml#c13-fig-0010 .figure}
![9781119489542-fg1310.png](https://i.imgur.com/JrGYGas.jpeg){.center}
:::

The background is set to white (255), and the [`noStroke`]{.Code-within-text} function removes borders from the shapes. You can comment out the function by using two forward slashes ([`//`]{.Code-within-text}), to see the effect.

[]{#c13.xhtml#Page_320 .pagebreak role="doc-pagebreak" title="320"}It\'s also important to note that all shapes are drawn in the order in which they were programmed. You can see that the first circle to be drawn is red because the other two circles are layered on top of it. The red value is the highest possible (255), as is the second for green and the third for blue. If another shape were drawn at the end of the code, it would be the same strong blue because that is the last [`fill`]{.Code-within-text} value.

You can also affect the opacity of the colors, creating semitransparent shapes. By adding a fourth value to the [`fill`]{.Code-within-text} function, you can set the opacity from 0 (fully transparent) to 255 (solid color). Update the preceding code with the following values to give the circles transparency:

[]{#c13.xhtml#c13-code-0022}[]{#c13.xhtml#c13-lntxt-0022}

`   background(255);`{#c13.xhtml#c13-line-0046}

`   noStroke();`{#c13.xhtml#c13-line-0047}

` `{#c13.xhtml#c13-line-0048}

`   // Bright red`{#c13.xhtml#c13-line-0049}

`   fill(255,0,0,100);`{#c13.xhtml#c13-line-0050}

`   ellipse(50,35,40,40);`{#c13.xhtml#c13-line-0051}

` `{#c13.xhtml#c13-line-0052}

`   // Bright green`{#c13.xhtml#c13-line-0053}

`   fill(0,255,0,100);`{#c13.xhtml#c13-line-0054}

`   ellipse(38,55,40,40);`{#c13.xhtml#c13-line-0055}

` `{#c13.xhtml#c13-line-0056}

`   // Bright blue`{#c13.xhtml#c13-line-0057}

`   fill(0,0,255,100);`{#c13.xhtml#c13-line-0058}

`   ellipse(62,55,40,40);`{#c13.xhtml#c13-line-0059}
:::
:::

::: {.section}
[]{#c13.xhtml#c13-sec-0017}

### Playing with interaction {#c13.xhtml#h3-5 .Heading-2}

All of this is fun but static. In the next example, you inject some life into your sketches by using your mouse as an input. To do this, you must constantly update the sketch by looping through it over and over again, sending new values for each loop. Write the following code to create an interactive sketch: []{#c13.xhtml#Page_321 .pagebreak role="doc-pagebreak" title="321"}

[]{#c13.xhtml#c13-code-0023}[]{#c13.xhtml#c13-lntxt-0023}

`void setup() {`{#c13.xhtml#c13-line-0060}

`}`{#c13.xhtml#c13-line-0061}

` `{#c13.xhtml#c13-line-0062}

`void draw() {`{#c13.xhtml#c13-line-0063}

`ellipse(mouseX,mouseY,20,20);`{#c13.xhtml#c13-line-0064}

`}`{#c13.xhtml#c13-line-0065}

This code draws an ellipse centered on your mouse pointer coordinates, so when you move your mouse you leave a trail of ellipses behind, as shown in [Figure 13-11](#c13.xhtml#c13-fig-0011){#c13.xhtml#rc13-fig-0011}. The functions [`mouseX`]{.Code-within-text} and [`mouseY`]{.Code-within-text} are shown in pink in the text editor and take the coordinates of your mouse pointer in the display window. The values are the number of pixels horizontally and vertically, respectively.

::: {#c13.xhtml#c13-fig-0011 .figure}
![9781119489542-fg1311.png](https://i.imgur.com/t2TShR3.jpeg){.center}
:::

This code might look familiar. Instead of Arduino\'s [`void setup`]{.Code-within-text} and [`void loop`]{.Code-within-text}, Processing uses [`void setup`]{.Code-within-text} and [`void draw`]{.Code-within-text}. These work in almost the same way: [`setup`]{.Code-within-text} runs once at the start of the sketch; [`loop`]{.Code-within-text} and [`draw`]{.Code-within-text} run forever or until they are told to stop. You can stop the sketch at any time by clicking the Stop button.

Change the sketch slightly, and you can cover up all those previous ellipses to display only the most recent (see [Figure 13-12](#c13.xhtml#c13-fig-0012){#c13.xhtml#rc13-fig-0012}).

[]{#c13.xhtml#c13-code-0024}[]{#c13.xhtml#c13-lntxt-0024}

`void setup() {`{#c13.xhtml#c13-line-0066}

`}`{#c13.xhtml#c13-line-0067}

` `{#c13.xhtml#c13-line-0068}

`void draw() {`{#c13.xhtml#c13-line-0069}

`background(0);`{#c13.xhtml#c13-line-0070}

`ellipse(mouseX,mouseY,20,20);`{#c13.xhtml#c13-line-0071}

`}`{#c13.xhtml#c13-line-0072}

::: {#c13.xhtml#c13-fig-0012 .figure}
![9781119489542-fg1312.png](https://i.imgur.com/lwX2Av7.jpeg){.center}
:::

[]{#c13.xhtml#Page_322 .pagebreak role="doc-pagebreak" title="322"}There is much more to Processing that I can't cover in this book. However, these few points should be enough to gain a basic comprehension of how code relates to the onscreen visuals. You can find a wealth of examples, both on the Processing site and in the Processing software. The best approach is to run the examples and then tweak the values to see what happens. You\'ll learn what's going on much more quickly by experimenting, and with no electronics, you won\'t break anything.
:::
:::

[]{#c14.xhtml}

[]{#c14.xhtml#Page_323 .pagebreak role="doc-pagebreak" title="323"}Chapter 14

# Processing the Physical World {#c14.xhtml#a1 .Chap-Title}

::: {.section}
[]{#c14.xhtml#c14-sec-0001}[]{#c14.xhtml#c14-feafxd-0001}

IN THIS CHAPTER

![check.png](https://i.imgur.com/B3kxdgT.jpeg) **Turning on a real light with a virtual switch**

![check.png](https://i.imgur.com/AP5YES3.jpeg) **Graphing data from the physical world**

![check.png](https://i.imgur.com/w57s4Wz.jpeg) **Sending signals between the Arduino and Processing**

In the preceding chapter, you learn the basics of Processing and its similarities to and differences from Arduino. This chapter is all about combining both tools to integrate the virtual and physical worlds. These few exercises teach you the basics about sending and receiving data in both Processing and Arduino. You can build on this knowledge to create your own projects, maybe to generate some awesome onscreen visuals from your sensors or to turn on a light every time someone mentions you on Twitter.
:::

::: {.section}
[]{#c14.xhtml#c14-sec-0002}

## Making a Virtual Button {#c14.xhtml#h2-1 .Heading-1}

In this example, you learn how to make an onscreen button in Processing that affects a physical LED on your Arduino. This is a great sketch to get started with interactions between computers and the real world, and between an Arduino and Processing.

You need the following:

-   [An Arduino Uno]{#c14.xhtml#c14-li-0004}
-   [An LED]{#c14.xhtml#c14-li-0005}

[]{#c14.xhtml#Page_324 .pagebreak role="doc-pagebreak" title="324"}The setup is simple for this introduction to Arduino and Processing, requiring only a single LED.

As shown in [Figures 14-1](#c14.xhtml#c14-fig-0001){#c14.xhtml#rc14-fig-0001} and [14-2](#c14.xhtml#c14-fig-0002){#c14.xhtml#rc14-fig-0002}, insert the long leg of the LED into pin 13 and the short leg into GND. If you don't have an LED, you can simply monitor the onboard LED marked L.

::: {#c14.xhtml#c14-fig-0001 .figure}
![9781119489542-fg1401.png](https://i.imgur.com/wMNnKT1.jpeg){.center}
:::

::: {#c14.xhtml#c14-fig-0002 .figure}
![9781119489542-fg1402.png](https://i.imgur.com/SQkrgRx.jpeg){.center}
:::

::: {.section}
[]{#c14.xhtml#c14-sec-0003}

### Setting up the Arduino code {#c14.xhtml#h3-1 .Heading-2}

After your circuit is assembled, you need the appropriate software to use it. From the Arduino menu, choose File ⇒   Examples ⇒   04.Communication ⇒   PhysicalPixel to open the sketch.

This sketch contains both Arduino code and the relevant Processing code for the sketch to work. (It also has a variation in Max 5.) The code below the Arduino code is commented out to avoid interfering with the Arduino code.

![technicalstuff.png](https://i.imgur.com/AshmCFI.jpeg) In older versions of Arduino, the sketch files ended with [`.pde`]{.Code-within-text}, which is the Processing suffix. This caused confusion, so now the Arduino suffix is [`.ino`]{.Code-within-text}. Different suffixes make it possible to have the Arduino sketch and the Processing sketch in the same place. If you try to open a [`.pde`]{.Code-within-text} file in Arduino, the application assumes that it is an old Arduino sketch and asks whether you want to change the suffix to [`.ino`]{.Code-within-text}.

[]{#c14.xhtml#c14-code-0001}[]{#c14.xhtml#c14-lntxt-0001}

`/*`{#c14.xhtml#c14-line-0001}

`  Physical Pixel`{#c14.xhtml#c14-line-0002}

` `{#c14.xhtml#c14-line-0003}

` An example of using the Arduino board to receive data from the`{#c14.xhtml#c14-line-0004}

` computer.  In this case, the Arduino boards turns on an LED when`{#c14.xhtml#c14-line-0005}

` it receives the character 'H', and turns off the LED when it`{#c14.xhtml#c14-line-0006}

` receives the character 'L'.`{#c14.xhtml#c14-line-0007}

` `{#c14.xhtml#c14-line-0008}

` The data can be sent from the Arduino serial monitor, or another`{#c14.xhtml#c14-line-0009}

` program like Processing (see code below), Flash (via a serial-net`{#c14.xhtml#c14-line-0010}

` proxy), PD, or Max/MSP.`{#c14.xhtml#c14-line-0011}

` `{#c14.xhtml#c14-line-0012}

` The circuit:`{#c14.xhtml#c14-line-0013}

` * LED connected from digital pin 13 to ground`{#c14.xhtml#c14-line-0014}

` `{#c14.xhtml#c14-line-0015}

` created 2006`{#c14.xhtml#c14-line-0016}

` by David A. Mellis`{#c14.xhtml#c14-line-0017}

` modified 30 Aug 2011`{#c14.xhtml#c14-line-0018}

` by Tom Igoe and Scott Fitzgerald`{#c14.xhtml#c14-line-0019}

` `{#c14.xhtml#c14-line-0020}

` This example code is in the public domain.`{#c14.xhtml#c14-line-0021}

` `{#c14.xhtml#c14-line-0022}

` http://www.arduino.cc/en/Tutorial/PhysicalPixel`{#c14.xhtml#c14-line-0023}

` */`{#c14.xhtml#c14-line-0024}

` `{#c14.xhtml#c14-line-0025}

`const int ledPin = 13; // the pin that the LED is attached to`{#c14.xhtml#c14-line-0026}

`int incomingByte;      // a variable to read incoming serial data into`{#c14.xhtml#c14-line-0027}

` `{#c14.xhtml#c14-line-0028}

`void setup() {`{#c14.xhtml#c14-line-0029}

`  // initialize serial communication:`{#c14.xhtml#c14-line-0030}

`  Serial.begin(9600);`{#c14.xhtml#c14-line-0031}

`  // initialize the LED pin as an output:`{#c14.xhtml#c14-line-0032}

`  pinMode(ledPin, OUTPUT);`{#c14.xhtml#c14-line-0033}

`}`{#c14.xhtml#c14-line-0034}

` `{#c14.xhtml#c14-line-0035}

`void loop() {`{#c14.xhtml#c14-line-0036}

`  // see if there's incoming serial data:`{#c14.xhtml#c14-line-0037}

`  if (Serial.available() > 0) {`{#c14.xhtml#c14-line-0038}

`    // read the oldest byte in the serial buffer:`{#c14.xhtml#c14-line-0039}

`    incomingByte = Serial.read();`{#c14.xhtml#c14-line-0040}

`    // if it's a capital H (ASCII 72), turn on the LED:`{#c14.xhtml#c14-line-0041}

`    if (incomingByte == 'H') {`{#c14.xhtml#c14-line-0042}

`      digitalWrite(ledPin, HIGH);`{#c14.xhtml#c14-line-0043}

`    }`{#c14.xhtml#c14-line-0044}

`    // if it's an L (ASCII 76) turn off the LED:`{#c14.xhtml#c14-line-0045}

`    if (incomingByte == 'L') {`{#c14.xhtml#c14-line-0046}

`      digitalWrite(ledPin, LOW);`{#c14.xhtml#c14-line-0047}

`    }`{#c14.xhtml#c14-line-0048}

`  }`{#c14.xhtml#c14-line-0049}

`}`{#c14.xhtml#c14-line-0050}

Now go through the steps to upload your sketch.

With the Arduino set up to receive a message from Processing, you need to set up the Processing sketch to send a signal message over the same serial port to your Arduino.
:::

::: {.section}
[]{#c14.xhtml#c14-sec-0004}

### Setting up the Processing code {#c14.xhtml#h3-2 .Heading-2}

The Processing code is available within multiline comment markers ([`/* */`]{.Code-within-text}) at the bottom of the Arduino PhysicalPixel sketch. Copy the code within the comment markers, paste it into a new Processing sketch, and save it with an appropriate name, such as PhysicalPixel:

[]{#c14.xhtml#c14-code-0002}[]{#c14.xhtml#c14-lntxt-0002}

`// Mouse over serial`{#c14.xhtml#c14-line-0051}

` `{#c14.xhtml#c14-line-0052}

` // Demonstrates how to send data to the Arduino I/O board, in order to`{#c14.xhtml#c14-line-0053}

` // turn ON a light if the mouse is over a square and turn it off`{#c14.xhtml#c14-line-0054}

` // if the mouse is not.`{#c14.xhtml#c14-line-0055}

` `{#c14.xhtml#c14-line-0056}

` // created 2003-4`{#c14.xhtml#c14-line-0057}

` // based on examples by Casey Reas and Hernando Barragan`{#c14.xhtml#c14-line-0058}

` // modified 30 Aug 2011`{#c14.xhtml#c14-line-0059}

` // by Tom Igoe`{#c14.xhtml#c14-line-0060}

` // This example code is in the public domain.`{#c14.xhtml#c14-line-0061}

` `{#c14.xhtml#c14-line-0062}

` `{#c14.xhtml#c14-line-0063}

` `{#c14.xhtml#c14-line-0064}

` import processing.serial.*;`{#c14.xhtml#c14-line-0065}

` `{#c14.xhtml#c14-line-0066}

` float boxX;`{#c14.xhtml#c14-line-0067}

` float boxY;`{#c14.xhtml#c14-line-0068}

` int boxSize = 20;`{#c14.xhtml#c14-line-0069}

` boolean mouseOverBox = false;`{#c14.xhtml#c14-line-0070}

` `{#c14.xhtml#c14-line-0071}

` Serial port;`{#c14.xhtml#c14-line-0072}

` `{#c14.xhtml#c14-line-0073}

` void setup()  {`{#c14.xhtml#c14-line-0074}

` size(200, 200);`{#c14.xhtml#c14-line-0075}

` boxX = width/2.0;`{#c14.xhtml#c14-line-0076}

` boxY = height/2.0;`{#c14.xhtml#c14-line-0077}

` rectMode(RADIUS);`{#c14.xhtml#c14-line-0078}

` `{#c14.xhtml#c14-line-0079}

` // List all the available serial ports in the output pane.`{#c14.xhtml#c14-line-0080}

` // You will need to choose the port that the Arduino board is`{#c14.xhtml#c14-line-0081}

` // connected to from this list. The first port in the list is`{#c14.xhtml#c14-line-0082}

` // port #0 and the third port in the list is port #2.`{#c14.xhtml#c14-line-0083}

` println(Serial.list());`{#c14.xhtml#c14-line-0084}

` `{#c14.xhtml#c14-line-0085}

` // Open the port that the Arduino board is connected to (in this case #0)`{#c14.xhtml#c14-line-0086}

` // Make sure to open the port at the same speed Arduino is using (9600bps)`{#c14.xhtml#c14-line-0087}

` port = new Serial(this, Serial.list()[0], 9600);`{#c14.xhtml#c14-line-0088}

` `{#c14.xhtml#c14-line-0089}

` }`{#c14.xhtml#c14-line-0090}

` `{#c14.xhtml#c14-line-0091}

` void draw()`{#c14.xhtml#c14-line-0092}

` {`{#c14.xhtml#c14-line-0093}

` background(0);`{#c14.xhtml#c14-line-0094}

` `{#c14.xhtml#c14-line-0095}

` // Test if the cursor is over the box`{#c14.xhtml#c14-line-0096}

` if (mouseX > boxX-boxSize && mouseX < boxX+boxSize &&`{#c14.xhtml#c14-line-0097}

` mouseY > boxY-boxSize && mouseY < boxY+boxSize) {`{#c14.xhtml#c14-line-0098}

` mouseOverBox = true;`{#c14.xhtml#c14-line-0099}

` // draw a line around the box and change its color:`{#c14.xhtml#c14-line-0100}

` stroke(255);`{#c14.xhtml#c14-line-0101}

` fill(153);`{#c14.xhtml#c14-line-0102}

` // send an 'H' to indicate mouse is over square:`{#c14.xhtml#c14-line-0103}

` port.write('H');`{#c14.xhtml#c14-line-0104}

` }`{#c14.xhtml#c14-line-0105}

` else {`{#c14.xhtml#c14-line-0106}

` // return the box to its inactive state:`{#c14.xhtml#c14-line-0107}

` stroke(153);`{#c14.xhtml#c14-line-0108}

` fill(153);`{#c14.xhtml#c14-line-0109}

` // send an 'L' to turn the LED off:`{#c14.xhtml#c14-line-0110}

` port.write('L');`{#c14.xhtml#c14-line-0111}

` mouseOverBox = false;`{#c14.xhtml#c14-line-0112}

` }`{#c14.xhtml#c14-line-0113}

` `{#c14.xhtml#c14-line-0114}

` // Draw the box`{#c14.xhtml#c14-line-0115}

` rect(boxX, boxY, boxSize, boxSize);`{#c14.xhtml#c14-line-0116}

` }`{#c14.xhtml#c14-line-0117}

Click the Run button to execute the Processing sketch, and an applet appears. The applet has a black background with a gray square in the middle, representing your virtual button (shown in [Figure 14-3](#c14.xhtml#c14-fig-0003){#c14.xhtml#rc14-fig-0003}). If you move your mouse cursor over the gray square (or pixel), you can see that its edges turn white. If you then look at your Arduino, you see that whenever your mouse cursor hovers over the gray square, the LED on your board illuminates, giving you a physical representation of your pixel.

::: {#c14.xhtml#c14-fig-0003 .figure}
![9781119489542-fg1403.png](https://i.imgur.com/ZrrPzXC.jpeg){.center}
:::

If your LED doesn\'t light, double-check your wiring:

-   [Make sure that you're using the correct pin number.]{#c14.xhtml#c14-li-0006}
-   [Make sure that the LED legs are inserted correctly.]{#c14.xhtml#c14-li-0007}
-   [Check that you're using the correct serial port.]{#c14.xhtml#c14-li-0008}
-   [Check that your Arduino code uploaded correctly and that your Processing code has no errors. Note that you cannot upload while the Processing sketch is communicating with your Arduino, so you need to stop the sketch before uploading.]{#c14.xhtml#c14-li-0009}
:::

::: {.section}
[]{#c14.xhtml#Page_329 .pagebreak role="doc-pagebreak" title="329"}[]{#c14.xhtml#c14-sec-0005}

### Understanding the Processing PhysicalPixel sketch {#c14.xhtml#h3-3 .Heading-2}

Wherever possible, dividing projects into their elements is a good idea. You may have many inputs and outputs, but if you deal with them one at a time, they are easier to understand and easier to troubleshoot. Because the Processing side is the input, you're wise to start with that.

The structure of a Processing sketch is similar to Arduino. You include libraries and declare variables at the start of the sketch and set fixed values or initializations in [`setup.`]{.Code-within-text} The [`draw`]{.Code-within-text} function then repeats its process until told otherwise.

Processing uses libraries to add functionality in the same way as Arduino does. In this case, a serial communication library is needed to talk to Arduino. In Arduino, this library is included by using [`#include <libraryName.h>`]{.Code-within-text}. However, in Processing, you use the [`import`]{.Code-within-text} keyword, followed by the name and the syntax [`*`]{.Code-within-text} to load all the related parts of that library:

[]{#c14.xhtml#c14-code-0003}[]{#c14.xhtml#c14-lntxt-0003}

`import processing.serial.*;`{#c14.xhtml#c14-line-0118}

A *float* is a floating-point number, one with a decimal place, such as 0.5 or 10.9. In this case, two floating-point numbers are declared, [`boxX`]{.Code-within-text} and [`boxY`]{.Code-within-text}. These are the coordinates for the location of the box:

[]{#c14.xhtml#c14-code-0004}[]{#c14.xhtml#c14-lntxt-0004}

`float boxX;`{#c14.xhtml#c14-line-0119}

`float boxY;`{#c14.xhtml#c14-line-0120}

Next, [`boxSize`]{.Code-within-text} defines the size of the box as an integer, or whole number. Because it is square, only one value is needed:

[]{#c14.xhtml#c14-code-0005}[]{#c14.xhtml#c14-lntxt-0005}

`int boxSize = 20;`{#c14.xhtml#c14-line-0121}

A Boolean (which can be only [`true`]{.Code-within-text} or [`false`]{.Code-within-text}) is used to communicate that the mouse cursor is over the box. [`boolean`]{.Code-within-text} is set to start as [`false`]{.Code-within-text}:

[]{#c14.xhtml#c14-code-0006}[]{#c14.xhtml#c14-lntxt-0006}

`boolean mouseOverBox = false;`{#c14.xhtml#c14-line-0122}

The last thing to do is create a new [`Serial port`]{.Code-within-text} object. Many serial connections could be in use by your computer, so it\'s important that each one be named so that it can be used as needed. In this case, you are using only one port. The word *serial* is specific to the serial library to indicate that you want to create a new serial object (connection), and the word *port* is the name of the object (connection) used to refer to the port from this point on. Think of it as giving your cat a collar. If too []{#c14.xhtml#Page_330 .pagebreak role="doc-pagebreak" title="330"}many cats are in a room, they all look fairly similar and follow the same general rules, but they are still all individual. If you put a colored collar on each cat with its name printed on it, you can easily identify which one is which.

[]{#c14.xhtml#c14-code-0007}[]{#c14.xhtml#c14-lntxt-0007}

`Serial port;`{#c14.xhtml#c14-line-0123}

In [`setup`]{.Code-within-text}, the first item to define is the size of the display window, which is set to 200 pixels square:

[]{#c14.xhtml#c14-code-0008}[]{#c14.xhtml#c14-lntxt-0008}

`void setup() {`{#c14.xhtml#c14-line-0124}

`  size(200,200);`{#c14.xhtml#c14-line-0125}

The variables for [`boxX`]{.Code-within-text} and [`boxY`]{.Code-within-text} are set to be proportional to the width and height, respectively, of the display window. They are always equal to half the width and height. Next, [`rectMode`]{.Code-within-text} is set to [`RADIUS`]{.Code-within-text}, which is similar to [`CENTER`]{.Code-within-text}, but instead of specifying the overall width and height of the rectangle, [`RADIUS`]{.Code-within-text} specifies half the height and width. ([`CENTER`]{.Code-within-text} could be interpreted as diameter in that respect.) Because the coordinates of the box are centered and are aligned to the center point of the display window, the box is also perfectly centered:

[]{#c14.xhtml#c14-code-0009}[]{#c14.xhtml#c14-lntxt-0009}

`  boxX = width/2.0;`{#c14.xhtml#c14-line-0126}

`  boxY = height/2.0;`{#c14.xhtml#c14-line-0127}

`  rectMode(RADIUS);`{#c14.xhtml#c14-line-0128}

Your computer may have a lot of serial connections, so it\'s best to print a list of them to locate your Arduino:

[]{#c14.xhtml#c14-code-0010}[]{#c14.xhtml#c14-lntxt-0010}

`  println(Serial.list());`{#c14.xhtml#c14-line-0129}

The most recent port usually appears at the top of this list in position 0, so if you've just plugged in your Arduino, the first item is likely the one you want. If you\'re not using the [`Serial.list`]{.Code-within-text} function, you could replace [`Serial.list()[0]`]{.Code-within-text} with another number in the list, which will be printed on the console. You can also replace [`Serial.list()[0]`]{.Code-within-text} with the name of the port, such as /dev/tty.usbmodem26221 or COM5. Specifying the name is also useful if you have multiple Arduinos connected to the same computer. The number 9600 refers to the baud rate, which is the rate at which you\'re communicating with the Arduino.

[]{#c14.xhtml#c14-code-0011}[]{#c14.xhtml#c14-lntxt-0011}

`port = new Serial(this, Serial.list()[0], 9600);`{#c14.xhtml#c14-line-0130}

`}`{#c14.xhtml#c14-line-0131}

[]{#c14.xhtml#Page_331 .pagebreak role="doc-pagebreak" title="331"}![remember.png](https://i.imgur.com/JdJJUC7.jpeg) If the baud rate number is not the same on both ends (the sending and receiving end), the data will not be received.

In [`draw`]{.Code-within-text}, the first task is to draw a black background:

[]{#c14.xhtml#c14-code-0012}[]{#c14.xhtml#c14-lntxt-0012}

`void draw()`{#c14.xhtml#c14-line-0132}

`{`{#c14.xhtml#c14-line-0133}

`  background(0);`{#c14.xhtml#c14-line-0134}

Processing uses the same (or similar) conditionals as Arduino. This [`if`]{.Code-within-text} statement tests the mouse value to see whether the cursor is over the box area. If [`mouseX`]{.Code-within-text} is greater than the box coordinate (center) minus the size of the box (half the box width), and less than the box coordinate (center) plus the size of the box (half the box width), the horizontal position is over the box. This statement is used again with the vertical position, using [`AND`]{.Code-within-text} statements ([`&&`]{.Code-within-text}) to add to the conditions of the [`if`]{.Code-within-text} statement. Only if all these are [`true`]{.Code-within-text} can the Boolean [`mouseOverBox`]{.Code-within-text} be declared true:

[]{#c14.xhtml#c14-code-0013}[]{#c14.xhtml#c14-lntxt-0013}

`  // Test if the cursor is over the box`{#c14.xhtml#c14-line-0135}

`  if (mouseX > boxX-boxSize && mouseX < boxX+boxSize &&`{#c14.xhtml#c14-line-0136}

`    mouseY > boxY-boxSize && mouseY < boxY+boxSize) {`{#c14.xhtml#c14-line-0137}

`    mouseOverBox = true;`{#c14.xhtml#c14-line-0138}

To indicate that [`mouseOverBox`]{.Code-within-text} is [`true`]{.Code-within-text}, the code draws a white line around the box. Rather than requiring that another box be drawn, the white line appears simply by changing the stroke, or outline, value (*stroke* is a term common in most graphics software). The stroke is set to 255, which outlines the box in white:

[]{#c14.xhtml#c14-code-0014}[]{#c14.xhtml#c14-lntxt-0014}

`    // draw a line around the box and change its color:`{#c14.xhtml#c14-line-0139}

`    stroke(255);`{#c14.xhtml#c14-line-0140}

Fill is set to 153, a mid-gray, which colors the next object drawn:

[]{#c14.xhtml#c14-code-0015}[]{#c14.xhtml#c14-lntxt-0015}

`    fill(153);`{#c14.xhtml#c14-line-0141}

Then the all-important communication is sent. The [`port.write`]{.Code-within-text} statement is similar to [`Serial.print`]{.Code-within-text} but is used for writing to a serial port in Processing. The character sent is [`H`]{.Code-within-text}, for high:

[]{#c14.xhtml#c14-code-0016}[]{#c14.xhtml#c14-lntxt-0016}

`    // send an 'H' to indicate mouse is over square:`{#c14.xhtml#c14-line-0142}

`    port.write('H');`{#c14.xhtml#c14-line-0143}

`  }`{#c14.xhtml#c14-line-0144}

[]{#c14.xhtml#Page_332 .pagebreak role="doc-pagebreak" title="332"} The [`else`]{.Code-within-text} statement tells Processing what to do if the mouse cursor is not over the box:

[]{#c14.xhtml#c14-code-0017}[]{#c14.xhtml#c14-lntxt-0017}

`  else {`{#c14.xhtml#c14-line-0145}

The [`stroke`]{.Code-within-text} value is set to the same mid-gray as the box. The box fill color remains the same whether active or inactive:

[]{#c14.xhtml#c14-code-0018}[]{#c14.xhtml#c14-lntxt-0018}

`    // return the box to its inactive state:`{#c14.xhtml#c14-line-0146}

`    stroke(153);`{#c14.xhtml#c14-line-0147}

`    fill(153);`{#c14.xhtml#c14-line-0148}

The character L is sent to the serial port to signify that the LED should be set low:

[]{#c14.xhtml#c14-code-0019}[]{#c14.xhtml#c14-lntxt-0019}

`    // send an 'L' to turn the LED off:`{#c14.xhtml#c14-line-0149}

`    port.write('L');`{#c14.xhtml#c14-line-0150}

The Boolean [`mouseOverBox`]{.Code-within-text} is set to [`false`]{.Code-within-text}:

[]{#c14.xhtml#c14-code-0020}[]{#c14.xhtml#c14-lntxt-0020}

`    mouseOverBox = false;`{#c14.xhtml#c14-line-0151}

`  }`{#c14.xhtml#c14-line-0152}

Finally, the box (technically a rectangle) is drawn. Its coordinates are always centered, and its size remains the same; the only difference is the color applied by the [`if`]{.Code-within-text} statement. If the mouse cursor is over the box, the [`stroke`]{.Code-within-text} value is changed to white (active), and if not, the [`stroke`]{.Code-within-text} value is set to the same gray as the box and appears to not be there (inactive):

[]{#c14.xhtml#c14-code-0021}[]{#c14.xhtml#c14-lntxt-0021}

`  // Draw the box`{#c14.xhtml#c14-line-0153}

`  rect(boxX, boxY, boxSize, boxSize);`{#c14.xhtml#c14-line-0154}

`}`{#c14.xhtml#c14-line-0155}
:::

::: {.section}
[]{#c14.xhtml#c14-sec-0006}

### Understanding the Arduino PhysicalPixel sketch {#c14.xhtml#h3-4 .Heading-2}

In the preceding section, you find out how the Processing side provides a signal. The signal is sent over the serial connection to your Arduino. In this section, I explain what the Arduino code does with the signal. The Arduino code for this example is simple compared to other examples in this book and is great for understanding how a serial connection is made. I always recommend starting with this sketch for any Processing-to-Arduino communication. It\'s great as a foundation to make sure that your hardware and software are working, and you can then build on or adapt it as needed.

[]{#c14.xhtml#Page_333 .pagebreak role="doc-pagebreak" title="333"}First, the constant and variable values are declared. The LED pin --- pin 13 --- is the LED output and does not change, so it is declared as a constant. The [`incomingByte`]{.Code-within-text} value does change and is declared as an integer ([`int`]{.Code-within-text}), not a character ([`char`]{.Code-within-text}). I explain why a bit later.

[]{#c14.xhtml#c14-code-0022}[]{#c14.xhtml#c14-lntxt-0022}

`const int ledPin = 13; // the pin that the LED is attached to`{#c14.xhtml#c14-line-0156}

`int incomingByte;      // a variable to read incoming serial data into`{#c14.xhtml#c14-line-0157}

In [`setup`]{.Code-within-text}, the serial communication is initialized and set to a matching baud rate of 9600.

![remember.png](https://i.imgur.com/A47E3Sh.jpeg) Remember that in Processing and Arduino, if you change the speed of the device or application sending data, you also must change the speed of the device or application receiving data. When communicating with a computer, you must choose from the following values: 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, or 115200.

[]{#c14.xhtml#c14-code-0023}[]{#c14.xhtml#c14-lntxt-0023}

`void setup() {`{#c14.xhtml#c14-line-0158}

`  // initialize serial communication:`{#c14.xhtml#c14-line-0159}

`  Serial.begin(9600);`{#c14.xhtml#c14-line-0160}

Pin 13, or [`ledPin`]{.Code-within-text} as it is named, is set to be an output.

[]{#c14.xhtml#c14-code-0024}[]{#c14.xhtml#c14-lntxt-0024}

`  // initialize the LED pin as an output:`{#c14.xhtml#c14-line-0161}

`  pinMode(ledPin, OUTPUT);`{#c14.xhtml#c14-line-0162}

`}`{#c14.xhtml#c14-line-0163}

The first action in the [`loop`]{.Code-within-text} is to determine whether any data is available. [`Serial.available`]{.Code-within-text} reads the serial buffer, which stores any data sent to the Arduino before it is read. Nothing happens until data is sent to the buffer.

By checking that the value is greater than 0, you reduce the number of readings considerably. Reading lots of 0 or null values can considerably slow down the operation of your Arduino and any programs or hardware reading from it:

[]{#c14.xhtml#c14-code-0025}[]{#c14.xhtml#c14-lntxt-0025}

`void loop() {`{#c14.xhtml#c14-line-0164}

`  // see if there's incoming serial data:`{#c14.xhtml#c14-line-0165}

`  if (Serial.available() > 0) {`{#c14.xhtml#c14-line-0166}

If a value is greater than 0, it is stored in the [`int`]{.Code-within-text} variable [`incomingByte`]{.Code-within-text}:

[]{#c14.xhtml#c14-code-0026}[]{#c14.xhtml#c14-lntxt-0026}

`    // read the oldest byte in the serial buffer:`{#c14.xhtml#c14-line-0167}

`    incomingByte = Serial.read();`{#c14.xhtml#c14-line-0168}

[]{#c14.xhtml#Page_334 .pagebreak role="doc-pagebreak" title="334"} Now you need to know if the data received is what your program is expecting. Processing sent H as a character, but that is just a byte of data that can be understood as a number or a character. In this case, you\'re treating it as an integer. This [`if`]{.Code-within-text} statement checks to see whether the integer value is equal to 72, which is equal to the character H in ASCII. The inverted commas indicate that it is a character and not a variable. The statement [`if (incomingByte == 72) {`]{.Code-within-text} would return the same result:

[]{#c14.xhtml#c14-code-0027}[]{#c14.xhtml#c14-lntxt-0027}

`    // if it's a capital H (ASCII 72), turn on the LED:`{#c14.xhtml#c14-line-0169}

`    if (incomingByte == 'H') {`{#c14.xhtml#c14-line-0170}

If the values are equal, pin 13 is set [`HIGH`]{.Code-within-text}:

[]{#c14.xhtml#c14-code-0028}[]{#c14.xhtml#c14-lntxt-0028}

`      digitalWrite(ledPin, HIGH);`{#c14.xhtml#c14-line-0171}

`    }`{#c14.xhtml#c14-line-0172}

If the value is the character L, or the integer value 76, the same pin is set [`LOW`]{.Code-within-text}:

[]{#c14.xhtml#c14-code-0029}[]{#c14.xhtml#c14-lntxt-0029}

`    // if it's an L (ASCII 76) turn off the LED:`{#c14.xhtml#c14-line-0173}

`    if (incomingByte == 'L') {`{#c14.xhtml#c14-line-0174}

`      digitalWrite(ledPin, LOW);`{#c14.xhtml#c14-line-0175}

`    }`{#c14.xhtml#c14-line-0176}

`  }`{#c14.xhtml#c14-line-0177}

`}`{#c14.xhtml#c14-line-0178}

This basic Processing-to-Arduino interaction works great as the basis for larger projects. In this example, the onscreen interaction is the input and could be swapped for more useful or elaborate inputs. One such input is face tracking: When your face is at the center of the screen, the signal is sent. On the Arduino side of the code, as is true of Processing, a vast array of outputs could be triggered besides lighting an LED (lovely though it is). For instance, you could link optocouplers to a remote and begin playback whenever a high signal is sent, and you could pause playback whenever a low signal is sent. See the bonus chapter, "Hacking Other Hardware," at [[`www.dummies.com/go/arduinofd`]{.Code-within-text}](http://www.dummies.com/go/arduinofd) for more about working with optocouplers.
:::
:::

::: {.section}
[]{#c14.xhtml#c14-sec-0007}

## Drawing a Graph {#c14.xhtml#h2-2 .Heading-1}

In the preceding section, you see how to send a signal in one direction. Want to learn how to send signals the other direction, from Arduino to Processing? In this example, you find out how to read the value of a potentiometer using your Arduino and display it in a Processing applet.

[]{#c14.xhtml#Page_335 .pagebreak role="doc-pagebreak" title="335"}You need the following:

-   [An Arduino Uno]{#c14.xhtml#c14-li-0010}
-   [A breadboard]{#c14.xhtml#c14-li-0011}
-   [A potentiometer]{#c14.xhtml#c14-li-0012}
-   [Jump wires]{#c14.xhtml#c14-li-0013}

This basic circuit uses a potentiometer to send an analog value to Processing that can be interpreted and displayed on an onscreen graph. Assemble the circuit by connecting the center pin of the potentiometer to analog pin 0, following [Figures 14-4](#c14.xhtml#c14-fig-0004){#c14.xhtml#rc14-fig-0004} and [14-5](#c14.xhtml#c14-fig-0005){#c14.xhtml#rc14-fig-0005}. The potentiometer is wired with the central pin connected to analog pin 0. Of the other two pins, one is connected to 5V and the other to GND. By reversing these pins, you can change the directions that the potentiometer counts when turned.

::: {#c14.xhtml#c14-fig-0004 .figure}
![9781119489542-fg1404.png](https://i.imgur.com/EqrXq9G.jpeg){.center}
:::

::: {#c14.xhtml#c14-fig-0005 .figure}
![9781119489542-fg1405.png](https://i.imgur.com/atEjxgG.jpeg){.center}
:::

::: {.section}
[]{#c14.xhtml#c14-sec-0008}

### Setting up the Arduino code {#c14.xhtml#h3-5 .Heading-2}

After you assemble your circuit, you need the appropriate software to use it. From the Arduino menu, choose File ⇒   Examples ⇒   04.Communication ⇒   Graph to open the sketch. This sketch contains both Arduino code and the relevant Processing code for the sketch to work (and has a variation in Max 5 as well). The Processing code below the Arduino code is commented out to avoid interfering with the Arduino code.

[]{#c14.xhtml#c14-code-0030}[]{#c14.xhtml#c14-lntxt-0030}

`/*`{#c14.xhtml#c14-line-0179}

`  Graph`{#c14.xhtml#c14-line-0180}

` `{#c14.xhtml#c14-line-0181}

` A simple example of communication from the Arduino board to the computer:`{#c14.xhtml#c14-line-0182}

` the value of analog input 0 is sent out the serial port.  We call this "serial"`{#c14.xhtml#c14-line-0183}

` communication because the connection appears to both the Arduino and the`{#c14.xhtml#c14-line-0184}

` computer as a serial port, even though it may actually use`{#c14.xhtml#c14-line-0185}

` a USB cable. Bytes are sent one after another (serially) from the Arduino`{#c14.xhtml#c14-line-0186}

` to the computer.`{#c14.xhtml#c14-line-0187}

` `{#c14.xhtml#c14-line-0188}

` You can use the Arduino Serial Monitor to view the sent data, or it can`{#c14.xhtml#c14-line-0189}

` be read by Processing, PD, Max/MSP, or any other program capable of reading`{#c14.xhtml#c14-line-0190}

` data from a serial port.  The Processing code below graphs the data received`{#c14.xhtml#c14-line-0191}

` so you can see the value of the analog input changing over time.`{#c14.xhtml#c14-line-0192}

` `{#c14.xhtml#c14-line-0193}

` The circuit:`{#c14.xhtml#c14-line-0194}

` - any analog input sensor attached to analog in pin 0.`{#c14.xhtml#c14-line-0195}

`created 2006`{#c14.xhtml#c14-line-0196}

` by David A. Mellis`{#c14.xhtml#c14-line-0197}

` modified 9 Apr 2012`{#c14.xhtml#c14-line-0198}

` by Tom Igoe and Scott Fitzgerald`{#c14.xhtml#c14-line-0199}

` `{#c14.xhtml#c14-line-0200}

` This example code is in the public domain.`{#c14.xhtml#c14-line-0201}

` `{#c14.xhtml#c14-line-0202}

` http://www.arduino.cc/en/Tutorial/Graph`{#c14.xhtml#c14-line-0203}

` */`{#c14.xhtml#c14-line-0204}

` `{#c14.xhtml#c14-line-0205}

`void setup() {`{#c14.xhtml#c14-line-0206}

`  // initialize the serial communication:`{#c14.xhtml#c14-line-0207}

`  Serial.begin(9600);`{#c14.xhtml#c14-line-0208}

`}`{#c14.xhtml#c14-line-0209}

` `{#c14.xhtml#c14-line-0210}

`void loop() {`{#c14.xhtml#c14-line-0211}

`  // send the value of analog input 0:`{#c14.xhtml#c14-line-0212}

`  Serial.println(analogRead(A0));`{#c14.xhtml#c14-line-0213}

`  // wait a bit for the analog-to-digital converter`{#c14.xhtml#c14-line-0214}

`  // to stabilize after the last reading:`{#c14.xhtml#c14-line-0215}

`  delay(2);`{#c14.xhtml#c14-line-0216}

`}`{#c14.xhtml#c14-line-0217}

Now go through the steps to upload your sketch.

With the Arduino now set up to send a message to Processing, you need to set up the Processing sketch to receive that message over the serial port.
:::

::: {.section}
[]{#c14.xhtml#c14-sec-0009}

### Setting up the Processing code {#c14.xhtml#h3-6 .Heading-2}

The Processing code is found within multiline comments markers [`(/* */`]{.Code-within-text}) at the bottom of the Arduino Graph sketch. Copy the code within the comment markers and then paste it into a new Processing sketch, saved with an appropriate name, such as Graph.

[]{#c14.xhtml#c14-code-0031}[]{#c14.xhtml#c14-lntxt-0031}

`// Graphing sketch`{#c14.xhtml#c14-line-0218}

` `{#c14.xhtml#c14-line-0219}

` `{#c14.xhtml#c14-line-0220}

`// This program takes ASCII-encoded strings from the serial port at 9600 baud`{#c14.xhtml#c14-line-0221}

`// and graphs them. It expects values in the range 0 to 1023, followed by a`{#c14.xhtml#c14-line-0222}

`// newline, or newline and carriage return`{#c14.xhtml#c14-line-0223}

` `{#c14.xhtml#c14-line-0224}

`// Created 20 Apr 2005`{#c14.xhtml#c14-line-0225}

`// Updated 18 Jan 2008`{#c14.xhtml#c14-line-0226}

`// by Tom Igoe`{#c14.xhtml#c14-line-0227}

`// This example code is in the public domain.`{#c14.xhtml#c14-line-0228}

` `{#c14.xhtml#c14-line-0229}

`import processing.serial.*;`{#c14.xhtml#c14-line-0230}

` `{#c14.xhtml#c14-line-0231}

`Serial myPort;        // The serial port`{#c14.xhtml#c14-line-0232}

`int xPos = 1;         // horizontal position of the graph`{#c14.xhtml#c14-line-0233}

`float inByte = 0;`{#c14.xhtml#c14-line-0234}

` `{#c14.xhtml#c14-line-0235}

`void setup () {`{#c14.xhtml#c14-line-0236}

`  // set the window size:`{#c14.xhtml#c14-line-0237}

`  size(400, 300);`{#c14.xhtml#c14-line-0238}

` `{#c14.xhtml#c14-line-0239}

`// List all the available serial ports`{#c14.xhtml#c14-line-0240}

`// if using Processing 2.1 or later, use Serial.printArray()`{#c14.xhtml#c14-line-0241}

`println(Serial.list());  // I know that the first port in the serial list on`{#c14.xhtml#c14-line-0242}

`  // my mac is always my  Arduino, so I open Serial.list()[0].`{#c14.xhtml#c14-line-0243}

`  // Open whatever port is the one you're using.`{#c14.xhtml#c14-line-0244}

`  myPort = new Serial(this, Serial.list()[0], 9600);`{#c14.xhtml#c14-line-0245}

` `{#c14.xhtml#c14-line-0246}

`  // don't generate a serialEvent() unless you get a newline character:`{#c14.xhtml#c14-line-0247}

`  myPort.bufferUntil('\n');`{#c14.xhtml#c14-line-0248}

`  // set initial background:`{#c14.xhtml#c14-line-0249}

`  background(0);`{#c14.xhtml#c14-line-0250}

`}`{#c14.xhtml#c14-line-0251}

` `{#c14.xhtml#c14-line-0252}

`void draw () {`{#c14.xhtml#c14-line-0253}

`  // draw the line:`{#c14.xhtml#c14-line-0254}

`  stroke(127, 34, 255);`{#c14.xhtml#c14-line-0255}

`  line(xPos, height, xPos, height - inByte);`{#c14.xhtml#c14-line-0256}

` `{#c14.xhtml#c14-line-0257}

`  // at the edge of the screen, go back to the beginning:`{#c14.xhtml#c14-line-0258}

`  if (xPos >= width) {`{#c14.xhtml#c14-line-0259}

`    xPos = 0;`{#c14.xhtml#c14-line-0260}

`    background(0);`{#c14.xhtml#c14-line-0261}

`  } else {`{#c14.xhtml#c14-line-0262}

`    // increment the horizontal position:`{#c14.xhtml#c14-line-0263}

`    xPos++;`{#c14.xhtml#c14-line-0264}

`  }`{#c14.xhtml#c14-line-0265}

`}`{#c14.xhtml#c14-line-0266}

` `{#c14.xhtml#c14-line-0267}

`void serialEvent (Serial myPort) {`{#c14.xhtml#c14-line-0268}

`  // get the ASCII string:`{#c14.xhtml#c14-line-0269}

`  String inString = myPort.readStringUntil('\n');`{#c14.xhtml#c14-line-0270}

` `{#c14.xhtml#c14-line-0271}

`  if (inString != null) {`{#c14.xhtml#c14-line-0272}

`    // trim off any whitespace:`{#c14.xhtml#c14-line-0273}

`    inString = trim(inString);`{#c14.xhtml#c14-line-0274}

`    // convert to an int and map to the screen height:`{#c14.xhtml#c14-line-0275}

`    inByte = float(inString);`{#c14.xhtml#c14-line-0276}

`    println(inByte);`{#c14.xhtml#c14-line-0277}

`    inByte = map(inByte, 0, 1023, 0, height);`{#c14.xhtml#c14-line-0278}

`  }`{#c14.xhtml#c14-line-0279}

`}`{#c14.xhtml#c14-line-0280}

Click the Run button to execute the Processing sketch, and an applet appears. The applet has a black background with a purple graph representing the analog Arduino input, as shown in [Figure 14-6](#c14.xhtml#c14-fig-0006){#c14.xhtml#rc14-fig-0006}. As you turn the potentiometer, the purple graph changes to match it. The graph is updated over time, so as the reading progresses, the graph fills the horizontal space. When it reaches the edge of the display window, the graph resets to the starting point, on the left side.

::: {#c14.xhtml#c14-fig-0006 .figure}
![9781119489542-fg1406.png](https://i.imgur.com/5qs3Vq4.jpeg){.center}
:::

If you don\'t see a graph, double-check your wiring:

-   [Make sure you're using the correct pin number.]{#c14.xhtml#c14-li-0014}
-   [Make sure that the potentiometer is wired the correct way around.]{#c14.xhtml#c14-li-0015}
-   [Check that you're using the correct serial port.]{#c14.xhtml#c14-li-0016}
-   [Check that your Arduino code uploaded correctly and that your Processing code has no errors. Note that you cannot upload while the Processing sketch is communicating with your Arduino, so stop the sketch before uploading.]{#c14.xhtml#c14-li-0017}
:::

::: {.section}
[]{#c14.xhtml#Page_340 .pagebreak role="doc-pagebreak" title="340"}[]{#c14.xhtml#c14-sec-0010}

### Understanding the Arduino Graph sketch {#c14.xhtml#h3-7 .Heading-2}

In [`setup`]{.Code-within-text}, the code just needs to initialize the serial port. The serial port is set to a baud rate of 9600, which must match the baud rate in the Processing sketch.

The analog input pins are set to input by default, so you don't need to set their [`pinMode`]{.Code-within-text}:

[]{#c14.xhtml#c14-code-0032}[]{#c14.xhtml#c14-lntxt-0032}

`void setup() {`{#c14.xhtml#c14-line-0281}

`  // initialize the serial communication:`{#c14.xhtml#c14-line-0282}

`  Serial.begin(9600);`{#c14.xhtml#c14-line-0283}

`}`{#c14.xhtml#c14-line-0284}

In [`loop`]{.Code-within-text}, a single line prints the value of the sensor to the serial port. The pin is directly named rather than being given a variable (such as [`analogPin`]{.Code-within-text}) because no repeat mentions occur. This pin is [`A0`]{.Code-within-text}, or analog input pin 0:

[]{#c14.xhtml#c14-code-0033}[]{#c14.xhtml#c14-lntxt-0033}

`void loop() {`{#c14.xhtml#c14-line-0285}

`  // send the value of analog input 0:`{#c14.xhtml#c14-line-0286}

`  Serial.println(analogRead(A0));`{#c14.xhtml#c14-line-0287}

Analog readings are made extremely quickly, usually more quickly than they can be converted to digital format. Sometimes this speed causes errors, so a short delay of 2 milliseconds between readings can help stabilize the results. Think of it like a tap that limits the flow of water:

[]{#c14.xhtml#c14-code-0034}[]{#c14.xhtml#c14-lntxt-0034}

`  // wait a bit for the analog-to-digital converter`{#c14.xhtml#c14-line-0288}

`  // to stabilize after the last reading:`{#c14.xhtml#c14-line-0289}

`  delay(2);`{#c14.xhtml#c14-line-0290}

`}`{#c14.xhtml#c14-line-0291}
:::

::: {.section}
[]{#c14.xhtml#c14-sec-0011}

### Understanding the Processing Graph sketch {#c14.xhtml#h3-8 .Heading-2}

When data is sent to the serial port, Processing reads that data and interprets it to draw the bar graph. First you import the serial library into the sketch and create a new instance of it. In this case, the new serial port object is called [`myPort`]{.Code-within-text}:

[]{#c14.xhtml#c14-code-0035}[]{#c14.xhtml#c14-lntxt-0035}

`import processing.serial.*;`{#c14.xhtml#c14-line-0292}

` `{#c14.xhtml#c14-line-0293}

`Serial myPort;        // The serial port`{#c14.xhtml#c14-line-0294}

[]{#c14.xhtml#Page_341 .pagebreak role="doc-pagebreak" title="341"} One integer, defined as [`xPos`]{.Code-within-text} , keeps track of where the latest bar in the bar graph is drawn (the x position):

[]{#c14.xhtml#c14-code-0036}[]{#c14.xhtml#c14-lntxt-0036}

`int xPos = 1;         // horizontal position of the graph`{#c14.xhtml#c14-line-0295}

In [`setup`]{.Code-within-text}, the display window is defined as 400 pixels wide and 300 pixels tall:

[]{#c14.xhtml#c14-code-0037}[]{#c14.xhtml#c14-lntxt-0037}

`void setup () {`{#c14.xhtml#c14-line-0296}

`  // set the window size:`{#c14.xhtml#c14-line-0297}

`  size(400,300);`{#c14.xhtml#c14-line-0298}

To find the correct serial port, [`Serial.list`]{.Code-within-text} is called and printed to the console with [`println`]{.Code-within-text}. The function [`println`]{.Code-within-text} is similar to [`Serial.println`]{.Code-within-text} in Arduino but is used in Processing for monitoring values. These values print to the console rather than the serial port and are used for debugging rather than communication:

[]{#c14.xhtml#c14-code-0038}[]{#c14.xhtml#c14-lntxt-0038}

`  // List all the available serial ports`{#c14.xhtml#c14-line-0299}

`  println(Serial.list());`{#c14.xhtml#c14-line-0300}

Your Arduino is likely to appear at the top of the list, so [`myPort`]{.Code-within-text} uses position 0 as the Arduino serial port. If you are not using the [`Serial.list`]{.Code-within-text} function, you can replace [`Serial.list()[0]`]{.Code-within-text} with another number in the list, which prints to the console. You can also replace [`Serial.list()[0]`]{.Code-within-text} with the name of the port, such as /dev/tty.usbmodem26221 or COM5. Specifying the name is also useful if you have multiple Arduinos connected to the same computer. The number 9600 refers to the baud rate, the rate at which you are communicating with the Arduino. If the rate is not the same on both ends, the data will not be received:

[]{#c14.xhtml#c14-code-0039}[]{#c14.xhtml#c14-lntxt-0039}

`myPort = new Serial(this, Serial.list()[0], 9600);`{#c14.xhtml#c14-line-0301}

In this example, you have another way to sort out the good data from the bad. The [`serialEvent`]{.Code-within-text} function triggers every time data arrives in the serial buffer. This line checks to see whether a character followed by a newline character is sent, such as [`Serial.println(100)`]{.Code-within-text} on the Arduino side. Newline, or Return on a keyboard, has an ASCII character, which is referred to as [`\n`]{.Code-within-text}. The line could also look for other special characters, such as a tab, which is [`\t`]{.Code-within-text}.:

[]{#c14.xhtml#c14-code-0040}[]{#c14.xhtml#c14-lntxt-0040}

`  // don't generate a serialEvent() unless you get a newline character:`{#c14.xhtml#c14-line-0302}

`  myPort.bufferUntil('\n');`{#c14.xhtml#c14-line-0303}

To start, the background is colored black:

[]{#c14.xhtml#c14-code-0041}[]{#c14.xhtml#c14-lntxt-0041}

`  // set initial background:`{#c14.xhtml#c14-line-0304}

`  background(0);`{#c14.xhtml#c14-line-0305}

`}`{#c14.xhtml#c14-line-0306}

` `{#c14.xhtml#c14-line-0307}

`void draw () {`{#c14.xhtml#c14-line-0308}

`  // everything happens in the serialEvent()`{#c14.xhtml#c14-line-0309}

`}`{#c14.xhtml#c14-line-0310}

This bar graph is detailed, with one bar represented by a column of pixels. The [`line`]{.Code-within-text} function creates these awesome visuals. To change the color of the line to purple, the [`stroke`]{.Code-within-text} value is set to its RGB components.

The line is defined by its start and end point. Because we\'re displaying a graph, you want lots of vertical lines with varying heights. As you can see, the *x,* or horizontal, coordinates are the same variable. The height coordinate for one end of the line is equal to the height of the window, which fixes the height coordinate to the bottom edge of the window. The other height value is equal to the height minus the [`inByte`]{.Code-within-text} value, so the greater the value, the nearer the top of the line is to the top of the window:

[]{#c14.xhtml#c14-code-0042}[]{#c14.xhtml#c14-lntxt-0042}

`void draw () {`{#c14.xhtml#c14-line-0311}

`    // draw the line:`{#c14.xhtml#c14-line-0312}

`    stroke(127, 34, 255);`{#c14.xhtml#c14-line-0313}

`    line(xPos, height, xPos, height - inByte);`{#c14.xhtml#c14-line-0314}

![tip.png](https://i.imgur.com/j8hOIrq.jpeg) If you\'re having trouble selecting a color, choose Tools ⇒   Color Selector on the Processing menu. The Color Selector displays a color wheel with the red, green, and blue values --- as well as the hexadecimal value --- of any color you select, as you can see in [Figure 14-7](#c14.xhtml#c14-fig-0007){#c14.xhtml#rc14-fig-0007}.

::: {#c14.xhtml#c14-fig-0007 .figure}
![9781119489542-fg1407.png](https://i.imgur.com/GsLOPh1.jpeg){.center}
:::

This next bit of code handles the movement of the [`xPos`]{.Code-within-text}, or horizontal, position of the graph over time. If [`xPos`]{.Code-within-text} is greater than or equal to the width, the line reaches []{#c14.xhtml#Page_343 .pagebreak role="doc-pagebreak" title="343"}beyond the edge of the display window. When this happens, the variable is returned to 0, and a new background is drawn to cover the old graph:

[]{#c14.xhtml#c14-code-0043}[]{#c14.xhtml#c14-lntxt-0043}

`// at the edge of the screen, go back to the beginning:`{#c14.xhtml#c14-line-0315}

`  if (xPos >= width) {`{#c14.xhtml#c14-line-0316}

`    xPos = 0;`{#c14.xhtml#c14-line-0317}

`    background(0);`{#c14.xhtml#c14-line-0318}

`  }`{#c14.xhtml#c14-line-0319}

If [`xPos`]{.Code-within-text} is not equal to the width, it is increased by one pixel for the next reading:

[]{#c14.xhtml#c14-code-0044}[]{#c14.xhtml#c14-lntxt-0044}

`  else {`{#c14.xhtml#c14-line-0320}

`    // increment the horizontal position:`{#c14.xhtml#c14-line-0321}

`    xPos++;`{#c14.xhtml#c14-line-0322}

`  }`{#c14.xhtml#c14-line-0323}

`}`{#c14.xhtml#c14-line-0324}

The s[`erialEvent`]{.Code-within-text} function is part of the serial library and triggers when data arrives in the serial buffer. Because the [`bufferUntil('\n')`]{.Code-within-text} condition has been used, [`serialEvent`]{.Code-within-text} triggers when a newline character is buffered:

[]{#c14.xhtml#c14-code-0045}[]{#c14.xhtml#c14-lntxt-0045}

`void serialEvent (Serial myPort) {`{#c14.xhtml#c14-line-0325}

A temporary string is declared to store the data read from [`myPort`]{.Code-within-text}. Data is read until a newline character appears. Because the Arduino is sending an integer followed by a newline followed by an integer and so on, each value is read individually:

[]{#c14.xhtml#c14-code-0046}[]{#c14.xhtml#c14-lntxt-0046}

`// get the ASCII string:`{#c14.xhtml#c14-line-0326}

`  String inString = myPort.readStringUntil('\n');`{#c14.xhtml#c14-line-0327}

An [`if`]{.Code-within-text} statement checks that the string contains data and is not equal to 0, or null:

[]{#c14.xhtml#c14-code-0047}[]{#c14.xhtml#c14-lntxt-0047}

`  if (inString != null) {`{#c14.xhtml#c14-line-0328}

To make sure that no anomalies exist, the [`trim`]{.Code-within-text} function removes spaces, tabs, and carriage returns from the string. The [`trim`]{.Code-within-text} function effectively removes all formatting from the characters so that they can be read clearly:

[]{#c14.xhtml#c14-code-0048}[]{#c14.xhtml#c14-lntxt-0048}

`    // trim off any whitespace:`{#c14.xhtml#c14-line-0329}

`    inString = trim(inString);`{#c14.xhtml#c14-line-0330}

[]{#c14.xhtml#Page_344 .pagebreak role="doc-pagebreak" title="344"} Now the clean string of numbers is converted into a float, called [`inByte`]{.Code-within-text}. The float is declared on the left side of the equation and is made equal to the float conversion of [`inString`]{.Code-within-text}. You can also use parentheses around the variable to convert it to other types of data, such as [`int()`]{.Code-within-text} or [`byte()`]{.Code-within-text}:

[]{#c14.xhtml#c14-code-0049}[]{#c14.xhtml#c14-lntxt-0049}

`    // convert to an int and map to the screen height:`{#c14.xhtml#c14-line-0331}

`    inByte = float(inString);`{#c14.xhtml#c14-line-0332}

`    println(inByte);`{#c14.xhtml#c14-line-0333}

The newly declared [`inByte`]{.Code-within-text} is then mapped, or scaled, to a more useful range. The range of the sensor is 0 to 1023, so [`inByte`]{.Code-within-text} is scaled to a range of 0 to the height of the display window, keeping the display proportional without exceeding the height of the window:

[]{#c14.xhtml#c14-code-0050}[]{#c14.xhtml#c14-lntxt-0050}

`    inByte = map(inByte, 0, 1023, 0, height);`{#c14.xhtml#c14-line-0334}

This example is a great exercise for getting familiar with communication between Arduino and Processing. The Arduino could easily be sending data from an analog sensor detecting sound, movement, or light. On the Processing side, things are a little more complicated, but largely because you are generating a complicated visual. The graph could just as easily be an ellipse that gets bigger or smaller as the values change. Why not try it?
:::
:::

::: {.section}
[]{#c14.xhtml#c14-sec-0012}

## Sending Multiple Signals {#c14.xhtml#h2-3 .Heading-1}

The only thing better than sending signals to Processing is sending multiple signals, right? Sending values from multiple sensors is easy, but handling them in the correct order on the other end can be difficult. In this example, you learn how to send data from three separate sensors attached to your Arduino to a Processing sketch.

You need the following:

-   [An Arduino Uno]{#c14.xhtml#c14-li-0018}
-   [A breadboard]{#c14.xhtml#c14-li-0019}
-   [Two 10k ohm potentiometers]{#c14.xhtml#c14-li-0020}
-   [A pushbutton]{#c14.xhtml#c14-li-0021}
-   [[]{#c14.xhtml#Page_345 .pagebreak role="doc-pagebreak" title="345"}A 10k ohm resistor]{#c14.xhtml#c14-li-0022}
-   [Jump wires]{#c14.xhtml#c14-li-0023}

The circuit is a combination of three separate inputs. Although they all use the same power and ground, you can think of the inputs individually. Two potentiometers provide two values. These are wired in the same way you would wire a light or temperature sensor, with one side wired to 5V and the other wired to the analog input pin reading it as well as to GND via a resistor. These potentiometers could be replaced with any analog inputs with the appropriate resistors.

The pushbutton provides a digital input as well. One side of the pushbutton is wired to 5V and the other is wired to the digital pin reading it as well as GND via a resistor. Complete the circuit as shown in [Figures 14-8](#c14.xhtml#c14-fig-0008){#c14.xhtml#rc14-fig-0008} and [14-9](#c14.xhtml#c14-fig-0009){#c14.xhtml#rc14-fig-0009}.

::: {#c14.xhtml#c14-fig-0008 .figure}
![9781119489542-fg1408.png](https://i.imgur.com/Dt2UdEJ.jpeg){.center}
:::

::: {#c14.xhtml#c14-fig-0009 .figure}
![9781119489542-fg1409.png](https://i.imgur.com/Ro5BUUZ.jpeg){.center}
:::

::: {.section}
[]{#c14.xhtml#c14-sec-0013}

### Setting up the Arduino code {#c14.xhtml#h3-9 .Heading-2}

After you assemble your circuit, you need the appropriate software to use it. From the Arduino menu, choose File ⇒   Examples ⇒   04.Communication ⇒   SerialCallResponse. This sketch contains both Arduino code and the relevant Processing code for the sketch to work (along with a variation in Max 5 as well). The Processing code below the Arduino code is commented out to avoid interference with the Arduino sketch:

[]{#c14.xhtml#c14-code-0051}[]{#c14.xhtml#c14-lntxt-0051}

`/*`{#c14.xhtml#c14-line-0335}

`Serial Call and Response`{#c14.xhtml#c14-line-0336}

` Language: Wiring/Arduino`{#c14.xhtml#c14-line-0337}

` `{#c14.xhtml#c14-line-0338}

` This program sends an ASCII A (byte of value 65) on startup`{#c14.xhtml#c14-line-0339}

` and repeats that until it gets some data in.`{#c14.xhtml#c14-line-0340}

` Then it waits for a byte in the serial port, and`{#c14.xhtml#c14-line-0341}

` sends three sensor values whenever it gets a byte in.`{#c14.xhtml#c14-line-0342}

` `{#c14.xhtml#c14-line-0343}

` Thanks to Greg Shakar and Scott Fitzgerald for the improvements`{#c14.xhtml#c14-line-0344}

` `{#c14.xhtml#c14-line-0345}

`   The circuit:`{#c14.xhtml#c14-line-0346}

` * potentiometers attached to analog inputs 0 and 1`{#c14.xhtml#c14-line-0347}

` * pushbutton attached to digital I/O 2`{#c14.xhtml#c14-line-0348}

` `{#c14.xhtml#c14-line-0349}

` `{#c14.xhtml#c14-line-7345}

` Created 26 Sept. 2005`{#c14.xhtml#c14-line-0350}

` by Tom Igoe`{#c14.xhtml#c14-line-0351}

` modified 24 April 2012`{#c14.xhtml#c14-line-0352}

` by Tom Igoe and Scott Fitzgerald`{#c14.xhtml#c14-line-0353}

` `{#c14.xhtml#c14-line-0354}

` This example code is in the public domain.`{#c14.xhtml#c14-line-0355}

` `{#c14.xhtml#c14-line-0356}

` http://www.arduino.cc/en/Tutorial/SerialCallResponse`{#c14.xhtml#c14-line-0357}

` `{#c14.xhtml#c14-line-0358}

` */`{#c14.xhtml#c14-line-0359}

` `{#c14.xhtml#c14-line-0360}

`int firstSensor = 0;    // first analog sensor`{#c14.xhtml#c14-line-0361}

`int secondSensor = 0;   // second analog sensor`{#c14.xhtml#c14-line-0362}

`int thirdSensor = 0;    // digital sensor`{#c14.xhtml#c14-line-0363}

`int inByte = 0;         // incoming serial byte`{#c14.xhtml#c14-line-0364}

` `{#c14.xhtml#c14-line-0365}

`void setup()`{#c14.xhtml#c14-line-0366}

`{`{#c14.xhtml#c14-line-0367}

`  // start serial port at 9600 bps:`{#c14.xhtml#c14-line-0368}

`  Serial.begin(9600);`{#c14.xhtml#c14-line-0369}

`  while (!Serial) {`{#c14.xhtml#c14-line-0370}

`    ; // wait for serial port to connect. Needed for native USB port only`{#c14.xhtml#c14-line-0371}

`  }`{#c14.xhtml#c14-line-0372}

`pinMode(2, INPUT);   // digital sensor is on digital pin 2`{#c14.xhtml#c14-line-0373}

`  establishContact();  // send a byte to establish contact until receiver`{#c14.xhtml#c14-line-0374}

`                       // responds`{#c14.xhtml#c14-line-0375}

`}`{#c14.xhtml#c14-line-0376}

` `{#c14.xhtml#c14-line-0377}

`void loop()`{#c14.xhtml#c14-line-0378}

`{`{#c14.xhtml#c14-line-0379}

`  // if we get a valid byte, read analog ins:`{#c14.xhtml#c14-line-0380}

`  if (Serial.available() > 0) {`{#c14.xhtml#c14-line-0381}

`    // get incoming byte:`{#c14.xhtml#c14-line-0382}

`    inByte = Serial.read();`{#c14.xhtml#c14-line-0383}

`    // read first analog input, divide by 4 to make the range 0-255:`{#c14.xhtml#c14-line-0384}

`    firstSensor = analogRead(A0)/4;`{#c14.xhtml#c14-line-0385}

`    // delay 10ms to let the ADC recover:`{#c14.xhtml#c14-line-0386}

`    delay(10);`{#c14.xhtml#c14-line-0387}

`    // read second analog input, divide by 4 to make the range 0-255:`{#c14.xhtml#c14-line-0388}

`    secondSensor = analogRead(1)/4;`{#c14.xhtml#c14-line-0389}

`    // read  switch, map it to 0 or 255L`{#c14.xhtml#c14-line-0390}

`    thirdSensor = map(digitalRead(2), 0, 1, 0, 255);`{#c14.xhtml#c14-line-0391}

`    // send sensor values:`{#c14.xhtml#c14-line-0392}

`    Serial.write(firstSensor);`{#c14.xhtml#c14-line-0393}

`    Serial.write(secondSensor);`{#c14.xhtml#c14-line-0394}

`    Serial.write(thirdSensor);`{#c14.xhtml#c14-line-0395}

`  }`{#c14.xhtml#c14-line-0396}

`}`{#c14.xhtml#c14-line-0397}

` `{#c14.xhtml#c14-line-0398}

`void establishContact() {`{#c14.xhtml#c14-line-0399}

`  while (Serial.available() <= 0) {`{#c14.xhtml#c14-line-0400}

`    Serial.print('A');   // send a capital A`{#c14.xhtml#c14-line-0401}

`    delay(300);`{#c14.xhtml#c14-line-0402}

`  }`{#c14.xhtml#c14-line-0403}

`}`{#c14.xhtml#c14-line-0404}

Upload this code to your Arduino. Now that the Arduino is set up to send data to Processing, you need to set up the Processing sketch to receive and interpret the data over the serial port.
:::

::: {.section}
[]{#c14.xhtml#c14-sec-0014}

### Setting up the Processing code {#c14.xhtml#h3-10 .Heading-2}

You find the Processing code within multiline comment markers ([`/* */`]{.Code-within-text}) at the bottom of the Arduino SerialCallResponse sketch. Copy the code within the comment markers into a new Processing sketch and save with an appropriate name, such as SerialCallResponse:

[]{#c14.xhtml#c14-code-0052}[]{#c14.xhtml#c14-lntxt-0052}

`// This example code is in the public domain.`{#c14.xhtml#c14-line-0405}

` `{#c14.xhtml#c14-line-0406}

`import processing.serial.*;`{#c14.xhtml#c14-line-0407}

` `{#c14.xhtml#c14-line-0408}

`int bgcolor;           // Background color`{#c14.xhtml#c14-line-0409}

`int fgcolor;           // Fill color`{#c14.xhtml#c14-line-0410}

`Serial myPort;                       // The serial port`{#c14.xhtml#c14-line-0411}

`int[] serialInArray = new int[3];    // Where we'll put what we receive`{#c14.xhtml#c14-line-0412}

`int serialCount = 0;                 // A count of how many bytes we receive`{#c14.xhtml#c14-line-0413}

`int xpos, ypos;                 // Starting position of the ball`{#c14.xhtml#c14-line-0414}

`boolean firstContact = false;        // Whether we've heard from the`{#c14.xhtml#c14-line-0415}

`                                     // microcontroller`{#c14.xhtml#c14-line-0416}

` `{#c14.xhtml#c14-line-0417}

`void setup() {`{#c14.xhtml#c14-line-0418}

`  size(256, 256);  // Stage size`{#c14.xhtml#c14-line-0419}

`  noStroke();      // No border on the next thing drawn`{#c14.xhtml#c14-line-0420}

` `{#c14.xhtml#c14-line-0421}

`  // Set the starting position of the ball (middle of the stage)`{#c14.xhtml#c14-line-0422}

`  xpos = width/2;`{#c14.xhtml#c14-line-0423}

`  ypos = height/2;`{#c14.xhtml#c14-line-0424}

` `{#c14.xhtml#c14-line-0425}

`  // Print a list of the serial ports, for debugging purposes:`{#c14.xhtml#c14-line-0426}

`  println(Serial.list());`{#c14.xhtml#c14-line-0427}

` `{#c14.xhtml#c14-line-0428}

`  // I know that the first port in the serial list on my mac`{#c14.xhtml#c14-line-0429}

`  // is always my  FTDI adaptor, so I open Serial.list()[0].`{#c14.xhtml#c14-line-0430}

`  // On Windows machines, this generally opens COM1.`{#c14.xhtml#c14-line-0431}

`  // Open whatever port is the one you're using.`{#c14.xhtml#c14-line-0432}

`  String portName = Serial.list()[0];`{#c14.xhtml#c14-line-0433}

`  myPort = new Serial(this, portName, 9600);`{#c14.xhtml#c14-line-0434}

`}`{#c14.xhtml#c14-line-0435}

` `{#c14.xhtml#c14-line-0436}

`void draw() {`{#c14.xhtml#c14-line-0437}

`  background(bgcolor);`{#c14.xhtml#c14-line-0438}

`  fill(fgcolor);`{#c14.xhtml#c14-line-0439}

`  // Draw the shape`{#c14.xhtml#c14-line-0440}

`  ellipse(xpos, ypos, 20, 20);`{#c14.xhtml#c14-line-0441}

`}`{#c14.xhtml#c14-line-0442}

` `{#c14.xhtml#c14-line-0443}

`void serialEvent(Serial myPort) {`{#c14.xhtml#c14-line-0444}

`  // read a byte from the serial port:`{#c14.xhtml#c14-line-0445}

`  int inByte = myPort.read();`{#c14.xhtml#c14-line-0446}

`  // if this is the first byte received, and it's an A,`{#c14.xhtml#c14-line-0447}

`  // clear the serial buffer and note that you've`{#c14.xhtml#c14-line-0448}

`  // had first contact from the microcontroller.`{#c14.xhtml#c14-line-0449}

`  // Otherwise, add the incoming byte to the array:`{#c14.xhtml#c14-line-0450}

`  if (firstContact == false) {`{#c14.xhtml#c14-line-0451}

`    if (inByte == 'A') {`{#c14.xhtml#c14-line-0452}

`      myPort.clear();          // clear the serial port buffer`{#c14.xhtml#c14-line-0453}

`      firstContact = true;     // you've had first contact from the microcontroller`{#c14.xhtml#c14-line-0454}

`      myPort.write('A');       // ask for more`{#c14.xhtml#c14-line-0455}

`    }`{#c14.xhtml#c14-line-0456}

`  }`{#c14.xhtml#c14-line-0457}

`  else {`{#c14.xhtml#c14-line-0458}

`    // Add the latest byte from the serial port to array:`{#c14.xhtml#c14-line-0459}

`    serialInArray[serialCount] = inByte;`{#c14.xhtml#c14-line-0460}

`    serialCount++;`{#c14.xhtml#c14-line-0461}

` `{#c14.xhtml#c14-line-0462}

`    // If we have 3 bytes:`{#c14.xhtml#c14-line-0463}

`    if (serialCount > 2 ) {`{#c14.xhtml#c14-line-0464}

`      xpos = serialInArray[0];`{#c14.xhtml#c14-line-0465}

`      ypos = serialInArray[1];`{#c14.xhtml#c14-line-0466}

`      fgcolor = serialInArray[2];`{#c14.xhtml#c14-line-0467}

` `{#c14.xhtml#c14-line-0468}

`      // print the values (for debugging purposes only):`{#c14.xhtml#c14-line-0469}

`      println(xpos + "\t" + ypos + "\t" + fgcolor);`{#c14.xhtml#c14-line-0470}

` `{#c14.xhtml#c14-line-0471}

`      // Send a capital A to request new sensor readings:`{#c14.xhtml#c14-line-0472}

`      myPort.write('A');`{#c14.xhtml#c14-line-0473}

`      // Reset serialCount:`{#c14.xhtml#c14-line-0474}

`      serialCount = 0;`{#c14.xhtml#c14-line-0475}

`    }`{#c14.xhtml#c14-line-0476}

`  }`{#c14.xhtml#c14-line-0477}

`}`{#c14.xhtml#c14-line-0478}

Click the Run button to execute the Processing sketch, and an applet appears. The applet has a black background, and whenever you press the pushbutton, a white dot appears. Move the potentiometers to move the dot horizontally and vertically. When you release the pushbutton, the dot disappears.

If you don\'t see the correct behavior, double-check your wiring:

-   [Make sure that you're using the correct pin numbers.]{#c14.xhtml#c14-li-0024}
-   [Make sure that the potentiometers are wired the correct way around.]{#c14.xhtml#c14-li-0025}
-   [Check that you're using the correct serial port.]{#c14.xhtml#c14-li-0026}
-   [Check that your Arduino code uploaded correctly and that your Processing code has no errors. Note that you cannot upload while the Processing sketch is communicating with your Arduino, so stop the sketch before uploading.]{#c14.xhtml#c14-li-0027}
:::

::: {.section}
[]{#c14.xhtml#c14-sec-0015}

### Understanding the Arduino SerialCallResponse sketch {#c14.xhtml#h3-11 .Heading-2}

At the start of the sketch, four integer variables are declared. Three are for the sensor values and one stores an incoming byte from the Processing sketch:

[]{#c14.xhtml#c14-code-0053}[]{#c14.xhtml#c14-lntxt-0053}

`int firstSensor = 0;    // first analog sensor`{#c14.xhtml#c14-line-0479}

`int secondSensor = 0;   // second analog sensor`{#c14.xhtml#c14-line-0480}

`int thirdSensor = 0;    // digital sensor`{#c14.xhtml#c14-line-0481}

`int inByte = 0;         // incoming serial byte`{#c14.xhtml#c14-line-0482}

In [`setup`]{.Code-within-text}, the serial port is established with a baud rate of 9600. The [`while`]{.Code-within-text} statement continually checks for the presence of a serial connection before proceeding. The statement is interpreted as "while there is not a serial connection, do nothing." This line of code is needed only for the Leonardo boards: []{#c14.xhtml#Page_351 .pagebreak role="doc-pagebreak" title="351"}

[]{#c14.xhtml#c14-code-0054}[]{#c14.xhtml#c14-lntxt-0054}

`void setup()`{#c14.xhtml#c14-line-0483}

`{`{#c14.xhtml#c14-line-0484}

`  // start serial port at 9600 bps:`{#c14.xhtml#c14-line-0485}

`  Serial.begin(9600);`{#c14.xhtml#c14-line-0486}

`  while (!Serial) {`{#c14.xhtml#c14-line-0487}

`    ; // wait for serial port to connect. Needed for USB port only`{#c14.xhtml#c14-line-0488}

`  }`{#c14.xhtml#c14-line-0489}

Pin 2 is the pushbutton pin and is set as an input by using [`pinMode`]{.Code-within-text}:

[]{#c14.xhtml#c14-code-0055}[]{#c14.xhtml#c14-lntxt-0055}

`  pinMode(2, INPUT);   // digital sensor is on digital pin 2`{#c14.xhtml#c14-line-0490}

A special custom function called [`establishContact`]{.Code-within-text} is called to signal to the Processing sketch that the Arduino is ready:

[]{#c14.xhtml#c14-code-0056}[]{#c14.xhtml#c14-lntxt-0056}

`  establishContact();  // send a byte to establish contact until receiver responds`{#c14.xhtml#c14-line-0491}

`}`{#c14.xhtml#c14-line-0492}

In the [`loop`]{.Code-within-text}, an [`if`]{.Code-within-text} statement checks whether any data being sent is greater than 0. If it is, that byte is read into the [`inByte`]{.Code-within-text} variable:

[]{#c14.xhtml#c14-code-0057}[]{#c14.xhtml#c14-lntxt-0057}

`void loop()`{#c14.xhtml#c14-line-0493}

`{`{#c14.xhtml#c14-line-0494}

`  // if we get a valid byte, read analog ins:`{#c14.xhtml#c14-line-0495}

`  if (Serial.available() > 0) {`{#c14.xhtml#c14-line-0496}

`    // get incoming byte:`{#c14.xhtml#c14-line-0497}

`    inByte = Serial.read();`{#c14.xhtml#c14-line-0498}

The [`firstSensor`]{.Code-within-text} variable stores the value of the potentiometer on analog pin 0 after dividing it by 4. This simple math reduces the range 0 to 1023 to the range 0 to 255:

[]{#c14.xhtml#c14-code-0058}[]{#c14.xhtml#c14-lntxt-0058}

`    // read first analog input, divide by 4 to make the range 0-255:`{#c14.xhtml#c14-line-0499}

`    firstSensor = analogRead(A0)/4;`{#c14.xhtml#c14-line-0500}

A short break of 10 milliseconds occurs to give the analog-to-digital converter plenty of time to process the first value:

[]{#c14.xhtml#c14-code-0059}[]{#c14.xhtml#c14-lntxt-0059}

`    // delay 10ms to let the ADC recover:`{#c14.xhtml#c14-line-0501}

`    delay(10);`{#c14.xhtml#c14-line-0502}

[]{#c14.xhtml#Page_352 .pagebreak role="doc-pagebreak" title="352"} The second sensor is read and converted in the same way and then the code writes to the [`secondSensor`]{.Code-within-text} variable:

[]{#c14.xhtml#c14-code-0060}[]{#c14.xhtml#c14-lntxt-0060}

`    // read second analog input, divide by 4 to make the range 0-255:`{#c14.xhtml#c14-line-0503}

`    secondSensor = analogRead(1)/4;`{#c14.xhtml#c14-line-0504}

The switch is a little different. To scale the values, the [`map`]{.Code-within-text} function is used. The first parameter inside the [`map`]{.Code-within-text} function is the number to be mapped. In this case, that number is a [`digital read`]{.Code-within-text} of pin 2. Saving the [`digitalRead`]{.Code-within-text} value to a variable first in this case is neither necessary nor beneficial. The switch will only return a value of 0 or 1, and it is mapped to the same range as the other sensors, 0 to 255, so it will return 0 or 255 instead. The converted value is stored in [`thirdSensor`]{.Code-within-text}:

[]{#c14.xhtml#c14-code-0061}[]{#c14.xhtml#c14-lntxt-0061}

`// read  switch, map it to 0 or 255L`{#c14.xhtml#c14-line-0505}

`    thirdSensor = map(digitalRead(2), 0, 1, 0, 255);`{#c14.xhtml#c14-line-0506}

Each of the sensor values is then sent one at a time to the serial port by using [`Serial.write`]{.Code-within-text}:

[]{#c14.xhtml#c14-code-0062}[]{#c14.xhtml#c14-lntxt-0062}

`    // send sensor values:`{#c14.xhtml#c14-line-0507}

`    Serial.write(firstSensor);`{#c14.xhtml#c14-line-0508}

`    Serial.write(secondSensor);`{#c14.xhtml#c14-line-0509}

`    Serial.write(thirdSensor);`{#c14.xhtml#c14-line-0510}

`  }`{#c14.xhtml#c14-line-0511}

`}`{#c14.xhtml#c14-line-0512}

At the end of the sketch is the custom [`establishContact`]{.Code-within-text} function, which was called in [`setup`]{.Code-within-text}. This function monitors the serial port to see whether a serial connection is available. If not, [`establishContact`]{.Code-within-text} sends an uppercase *A* to the serial port every 300 milliseconds. When a connection is available, the function stops:

[]{#c14.xhtml#c14-code-0063}[]{#c14.xhtml#c14-lntxt-0063}

`void establishContact() {`{#c14.xhtml#c14-line-0513}

`  while (Serial.available() <= 0) {`{#c14.xhtml#c14-line-0514}

`    Serial.print('A');   // send a capital A`{#c14.xhtml#c14-line-0515}

`    delay(300);`{#c14.xhtml#c14-line-0516}

`  }`{#c14.xhtml#c14-line-0517}

`}`{#c14.xhtml#c14-line-0518}
:::

::: {.section}
[]{#c14.xhtml#c14-sec-0016}

### Understanding the Processing SerialCallResponse sketch {#c14.xhtml#h3-12 .Heading-2}

Now examine what\'s happening on the Processing side to establish contact, interpret the values, and display the data. The first action to take in the Processing sketch is to import the serial library: []{#c14.xhtml#Page_353 .pagebreak role="doc-pagebreak" title="353"}

[]{#c14.xhtml#c14-code-0064}[]{#c14.xhtml#c14-lntxt-0064}

`import processing.serial.*;`{#c14.xhtml#c14-line-0519}

Many variables need to be declared for this sketch. The first two are colors for the background and shapes:

[]{#c14.xhtml#c14-code-0065}[]{#c14.xhtml#c14-lntxt-0065}

`int bgcolor;           // Background color`{#c14.xhtml#c14-line-0520}

`int fgcolor;           // Fill color`{#c14.xhtml#c14-line-0521}

A new instance of serial port, called [`myPort`]{.Code-within-text}, is created:

[]{#c14.xhtml#c14-code-0066}[]{#c14.xhtml#c14-lntxt-0066}

`Serial myPort;                       // The serial port`{#c14.xhtml#c14-line-0522}

An array of integer values is created and declared to be three values long:

[]{#c14.xhtml#c14-code-0067}[]{#c14.xhtml#c14-lntxt-0067}

`int[] serialInArray = new int[3];    // Where we'll put what we receive`{#c14.xhtml#c14-line-0523}

An integer counter is declared to keep track of how many bytes have been read:

[]{#c14.xhtml#c14-code-0068}[]{#c14.xhtml#c14-lntxt-0068}

`int serialCount = 0;                 // A count of how many bytes we receive`{#c14.xhtml#c14-line-0524}

The integer values [`xpos`]{.Code-within-text} and [`ypos`]{.Code-within-text} store the coordinates of the dot:

[]{#c14.xhtml#c14-code-0069}[]{#c14.xhtml#c14-lntxt-0069}

`int xpos, ypos;                 // Starting position of the ball`{#c14.xhtml#c14-line-0525}

A Boolean stores a value that indicates whether contact has been made with the Arduino:

[]{#c14.xhtml#c14-code-0070}[]{#c14.xhtml#c14-lntxt-0070}

`boolean firstContact = false;        // Whether we've heard from the microcontroller`{#c14.xhtml#c14-line-0526}

In [`setup`]{.Code-within-text}, the size of the display window is set. The [`noStroke`]{.Code-within-text} function ensures that no borders are on shapes drawn from this point on in the sketch. Choosing [`stroke`]{.Code-within-text} or [`noStroke`]{.Code-within-text} depends on your graphical preferences.

[]{#c14.xhtml#c14-code-0071}[]{#c14.xhtml#c14-lntxt-0071}

`void setup() {`{#c14.xhtml#c14-line-0527}

`  size(256, 256);  // Stage size`{#c14.xhtml#c14-line-0528}

`  noStroke();      // No border on the next thing drawn`{#c14.xhtml#c14-line-0529}

The starting values for the dot are set to half the width and half the height, respectively, of the display window, which is the center of the window:

[]{#c14.xhtml#c14-code-0072}[]{#c14.xhtml#c14-lntxt-0072}

`  // Set the starting position of the ball (middle of the stage)`{#c14.xhtml#c14-line-0530}

`  xpos = width/2;`{#c14.xhtml#c14-line-0531}

`  ypos = height/2;`{#c14.xhtml#c14-line-0532}

[]{#c14.xhtml#Page_354 .pagebreak role="doc-pagebreak" title="354"} To make the serial connection, a serial list is drawn:

[]{#c14.xhtml#c14-code-0073}[]{#c14.xhtml#c14-lntxt-0073}

`  // Print a list of the serial ports, for debugging purposes:`{#c14.xhtml#c14-line-0533}

`  println(Serial.list());`{#c14.xhtml#c14-line-0534}

Your Arduino usually tops the list, so the temporary string [`portName`]{.Code-within-text} stores the name of position 0 in the list, and [`myPort`]{.Code-within-text} uses that connection when the serial port is set. Note that this code could be written as [`Serial(this, Serial.list()[0], 9600);`]{.Code-within-text}.

If you\'re not using the [`Serial.list`]{.Code-within-text} function, you can replace [`Serial.list()[0]`]{.Code-within-text} with another number in the list, which is printed to the console. You can also replace [`Serial.list()[0]`]{.Code-within-text} with the name of the port. This feature is useful if you have multiple Arduinos connected. The number 9600 refers to the baud rate and must be the same on both ends:

[]{#c14.xhtml#c14-code-0074}[]{#c14.xhtml#c14-lntxt-0074}

`String portName = Serial.list()[0];`{#c14.xhtml#c14-line-0535}

`  myPort = new Serial(this, portName, 9600);`{#c14.xhtml#c14-line-0536}

`}`{#c14.xhtml#c14-line-0537}

In [`draw`]{.Code-within-text}, the background is drawn first. Because the background is undefined, it has a default value of 0, which is black. The fill color is also undefined for now, so the ellipse is black as well. The fill and background colors are updated in the [`serialEvent`]{.Code-within-text} function, so colored shapes will appear only when there is activity from the sensors.

[]{#c14.xhtml#c14-code-0075}[]{#c14.xhtml#c14-lntxt-0075}

`void draw() {`{#c14.xhtml#c14-line-0538}

`  background(bgcolor);`{#c14.xhtml#c14-line-0539}

`  fill(fgcolor);`{#c14.xhtml#c14-line-0540}

The ellipse is drawn, centered on the display window and with a fixed diameter of 20 pixels:

[]{#c14.xhtml#c14-code-0076}[]{#c14.xhtml#c14-lntxt-0076}

`  // Draw the shape`{#c14.xhtml#c14-line-0541}

`  ellipse(xpos, ypos, 20, 20);`{#c14.xhtml#c14-line-0542}

`}`{#c14.xhtml#c14-line-0543}

Most of the action happens in [`serialEvent`]{.Code-within-text}, which affects the ellipse being constantly drawn by the [`draw`]{.Code-within-text} loop:

[]{#c14.xhtml#c14-code-0077}[]{#c14.xhtml#c14-lntxt-0077}

`void serialEvent(Serial myPort) {`{#c14.xhtml#c14-line-0544}

If data is sent over the serial port, it triggers [`serialEvent`]{.Code-within-text}. The first byte of data is read by using [`myPort.read`]{.Code-within-text} and stored in the temporary variable [`inByte`]{.Code-within-text}: []{#c14.xhtml#Page_355 .pagebreak role="doc-pagebreak" title="355"}

[]{#c14.xhtml#c14-code-0078}[]{#c14.xhtml#c14-lntxt-0078}

`  // read a byte from the serial port:`{#c14.xhtml#c14-line-0545}

`  int inByte = myPort.read();`{#c14.xhtml#c14-line-0546}

If the Processing sketch is not already in contact with a serial device, it proceeds to the next [`if`]{.Code-within-text} statement to see whether the byte is the character *A.* If so, the buffer clears and the Boolean [`firstContact`]{.Code-within-text} is set to [`true`]{.Code-within-text} and sends an *A* character back. Remember that [`establishContact`]{.Code-within-text} function on the Arduino? It repeatedly sends the character *A* until the connection is made. When an *A* is sent back the other way, it triggers [`if (Serial.available() > 0)`]{.Code-within-text}, which starts sending the data from the Arduino. This technique is called *handshaking*, a mutual negotiation between two parts of a system to establish a connection:

[]{#c14.xhtml#c14-code-0079}[]{#c14.xhtml#c14-lntxt-0079}

`if (firstContact == false) {`{#c14.xhtml#c14-line-0547}

`    if (inByte == 'A') {`{#c14.xhtml#c14-line-0548}

`      myPort.clear();          // clear the serial port buffer`{#c14.xhtml#c14-line-0549}

`      firstContact = true;     // you've had first contact from the microcontroller`{#c14.xhtml#c14-line-0550}

`      myPort.write('A');       // ask for more`{#c14.xhtml#c14-line-0551}

`    }`{#c14.xhtml#c14-line-0552}

`  }`{#c14.xhtml#c14-line-0553}

If [`firstContact`]{.Code-within-text} is [`true`]{.Code-within-text}, the program reads bytes as they arrive and adds them in order to the [`serialInArray`]{.Code-within-text} array:

[]{#c14.xhtml#c14-code-0080}[]{#c14.xhtml#c14-lntxt-0080}

`  else {`{#c14.xhtml#c14-line-0554}

`    // Add the latest byte from the serial port to array:`{#c14.xhtml#c14-line-0555}

`    serialInArray[serialCount] = inByte;`{#c14.xhtml#c14-line-0556}

Every time a byte is read, the counter increases by one:

[]{#c14.xhtml#c14-code-0081}[]{#c14.xhtml#c14-lntxt-0081}

`    serialCount++;`{#c14.xhtml#c14-line-0557}

When the counter is greater than 2, all three bytes have been read and assigned their tasks:

[]{#c14.xhtml#c14-code-0082}[]{#c14.xhtml#c14-lntxt-0082}

`    // If we have 3 bytes:`{#c14.xhtml#c14-line-0558}

`    if (serialCount > 2 ) {`{#c14.xhtml#c14-line-0559}

The potentiometer on analog 0 reflects the horizontal position of the dot, the potentiometer on analog 1 is the vertical position, and the button is the fill color:

[]{#c14.xhtml#c14-code-0083}[]{#c14.xhtml#c14-lntxt-0083}

`      xpos = serialInArray[0];`{#c14.xhtml#c14-line-0560}

`      ypos = serialInArray[1];`{#c14.xhtml#c14-line-0561}

`      fgcolor = serialInArray[2];`{#c14.xhtml#c14-line-0562}

[]{#c14.xhtml#Page_356 .pagebreak role="doc-pagebreak" title="356"} These values are also printed to the console for debugging, to check that everything is operating as intended. In Processing, you can combine many values in a [`print`]{.Code-within-text} or [`println`]{.Code-within-text} statement by using the [`+`]{.Code-within-text} symbol. You can also use [`\t`]{.Code-within-text} to put a tab in between each value to space them neatly:

[]{#c14.xhtml#c14-code-0084}[]{#c14.xhtml#c14-lntxt-0084}

`// print the values (for debugging purposes only):`{#c14.xhtml#c14-line-0563}

`      println(xpos + "\t" + ypos + "\t" + fgcolor);`{#c14.xhtml#c14-line-0564}

Another uppercase *A* is sent to trigger the [`if (Serial.available() > 0)`]{.Code-within-text} conditional and repeat the process:

[]{#c14.xhtml#c14-code-0085}[]{#c14.xhtml#c14-lntxt-0085}

`      // Send a capital A to request new sensor readings:`{#c14.xhtml#c14-line-0565}

`      myPort.write('A');`{#c14.xhtml#c14-line-0566}

The [`serialCount`]{.Code-within-text} value is reset to 0 for the next set of values:

[]{#c14.xhtml#c14-code-0086}[]{#c14.xhtml#c14-lntxt-0086}

`      // Reset serialCount:`{#c14.xhtml#c14-line-0567}

`      serialCount = 0;`{#c14.xhtml#c14-line-0568}

`    }`{#c14.xhtml#c14-line-0569}

`  }`{#c14.xhtml#c14-line-0570}

`}`{#c14.xhtml#c14-line-0571}

This example is a great way to get started reading multiple sensors into a computer program. Why not build your own giant keyboard to reenact a scene from the Tom Hanks film *Big*? Or gather data from a variety of sensors to monitor the weather around your house? The output for this sketch is basic but offers a huge potential for amazing and creative ways to map data. A few web searches for *data visualization* will give you an idea of what's possible.
:::
:::

[]{#p05.xhtml}

::: {.section}
[]{#p05.xhtml#Page_357 .pagebreak role="doc-pagebreak" title="357"}Part 5

# The Part of Tens {#p05.xhtml#a1 .Part-Title}

::: {.section}
[]{#p05.xhtml#p05-sec-0001}

[]{#p05.xhtml#Page_358 .pagebreak role="doc-pagebreak" title="358"}IN THIS PART ...

Discover websites that will inspire you to learn more about Arduino.

Browse online stores for all sorts of Arduino-compatible components.
:::
:::

[]{#c15.xhtml}

[]{#c15.xhtml#Page_359 .pagebreak role="doc-pagebreak" title="359"}Chapter 15

# Ten Places to Learn More about Arduino {#c15.xhtml#a1 .Chap-Title}

::: {.section}
[]{#c15.xhtml#c15-sec-0001}[]{#c15.xhtml#c15-feafxd-0001}

IN THIS CHAPTER

![check.png](https://i.imgur.com/JYof7Bp.jpeg) **Looking for inspiration on the web**

![check.png](https://i.imgur.com/ipHJM7i.jpeg) **Searching for tutorials and further reading**

![check.png](https://i.imgur.com/3eDbY5k.jpeg) **Finding communities in the real world**

If this is your first step into the world of Arduino, you will be relieved to know that you have an abundance of resources available on the Internet. You can find new Arduino-compatible hardware, projects, tutorials, and even inspiration. In this chapter, I offer ten popular websites to help you on your journey of discovery.
:::

::: {.section}
[]{#c15.xhtml#c15-sec-0002}

## Arduino Blog {#c15.xhtml#h2-1 .Heading-1}

[[`blog.arduino.cc`]{.Code-within-text}](https://blog.arduino.cc/)

The Arduino blog is a great source of all Arduino-related news. You can find news on the latest official hardware and software as well as on other interesting projects. Also found here are talks that the Arduino team wants to share with the community.
:::

::: {.section}
[]{#c15.xhtml#Page_360 .pagebreak role="doc-pagebreak" title="360"}[]{#c15.xhtml#c15-sec-0003}

## Hack a Day {#c15.xhtml#h2-2 .Heading-1}

[[`hackaday.com`]{.Code-within-text}](https://hackaday.com/)

Hack a Day is an excellent resource for all sorts of technological magic. In addition to presenting a lot of Arduino-related projects and posts, the site offers equal amounts of just about any other category of technology that you can think of. This site contains an excellent collection of posts and information to fuel the imagination.
:::

::: {.section}
[]{#c15.xhtml#c15-sec-0004}

## SparkFun {#c15.xhtml#h2-3 .Heading-1}

[[`www.sparkfun.com/news`]{.Code-within-text}](https://www.sparkfun.com/news)

SparkFun manufactures and sells all sorts of products to make your projects possible, and many of these involve Arduino. SparkFun has an excellent and well-maintained newsfeed that always has some sort of interesting new product or kit to show off. The company also provides excellent videos that explain its kits and document events that the SparkFun team hosts or attends.
:::

::: {.section}
[]{#c15.xhtml#c15-sec-0005}

## MAKE {#c15.xhtml#h2-4 .Heading-1}

[[`makezine.com/blog`]{.Code-within-text}](https://makezine.com/blog/)

*MAKE* is hobbyist magazine that celebrates all kinds of technology. Its blog covers interesting do-it-yourself (DIY) technology and projects for inspiration. Arduino is so important to this community that it has its own subsection in the blog.
:::

::: {.section}
[]{#c15.xhtml#c15-sec-0006}

## Adafruit {#c15.xhtml#h2-5 .Heading-1}

[[`blog.adafruit.com`]{.Code-within-text}](https://blog.adafruit.com/)

Adafruit is an online shop, repository, and forum for all kinds of kits to help you make your projects work. Its blog announces the ever-growing selection of available Adafruit products as well as other interesting tech news.
:::

::: {.section}
[]{#c15.xhtml#Page_361 .pagebreak role="doc-pagebreak" title="361"}[]{#c15.xhtml#c15-sec-0007}

## Instructables {#c15.xhtml#h2-6 .Heading-1}

[[`www.instructables.com`]{.Code-within-text}](https://www.instructables.com/)

Instructables is a web-based documentation platform that allows people to share their projects and step-by-step instructions. Instructables isn't just about Arduino or even technology, so you can find a whole world of interesting material there.
:::

::: {.section}
[]{#c15.xhtml#c15-sec-0008}

## YouTube {#c15.xhtml#h2-7 .Heading-1}

[[`www.youtube.com`]{.Code-within-text}](https://youtube.com)

YouTube is a great place to kill time, but rather than watching cats do funny things, why not enter *Arduino* in the site's search box to discover new projects that people are sharing. YouTube videos won't always be the most reliable source for well-documented projects, but the videos provide a broad look at Arduino projects in action. Watching videos is especially useful for seeing the proper result of projects.
:::

::: {.section}
[]{#c15.xhtml#c15-sec-0009}

## Hackerspaces {#c15.xhtml#h2-8 .Heading-1}

[[`hackerspaces.org`]{.Code-within-text}](https://hackerspaces.org)

*Hackerspaces* are physical spaces where artists, designers, makers, hackers, coders, engineers, or anyone else can meet to learn, socialize, and collaborate on projects. Hackerspaces are found in a loose network all over the world. A good place to start to find one near you is the map at [[`hackerspaces.org/wiki/List_of_Hacker_Spaces`]{.Code-within-text}](https://hackerspaces.org/wiki/List_of_Hacker_Spaces).
:::

::: {.section}
[]{#c15.xhtml#c15-sec-0010}

## Forum {#c15.xhtml#h2-9 .Heading-1}

[[`arduino.cc/forum`]{.Code-within-text}](https://arduino.cc/forum/)

The Arduino Forum is a great place to get answers to specific Arduino questions. You often find that other people are working through the same problems that you are, so you're likely to find the answer to almost any problem with some thorough searching.
:::

::: {.section}
[]{#c15.xhtml#Page_362 .pagebreak role="doc-pagebreak" title="362"}[]{#c15.xhtml#c15-sec-0011}

## Friends, Colleagues, and Workshops {#c15.xhtml#h2-10 .Heading-1}

Starting out in the world of Arduino can be difficult on your own. You can find many sources on the Internet, but one of the best ways to learn is with friends and colleagues, because learning together teaches you much more than learning on your own can.

Even better is to go to workshops and meet other people. You may find that they have the same interests, allowing you to pool what you know; or they may have different interests, providing an opportunity to show you something new. Arduino workshops are taking place all over the world, so with some careful searching in the Arduino Forum, Hackerspace forums, and Google, you should be able to find a workshop near you.
:::

[]{#c16.xhtml}

[]{#c16.xhtml#Page_363 .pagebreak role="doc-pagebreak" title="363"}Chapter 16

# Ten Great Shops to Know {#c16.xhtml#a1 .Chap-Title}

::: {.section}
[]{#c16.xhtml#c16-sec-0001}[]{#c16.xhtml#c16-feafxd-0001}

IN THIS CHAPTER

![check.png](https://i.imgur.com/7NCdOWs.jpeg) **Discovering Arduino suppliers around the world**

![check.png](https://i.imgur.com/Q7Ur7wT.jpeg) **Introducing international electronics distributors**

![check.png](https://i.imgur.com/yDlqBeZ.jpeg) **Reusing old parts**

When it comes to buying parts for your project, you'll find a huge and growing number of shops that cater to your needs. Although these stores deal in other hobby electronics as well as Arduino, they stock a variety of boards and components that you can use in your Arduino project. This chapter provides just a small sample of the stores out there, so shop around.
:::

::: {.section}
[]{#c16.xhtml#c16-sec-0002}

## Adafruit {#c16.xhtml#h2-1 .Heading-1}

[[`www.adafruit.com`]{.Code-within-text}](https://www.adafruit.com/)

MIT engineer Limor "Ladyada" Fried founded Adafruit in 2005. Through its website, the company offers a wealth of resources, including products the company designs and makes itself; other products sourced from all over; tools and equipment to help you construct your projects; and tutorials, forums, and videos covering a wide range of topics. Adafruit is based in New York, New York (it's a wonderful town!). It distributes worldwide and has distributors in many countries.
:::

::: {.section}
[]{#c16.xhtml#Page_364 .pagebreak role="doc-pagebreak" title="364"}[]{#c16.xhtml#c16-sec-0003}

## Arduino Store {#c16.xhtml#h2-2 .Heading-1}

[[`store.arduino.cc`]{.Code-within-text}](https://store.arduino.cc/)

Arduino Store was official opened in May 2011 to sell Arduino products directly rather than solely through distributors. The store sells all official Arduino-branded products as well as a few select third-party ones. It also sells TinkerKit, which is designed to make Arduino and electronics even simpler for beginners by using plugs to connect inputs and outputs rather than requiring breadboards or soldering.
:::

::: {.section}
[]{#c16.xhtml#c16-sec-0004}

## Seeed Studio {#c16.xhtml#h2-3 .Heading-1}

[[`www.seeedstudio.com`]{.Code-within-text}](https://www.seeedstudio.com/)

Seeed Studio is based in Shenzhen, China and is self-described as an "open hardware facilitation company." The shop uses local manufacturing to quickly make prototypes and small-scale projects that are distributed worldwide. In addition to manufacturing and selling products, the company offers a community area on its website where people can vote for the projects that they want Seeed Studio to bring to fruition.
:::

::: {.section}
[]{#c16.xhtml#c16-sec-0005}

## SparkFun {#c16.xhtml#h2-4 .Heading-1}

[[`www.sparkfun.com`]{.Code-within-text}](https://www.sparkfun.com/)

SparkFun sells all sorts of parts for every variety of electronics project. As well as selling Arduino-compatible hardware, it designs and makes a lot of its own boards and kits. SparkFun has an excellent site that acts as a shop front, a support desk, and a classroom for Arduinists. SparkFun also has active (and vocal) commenters on each of its product pages, which help to support and continually improve the company's products. SparkFun was founded in 2003 and is based in Boulder, Colorado.
:::

::: {.section}
[]{#c16.xhtml#Page_365 .pagebreak role="doc-pagebreak" title="365"}[]{#c16.xhtml#c16-sec-0006}

## Allied Electroncs {#c16.xhtml#h2-5 .Heading-1}

[[`www.alliedelec.com`]{.Code-within-text}](https://www.alliedelec.com/)

Allied Electronics markets itself as "the world's largest distributor of electronics and maintenance products," and is a reliable source of an extensive range of products at low prices. Allied Electronics has a sister company that operates in Europe, RS Components.
:::

::: {.section}
[]{#c16.xhtml#c16-sec-0007}

## Newark Electronics {#c16.xhtml#h2-6 .Heading-1}

[[`www.newark.com`]{.Code-within-text}](http://www.newark.com/)

Newark is a Chicago-based supplier of electronics with an enormous range of components to choose from. It operates worldwide under the Premier Farnell Group. This company is made up of several sister companies that allow the group to distribute to 24 countries in Europe (Farnell), North America (Newark Electronics) and Asia Pacific (Element14).
:::

::: {.section}
[]{#c16.xhtml#c16-sec-0008}

## Mouser {#c16.xhtml#h2-7 .Heading-1}

[[`www.mouser.com`]{.Code-within-text}](https://www.mouser.com/)

Originally founded by Jerry Mouser, a physics teacher in search of components for a high school electronics program, Mouser Electronics is now a leading US-based electronics distributor. Among its stock is a huge selection of development boards, ideal for those who are just starting out with electronics.
:::

::: {.section}
[]{#c16.xhtml#c16-sec-0009}

## Digi-Key {#c16.xhtml#h2-8 .Heading-1}

[[`www.digikey.com`]{.Code-within-text}](https://www.digikey.com)

Digi-Key is one of the largest distributors of electronic components in North America. The company originally started by supplying the hobbyist market of amateur radio enthusiasts, but has since grown into an international electronics distributor.
:::

::: {.section}
[]{#c16.xhtml#Page_366 .pagebreak role="doc-pagebreak" title="366"}[]{#c16.xhtml#c16-sec-0010}

## eBay {#c16.xhtml#h2-9 .Heading-1}

[[`www.ebay.com`]{.Code-within-text}](https://www.ebay.com)

One person's junk is another person's treasure, and eBay is a great source of tech products that need a new home. Many parts are available through eBay --- even specific ones. But better than that, you can find other bits of consumer electronics that you can hack to suit your own ends.
:::

::: {.section}
[]{#c16.xhtml#c16-sec-0011}

## Dumpster Diving {#c16.xhtml#h2-10 .Heading-1}

Dumpster diving is not technically a shop, but it is a great resource nonetheless! People are always amazed at the amount of useful stuff that's thrown away, but they rarely know what's useful and what's not. The key is to know what you're looking for and find out whether you can salvage the parts you need for your project. This process may take a bit of Googling because so many products and components are available that could be of use to your project.

For example, a motor can be expensive if bought new but is used in a variety of consumer electronics that are often discarded. Printers and scanners use relatively complex and expensive stepper motors, which you could repurpose in an Arduino project. Also, because these everyday objects are mass-produced, even buying a new printer with several motors could be cheaper than buying the motors individually.
:::

[]{#b01.xhtml}

::: {.section .ATA .contributors}
[]{#b01.xhtml#Page_385 .pagebreak role="doc-pagebreak" title="385"}[]{#b01.xhtml#b01-sec-0001}

## About the Author {.Heading-1}

John Nussey is an entrepreneur, designer, and technologist based in London.

His work involves using technology in new and interesting ways and covers many areas, including electronics, physical computing, product prototyping, product design and the Internet of Things.

During his career, he has worked on many varied projects with clients such as ARUP, the BBC and the National Maritime Museum. He has also founded companies, including ONN Studio, which helps people realize their product ideas, and Ding, which makes beautiful smart-home products.

He is a proud advocate of Arduino and has taught the craft of interaction design and prototyping to people of all ages, competencies, and abilities at a variety of establishments, including Goldsmiths College, the Bartlett School of Architecture, and the Royal College of Art.
:::

::: {.section .dedication .dedication role="doc-dedication"}
[]{#b01.xhtml#b01-sec-0002}

## Dedication {.Heading-1 style="page-break-before: always;"}

To Avril O'Neil, the love of my life (and only person I trust with a soldering iron), for sharing so many experiences with me and providing support when I need it most; to Roanne O'Neil for our stimulating literary chats; and to Alexandra Deschamps-Sonsino and Massimo Banzi for introducing me to Arduino, which has allowed me to pursue such a varied and exciting career.
:::

::: {.section .acknowledgments role="doc-acknowledgments"}
[]{#b01.xhtml#b01-sec-0003}

## []{#b01.xhtml#Page_386 .pagebreak role="doc-pagebreak" title="386"}Author's Acknowledgments {.Heading-1 style="page-break-before: always;"}

I would like to thank the folks at Wiley, especially Susan Pink and Katie Mohr for always being upbeat and encouraging.

Many thanks to Guy Hart-Davis for his excellent technical editing.

A big thanks to my friends, my family, and the *Arduino For Dummies* readers I've met since 2013,for their encouragement and enthusiasm. I love making things, and I hope this book inspires you to make things of your own and find the same passion I have found.

**Publisher's Acknowledgments**

**Executive Editor:** Katie Mohr

**Project Editor:** Susan Pink

**Copy Editor:** Susan Pink

**Technical Editor:** Guy Hart-Davis

**Editorial Assistant:** Matthew Lowe

**Sr. Editorial Assistant:** Cherie Case

**Production Editor:** Siddique Shaik

**Cover Image:** Courtesy of John Nussey
:::

[]{#dum-social-media-ad.xhtml}

::: {.page-box}
Take Dummies with you everywhere you go!

[![](www.dummies.com)](http://www.dummies.com)

Go to our [Website](http://www.dummies.com)

[![](fordummies)](http://www.facebook.com/fordummies)

Like us on [Facebook](http://www.facebook.com/fordummies)

[![](fordummies)](http://www.twitter.com/fordummies)

Follow us on [Twitter](http://www.twitter.com/fordummies)

[![](fordummies)](http://www.youtube.com/user/fordummies)

Watch us on [YouTube](http://www.youtube.com/user/fordummies)

[![](groups?home=![LinkedIn Logo](/Volumes/Download(ThinkPad)/scan/epub_to_md/converted_md/Arduino for Dummies - John Nussey/assets/images/linkedin-logo.png)gid=3229946![LinkedIn Logo](/Volumes/Download(ThinkPad)/scan/epub_to_md/converted_md/Arduino for Dummies - John Nussey/assets/images/linkedin-logo.png)trk=anet_ug_hm)](http://www.linkedin.com/groups?home=&gid=3229946&trk=anet_ug_hm)

Join us on [LinkedIn](http://www.linkedin.com/groups?home=&gid=3229946&trk=anet_ug_hm)

[![]()](http://pinterest.com/fordummies/)

Pin us on [Pinterest](http://pinterest.com/fordummies/)

[![](105265587979403653723)](https://plus.google.com/105265587979403653723)

Circle us on [google+](https://plus.google.com/105265587979403653723)

[![](newsletter)](http://www.dummies.com/go/newsletter)

Subscribe to our [newsletter](http://www.dummies.com/go/newsletter)

[![]()](http://covers.dummies.com/)

Create your own [Dummies book cover](http://covers.dummies.com/)

[![](dummiesmerchandise.com)](http://dummiesmerchandise.com)

[Shop Online](http://dummiesmerchandise.com)

![dummies-wordmark.png](https://i.imgur.com/ychqdEU.jpeg)
:::

[]{#b02.xhtml}

::: {.section .index role="doc-index"}
```{=html}
<header>
```
# []{#b02.xhtml#Page_367 .pagebreak role="doc-pagebreak" title="367"}Index {#b02.xhtml#index1 .Chap-Title}

```{=html}
</header>
```
::: {.section}
## Symbols {.Heading-1}

1.  [A socket, [63](#c04.xhtml#Page_63)]{#b02.xhtml#ind2}
2.  [\*/ (asterisk forward slash), [46](#c03.xhtml#Page_46)]{#b02.xhtml#ind3}
3.  [\\t (back slash t), [118](#c06.xhtml#Page_118)]{#b02.xhtml#ind4}
4.  [!= (comparison symbol), [217](#c10.xhtml#Page_217)]{#b02.xhtml#ind5}
5.  [{} (curly brackets/braces), [48](#c03.xhtml#Page_48), [150](#c07.xhtml#Page_150)]{#b02.xhtml#ind6}
6.  [// (double forward slash), [47](#c03.xhtml#Page_47)]{#b02.xhtml#ind7}
7.  [/\* (forward slash asterisk), [46](#c03.xhtml#Page_46)]{#b02.xhtml#ind8}
8.  [μA (microamps), [65](#c04.xhtml#Page_65)]{#b02.xhtml#ind9}
9.  [mA (milliamps), [65](#c04.xhtml#Page_65)]{#b02.xhtml#ind10}
10. [/\* \*/ (multiline comment markers), [326](#c14.xhtml#Page_326)]{#b02.xhtml#ind11}
11. [- (negative), [58](#c04.xhtml#Page_58), [77](#c05.xhtml#Page_77), [138](#c07.xhtml#Page_138)]{#b02.xhtml#ind12}
12. [\|\|(or), [94](#c06.xhtml#Page_94)]{#b02.xhtml#ind13}
13. [+ (positive), [58](#c04.xhtml#Page_58), [70](#c05.xhtml#Page_70), [77](#c05.xhtml#Page_77), [138](#c07.xhtml#Page_138)]{#b02.xhtml#ind14}
14. [\" \" (quotation marks), [118](#c06.xhtml#Page_118)]{#b02.xhtml#ind15}
15. [\[\] (square brackets), [150](#c07.xhtml#Page_150), [228](#c10.xhtml#Page_228)]{#b02.xhtml#ind16}
:::

::: {.section}
## A {.Heading-1}

1.  [AAC (Advanced Audio Coding), [290](#c12.xhtml#Page_290)]{#b02.xhtml#ind18}
2.  [AC voltage, [64](#c04.xhtml#Page_64)]{#b02.xhtml#ind19}
3.  [AC-to-DC adaptor, [22](#c02.xhtml#Page_22)]{#b02.xhtml#ind20}
4.  [Adafruit FONA 800 shield, [296](#c12.xhtml#Page_296)--297]{#b02.xhtml#ind21}
5.  [Adafruit Industries (distributor), [24](#c02.xhtml#Page_24), [26](#c02.xhtml#Page_26), [27](#c02.xhtml#Page_27), [173](#c08.xhtml#Page_173)--174, [289](#c12.xhtml#Page_289), [292](#c12.xhtml#Page_292), [294](#c12.xhtml#Page_294)--295, [296](#c12.xhtml#Page_296), [298](#c12.xhtml#Page_298), [360](#c15.xhtml#Page_360), [363](#c16.xhtml#Page_363)]{#b02.xhtml#ind22}
6.  [Adafruit motor/stepper/servo shield Kit v2.3, [294](#c12.xhtml#Page_294)--295]{#b02.xhtml#ind23}
7.  [Adafruit Wave shield v1.1, [289](#c12.xhtml#Page_289)--290]{#b02.xhtml#ind24}
8.  [adhesive putty, [127](#c07.xhtml#Page_127), [184](#c09.xhtml#Page_184)--185, [195](#c09.xhtml#Page_195), [198](#c09.xhtml#Page_198)]{#b02.xhtml#ind25}
9.  [Advanced Audio Coding (AAC), [290](#c12.xhtml#Page_290)]{#b02.xhtml#ind26}
10. [Albion Café, [167](#c08.xhtml#Page_167)]{#b02.xhtml#ind27}
11. [Allen, Bruce (developer), [277](#c11.xhtml#Page_277)]{#b02.xhtml#ind28}
12. [Allied Electronics (disctributor), [365](#c16.xhtml#Page_365)]{#b02.xhtml#ind29}
13. [Amazon (supplier), [29](#c02.xhtml#Page_29)]{#b02.xhtml#ind30}
14. [ambient sensor, [281](#c11.xhtml#Page_281)]{#b02.xhtml#ind31}
15. [amperes (I), [71](#c05.xhtml#Page_71)]{#b02.xhtml#ind32}
16. [amps (A), [63](#c04.xhtml#Page_63), [65](#c04.xhtml#Page_65), [70](#c05.xhtml#Page_70), [71](#c05.xhtml#Page_71)]{#b02.xhtml#ind33}
17. [analog input pins/analog in pins, [20](#c02.xhtml#Page_20), [21](#c02.xhtml#Page_21)]{#b02.xhtml#ind34}
18. [analog out pins, [21](#c02.xhtml#Page_21)]{#b02.xhtml#ind35}
19. [analog sensors, [106](#c06.xhtml#Page_106)--107, [113](#c06.xhtml#Page_113), [225](#c10.xhtml#Page_225)--231]{#b02.xhtml#ind36}
20. [AnalogInOutSerial circuit, [199](#c09.xhtml#Page_199)]{#b02.xhtml#ind37}
21. [AnalogInOutSerial sketch]{#b02.xhtml#ind38}
    1.  [implementing, [265](#c11.xhtml#Page_265)--268, [281](#c11.xhtml#Page_281)--284]{#b02.xhtml#ind39}
    2.  [setting up, [113](#c06.xhtml#Page_113)--116]{#b02.xhtml#ind40}
    3.  [understanding, [117](#c06.xhtml#Page_117)--118, [268](#c11.xhtml#Page_268), [284](#c11.xhtml#Page_284)]{#b02.xhtml#ind41}
22. [AnalogInput sketch, [103](#c06.xhtml#Page_103)--109]{#b02.xhtml#ind42}
23. [[ `analogRead` ]{.Code-within-text} function, [107](#c06.xhtml#Page_107), [230](#c10.xhtml#Page_230)]{#b02.xhtml#ind43}
24. [analog-to-digital converter, [107](#c06.xhtml#Page_107)]{#b02.xhtml#ind44}
25. [[ `analogWrite` ]{.Code-within-text} function, [91](#c06.xhtml#Page_91), [118](#c06.xhtml#Page_118), [128](#c07.xhtml#Page_128), [236](#c10.xhtml#Page_236)]{#b02.xhtml#ind45}
26. [Android, [25](#c02.xhtml#Page_25), [310](#c13.xhtml#Page_310), [311](#c13.xhtml#Page_311)]{#b02.xhtml#ind46}
27. [anode (+), [77](#c05.xhtml#Page_77), [121](#c07.xhtml#Page_121)]{#b02.xhtml#ind47}
28. [application programming interface (API), [163](#c08.xhtml#Page_163), [308](#c13.xhtml#Page_308)]{#b02.xhtml#ind48}
29. [Arduin-ists, [1](#c00.xhtml#Page_1)]{#b02.xhtml#ind49}
30. [Arduino. *See also specific topics*]{#b02.xhtml#ind50}
    1.  [blog for, [298](#c12.xhtml#Page_298), [359](#c15.xhtml#Page_359)]{#b02.xhtml#ind51}
    2.  [boards for, [17](#c02.xhtml#Page_17), [24](#c02.xhtml#Page_24)--27]{#b02.xhtml#ind52}
    3.  [community for, [286](#c12.xhtml#Page_286)]{#b02.xhtml#ind53}
    4.  [downloads, [33](#c02.xhtml#Page_33)]{#b02.xhtml#ind54}
    5.  [environment, [33](#c02.xhtml#Page_33)--35, [94](#c06.xhtml#Page_94), [125](#c07.xhtml#Page_125)]{#b02.xhtml#ind55}
    6.  [history of, [8](#c01.xhtml#Page_8)--11]{#b02.xhtml#ind56}
    7.  [installing, [33](#c02.xhtml#Page_33)]{#b02.xhtml#ind57}
    8.  [learning-by-doing approach, [11](#c01.xhtml#Page_11)--14]{#b02.xhtml#ind58}
    9.  [as name encompassing host of concepts, [17](#c02.xhtml#Page_17)]{#b02.xhtml#ind59}
    10. [purpose of, [7](#c01.xhtml#Page_7), [37](#c03.xhtml#Page_37)]{#b02.xhtml#ind60}
    11. [as trademarked brand, [24](#c02.xhtml#Page_24)]{#b02.xhtml#ind61}
31. [Arduino (supplier), [288](#c12.xhtml#Page_288)]{#b02.xhtml#ind62}
32. [Arduino 101, [26](#c02.xhtml#Page_26)]{#b02.xhtml#ind63}
33. [Arduino Duemilanove (board), [19](#c02.xhtml#Page_19)]{#b02.xhtml#ind64}
34. [Arduino Ethernet shield, [168](#c08.xhtml#Page_168), [170](#c08.xhtml#Page_170)]{#b02.xhtml#ind65}
35. [Arduino forums, [15](#c01.xhtml#Page_15), [361](#c15.xhtml#Page_361)]{#b02.xhtml#ind66}
36. [Arduino Graph sketch, [336](#c14.xhtml#Page_336)--340]{#b02.xhtml#ind67}
37. [Arduino Leonardo (board), [25](#c02.xhtml#Page_25)]{#b02.xhtml#ind68}
38. [Arduino LilyPad (board), [26](#c02.xhtml#Page_26)]{#b02.xhtml#ind69}
39. [Arduino Mega 2560 R3, [25](#c02.xhtml#Page_25)]{#b02.xhtml#ind70}
40. [Arduino Mega ADK, [25](#c02.xhtml#Page_25)]{#b02.xhtml#ind71}
41. [Arduino Mini R5, [25](#c02.xhtml#Page_25)]{#b02.xhtml#ind72}
42. [[]{#b02.xhtml#Page_368 .pagebreak role="doc-pagebreak" title="368"}Arduino MKR1000, [26](#c02.xhtml#Page_26), [295](#c12.xhtml#Page_295)]{#b02.xhtml#ind73}
43. [Arduino Nano 3.0 (board), [25](#c02.xhtml#Page_25)]{#b02.xhtml#ind74}
44. [Arduino PhysicalPixel sketch, [326](#c14.xhtml#Page_326)--328, [332](#c14.xhtml#Page_332)--334]{#b02.xhtml#ind75}
45. [Arduino Playground, [15](#c01.xhtml#Page_15), [277](#c11.xhtml#Page_277), [302](#c12.xhtml#Page_302), [307](#c13.xhtml#Page_307), [308](#c13.xhtml#Page_308)]{#b02.xhtml#ind76}
46. [Arduino Pro (board), [24](#c02.xhtml#Page_24), [26](#c02.xhtml#Page_26)]{#b02.xhtml#ind77}
47. [Arduino Pro Mini (board), [27](#c02.xhtml#Page_27), [165](#c08.xhtml#Page_165)]{#b02.xhtml#ind78}
48. [Arduino proto kit, [191](#c09.xhtml#Page_191)]{#b02.xhtml#ind79}
49. [Arduino Serial board, original, [11](#c01.xhtml#Page_11)]{#b02.xhtml#ind80}
50. [Arduino SerialCallResponse sketch, [346](#c14.xhtml#Page_346)--348, [350](#c14.xhtml#Page_350)--352]{#b02.xhtml#ind81}
51. [Arduino Shield List, [298](#c12.xhtml#Page_298)]{#b02.xhtml#ind82}
52. [Arduino Software (IDE), [20](#c02.xhtml#Page_20)]{#b02.xhtml#ind83}
53. [Arduino Starter Kit, [31](#c02.xhtml#Page_31)]{#b02.xhtml#ind84}
54. [Arduino Store, [27](#c02.xhtml#Page_27), [298](#c12.xhtml#Page_298), [364](#c16.xhtml#Page_364)]{#b02.xhtml#ind85}
55. [Arduino Uno, [30](#c02.xhtml#Page_30), [318](#c13.xhtml#Page_318)]{#b02.xhtml#ind86}
56. [Arduino Uno R3, [18](#c02.xhtml#Page_18)--24, [300](#c12.xhtml#Page_300)]{#b02.xhtml#ind87}
57. [Arduino Web Editor, [35](#c02.xhtml#Page_35)--36]{#b02.xhtml#ind88}
58. [Arduino Wi-Fi Shield, [172](#c08.xhtml#Page_172)]{#b02.xhtml#ind89}
59. [Arduino Wireless Shield, [174](#c08.xhtml#Page_174)]{#b02.xhtml#ind90}
60. [arrays, [150](#c07.xhtml#Page_150)--151]{#b02.xhtml#ind91}
61. [asterisk forward slash (\*/), [46](#c03.xhtml#Page_46)]{#b02.xhtml#ind92}
62. [ATmega 328 microcontroller chip, [19](#c02.xhtml#Page_19)--20, [23](#c02.xhtml#Page_23), [25](#c02.xhtml#Page_25), [107](#c06.xhtml#Page_107)]{#b02.xhtml#ind93}
63. [ATmega328P-PU chip, [40](#c03.xhtml#Page_40)]{#b02.xhtml#ind94}
64. [Atmel (chip manufacturer), [19](#c02.xhtml#Page_19)]{#b02.xhtml#ind95}
65. [ATMEL chip, [40](#c03.xhtml#Page_40)]{#b02.xhtml#ind96}
66. [[`average`]{.Code-within-text} variable, [229](#c10.xhtml#Page_229)]{#b02.xhtml#ind97}
:::

::: {.section}
## B {.Heading-1}

1.  [back slash t (\\t), [118](#c06.xhtml#Page_118)]{#b02.xhtml#ind99}
2.  [background, [318](#c13.xhtml#Page_318)--319]{#b02.xhtml#ind100}
3.  [Badger, Paul (developer), [256](#c11.xhtml#Page_256)]{#b02.xhtml#ind101}
4.  [Baker Tweet project, [167](#c08.xhtml#Page_167)--168]{#b02.xhtml#ind102}
5.  [Banzi, Massimo (developer), [9](#c01.xhtml#Page_9)]{#b02.xhtml#ind103}
6.  [Barragán, Hernando (designer), [9](#c01.xhtml#Page_9)]{#b02.xhtml#ind104}
7.  [base-2, [318](#c13.xhtml#Page_318)]{#b02.xhtml#ind105}
8.  [base-10, [318](#c13.xhtml#Page_318)]{#b02.xhtml#ind106}
9.  [base-16, [318](#c13.xhtml#Page_318)]{#b02.xhtml#ind107}
10. [Basic Stamp, [7](#c01.xhtml#Page_7), [9](#c01.xhtml#Page_9), [10](#c01.xhtml#Page_10)]{#b02.xhtml#ind108}
11. [batteries, [22](#c02.xhtml#Page_22), [70](#c05.xhtml#Page_70), [76](#c05.xhtml#Page_76)--77. *See also* [lithium batteries](#b02.xhtml#ind698)]{#b02.xhtml#ind109}
12. [baud rate, [112](#c06.xhtml#Page_112)]{#b02.xhtml#ind110}
13. [beginner\'s kit, [29](#c02.xhtml#Page_29)--32]{#b02.xhtml#ind111}
14. [Berg (design consultancy), [173](#c08.xhtml#Page_173)]{#b02.xhtml#ind112}
15. [BERG Cloud, [173](#c08.xhtml#Page_173), [174](#c08.xhtml#Page_174)]{#b02.xhtml#ind113}
16. [BERG Cloud Bridge, [174](#c08.xhtml#Page_174)]{#b02.xhtml#ind114}
17. [Big Lamp, [171](#c08.xhtml#Page_171), [172](#c08.xhtml#Page_172)]{#b02.xhtml#ind115}
18. [binary number system, [318](#c13.xhtml#Page_318)]{#b02.xhtml#ind116}
19. [bit (of memory), [318](#c13.xhtml#Page_318)]{#b02.xhtml#ind117}
20. [black]{#b02.xhtml#ind118}
    1.  [as color of ground, [90](#c06.xhtml#Page_90)]{#b02.xhtml#ind119}
    2.  [as one of two colors of negative (-), [58](#c04.xhtml#Page_58), [80](#c05.xhtml#Page_80)]{#b02.xhtml#ind120}
21. [bleeps, [67](#c04.xhtml#Page_67)]{#b02.xhtml#ind121}
22. [Blink sketch, [38](#c03.xhtml#Page_38), [44](#c03.xhtml#Page_44)--51]{#b02.xhtml#ind122}
23. [blinking better]{#b02.xhtml#ind123}
    1.  [building BlinkWithoutDelay sketch, [207](#c10.xhtml#Page_207)--210]{#b02.xhtml#ind124}
    2.  [overview, [205](#c10.xhtml#Page_205)--207]{#b02.xhtml#ind125}
    3.  [understanding BlinkWithoutDelay sketch, [210](#c10.xhtml#Page_210)--212]{#b02.xhtml#ind126}
24. [blinking L, [44](#c03.xhtml#Page_44)]{#b02.xhtml#ind127}
25. [blinking LEDs, in AnalogInput sketch, [108](#c06.xhtml#Page_108)]{#b02.xhtml#ind128}
26. [BlinkWithoutDelay sketch]{#b02.xhtml#ind129}
    1.  [setting up, [207](#c10.xhtml#Page_207)--210]{#b02.xhtml#ind130}
    2.  [understanding, [210](#c10.xhtml#Page_210)--212]{#b02.xhtml#ind131}
27. [block comment, [46](#c03.xhtml#Page_46)--47]{#b02.xhtml#ind132}
28. [blogs]{#b02.xhtml#ind133}
    1.  [Arduino, [359](#c15.xhtml#Page_359)]{#b02.xhtml#ind134}
    2.  [Arduino-related, [298](#c12.xhtml#Page_298)]{#b02.xhtml#ind135}
29. [blue, as one of two colors of negative (-), [58](#c04.xhtml#Page_58)]{#b02.xhtml#ind136}
30. [Bluetooth devices, [26](#c02.xhtml#Page_26), [166](#c08.xhtml#Page_166)]{#b02.xhtml#ind137}
31. [Blu-Tack (adhesive putty), [127](#c07.xhtml#Page_127), [184](#c09.xhtml#Page_184)]{#b02.xhtml#ind138}
32. [boards]{#b02.xhtml#ind139}
    1.  [identifying, [38](#c03.xhtml#Page_38)--40]{#b02.xhtml#ind140}
    2.  [specific. *See specific boards*]{#b02.xhtml#ind141}
33. [Booleans, [248](#c11.xhtml#Page_248), [329](#c14.xhtml#Page_329)]{#b02.xhtml#ind142}
34. [Borch, Malthe (developer), [161](#c08.xhtml#Page_161)]{#b02.xhtml#ind143}
35. [Bostik (company), [184](#c09.xhtml#Page_184)]{#b02.xhtml#ind144}
36. [bouncing, [212](#c10.xhtml#Page_212)--218]{#b02.xhtml#ind145}
37. [Boxall, John (developer), [292](#c12.xhtml#Page_292)]{#b02.xhtml#ind146}
38. [braiding wire connectors, [203](#c09.xhtml#Page_203)]{#b02.xhtml#ind147}
39. [breadboards, [58](#c04.xhtml#Page_58)--59]{#b02.xhtml#ind148}
40. [breakout boards, [26](#c02.xhtml#Page_26), [295](#c12.xhtml#Page_295)]{#b02.xhtml#ind149}
41. [[`brightness`]{.Code-within-text} variable, [92](#c06.xhtml#Page_92), [93](#c06.xhtml#Page_93)]{#b02.xhtml#ind150}
42. [brushed DC motors, [121](#c07.xhtml#Page_121)]{#b02.xhtml#ind151}
43. [brushes, copper, [120](#c07.xhtml#Page_120)]{#b02.xhtml#ind152}
44. [Buechley, Leah (designer/developer), [26](#c02.xhtml#Page_26)]{#b02.xhtml#ind153}
45. [built-in color wheel, [342](#c14.xhtml#Page_342)]{#b02.xhtml#ind154}
46. [Burton, [165](#c08.xhtml#Page_165)]{#b02.xhtml#ind155}
47. [butane soldering iron, [180](#c09.xhtml#Page_180)]{#b02.xhtml#ind156}
48. [[]{#b02.xhtml#Page_369 .pagebreak role="doc-pagebreak" title="369"}Button circuit, [97](#c06.xhtml#Page_97)]{#b02.xhtml#ind157}
49. [Button sketch, [96](#c06.xhtml#Page_96)--102]{#b02.xhtml#ind158}
50. [buttons]{#b02.xhtml#ind159}
    1.  [compared to switches, [238](#c11.xhtml#Page_238)]{#b02.xhtml#ind160}
    2.  [making better, [218](#c10.xhtml#Page_218)--225]{#b02.xhtml#ind161}
    3.  [making them easier, [238](#c11.xhtml#Page_238)--243]{#b02.xhtml#ind162}
    4.  [making virtual button, [323](#c14.xhtml#Page_323)--334]{#b02.xhtml#ind163}
    5.  [StateChangeDetection sketch, [218](#c10.xhtml#Page_218)--225]{#b02.xhtml#ind164}
    6.  [toggle buttons, [238](#c11.xhtml#Page_238)]{#b02.xhtml#ind165}
51. [[`buttonState`]{.Code-within-text} variable, [100](#c06.xhtml#Page_100)--101, [113](#c06.xhtml#Page_113), [216](#c10.xhtml#Page_216), [217](#c10.xhtml#Page_217), [218](#c10.xhtml#Page_218), [274](#c11.xhtml#Page_274)]{#b02.xhtml#ind166}
52. [buzzers, [31](#c02.xhtml#Page_31), [142](#c07.xhtml#Page_142)--143, [244](#c11.xhtml#Page_244)]{#b02.xhtml#ind167}
53. [byte (of memory), [318](#c13.xhtml#Page_318)]{#b02.xhtml#ind168}
:::

::: {.section}
## C {.Heading-1}

1.  [C (programming language), [44](#c03.xhtml#Page_44), [306](#c13.xhtml#Page_306)]{#b02.xhtml#ind170}
2.  [C++ (programming language), [306](#c13.xhtml#Page_306), [310](#c13.xhtml#Page_310)]{#b02.xhtml#ind171}
3.  [cable ties, [204](#c09.xhtml#Page_204)]{#b02.xhtml#ind172}
4.  [cabling, [204](#c09.xhtml#Page_204)]{#b02.xhtml#ind173}
5.  [calibrating inputs, [231](#c10.xhtml#Page_231)--236]{#b02.xhtml#ind174}
6.  [Calibration sketch, [231](#c10.xhtml#Page_231)--236]{#b02.xhtml#ind175}
7.  [Calix, Mira (composer), [163](#c08.xhtml#Page_163)]{#b02.xhtml#ind176}
8.  [capacitive sensors, [255](#c11.xhtml#Page_255)--256, [258](#c11.xhtml#Page_258)--259]{#b02.xhtml#ind177}
9.  [Capacitive Touch Keypads, [255](#c11.xhtml#Page_255)]{#b02.xhtml#ind178}
10. [CapPinSketch sketch, [258](#c11.xhtml#Page_258)--264]{#b02.xhtml#ind179}
11. [CapSense library, [257](#c11.xhtml#Page_257)--258, [262](#c11.xhtml#Page_262), [302](#c12.xhtml#Page_302)]{#b02.xhtml#ind180}
12. [carriage return, [113](#c06.xhtml#Page_113)]{#b02.xhtml#ind181}
13. [case sensitive, [48](#c03.xhtml#Page_48)]{#b02.xhtml#ind182}
14. [Castro, Arturo (developer), [310](#c13.xhtml#Page_310)]{#b02.xhtml#ind183}
15. [cathode (-), [77](#c05.xhtml#Page_77), [121](#c07.xhtml#Page_121)]{#b02.xhtml#ind184}
16. [center negative plug, [22](#c02.xhtml#Page_22)]{#b02.xhtml#ind185}
17. [center positive plug, [22](#c02.xhtml#Page_22)]{#b02.xhtml#ind186}
18. [CERN Larger Hadron Collider, [120](#c07.xhtml#Page_120)]{#b02.xhtml#ind187}
19. [[`char`]{.Code-within-text} (characters), [150](#c07.xhtml#Page_150)]{#b02.xhtml#ind188}
20. [Cheat Sheet (website), [3](#c00.xhtml#Page_3)]{#b02.xhtml#ind189}
21. [chicken game, [174](#c08.xhtml#Page_174)--176]{#b02.xhtml#ind190}
22. [China, Arduino suppliers in, [364](#c16.xhtml#Page_364)]{#b02.xhtml#ind191}
23. [chips]{#b02.xhtml#ind192}
    1.  [ATmega 328 microcontroller chip, [19](#c02.xhtml#Page_19)--20, [23](#c02.xhtml#Page_23), [25](#c02.xhtml#Page_25), [108](#c06.xhtml#Page_108)]{#b02.xhtml#ind193}
    2.  [ATmega328P-PU chip, [40](#c03.xhtml#Page_40)]{#b02.xhtml#ind194}
    3.  [ATMEL chip, [40](#c03.xhtml#Page_40)]{#b02.xhtml#ind195}
    4.  [microcontroller chip, [7](#c01.xhtml#Page_7), [10](#c01.xhtml#Page_10)]{#b02.xhtml#ind196}
    5.  [plated-through hole (PTH) chip, [20](#c02.xhtml#Page_20)]{#b02.xhtml#ind197}
    6.  [surface mount device (SMD) chip, [20](#c02.xhtml#Page_20)]{#b02.xhtml#ind198}
24. [chocolate block (choc blocks), [203](#c09.xhtml#Page_203)]{#b02.xhtml#ind199}
25. [Chorus project, [163](#c08.xhtml#Page_163)--165]{#b02.xhtml#ind200}
26. [CIID (Copenhagen Institute of Interaction Design), [161](#c08.xhtml#Page_161), [163](#c08.xhtml#Page_163)]{#b02.xhtml#ind201}
27. [circuit bending, [13](#c01.xhtml#Page_13)--14]{#b02.xhtml#ind202}
28. [circuit diagrams]{#b02.xhtml#ind203}
    1.  [analog input and LED output, [266](#c11.xhtml#Page_266)]{#b02.xhtml#ind204}
    2.  [Arduino with LED connected to pin 13, [324](#c14.xhtml#Page_324)]{#b02.xhtml#ind205}
    3.  [button, [219](#c10.xhtml#Page_219)]{#b02.xhtml#ind206}
    4.  [electret mic, [282](#c11.xhtml#Page_282)]{#b02.xhtml#ind207}
    5.  [keyboard, [252](#c11.xhtml#Page_252)]{#b02.xhtml#ind208}
    6.  [knock sensor, [245](#c11.xhtml#Page_245)]{#b02.xhtml#ind209}
    7.  [LED in pin 13, [207](#c10.xhtml#Page_207)]{#b02.xhtml#ind210}
    8.  [light sensor circuit, [226](#c10.xhtml#Page_226), [232](#c10.xhtml#Page_232)]{#b02.xhtml#ind211}
    9.  [light-sensor controlled Theremin, [154](#c07.xhtml#Page_154)]{#b02.xhtml#ind212}
    10. [LV-EZO, [277](#c11.xhtml#Page_277)]{#b02.xhtml#ind213}
    11. [piezo buzzer circuit, [146](#c07.xhtml#Page_146)]{#b02.xhtml#ind214}
    12. [PIR sensor, [272](#c11.xhtml#Page_272)]{#b02.xhtml#ind215}
    13. [potentiometer input, [335](#c14.xhtml#Page_335)]{#b02.xhtml#ind216}
    14. [pushbutton circuit, [213](#c10.xhtml#Page_213), [240](#c11.xhtml#Page_240)]{#b02.xhtml#ind217}
    15. [servo and potentiometer, [139](#c07.xhtml#Page_139)]{#b02.xhtml#ind218}
    16. [servo circuit, [135](#c07.xhtml#Page_135)]{#b02.xhtml#ind219}
    17. [simple circuit diagrams, [76](#c05.xhtml#Page_76)--78]{#b02.xhtml#ind220}
    18. [transistor circuit, [123](#c07.xhtml#Page_123), [130](#c07.xhtml#Page_130)]{#b02.xhtml#ind221}
    19. [two analog inputs and one digital, [345](#c14.xhtml#Page_345)]{#b02.xhtml#ind222}
    20. [working with, [76](#c05.xhtml#Page_76)--79]{#b02.xhtml#ind223}
29. [circuit layouts]{#b02.xhtml#ind224}
    1.  [analog input and LED output, [266](#c11.xhtml#Page_266)]{#b02.xhtml#ind225}
    2.  [button, [219](#c10.xhtml#Page_219)]{#b02.xhtml#ind226}
    3.  [electret mic, [282](#c11.xhtml#Page_282)]{#b02.xhtml#ind227}
    4.  [keyboard, [252](#c11.xhtml#Page_252)]{#b02.xhtml#ind228}
    5.  [knock sensor, [245](#c11.xhtml#Page_245)]{#b02.xhtml#ind229}
    6.  [light sensor, [226](#c10.xhtml#Page_226), [232](#c10.xhtml#Page_232)]{#b02.xhtml#ind230}
    7.  [LV-EZO, [276](#c11.xhtml#Page_276)]{#b02.xhtml#ind231}
    8.  [PIR sensor, [271](#c11.xhtml#Page_271)]{#b02.xhtml#ind232}
    9.  [pushbutton, [213](#c10.xhtml#Page_213), [240](#c11.xhtml#Page_240)]{#b02.xhtml#ind233}
30. [circuits]{#b02.xhtml#ind234}
    1.  [based on chemical properties, [14](#c01.xhtml#Page_14)]{#b02.xhtml#ind235}
    2.  [braiding wire connectors, [203](#c09.xhtml#Page_203)]{#b02.xhtml#ind236}
    3.  [cleaning up, [201](#c09.xhtml#Page_201)]{#b02.xhtml#ind237}
    4.  [knowing, [199](#c09.xhtml#Page_199)]{#b02.xhtml#ind238}
    5.  [laying out, [199](#c09.xhtml#Page_199)--200]{#b02.xhtml#ind239}
    6.  [[]{#b02.xhtml#Page_370 .pagebreak role="doc-pagebreak" title="370"}preparing wire, [200](#c09.xhtml#Page_200)]{#b02.xhtml#ind241}
    7.  [prototyping of on breadboards, [58](#c04.xhtml#Page_58)]{#b02.xhtml#ind242}
    8.  [setting up, [198](#c09.xhtml#Page_198)--201]{#b02.xhtml#ind243}
    9.  [soldering, [200](#c09.xhtml#Page_200)--201]{#b02.xhtml#ind244}
    10. [testing your shield, [201](#c09.xhtml#Page_201)]{#b02.xhtml#ind245}
    11. [twisting wire connectors, [203](#c09.xhtml#Page_203)]{#b02.xhtml#ind246}
    12. [using equations to build, [71](#c05.xhtml#Page_71)--75]{#b02.xhtml#ind247}
    13. [using stripboard rather than PCB, [192](#c09.xhtml#Page_192)]{#b02.xhtml#ind248}
31. [clippers, [186](#c09.xhtml#Page_186), [190](#c09.xhtml#Page_190), [201](#c09.xhtml#Page_201)]{#b02.xhtml#ind249}
32. [cloud-based, [35](#c02.xhtml#Page_35)]{#b02.xhtml#ind250}
33. [code]{#b02.xhtml#ind251}
    1.  [ability to access USB for changes in, [202](#c09.xhtml#Page_202)]{#b02.xhtml#ind252}
    2.  [as case sensitive, [48](#c03.xhtml#Page_48)]{#b02.xhtml#ind253}
    3.  [using existing code for different hardware, [274](#c11.xhtml#Page_274)]{#b02.xhtml#ind254}
34. [code lines]{#b02.xhtml#ind255}
    1.  [AnalogInOutSerial sketch, [115](#c06.xhtml#Page_115)--116, [267](#c11.xhtml#Page_267)--268, [283](#c11.xhtml#Page_283)--284]{#b02.xhtml#ind256}
    2.  [AnalogInput sketch, [105](#c06.xhtml#Page_105)--106]{#b02.xhtml#ind257}
    3.  [Arduino Graph sketch, [336](#c14.xhtml#Page_336)--337]{#b02.xhtml#ind258}
    4.  [Arduino PhysicalPixel sketch, [326](#c14.xhtml#Page_326)--328]{#b02.xhtml#ind259}
    5.  [Arduino SerialCallResponse sketch, [346](#c14.xhtml#Page_346)--348]{#b02.xhtml#ind260}
    6.  [blinking better, [205](#c10.xhtml#Page_205)--206]{#b02.xhtml#ind261}
    7.  [BlinkWithoutDelay sketch, [208](#c10.xhtml#Page_208)--210]{#b02.xhtml#ind262}
    8.  [Button sketch, [101](#c06.xhtml#Page_101)]{#b02.xhtml#ind263}
    9.  [Calibration sketch, [233](#c10.xhtml#Page_233)--234]{#b02.xhtml#ind264}
    10. [CapPinSketch sketch, [259](#c11.xhtml#Page_259)--261]{#b02.xhtml#ind265}
    11. [checked for syntax errors, [125](#c07.xhtml#Page_125)]{#b02.xhtml#ind266}
    12. [clicking pushbutton, [222](#c10.xhtml#Page_222)--224]{#b02.xhtml#ind267}
    13. [comments, [46](#c03.xhtml#Page_46), [47](#c03.xhtml#Page_47)]{#b02.xhtml#ind268}
    14. [Debounce sketch, [214](#c10.xhtml#Page_214)--216]{#b02.xhtml#ind269}
    15. [[`delay`]{.Code-within-text} code, [51](#c03.xhtml#Page_51)]{#b02.xhtml#ind270}
    16. [DigitalInputPullup sketch, [241](#c11.xhtml#Page_241)--242]{#b02.xhtml#ind271}
    17. [DigitalReadSerial sketch, [111](#c06.xhtml#Page_111), [272](#c11.xhtml#Page_272)--273]{#b02.xhtml#ind272}
    18. [Fade sketch, [91](#c06.xhtml#Page_91)]{#b02.xhtml#ind273}
    19. [Fading, [95](#c06.xhtml#Page_95)]{#b02.xhtml#ind274}
    20. [Knob sketch, [140](#c07.xhtml#Page_140)]{#b02.xhtml#ind275}
    21. [Knock sketch, [246](#c11.xhtml#Page_246)--247]{#b02.xhtml#ind276}
    22. [[`loop`]{.Code-within-text} code, [50](#c03.xhtml#Page_50)]{#b02.xhtml#ind277}
    23. [[`for`]{.Code-within-text} loops, [96](#c06.xhtml#Page_96)]{#b02.xhtml#ind278}
    24. [MaxSonar sketch, [277](#c11.xhtml#Page_277)--278]{#b02.xhtml#ind279}
    25. [Motor sketch, [124](#c07.xhtml#Page_124)--125]{#b02.xhtml#ind280}
    26. [MotorControl sketch, [130](#c07.xhtml#Page_130)--131]{#b02.xhtml#ind281}
    27. [MotorSpeed sketch, [126](#c07.xhtml#Page_126)--127]{#b02.xhtml#ind282}
    28. [PitchFollower sketch, [155](#c07.xhtml#Page_155)]{#b02.xhtml#ind283}
    29. [Processing Graph sketch, [340](#c14.xhtml#Page_340)--341]{#b02.xhtml#ind284}
    30. [Processing SerialCallResponse sketch, [348](#c14.xhtml#Page_348)--350]{#b02.xhtml#ind285}
    31. [serial communication line, [117](#c06.xhtml#Page_117)]{#b02.xhtml#ind286}
    32. [Smoothing sketch, [227](#c10.xhtml#Page_227)--228, [229](#c10.xhtml#Page_229)--231]{#b02.xhtml#ind287}
    33. [StateChangeDetection sketch, [220](#c10.xhtml#Page_220)--221]{#b02.xhtml#ind288}
    34. [Sweep sketch, [135](#c07.xhtml#Page_135)--136]{#b02.xhtml#ind289}
    35. [toneKeyboard sketch, [253](#c11.xhtml#Page_253)--254]{#b02.xhtml#ind290}
    36. [toneMelody sketch, [144](#c07.xhtml#Page_144)--145]{#b02.xhtml#ind291}
    37. [updating [`ledState`]{.Code-within-text} variable, [212](#c10.xhtml#Page_212)]{#b02.xhtml#ind292}
    38. [virtual button sketch, [325](#c14.xhtml#Page_325)--326]{#b02.xhtml#ind293}
35. [coil of wire. *See* [electromagnets](#b02.xhtml#ind421)]{#b02.xhtml#ind294}
36. [color coding, [79](#c05.xhtml#Page_79)--80, [90](#c06.xhtml#Page_90)]{#b02.xhtml#ind295}
37. [color wheel, [342](#c14.xhtml#Page_342)]{#b02.xhtml#ind296}
38. [colors. *See also specific colors*]{#b02.xhtml#ind297}
    1.  [changing of in Processing, [317](#c13.xhtml#Page_317)--320]{#b02.xhtml#ind298}
    2.  [colored code represented by [`bold`]{.Code-within-text}, [94](#c06.xhtml#Page_94)]{#b02.xhtml#ind299}
    3.  [of core functions, [49](#c03.xhtml#Page_49)--50]{#b02.xhtml#ind300}
    4.  [of GND (ground), [80](#c05.xhtml#Page_80)]{#b02.xhtml#ind301}
    5.  [of insulated equipment wire, [61](#c04.xhtml#Page_61), [189](#c09.xhtml#Page_189)]{#b02.xhtml#ind302}
    6.  [of negative (-), [80](#c05.xhtml#Page_80)]{#b02.xhtml#ind303}
    7.  [of positive (+), [58](#c04.xhtml#Page_58), [80](#c05.xhtml#Page_80)]{#b02.xhtml#ind304}
    8.  [resistor color charts, [81](#c05.xhtml#Page_81)--83]{#b02.xhtml#ind305}
    9.  [of wires in servo motors, [134](#c07.xhtml#Page_134)]{#b02.xhtml#ind306}
39. [COM socket (Common), [63](#c04.xhtml#Page_63)]{#b02.xhtml#ind307}
40. [comments (section of code), [46](#c03.xhtml#Page_46)]{#b02.xhtml#ind308}
41. [common ground, [22](#c02.xhtml#Page_22)]{#b02.xhtml#ind309}
42. [community-contributed libraries, [302](#c12.xhtml#Page_302)]{#b02.xhtml#ind310}
43. [comparison symbol (! =), [217](#c10.xhtml#Page_217)]{#b02.xhtml#ind311}
44. [Compass Card system, [168](#c08.xhtml#Page_168)--171]{#b02.xhtml#ind312}
45. [Compass Lounge (National Maritime Museum, London), [168](#c08.xhtml#Page_168)]{#b02.xhtml#ind313}
46. [Compile button, [125](#c07.xhtml#Page_125)]{#b02.xhtml#ind314}
47. [compiler/compiling, [35](#c02.xhtml#Page_35)]{#b02.xhtml#ind315}
48. [[`Compiling Sketch`]{.Code-within-text} message, [42](#c03.xhtml#Page_42)]{#b02.xhtml#ind316}
49. [components and parts for Arduino, [363](#c16.xhtml#Page_363)--366]{#b02.xhtml#ind317}
50. [connector strips, [203](#c09.xhtml#Page_203)]{#b02.xhtml#ind318}
51. [constant integers ([`const)`]{.Code-within-text}, [107](#c06.xhtml#Page_107)]{#b02.xhtml#ind319}
52. [[`constrain`]{.Code-within-text} function, [236](#c10.xhtml#Page_236)]{#b02.xhtml#ind320}
53. [continuity, checking of, [67](#c04.xhtml#Page_67)]{#b02.xhtml#ind321}
54. [continuity test function, [198](#c09.xhtml#Page_198)]{#b02.xhtml#ind322}
55. [Cooking Hacks (supplier), [297](#c12.xhtml#Page_297)]{#b02.xhtml#ind323}
56. [[]{#b02.xhtml#Page_371 .pagebreak role="doc-pagebreak" title="371"}Copenhagen Institute of Interaction Design (CIID), [161](#c08.xhtml#Page_161), [163](#c08.xhtml#Page_163)]{#b02.xhtml#ind324}
57. [copper braid, [187](#c09.xhtml#Page_187)]{#b02.xhtml#ind325}
58. [copper brushes, [120](#c07.xhtml#Page_120)]{#b02.xhtml#ind326}
59. [core function, [49](#c03.xhtml#Page_49)]{#b02.xhtml#ind327}
60. [costs]{#b02.xhtml#ind328}
    1.  [of Arduino compared to Wiring board, [10](#c01.xhtml#Page_10)]{#b02.xhtml#ind329}
    2.  [beginner\'s kits, [31](#c02.xhtml#Page_31)]{#b02.xhtml#ind330}
    3.  [of sensors. *See* [sensors](#b02.xhtml#ind1092), [costs of](#b02.xhtml#ind1011)]{#b02.xhtml#ind331}
    4.  [of shields, [288](#c12.xhtml#Page_288)--297]{#b02.xhtml#ind332}
61. [counters, [207](#c10.xhtml#Page_207), [222](#c10.xhtml#Page_222)--224, [353](#c14.xhtml#Page_353), [355](#c14.xhtml#Page_355)]{#b02.xhtml#ind333}
62. [crocodile clips, [63](#c04.xhtml#Page_63), [184](#c09.xhtml#Page_184), [195](#c09.xhtml#Page_195), [258](#c11.xhtml#Page_258)]{#b02.xhtml#ind334}
63. [Cuartielles, David (developer), [9](#c01.xhtml#Page_9)]{#b02.xhtml#ind335}
64. [curly brackets/braces {}, [48](#c03.xhtml#Page_48), [150](#c07.xhtml#Page_150)]{#b02.xhtml#ind336}
65. [current]{#b02.xhtml#ind337}
    1.  [flow of, [70](#c05.xhtml#Page_70)]{#b02.xhtml#ind338}
    2.  [measuring of in a circuit, [64](#c04.xhtml#Page_64)--65]{#b02.xhtml#ind339}
66. [Cycling 74 (software company), [308](#c13.xhtml#Page_308)]{#b02.xhtml#ind340}
:::

::: {.section}
## D {.Heading-1}

1.  [[`darkValue`]{.Code-within-text}, [206](#c10.xhtml#Page_206)]{#b02.xhtml#ind342}
2.  [data transfer, cutting costs of, [170](#c08.xhtml#Page_170)]{#b02.xhtml#ind343}
3.  [datasheets, [80](#c05.xhtml#Page_80)--81]{#b02.xhtml#ind344}
4.  [DC motors, [31](#c02.xhtml#Page_31), [121](#c07.xhtml#Page_121)--126, [294](#c12.xhtml#Page_294)]{#b02.xhtml#ind345}
5.  [DC voltage, [64](#c04.xhtml#Page_64)]{#b02.xhtml#ind346}
6.  [Debounce sketch, [212](#c10.xhtml#Page_212)--218]{#b02.xhtml#ind347}
7.  [debugging, [114](#c06.xhtml#Page_114)]{#b02.xhtml#ind348}
8.  [Dechamps-Sonsino, Alexandra (developer), [171](#c08.xhtml#Page_171)--173]{#b02.xhtml#ind349}
9.  [decimal number system, [318](#c13.xhtml#Page_318)]{#b02.xhtml#ind350}
10. [declarations, [91](#c06.xhtml#Page_91), [92](#c06.xhtml#Page_92)]{#b02.xhtml#ind351}
11. [[`define`]{.Code-within-text} function, [151](#c07.xhtml#Page_151)]{#b02.xhtml#ind352}
12. [degrees of freedom sensors, [166](#c08.xhtml#Page_166)]{#b02.xhtml#ind353}
13. [[`delay`]{.Code-within-text} function, [51](#c03.xhtml#Page_51)]{#b02.xhtml#ind354}
14. [de-soldering, [182](#c09.xhtml#Page_182), [187](#c09.xhtml#Page_187)]{#b02.xhtml#ind355}
15. [de-soldering wire, [187](#c09.xhtml#Page_187)]{#b02.xhtml#ind356}
16. [diagrams, circuit]{#b02.xhtml#ind357}
    1.  [analog input and LED output, [266](#c11.xhtml#Page_266)]{#b02.xhtml#ind358}
    2.  [Arduino with LED connected to pin 13, [324](#c14.xhtml#Page_324)]{#b02.xhtml#ind359}
    3.  [button, [219](#c10.xhtml#Page_219)]{#b02.xhtml#ind360}
    4.  [electret mic, [282](#c11.xhtml#Page_282)]{#b02.xhtml#ind361}
    5.  [keyboard, [252](#c11.xhtml#Page_252)]{#b02.xhtml#ind362}
    6.  [knock sensor, [245](#c11.xhtml#Page_245)]{#b02.xhtml#ind363}
    7.  [LED in pin 13, [207](#c10.xhtml#Page_207)]{#b02.xhtml#ind364}
    8.  [light sensor circuit, [226](#c10.xhtml#Page_226), [232](#c10.xhtml#Page_232)]{#b02.xhtml#ind365}
    9.  [light-sensor controlled Theremin, [154](#c07.xhtml#Page_154)]{#b02.xhtml#ind366}
    10. [LV-EZO, [277](#c11.xhtml#Page_277)]{#b02.xhtml#ind367}
    11. [piezo buzzer circuit, [146](#c07.xhtml#Page_146)]{#b02.xhtml#ind368}
    12. [PIR sensor, [272](#c11.xhtml#Page_272)]{#b02.xhtml#ind369}
    13. [potentiometer input, [335](#c14.xhtml#Page_335)]{#b02.xhtml#ind370}
    14. [pushbutton circuit, [213](#c10.xhtml#Page_213), [240](#c11.xhtml#Page_240)]{#b02.xhtml#ind371}
    15. [servo and potentiometer, [139](#c07.xhtml#Page_139)]{#b02.xhtml#ind372}
    16. [servo circuit, [135](#c07.xhtml#Page_135)]{#b02.xhtml#ind373}
    17. [simple circuit diagrams, [76](#c05.xhtml#Page_76)--78]{#b02.xhtml#ind374}
    18. [transistor circuit, [123](#c07.xhtml#Page_123), [130](#c07.xhtml#Page_130)]{#b02.xhtml#ind375}
    19. [two analog inputs and one digital, [345](#c14.xhtml#Page_345)]{#b02.xhtml#ind376}
    20. [working with, [76](#c05.xhtml#Page_76)--79]{#b02.xhtml#ind377}
17. [Diecimila (Arduino board), [19](#c02.xhtml#Page_19)]{#b02.xhtml#ind378}
18. [Digi-Key (supplier), [29](#c02.xhtml#Page_29), [202](#c09.xhtml#Page_202), [365](#c16.xhtml#Page_365)]{#b02.xhtml#ind379}
19. [digital display, on multimeter, [62](#c04.xhtml#Page_62)]{#b02.xhtml#ind380}
20. [digital multimeter, [62](#c04.xhtml#Page_62)]{#b02.xhtml#ind381}
21. [digital music services, [161](#c08.xhtml#Page_161)]{#b02.xhtml#ind382}
22. [digital pins, [20](#c02.xhtml#Page_20), [21](#c02.xhtml#Page_21), [50](#c03.xhtml#Page_50)]{#b02.xhtml#ind383}
23. [digital signals, [20](#c02.xhtml#Page_20), [280](#c11.xhtml#Page_280)]{#b02.xhtml#ind384}
24. [digital sketchbook, [9](#c01.xhtml#Page_9), [10](#c01.xhtml#Page_10)]{#b02.xhtml#ind385}
25. [DigitalInputPullup sketch, [239](#c11.xhtml#Page_239)--243]{#b02.xhtml#ind386}
26. [[`digitalRead`]{.Code-within-text} function, [101](#c06.xhtml#Page_101)]{#b02.xhtml#ind387}
27. [DigitalReadSerial sketch]{#b02.xhtml#ind388}
    1.  [implementing, [270](#c11.xhtml#Page_270)--273]{#b02.xhtml#ind389}
    2.  [setting up, [109](#c06.xhtml#Page_109)--112]{#b02.xhtml#ind390}
    3.  [understanding, [112](#c06.xhtml#Page_112)--113, [273](#c11.xhtml#Page_273)--274]{#b02.xhtml#ind391}
28. [[`digitalWrite`]{.Code-within-text} function, [50](#c03.xhtml#Page_50)--51, [212](#c10.xhtml#Page_212), [235](#c10.xhtml#Page_235), [248](#c11.xhtml#Page_248)]{#b02.xhtml#ind392}
29. [dimmer circuit, [114](#c06.xhtml#Page_114), [201](#c09.xhtml#Page_201)]{#b02.xhtml#ind393}
30. [dimmer switch, [103](#c06.xhtml#Page_103)]{#b02.xhtml#ind394}
31. [diodes, [30](#c02.xhtml#Page_30), [121](#c07.xhtml#Page_121), [122](#c07.xhtml#Page_122), [125](#c07.xhtml#Page_125)]{#b02.xhtml#ind395}
32. [distance, measuring, [274](#c11.xhtml#Page_274)--280]{#b02.xhtml#ind396}
33. [distributors. *See* [suppliers](#b02.xhtml#ind1248)]{#b02.xhtml#ind397}
34. [[`Done Compiling`]{.Code-within-text} message, [42](#c03.xhtml#Page_42)]{#b02.xhtml#ind398}
35. [[`Done Uploading`]{.Code-within-text} message, [42](#c03.xhtml#Page_42)]{#b02.xhtml#ind399}
36. [double forward slash (//), [47](#c03.xhtml#Page_47)]{#b02.xhtml#ind400}
37. [Drain (Collector), [124](#c07.xhtml#Page_124)]{#b02.xhtml#ind401}
38. [[`draw`]{.Code-within-text} function, [329](#c14.xhtml#Page_329)]{#b02.xhtml#ind402}
39. [Duemilanove (board), [19](#c02.xhtml#Page_19)]{#b02.xhtml#ind403}
40. [duty cycle, [87](#c06.xhtml#Page_87)]{#b02.xhtml#ind404}
41. [dynamos, [121](#c07.xhtml#Page_121)]{#b02.xhtml#ind405}
42. [Dziekan, Vince (designer), [165](#c08.xhtml#Page_165)]{#b02.xhtml#ind406}
:::

::: {.section}
## E {.Heading-1}

1.  [[]{#b02.xhtml#Page_372 .pagebreak role="doc-pagebreak" title="372"}eBay (supplier), [29](#c02.xhtml#Page_29), [365](#c16.xhtml#Page_365)]{#b02.xhtml#ind408}
2.  [EEPROM library, [299](#c12.xhtml#Page_299)]{#b02.xhtml#ind409}
3.  [electret microphone, [280](#c11.xhtml#Page_280)--281]{#b02.xhtml#ind410}
4.  [electric generators, [121](#c07.xhtml#Page_121)]{#b02.xhtml#ind411}
5.  [electric motors]{#b02.xhtml#ind412}
    1.  [as components in beginner\'s kit, [31](#c02.xhtml#Page_31)]{#b02.xhtml#ind413}
    2.  [DC motors. *See* [DC motors](#b02.xhtml#ind345)]{#b02.xhtml#ind414}
    3.  [diagram of, [120](#c07.xhtml#Page_120)]{#b02.xhtml#ind415}
    4.  [transistor circuit to drive, [129](#c07.xhtml#Page_129)]{#b02.xhtml#ind416}
    5.  [working with, [119](#c07.xhtml#Page_119)--121]{#b02.xhtml#ind417}
6.  [electric signals, [20](#c02.xhtml#Page_20)]{#b02.xhtml#ind418}
7.  [electricity, [69](#c05.xhtml#Page_69)--71]{#b02.xhtml#ind419}
8.  [electromagnetic field, [119](#c07.xhtml#Page_119), [255](#c11.xhtml#Page_255)]{#b02.xhtml#ind420}
9.  [electromagnets, [31](#c02.xhtml#Page_31), [119](#c07.xhtml#Page_119), [120](#c07.xhtml#Page_120)]{#b02.xhtml#ind421}
10. [electronics]{#b02.xhtml#ind422}
    1.  [disposal of materials, [183](#c09.xhtml#Page_183)]{#b02.xhtml#ind423}
    2.  [overview, [14](#c01.xhtml#Page_14)--15]{#b02.xhtml#ind424}
    3.  [preparation of workspace for, [32](#c02.xhtml#Page_32)--33]{#b02.xhtml#ind425}
    4.  [schools of thought around, [11](#c01.xhtml#Page_11)--14]{#b02.xhtml#ind426}
11. [electronics distributors, [28](#c02.xhtml#Page_28)--29]{#b02.xhtml#ind427}
12. [*Electronics For Dummies* (Shamieh), [70](#c05.xhtml#Page_70)]{#b02.xhtml#ind428}
13. [electronics wire, [189](#c09.xhtml#Page_189)]{#b02.xhtml#ind429}
14. [Element14 (distributor), [365](#c16.xhtml#Page_365)]{#b02.xhtml#ind430}
15. [ellipse, [316](#c13.xhtml#Page_316)--317]{#b02.xhtml#ind431}
16. [[`ellipse`]{.Code-within-text} statement, [312](#c13.xhtml#Page_312)]{#b02.xhtml#ind432}
17. [enclosures, [202](#c09.xhtml#Page_202)--203]{#b02.xhtml#ind433}
18. [encoder, [132](#c07.xhtml#Page_132)]{#b02.xhtml#ind434}
19. [equations, for building circuits, [71](#c05.xhtml#Page_71)--75]{#b02.xhtml#ind435}
20. [equipment wire, [60](#c04.xhtml#Page_60), [189](#c09.xhtml#Page_189), [200](#c09.xhtml#Page_200)]{#b02.xhtml#ind436}
21. [e-textiles, [26](#c02.xhtml#Page_26)]{#b02.xhtml#ind437}
22. [Ethernet library, [299](#c12.xhtml#Page_299)]{#b02.xhtml#ind438}
23. [Ethernet shield, [168](#c08.xhtml#Page_168), [170](#c08.xhtml#Page_170)]{#b02.xhtml#ind439}
24. [European Union Waste Electrical and Electronic Equipment Directive (WEEE), [183](#c09.xhtml#Page_183)]{#b02.xhtml#ind440}
25. [external supply jack/external power jack, [22](#c02.xhtml#Page_22)--23, [202](#c09.xhtml#Page_202)]{#b02.xhtml#ind441}
26. [eye protection, [190](#c09.xhtml#Page_190)]{#b02.xhtml#ind442}
:::

::: {.section}
## F {.Heading-1}

1.  [[`fadeAmount`]{.Code-within-text} variable, [92](#c06.xhtml#Page_92)]{#b02.xhtml#ind444}
2.  [[`fadeValue`]{.Code-within-text} variable, [96](#c06.xhtml#Page_96)]{#b02.xhtml#ind445}
3.  [Farnell (electronics distributor), [29](#c02.xhtml#Page_29), [202](#c09.xhtml#Page_202), [365](#c16.xhtml#Page_365)]{#b02.xhtml#ind446}
4.  [file extensions, naming, [325](#c14.xhtml#Page_325)]{#b02.xhtml#ind447}
5.  [fill, [319](#c13.xhtml#Page_319)--320]{#b02.xhtml#ind448}
6.  [Fio (board), [24](#c02.xhtml#Page_24)]{#b02.xhtml#ind449}
7.  [Firmata library, [299](#c12.xhtml#Page_299)]{#b02.xhtml#ind450}
8.  [Fitzsimmons, Duncan (cofounder Vitamins Design Ltd.), [165](#c08.xhtml#Page_165)]{#b02.xhtml#ind451}
9.  [fixed resistors, [30](#c02.xhtml#Page_30)]{#b02.xhtml#ind452}
10. [fixed-temperature soldering iron, [179](#c09.xhtml#Page_179)--180]{#b02.xhtml#ind453}
11. [Flap to Freedom game, [174](#c08.xhtml#Page_174)--176]{#b02.xhtml#ind454}
12. [float (floating-point numbers), [261](#c11.xhtml#Page_261), [329](#c14.xhtml#Page_329)]{#b02.xhtml#ind455}
13. [[`float`]{.Code-within-text} (floating-point numbers), [150](#c07.xhtml#Page_150)]{#b02.xhtml#ind456}
14. [flux-cored solder/flux, [183](#c09.xhtml#Page_183)]{#b02.xhtml#ind457}
15. [FM radio module, [162](#c08.xhtml#Page_162)]{#b02.xhtml#ind458}
16. [footprint, [25](#c02.xhtml#Page_25)]{#b02.xhtml#ind459}
17. [[`for`]{.Code-within-text} loops, [96](#c06.xhtml#Page_96), [128](#c07.xhtml#Page_128), [137](#c07.xhtml#Page_137), [151](#c07.xhtml#Page_151), [152](#c07.xhtml#Page_152), [229](#c10.xhtml#Page_229), [255](#c11.xhtml#Page_255)]{#b02.xhtml#ind460}
18. [force sensors, [249](#c11.xhtml#Page_249)--251]{#b02.xhtml#ind461}
19. [forums]{#b02.xhtml#ind462}
    1.  [Arduino, [15](#c01.xhtml#Page_15), [361](#c15.xhtml#Page_361)]{#b02.xhtml#ind463}
    2.  [in general, [16](#c01.xhtml#Page_16), [291](#c12.xhtml#Page_291)]{#b02.xhtml#ind464}
20. [forward slash asterisk (/\*), [46](#c03.xhtml#Page_46)]{#b02.xhtml#ind465}
21. [forward voltage, [73](#c05.xhtml#Page_73), [89](#c06.xhtml#Page_89)]{#b02.xhtml#ind466}
22. [frequency, [63](#c04.xhtml#Page_63)]{#b02.xhtml#ind467}
23. [friction, [59](#c04.xhtml#Page_59)]{#b02.xhtml#ind468}
24. [Fried, Limor (Ladyada) (Adafruit founder), [27](#c02.xhtml#Page_27)]{#b02.xhtml#ind469}
25. [Fry, Ben (developer), [9](#c01.xhtml#Page_9), [306](#c13.xhtml#Page_306)]{#b02.xhtml#ind470}
26. [functions]{#b02.xhtml#ind471}
    1.  [about, [47](#c03.xhtml#Page_47)--48]{#b02.xhtml#ind472}
    2.  [[`analogRead`]{.Code-within-text}, [107](#c06.xhtml#Page_107), [230](#c10.xhtml#Page_230)]{#b02.xhtml#ind473}
    3.  [[`analogWrite`]{.Code-within-text}, [91](#c06.xhtml#Page_91), [118](#c06.xhtml#Page_118), [128](#c07.xhtml#Page_128), [236](#c10.xhtml#Page_236)]{#b02.xhtml#ind474}
    4.  [[`constrain`]{.Code-within-text}, [236](#c10.xhtml#Page_236)]{#b02.xhtml#ind475}
    5.  [continuity test, [198](#c09.xhtml#Page_198)]{#b02.xhtml#ind476}
    6.  [core, [49](#c03.xhtml#Page_49)]{#b02.xhtml#ind477}
    7.  [[`define`]{.Code-within-text}, [151](#c07.xhtml#Page_151)]{#b02.xhtml#ind478}
    8.  [[`delay`]{.Code-within-text}, [51](#c03.xhtml#Page_51)]{#b02.xhtml#ind479}
    9.  [[`digitalRead`]{.Code-within-text}, [101](#c06.xhtml#Page_101)]{#b02.xhtml#ind480}
    10. [[`digitalWrite`]{.Code-within-text}, [50](#c03.xhtml#Page_50)--51, [212](#c10.xhtml#Page_212), [235](#c10.xhtml#Page_235), [248](#c11.xhtml#Page_248)]{#b02.xhtml#ind481}
    11. [[`draw`]{.Code-within-text}, [329](#c14.xhtml#Page_329)]{#b02.xhtml#ind482}
    12. [[`# include`]{.Code-within-text}, [147](#c07.xhtml#Page_147)]{#b02.xhtml#ind483}
    13. [[`loop`]{.Code-within-text}, [47](#c03.xhtml#Page_47), [50](#c03.xhtml#Page_50), [93](#c06.xhtml#Page_93), [96](#c06.xhtml#Page_96), [217](#c10.xhtml#Page_217), [263](#c11.xhtml#Page_263), [274](#c11.xhtml#Page_274), [279](#c11.xhtml#Page_279)]{#b02.xhtml#ind484}
    14. [[`map`]{.Code-within-text}, [117](#c06.xhtml#Page_117), [157](#c07.xhtml#Page_157), [236](#c10.xhtml#Page_236), [268](#c11.xhtml#Page_268)]{#b02.xhtml#ind485}
    15. [[`millis`]{.Code-within-text}, [211](#c10.xhtml#Page_211), [235](#c10.xhtml#Page_235), [262](#c11.xhtml#Page_262), [263](#c11.xhtml#Page_263)]{#b02.xhtml#ind486}
    16. [[`noTone`]{.Code-within-text}, [152](#c07.xhtml#Page_152)]{#b02.xhtml#ind487}
    17. [[`pulseIn`]{.Code-within-text}, [279](#c11.xhtml#Page_279)]{#b02.xhtml#ind488}
    18. [[`.readPin`]{.Code-within-text}, [262](#c11.xhtml#Page_262)]{#b02.xhtml#ind489}
    19. [[`setup`]{.Code-within-text}, [48](#c03.xhtml#Page_48)--49, [92](#c06.xhtml#Page_92), [263](#c11.xhtml#Page_263), [279](#c11.xhtml#Page_279)]{#b02.xhtml#ind490}
    20. [smoothing, [263](#c11.xhtml#Page_263)]{#b02.xhtml#ind491}
    21. [tone, [157](#c07.xhtml#Page_157)]{#b02.xhtml#ind492}
    22. [[`void loop`]{.Code-within-text}, [48](#c03.xhtml#Page_48)]{#b02.xhtml#ind493}
27. [Fun-Tak (adhesive putty), [184](#c09.xhtml#Page_184)]{#b02.xhtml#ind494}
:::

::: {.section}
## G {.Heading-1}

1.  [Gaggero, Clara (cofounder Vitamins Design Ltd.), [165](#c08.xhtml#Page_165)]{#b02.xhtml#ind496}
2.  [game controller, [293](#c12.xhtml#Page_293)]{#b02.xhtml#ind497}
3.  [Gate (Base), [124](#c07.xhtml#Page_124)]{#b02.xhtml#ind498}
4.  [Geiger counter - radiation sensor board shield, [297](#c12.xhtml#Page_297)]{#b02.xhtml#ind499}
5.  [GitHub, [257](#c11.xhtml#Page_257), [302](#c12.xhtml#Page_302)]{#b02.xhtml#ind500}
6.  [global variables, [211](#c10.xhtml#Page_211)]{#b02.xhtml#ind501}
7.  [GND (ground), [22](#c02.xhtml#Page_22), [52](#c03.xhtml#Page_52), [80](#c05.xhtml#Page_80)]{#b02.xhtml#ind502}
8.  [Good Night Lamp project, [171](#c08.xhtml#Page_171)--173]{#b02.xhtml#ind503}
9.  [Google]{#b02.xhtml#ind504}
    1.  [Arduino workshops, [362](#c15.xhtml#Page_362)]{#b02.xhtml#ind505}
    2.  [datasheets, [80](#c05.xhtml#Page_80)--81]{#b02.xhtml#ind506}
    3.  [transistor product numbers, [124](#c07.xhtml#Page_124)]{#b02.xhtml#ind507}
    4.  [XBee Wireless Module info, [162](#c08.xhtml#Page_162)]{#b02.xhtml#ind508}
10. [Google Code, [289](#c12.xhtml#Page_289), [302](#c12.xhtml#Page_302)]{#b02.xhtml#ind509}
11. [graph, drawing, [334](#c14.xhtml#Page_334)--344]{#b02.xhtml#ind510}
12. [graphical user interface (GUI), [9](#c01.xhtml#Page_9), [34](#c02.xhtml#Page_34), [35](#c02.xhtml#Page_35)--36]{#b02.xhtml#ind511}
13. [ground rail, [58](#c04.xhtml#Page_58)]{#b02.xhtml#ind512}
:::

::: {.section}
## H {.Heading-1}

1.  [Hack A Day website, [298](#c12.xhtml#Page_298), [360](#c15.xhtml#Page_360)]{#b02.xhtml#ind514}
2.  [hackerspaces, [361](#c15.xhtml#Page_361)]{#b02.xhtml#ind515}
3.  [hacking, [12](#c01.xhtml#Page_12)--13]{#b02.xhtml#ind516}
4.  [hacking existing toys, [175](#c08.xhtml#Page_175)]{#b02.xhtml#ind517}
5.  [header pins, [194](#c09.xhtml#Page_194)--195]{#b02.xhtml#ind518}
6.  [header sockets, [20](#c02.xhtml#Page_20)--21]{#b02.xhtml#ind519}
7.  [hertz (Hz), [63](#c04.xhtml#Page_63)]{#b02.xhtml#ind520}
8.  [hobby motors, [121](#c07.xhtml#Page_121)]{#b02.xhtml#ind521}
9.  [hobby servo, [133](#c07.xhtml#Page_133)]{#b02.xhtml#ind522}
10. [home printer project, [173](#c08.xhtml#Page_173)--174]{#b02.xhtml#ind523}
11. [hot air gun, [182](#c09.xhtml#Page_182)]{#b02.xhtml#ind524}
12. [hot glue, [204](#c09.xhtml#Page_204)]{#b02.xhtml#ind525}
13. [Hz (hertz), [63](#c04.xhtml#Page_63)]{#b02.xhtml#ind526}
:::

::: {.section}
## I {.Heading-1}

1.  [I (amperes), [71](#c05.xhtml#Page_71)]{#b02.xhtml#ind528}
2.  [I^2^C (eye-squared-see/eye-two-see) (communication protocol), use of to communicate with shield, [292](#c12.xhtml#Page_292)]{#b02.xhtml#ind529}
3.  [IC (integrated circuit), [19](#c02.xhtml#Page_19), [59](#c04.xhtml#Page_59), [199](#c09.xhtml#Page_199)]{#b02.xhtml#ind530}
4.  [ICO (design consultancy), [174](#c08.xhtml#Page_174), [176](#c08.xhtml#Page_176)]{#b02.xhtml#ind531}
5.  [icons, explained, [2](#c00.xhtml#Page_2)--3]{#b02.xhtml#ind532}
6.  [ICSP (In-Circuit Serial Programming) connector, [194](#c09.xhtml#Page_194)]{#b02.xhtml#ind533}
7.  [IDE (integrated development environment), [33](#c02.xhtml#Page_33), [34](#c02.xhtml#Page_34), [306](#c13.xhtml#Page_306), [310](#c13.xhtml#Page_310)]{#b02.xhtml#ind534}
8.  [IDII (Interaction Design Institute Ivera), [8](#c01.xhtml#Page_8)]{#b02.xhtml#ind535}
9.  [[`if`]{.Code-within-text} loop, [206](#c10.xhtml#Page_206)]{#b02.xhtml#ind536}
10. [[`if`]{.Code-within-text} statements, [93](#c06.xhtml#Page_93)--94, [101](#c06.xhtml#Page_101), [108](#c06.xhtml#Page_108), [211](#c10.xhtml#Page_211), [217](#c10.xhtml#Page_217), [223](#c10.xhtml#Page_223), [230](#c10.xhtml#Page_230), [242](#c11.xhtml#Page_242), [331](#c14.xhtml#Page_331)]{#b02.xhtml#ind537}
11. [Import Library drop-down list, [301](#c12.xhtml#Page_301)]{#b02.xhtml#ind538}
12. [IMU (inertial measurement units), [166](#c08.xhtml#Page_166)]{#b02.xhtml#ind539}
13. [In-Circuit Serial Programming (ICSP) connector, [194](#c09.xhtml#Page_194)]{#b02.xhtml#ind540}
14. [[`# include`]{.Code-within-text} function, [147](#c07.xhtml#Page_147)]{#b02.xhtml#ind541}
15. [index, [228](#c10.xhtml#Page_228)]{#b02.xhtml#ind542}
16. [inertial measurement units (IMU), [166](#c08.xhtml#Page_166)]{#b02.xhtml#ind543}
17. [infinity symbol, as sign of official Arduino board, [24](#c02.xhtml#Page_24)]{#b02.xhtml#ind544}
18. [infrared (IR) proximity sensor, [274](#c11.xhtml#Page_274)--275]{#b02.xhtml#ind545}
19. [ino (naming convention), [16](#c01.xhtml#Page_16), [325](#c14.xhtml#Page_325)]{#b02.xhtml#ind546}
20. [[`inputPin`]{.Code-within-text} variable, [229](#c10.xhtml#Page_229)]{#b02.xhtml#ind547}
21. [inputs]{#b02.xhtml#ind548}
    1.  [[`buttonPin`]{.Code-within-text} (pin 2) as, [100](#c06.xhtml#Page_100)--101]{#b02.xhtml#ind549}
    2.  [calibrating, [231](#c10.xhtml#Page_231)--236]{#b02.xhtml#ind550}
    3.  [described, [15](#c01.xhtml#Page_15)]{#b02.xhtml#ind551}
    4.  [fixing of to enclosure, [202](#c09.xhtml#Page_202)]{#b02.xhtml#ind552}
22. [Instructables (documentation platform), [361](#c15.xhtml#Page_361)]{#b02.xhtml#ind553}
23. [instruments, making, [153](#c07.xhtml#Page_153)--157]{#b02.xhtml#ind554}
24. [insulated equipment wire, [60](#c04.xhtml#Page_60)]{#b02.xhtml#ind555}
25. [[`int`]{.Code-within-text} (integers), [150](#c07.xhtml#Page_150), [210](#c10.xhtml#Page_210)]{#b02.xhtml#ind556}
26. [integer variables, [92](#c06.xhtml#Page_92)--94]{#b02.xhtml#ind557}
27. [integrated circuit (IC), [19](#c02.xhtml#Page_19), [59](#c04.xhtml#Page_59), [199](#c09.xhtml#Page_199)]{#b02.xhtml#ind558}
28. [integrated development environment (IDE), [33](#c02.xhtml#Page_33), [34](#c02.xhtml#Page_34), [306](#c13.xhtml#Page_306), [310](#c13.xhtml#Page_310)]{#b02.xhtml#ind559}
29. [interaction, playing with, [320](#c13.xhtml#Page_320)--322]{#b02.xhtml#ind560}
30. [interaction design, [8](#c01.xhtml#Page_8)]{#b02.xhtml#ind561}
31. [Interaction Design Institute Ivera (IDII), [8](#c01.xhtml#Page_8)]{#b02.xhtml#ind562}
32. [interactive Arduino project, Button sketch as, [100](#c06.xhtml#Page_100)]{#b02.xhtml#ind563}
33. [[`interval`]{.Code-within-text} variable, [210](#c10.xhtml#Page_210)]{#b02.xhtml#ind564}
34. [Inventor\'s Kit by SparkFun, [31](#c02.xhtml#Page_31)]{#b02.xhtml#ind565}
35. [[]{#b02.xhtml#Page_374 .pagebreak role="doc-pagebreak" title="374"}iOS, OpenFrameworks, [310](#c13.xhtml#Page_310)]{#b02.xhtml#ind566}
36. [IR (infrared) proximity sensor, [274](#c11.xhtml#Page_274)--275]{#b02.xhtml#ind567}
37. [Ivera (Italian king), [9](#c01.xhtml#Page_9)]{#b02.xhtml#ind568}
:::

::: {.section}
## J {.Heading-1}

1.  [Japan, use of Radiation Sensor Board in, [297](#c12.xhtml#Page_297)]{#b02.xhtml#ind570}
2.  [Java (programming language), [306](#c13.xhtml#Page_306)]{#b02.xhtml#ind571}
3.  [Joule, James Prescott (physicist), [74](#c05.xhtml#Page_74)]{#b02.xhtml#ind572}
4.  [Joule\'s Law, [74](#c05.xhtml#Page_74)--75]{#b02.xhtml#ind573}
5.  [joystick shield, [286](#c12.xhtml#Page_286), [293](#c12.xhtml#Page_293)--294]{#b02.xhtml#ind574}
6.  [jump wires, [58](#c04.xhtml#Page_58), [59](#c04.xhtml#Page_59)--61]{#b02.xhtml#ind575}
:::

::: {.section}
## K {.Heading-1}

1.  [keyboards, [12](#c01.xhtml#Page_12), [25](#c02.xhtml#Page_25), [251](#c11.xhtml#Page_251), [252](#c11.xhtml#Page_252), [356](#c14.xhtml#Page_356)]{#b02.xhtml#ind577}
2.  [Kin (design studio), [168](#c08.xhtml#Page_168), [171](#c08.xhtml#Page_171)]{#b02.xhtml#ind578}
3.  [kinetic installations, Chorus, [163](#c08.xhtml#Page_163)--165]{#b02.xhtml#ind579}
4.  [kits]{#b02.xhtml#ind580}
    1.  [Adafruit FONA 800 shield, [296](#c12.xhtml#Page_296)--297]{#b02.xhtml#ind581}
    2.  [Adafruit motor/stepper/servo shield Kit v2.3, [294](#c12.xhtml#Page_294)--295]{#b02.xhtml#ind582}
    3.  [Arduino proto kit, [191](#c09.xhtml#Page_191)]{#b02.xhtml#ind583}
    4.  [Arduino Starter Kit, [31](#c02.xhtml#Page_31)]{#b02.xhtml#ind584}
    5.  [beginner\'s, [29](#c02.xhtml#Page_29)--32]{#b02.xhtml#ind585}
    6.  [Inventor\'s Kit by SparkFun, [31](#c02.xhtml#Page_31)]{#b02.xhtml#ind586}
    7.  [proto shield kit, [191](#c09.xhtml#Page_191)]{#b02.xhtml#ind587}
    8.  [Proto shield kit Rev3, [288](#c12.xhtml#Page_288)--289]{#b02.xhtml#ind588}
    9.  [Proto-PIC Boffin Kit, [31](#c02.xhtml#Page_31)]{#b02.xhtml#ind589}
    10. [ProtoSnap kit, [26](#c02.xhtml#Page_26)]{#b02.xhtml#ind590}
    11. [Start Kit for Arduino (ARDX), [31](#c02.xhtml#Page_31)]{#b02.xhtml#ind591}
    12. [TinkerKit, [364](#c16.xhtml#Page_364)]{#b02.xhtml#ind592}
    13. [Ultimate GPS logger shield, [295](#c12.xhtml#Page_295)--296]{#b02.xhtml#ind593}
5.  [Knob sketch, [138](#c07.xhtml#Page_138)--142]{#b02.xhtml#ind594}
6.  [knock sensor, [243](#c11.xhtml#Page_243)--249]{#b02.xhtml#ind595}
7.  [Knock sketch, [244](#c11.xhtml#Page_244)--249]{#b02.xhtml#ind596}
:::

::: {.section}
## L {.Heading-1}

1.  [L LED, [23](#c02.xhtml#Page_23), [44](#c03.xhtml#Page_44)]{#b02.xhtml#ind598}
2.  [languages, programming]{#b02.xhtml#ind599}
    1.  [C, [44](#c03.xhtml#Page_44), [306](#c13.xhtml#Page_306)]{#b02.xhtml#ind600}
    2.  [C++, [306](#c13.xhtml#Page_306), [310](#c13.xhtml#Page_310)]{#b02.xhtml#ind601}
    3.  [Java, [306](#c13.xhtml#Page_306)]{#b02.xhtml#ind602}
    4.  [Max/MSP, [162](#c08.xhtml#Page_162), [308](#c13.xhtml#Page_308)]{#b02.xhtml#ind603}
    5.  [Max/Pure Data, [307](#c13.xhtml#Page_307)]{#b02.xhtml#ind604}
    6.  [openFrameworks, [175](#c08.xhtml#Page_175)]{#b02.xhtml#ind605}
    7.  [OpenFrameworks, [307](#c13.xhtml#Page_307), [310](#c13.xhtml#Page_310)]{#b02.xhtml#ind606}
    8.  [PureData, [308](#c13.xhtml#Page_308)]{#b02.xhtml#ind607}
3.  [laser pens, [264](#c11.xhtml#Page_264)]{#b02.xhtml#ind608}
4.  [laser pointers, [264](#c11.xhtml#Page_264)]{#b02.xhtml#ind609}
5.  [laser trip wires, [264](#c11.xhtml#Page_264)--265]{#b02.xhtml#ind610}
6.  [lasers, tripping along with, [264](#c11.xhtml#Page_264)--268]{#b02.xhtml#ind611}
7.  [[`lastButtonState`]{.Code-within-text} variable, [216](#c10.xhtml#Page_216), [217](#c10.xhtml#Page_217), [218](#c10.xhtml#Page_218)]{#b02.xhtml#ind612}
8.  [Last.fm, [162](#c08.xhtml#Page_162)--163]{#b02.xhtml#ind613}
9.  [layouts, circuit]{#b02.xhtml#ind614}
    1.  [analog input and LED output, [266](#c11.xhtml#Page_266)]{#b02.xhtml#ind615}
    2.  [button, [219](#c10.xhtml#Page_219)]{#b02.xhtml#ind616}
    3.  [electret mic, [282](#c11.xhtml#Page_282)]{#b02.xhtml#ind617}
    4.  [keyboard, [252](#c11.xhtml#Page_252)]{#b02.xhtml#ind618}
    5.  [knock sensor, [245](#c11.xhtml#Page_245)]{#b02.xhtml#ind619}
    6.  [light sensor, [226](#c10.xhtml#Page_226), [232](#c10.xhtml#Page_232)]{#b02.xhtml#ind620}
    7.  [LV-EZO, [276](#c11.xhtml#Page_276)]{#b02.xhtml#ind621}
    8.  [PIR sensor, [271](#c11.xhtml#Page_271)]{#b02.xhtml#ind622}
    9.  [pushbutton, [213](#c10.xhtml#Page_213), [240](#c11.xhtml#Page_240)]{#b02.xhtml#ind623}
10. [LCD (liquid crystal display), [292](#c12.xhtml#Page_292)]{#b02.xhtml#ind624}
11. [LCD screen, [168](#c08.xhtml#Page_168)]{#b02.xhtml#ind625}
12. [LCD shield, [286](#c12.xhtml#Page_286)]{#b02.xhtml#ind626}
13. [LDRs (light-dependant resistors), [30](#c02.xhtml#Page_30), [225](#c10.xhtml#Page_225)--226]{#b02.xhtml#ind627}
14. [lead poisoning, [183](#c09.xhtml#Page_183)]{#b02.xhtml#ind628}
15. [lead solder, [183](#c09.xhtml#Page_183)]{#b02.xhtml#ind629}
16. [lead-free solder, [183](#c09.xhtml#Page_183), [184](#c09.xhtml#Page_184)]{#b02.xhtml#ind630}
17. [LED fade sketch]{#b02.xhtml#ind631}
    1.  [setting up, [87](#c06.xhtml#Page_87)--91]{#b02.xhtml#ind632}
    2.  [tweaking, [94](#c06.xhtml#Page_94)--96]{#b02.xhtml#ind633}
    3.  [understanding, [91](#c06.xhtml#Page_91)]{#b02.xhtml#ind634}
    4.  [using for loops, [96](#c06.xhtml#Page_96)]{#b02.xhtml#ind635}
18. [[`led`]{.Code-within-text} variable, [92](#c06.xhtml#Page_92)]{#b02.xhtml#ind636}
19. [[`ledPin`]{.Code-within-text} variable, [107](#c06.xhtml#Page_107), [108](#c06.xhtml#Page_108), [236](#c10.xhtml#Page_236)]{#b02.xhtml#ind637}
20. [LEDs (light-emitting diodes)]{#b02.xhtml#ind638}
    1.  [ability to access within enclosure, [202](#c09.xhtml#Page_202)]{#b02.xhtml#ind639}
    2.  [blinking brighter, [52](#c03.xhtml#Page_52)--53]{#b02.xhtml#ind640}
    3.  [in Compass Card system, [169](#c08.xhtml#Page_169)]{#b02.xhtml#ind641}
    4.  [as components in beginner\'s kit, [30](#c02.xhtml#Page_30)]{#b02.xhtml#ind642}
    5.  [fading of, [117](#c06.xhtml#Page_117)]{#b02.xhtml#ind643}
    6.  [secured in circuit board, [199](#c09.xhtml#Page_199)]{#b02.xhtml#ind644}
    7.  [in simple circuit diagram, [76](#c05.xhtml#Page_76), [78](#c05.xhtml#Page_78)]{#b02.xhtml#ind645}
    8.  [on Uno board, [23[]{#b02.xhtml#Page_375 .pagebreak role="doc-pagebreak" title="375"}](#c02.xhtml#Page_23)]{#b02.xhtml#ind646}
21. [[`ledState`]{.Code-within-text} variable, [212](#c10.xhtml#Page_212), [216](#c10.xhtml#Page_216), [248](#c11.xhtml#Page_248)]{#b02.xhtml#ind647}
22. [Leonardo (board), [25](#c02.xhtml#Page_25)]{#b02.xhtml#ind648}
23. [Liberium (supplier), [297](#c12.xhtml#Page_297)]{#b02.xhtml#ind649}
24. [libraries]{#b02.xhtml#ind650}
    1.  [browsing, [298](#c12.xhtml#Page_298)--302]{#b02.xhtml#ind651}
    2.  [CapSense, [257](#c11.xhtml#Page_257)--258, [262](#c11.xhtml#Page_262), [302](#c12.xhtml#Page_302)]{#b02.xhtml#ind652}
    3.  [community-contributed, [302](#c12.xhtml#Page_302)]{#b02.xhtml#ind653}
    4.  [EEPROM, [299](#c12.xhtml#Page_299)]{#b02.xhtml#ind654}
    5.  [Ethernet, [299](#c12.xhtml#Page_299)]{#b02.xhtml#ind655}
    6.  [Firmata, [299](#c12.xhtml#Page_299)]{#b02.xhtml#ind656}
    7.  [installing additional, [300](#c12.xhtml#Page_300)--302]{#b02.xhtml#ind657}
    8.  [LiquidCrystal, [299](#c12.xhtml#Page_299)]{#b02.xhtml#ind658}
    9.  [obtaining contributed libraries, [302](#c12.xhtml#Page_302)]{#b02.xhtml#ind659}
    10. [Processing using, [329](#c14.xhtml#Page_329)]{#b02.xhtml#ind660}
    11. [removing, [301](#c12.xhtml#Page_301)]{#b02.xhtml#ind661}
    12. [reviewing standard libraries, [299](#c12.xhtml#Page_299)--300]{#b02.xhtml#ind662}
    13. [SD, [299](#c12.xhtml#Page_299)]{#b02.xhtml#ind663}
    14. [serial communication, [329](#c14.xhtml#Page_329)]{#b02.xhtml#ind664}
    15. [servo, [136](#c07.xhtml#Page_136), [141](#c07.xhtml#Page_141), [300](#c12.xhtml#Page_300)]{#b02.xhtml#ind665}
    16. [SoftwareSerial, [300](#c12.xhtml#Page_300)]{#b02.xhtml#ind666}
    17. [SPI, [300](#c12.xhtml#Page_300)]{#b02.xhtml#ind667}
    18. [Stepper, [300](#c12.xhtml#Page_300)]{#b02.xhtml#ind668}
    19. [TimerOne/Timer 1, [302](#c12.xhtml#Page_302)]{#b02.xhtml#ind669}
    20. [WiFi, [300](#c12.xhtml#Page_300)]{#b02.xhtml#ind670}
    21. [Wire, [300](#c12.xhtml#Page_300)]{#b02.xhtml#ind671}
    22. [writing your own, [302](#c12.xhtml#Page_302)]{#b02.xhtml#ind672}
25. [Lieberman, Zachary (developer), [310](#c13.xhtml#Page_310)]{#b02.xhtml#ind673}
26. [light bulbs, [74](#c05.xhtml#Page_74)]{#b02.xhtml#ind674}
27. [light switch circuit, [70](#c05.xhtml#Page_70), [76](#c05.xhtml#Page_76)--77]{#b02.xhtml#ind675}
28. [light-dependant resistors (LDRs), [30](#c02.xhtml#Page_30), [225](#c10.xhtml#Page_225)--226]{#b02.xhtml#ind676}
29. [light-emitting diodes (LEDs)]{#b02.xhtml#ind677}
    1.  [ability to access within enclosure, [202](#c09.xhtml#Page_202)]{#b02.xhtml#ind678}
    2.  [blinking brighter, [52](#c03.xhtml#Page_52)--53]{#b02.xhtml#ind679}
    3.  [in Compass Card system, [169](#c08.xhtml#Page_169)]{#b02.xhtml#ind680}
    4.  [as components in beginner\'s kit, [30](#c02.xhtml#Page_30)]{#b02.xhtml#ind681}
    5.  [fading of, [117](#c06.xhtml#Page_117)]{#b02.xhtml#ind682}
    6.  [secured in circuit board, [199](#c09.xhtml#Page_199)]{#b02.xhtml#ind683}
    7.  [in simple circuit diagram, [76](#c05.xhtml#Page_76), [78](#c05.xhtml#Page_78)]{#b02.xhtml#ind684}
    8.  [on Uno board, [23](#c02.xhtml#Page_23)]{#b02.xhtml#ind685}
30. [LilyPad (board), [24](#c02.xhtml#Page_24), [26](#c02.xhtml#Page_26)]{#b02.xhtml#ind686}
31. [line, [314](#c13.xhtml#Page_314)--315]{#b02.xhtml#ind687}
32. [Linksys Wi-Fi adapter, [168](#c08.xhtml#Page_168)]{#b02.xhtml#ind688}
33. [Linux]{#b02.xhtml#ind689}
    1.  [Arduino, [33](#c02.xhtml#Page_33)]{#b02.xhtml#ind690}
    2.  [Max/Pure Data, [308](#c13.xhtml#Page_308)]{#b02.xhtml#ind691}
    3.  [menu bar in, [34](#c02.xhtml#Page_34)]{#b02.xhtml#ind692}
    4.  [OpenFrameworks, [310](#c13.xhtml#Page_310)]{#b02.xhtml#ind693}
    5.  [Processing, [306](#c13.xhtml#Page_306)]{#b02.xhtml#ind694}
34. [LiPower shield, [295](#c12.xhtml#Page_295)]{#b02.xhtml#ind695}
35. [liquid crystal display (LCD), [292](#c12.xhtml#Page_292)]{#b02.xhtml#ind696}
36. [LiquidCrystal library, [299](#c12.xhtml#Page_299)]{#b02.xhtml#ind697}
37. [lithium batteries, [165](#c08.xhtml#Page_165)--166, [295](#c12.xhtml#Page_295)]{#b02.xhtml#ind698}
38. [Little Lamps, [171](#c08.xhtml#Page_171), [172](#c08.xhtml#Page_172)]{#b02.xhtml#ind699}
39. [Little Printer project, [173](#c08.xhtml#Page_173)--174]{#b02.xhtml#ind700}
40. [load sensors, [249](#c11.xhtml#Page_249)--251]{#b02.xhtml#ind701}
41. [local variables, [211](#c10.xhtml#Page_211)]{#b02.xhtml#ind702}
42. [locks, electrically operated, [120](#c07.xhtml#Page_120)]{#b02.xhtml#ind703}
43. [Locktite (company), [184](#c09.xhtml#Page_184)]{#b02.xhtml#ind704}
44. [long leg (anode or +), [52](#c03.xhtml#Page_52)]{#b02.xhtml#ind705}
45. [[`long`]{.Code-within-text} variable, [92](#c06.xhtml#Page_92), [210](#c10.xhtml#Page_210)--211, [216](#c10.xhtml#Page_216), [278](#c11.xhtml#Page_278)--279]{#b02.xhtml#ind706}
46. [lookup table, [149](#c07.xhtml#Page_149)]{#b02.xhtml#ind707}
47. [[`loop`]{.Code-within-text} function, [47](#c03.xhtml#Page_47), [50](#c03.xhtml#Page_50), [93](#c06.xhtml#Page_93), [96](#c06.xhtml#Page_96), [217](#c10.xhtml#Page_217), [263](#c11.xhtml#Page_263), [274](#c11.xhtml#Page_274), [279](#c11.xhtml#Page_279)]{#b02.xhtml#ind708}
48. [lowpass filter, [263](#c11.xhtml#Page_263)]{#b02.xhtml#ind709}
:::

::: {.section}
## M {.Heading-1}

1.  [mA socket, [63](#c04.xhtml#Page_63)]{#b02.xhtml#ind711}
2.  [Mac OS]{#b02.xhtml#ind712}
    1.  [Max/Pure Data, [308](#c13.xhtml#Page_308)]{#b02.xhtml#ind713}
    2.  [menu bar in, [34](#c02.xhtml#Page_34)]{#b02.xhtml#ind714}
    3.  [naming of serial ports, [40](#c03.xhtml#Page_40)]{#b02.xhtml#ind715}
    4.  [OpenFrameworks, [310](#c13.xhtml#Page_310)]{#b02.xhtml#ind716}
    5.  [Processing, [306](#c13.xhtml#Page_306)]{#b02.xhtml#ind717}
3.  [Macintosh OS X, [33](#c02.xhtml#Page_33)]{#b02.xhtml#ind718}
4.  [magical box of Baker Tweet project, [167](#c08.xhtml#Page_167)--168]{#b02.xhtml#ind719}
5.  [magnetic switch, [31](#c02.xhtml#Page_31)]{#b02.xhtml#ind720}
6.  [magnets, [120](#c07.xhtml#Page_120), [162](#c08.xhtml#Page_162). *See also* [electromagnets](#b02.xhtml#ind421)]{#b02.xhtml#ind721}
7.  [MAKE (hobbyist magazine), [298](#c12.xhtml#Page_298), [360](#c15.xhtml#Page_360)]{#b02.xhtml#ind722}
8.  [Maker Shed (supplier), [298](#c12.xhtml#Page_298)]{#b02.xhtml#ind723}
9.  [manual wire strippers, [186](#c09.xhtml#Page_186)]{#b02.xhtml#ind724}
10. [[`map`]{.Code-within-text} function, [117](#c06.xhtml#Page_117), [157](#c07.xhtml#Page_157), [236](#c10.xhtml#Page_236), [268](#c11.xhtml#Page_268)]{#b02.xhtml#ind725}
11. [Maplin (retailer) (UK), [14](#c01.xhtml#Page_14)]{#b02.xhtml#ind726}
12. [Maxbotix (supplier), [275](#c11.xhtml#Page_275)]{#b02.xhtml#ind727}
13. [Maxiuno, [308](#c13.xhtml#Page_308)]{#b02.xhtml#ind728}
14. [Max/MSP (programming language), [162](#c08.xhtml#Page_162), [308](#c13.xhtml#Page_308)]{#b02.xhtml#ind729}
15. [Max/Pure Data (programming language), [307](#c13.xhtml#Page_307)]{#b02.xhtml#ind730}
16. [MaxSonar code, [277](#c11.xhtml#Page_277)--278]{#b02.xhtml#ind731}
17. [[]{#b02.xhtml#Page_376 .pagebreak role="doc-pagebreak" title="376"}MaxSonar sketch]{#b02.xhtml#ind732}
    1.  [implementing, [275](#c11.xhtml#Page_275)--278]{#b02.xhtml#ind733}
    2.  [understanding, [278](#c11.xhtml#Page_278)--280]{#b02.xhtml#ind734}
18. [mechanical wire strippers, [186](#c09.xhtml#Page_186)--187]{#b02.xhtml#ind735}
19. [Mega 2560 R3 (board), [25](#c02.xhtml#Page_25)]{#b02.xhtml#ind736}
20. [Mega ADK (board), [25](#c02.xhtml#Page_25)]{#b02.xhtml#ind737}
21. [melody, playing of, [143](#c07.xhtml#Page_143)--153]{#b02.xhtml#ind738}
22. [menu bar, [34](#c02.xhtml#Page_34)]{#b02.xhtml#ind739}
23. [message area, [35](#c02.xhtml#Page_35), [125](#c07.xhtml#Page_125)]{#b02.xhtml#ind740}
24. [metal alloy, [177](#c09.xhtml#Page_177)]{#b02.xhtml#ind741}
25. [micro Lipo, [295](#c12.xhtml#Page_295)]{#b02.xhtml#ind742}
26. [microamps (μA), [65](#c04.xhtml#Page_65)]{#b02.xhtml#ind743}
27. [microcontroller boards, [7](#c01.xhtml#Page_7)]{#b02.xhtml#ind744}
28. [microcontroller chip, [7](#c01.xhtml#Page_7), [10](#c01.xhtml#Page_10)]{#b02.xhtml#ind745}
29. [microcontrollers, [7](#c01.xhtml#Page_7), [9](#c01.xhtml#Page_9), [10](#c01.xhtml#Page_10), [14](#c01.xhtml#Page_14)--15, [195](#c09.xhtml#Page_195)]{#b02.xhtml#ind746}
30. [microphone, [280](#c11.xhtml#Page_280)--281]{#b02.xhtml#ind747}
31. [microSD card reader, [290](#c12.xhtml#Page_290), [300](#c12.xhtml#Page_300)]{#b02.xhtml#ind748}
32. [microswitches, [238](#c11.xhtml#Page_238)]{#b02.xhtml#ind749}
33. [MIDI (musical instrument digital interface), [290](#c12.xhtml#Page_290), [291](#c12.xhtml#Page_291)]{#b02.xhtml#ind750}
34. [MIDI shield, [291](#c12.xhtml#Page_291)]{#b02.xhtml#ind751}
35. [milliamps (mA), [65](#c04.xhtml#Page_65)]{#b02.xhtml#ind752}
36. [[`millis`]{.Code-within-text} function, [211](#c10.xhtml#Page_211), [235](#c10.xhtml#Page_235), [262](#c11.xhtml#Page_262), [263](#c11.xhtml#Page_263)]{#b02.xhtml#ind753}
37. [Mini R5 (board), [25](#c02.xhtml#Page_25)]{#b02.xhtml#ind754}
38. [MKR1000 (board), [26](#c02.xhtml#Page_26), [295](#c12.xhtml#Page_295)]{#b02.xhtml#ind755}
39. [mobile phone, [286](#c12.xhtml#Page_286)]{#b02.xhtml#ind756}
40. [[`mode`]{.Code-within-text} parameter, [49](#c03.xhtml#Page_49)]{#b02.xhtml#ind757}
41. [model numbers, [81](#c05.xhtml#Page_81)]{#b02.xhtml#ind758}
42. [mode-selection dial, on multimeter, [62](#c04.xhtml#Page_62)]{#b02.xhtml#ind759}
43. [Modified Toy Orchestra, [13](#c01.xhtml#Page_13)]{#b02.xhtml#ind760}
44. [Moggridge, Bill (designer), [8](#c01.xhtml#Page_8)]{#b02.xhtml#ind761}
45. [Moog synthesizer, [12](#c01.xhtml#Page_12)]{#b02.xhtml#ind762}
46. [motion detection, [269](#c11.xhtml#Page_269)--274]{#b02.xhtml#ind763}
47. [Motor sketch, [122](#c07.xhtml#Page_122)--126]{#b02.xhtml#ind764}
48. [MotorControl sketch, [128](#c07.xhtml#Page_128)--131]{#b02.xhtml#ind765}
49. [motorPin, [131](#c07.xhtml#Page_131), [132](#c07.xhtml#Page_132)]{#b02.xhtml#ind766}
50. [motors, electric]{#b02.xhtml#ind767}
    1.  [as components in beginner\'s kit, [31](#c02.xhtml#Page_31)]{#b02.xhtml#ind768}
    2.  [DC motors. *See* [DC motors](#b02.xhtml#ind345)]{#b02.xhtml#ind769}
    3.  [diagram of, [120](#c07.xhtml#Page_120)]{#b02.xhtml#ind770}
    4.  [transistor circuit to drive, [129](#c07.xhtml#Page_129)]{#b02.xhtml#ind771}
    5.  [working with, [119](#c07.xhtml#Page_119)--121]{#b02.xhtml#ind772}
51. [MotorSpeed sketch, [126](#c07.xhtml#Page_126)--128]{#b02.xhtml#ind773}
52. [[`motorValue`]{.Code-within-text} variable, [131](#c07.xhtml#Page_131)]{#b02.xhtml#ind774}
53. [Mouser (electronics disctributor), [29](#c02.xhtml#Page_29), [365](#c16.xhtml#Page_365)]{#b02.xhtml#ind775}
54. [movement, detecting, [269](#c11.xhtml#Page_269)--274]{#b02.xhtml#ind776}
55. [MP3 player shield, [290](#c12.xhtml#Page_290)--291]{#b02.xhtml#ind777}
56. [multicore equipment wire, [60](#c04.xhtml#Page_60)--61, [189](#c09.xhtml#Page_189), [200](#c09.xhtml#Page_200)]{#b02.xhtml#ind778}
57. [multiline comment, [46](#c03.xhtml#Page_46)--47]{#b02.xhtml#ind779}
58. [multiline comment markers (/\* \*/), [326](#c14.xhtml#Page_326)]{#b02.xhtml#ind780}
59. [multimeter]{#b02.xhtml#ind781}
    1.  [continuity test function, [198](#c09.xhtml#Page_198)]{#b02.xhtml#ind782}
    2.  [described, [62](#c04.xhtml#Page_62)--63]{#b02.xhtml#ind783}
    3.  [uses of, [63](#c04.xhtml#Page_63)--67, [83](#c05.xhtml#Page_83), [98](#c06.xhtml#Page_98), [187](#c09.xhtml#Page_187)]{#b02.xhtml#ind784}
60. [museum exhibits, use of buttons in, [238](#c11.xhtml#Page_238)]{#b02.xhtml#ind785}
61. [musical industry, [291](#c12.xhtml#Page_291)]{#b02.xhtml#ind786}
62. [musical instrument digital interface (MIDI), [290](#c12.xhtml#Page_290), [291](#c12.xhtml#Page_291)]{#b02.xhtml#ind787}
63. [[`myservo`]{.Code-within-text} (servo object), [136](#c07.xhtml#Page_136)]{#b02.xhtml#ind788}
64. [[`myservo.write`]{.Code-within-text}, [141](#c07.xhtml#Page_141)]{#b02.xhtml#ind789}
:::

::: {.section}
## N {.Heading-1}

1.  [naming]{#b02.xhtml#ind791}
    1.  [conventions, ino, [16](#c01.xhtml#Page_16)]{#b02.xhtml#ind792}
    2.  [file extensions, [325](#c14.xhtml#Page_325)]{#b02.xhtml#ind793}
    3.  [function or variable names containing multiple words, [48](#c03.xhtml#Page_48)]{#b02.xhtml#ind794}
    4.  [guidelines for Arduino boards, [24](#c02.xhtml#Page_24)]{#b02.xhtml#ind795}
    5.  [servos, [136](#c07.xhtml#Page_136)]{#b02.xhtml#ind796}
2.  [Nano 3.0 (board), [25](#c02.xhtml#Page_25)]{#b02.xhtml#ind797}
3.  [National Maritime Museum (London), [168](#c08.xhtml#Page_168), [171](#c08.xhtml#Page_171)]{#b02.xhtml#ind798}
4.  [needle-nose pliers, [58](#c04.xhtml#Page_58), [61](#c04.xhtml#Page_61), [187](#c09.xhtml#Page_187)]{#b02.xhtml#ind799}
5.  [negative (-), [58](#c04.xhtml#Page_58), [77](#c05.xhtml#Page_77), [138](#c07.xhtml#Page_138)]{#b02.xhtml#ind800}
6.  [new button, [35](#c02.xhtml#Page_35)]{#b02.xhtml#ind801}
7.  [Newark Electronics (distributor), [365](#c16.xhtml#Page_365)]{#b02.xhtml#ind802}
8.  [newspaper, creating your own, [173](#c08.xhtml#Page_173)]{#b02.xhtml#ind803}
9.  [NG (Arduino board), [19](#c02.xhtml#Page_19)]{#b02.xhtml#ind804}
10. [Ninetendo GameBoy, [13](#c01.xhtml#Page_13), [292](#c12.xhtml#Page_292)]{#b02.xhtml#ind805}
11. [Nip, Andrew (developer), [161](#c08.xhtml#Page_161)]{#b02.xhtml#ind806}
12. [noises, [142](#c07.xhtml#Page_142)--153]{#b02.xhtml#ind807}
13. [Nokia, [165](#c08.xhtml#Page_165)]{#b02.xhtml#ind808}
14. [Nokia 6100 screen, [292](#c12.xhtml#Page_292)]{#b02.xhtml#ind809}
15. [[`noTone`]{.Code-within-text} function, [152](#c07.xhtml#Page_152)]{#b02.xhtml#ind810}
16. [NPN-type transistor, [124](#c07.xhtml#Page_124)]{#b02.xhtml#ind811}
17. [[`numReadings`]{.Code-within-text} variable, [227](#c10.xhtml#Page_227)]{#b02.xhtml#ind812}
:::

::: {.section}
## O {.Heading-1}

1.  [[]{#b02.xhtml#Page_377 .pagebreak role="doc-pagebreak" title="377"}Ogg Vorbis, [290](#c12.xhtml#Page_290)]{#b02.xhtml#ind814}
2.  [Ohm, Georg Simon (physicist), [71](#c05.xhtml#Page_71)]{#b02.xhtml#ind815}
3.  [ohms, [63](#c04.xhtml#Page_63), [65](#c04.xhtml#Page_65), [71](#c05.xhtml#Page_71), [83](#c05.xhtml#Page_83)]{#b02.xhtml#ind816}
4.  [Ohm\'s Law, [71](#c05.xhtml#Page_71)--73]{#b02.xhtml#ind817}
5.  [ON LED, [23](#c02.xhtml#Page_23)]{#b02.xhtml#ind818}
6.  [[`1`]{.Code-within-text} values, [111](#c06.xhtml#Page_111)]{#b02.xhtml#ind819}
7.  [Oomlout (design house), [31](#c02.xhtml#Page_31), [189](#c09.xhtml#Page_189)]{#b02.xhtml#ind820}
8.  [opacity, changing of in Processing, [317](#c13.xhtml#Page_317)--320]{#b02.xhtml#ind821}
9.  [open button, [35](#c02.xhtml#Page_35)]{#b02.xhtml#ind822}
10. [open source software, [15](#c01.xhtml#Page_15)--16]{#b02.xhtml#ind823}
11. [OpenFrameworks (programming language), [175](#c08.xhtml#Page_175), [307](#c13.xhtml#Page_307), [310](#c13.xhtml#Page_310)]{#b02.xhtml#ind824}
12. [OpenGL, [310](#c13.xhtml#Page_310)]{#b02.xhtml#ind825}
13. [optocouplers, [59](#c04.xhtml#Page_59)]{#b02.xhtml#ind826}
14. [orange, as indicative of core function, [49](#c03.xhtml#Page_49)]{#b02.xhtml#ind827}
15. [O\'Shea, Chris (developer), [176](#c08.xhtml#Page_176)]{#b02.xhtml#ind828}
16. [outputs]{#b02.xhtml#ind829}
    1.  [described, [15](#c01.xhtml#Page_15)]{#b02.xhtml#ind830}
    2.  [fixing of to enclosure, [202](#c09.xhtml#Page_202)]{#b02.xhtml#ind831}
    3.  [inverting of, [101](#c06.xhtml#Page_101)--102]{#b02.xhtml#ind832}
    4.  [[`ledPin`]{.Code-within-text} (pin 13) as, [100](#c06.xhtml#Page_100)--101]{#b02.xhtml#ind833}
    5.  [motors. *See* [electric motors](#b02.xhtml#ind412)]{#b02.xhtml#ind834}
17. [[`outputValue`]{.Code-within-text} variable, [117](#c06.xhtml#Page_117)--118]{#b02.xhtml#ind835}
18. [oxidation, in soldering, [183](#c09.xhtml#Page_183), [190](#c09.xhtml#Page_190)]{#b02.xhtml#ind836}
:::

::: {.section}
## P {.Heading-1}

1.  [P (power)]{#b02.xhtml#ind838}
    1.  [calculating, [73](#c05.xhtml#Page_73)--74]{#b02.xhtml#ind839}
    2.  [colors of, [80](#c05.xhtml#Page_80)]{#b02.xhtml#ind840}
    3.  [as important to color code, [90](#c06.xhtml#Page_90)]{#b02.xhtml#ind841}
2.  [P2N2222A transistor, [124](#c07.xhtml#Page_124)]{#b02.xhtml#ind842}
3.  [packages, [20](#c02.xhtml#Page_20)]{#b02.xhtml#ind843}
4.  [packaging your project, [202](#c09.xhtml#Page_202)--204]{#b02.xhtml#ind844}
5.  [paper tape, packaging of resistors on reel of, [83](#c05.xhtml#Page_83)]{#b02.xhtml#ind845}
6.  [parts and components for Arduino, [363](#c16.xhtml#Page_363)--366]{#b02.xhtml#ind846}
7.  [passive infrared (PIR) sensor, [269](#c11.xhtml#Page_269)]{#b02.xhtml#ind847}
8.  [passive resistors, [66](#c04.xhtml#Page_66)]{#b02.xhtml#ind848}
9.  [patching, [12](#c01.xhtml#Page_12)]{#b02.xhtml#ind849}
10. [PCB (printed circuit board), [7](#c01.xhtml#Page_7), [83](#c05.xhtml#Page_83), [191](#c09.xhtml#Page_191)]{#b02.xhtml#ind850}
11. [Pduino, [308](#c13.xhtml#Page_308)]{#b02.xhtml#ind851}
12. [pendulums in motion, [163](#c08.xhtml#Page_163)--164]{#b02.xhtml#ind852}
13. [perfboard, [192](#c09.xhtml#Page_192)]{#b02.xhtml#ind853}
14. [phone switchboards, [12](#c01.xhtml#Page_12)]{#b02.xhtml#ind854}
15. [photo diodes, [30](#c02.xhtml#Page_30)]{#b02.xhtml#ind855}
16. [photo resistors, [30](#c02.xhtml#Page_30)]{#b02.xhtml#ind856}
17. [physical computing, [9](#c01.xhtml#Page_9)]{#b02.xhtml#ind857}
18. [PhysicalPixel sketch]{#b02.xhtml#ind858}
    1.  [setting up, [326](#c14.xhtml#Page_326)--328]{#b02.xhtml#ind859}
    2.  [understanding Arduino sketch, [332](#c14.xhtml#Page_332)--334]{#b02.xhtml#ind860}
    3.  [understanding Processing sketch, [329](#c14.xhtml#Page_329)--332]{#b02.xhtml#ind861}
19. [PIC microcontroller, [7](#c01.xhtml#Page_7), [9](#c01.xhtml#Page_9)]{#b02.xhtml#ind862}
20. [piezo buzzer, [31](#c02.xhtml#Page_31), [142](#c07.xhtml#Page_142)--143]{#b02.xhtml#ind863}
21. [piezo element, [162](#c08.xhtml#Page_162)]{#b02.xhtml#ind864}
22. [piezo sensors, [243](#c11.xhtml#Page_243)--249]{#b02.xhtml#ind865}
23. [piezo speaker, [297](#c12.xhtml#Page_297)]{#b02.xhtml#ind866}
24. [piezoelectric buzzer, [142](#c07.xhtml#Page_142)--143]{#b02.xhtml#ind867}
25. [[`pin`]{.Code-within-text} parameter, [49](#c03.xhtml#Page_49), [50](#c03.xhtml#Page_50)]{#b02.xhtml#ind868}
26. [[`pinMode`]{.Code-within-text}, [49](#c03.xhtml#Page_49), [100](#c06.xhtml#Page_100)--101, [235](#c10.xhtml#Page_235)]{#b02.xhtml#ind869}
27. [PIR (passive infrared) sensor, [269](#c11.xhtml#Page_269)]{#b02.xhtml#ind870}
28. [[`pirSensor`]{.Code-within-text} pin, [273](#c11.xhtml#Page_273)]{#b02.xhtml#ind871}
29. [[`pitches.h`]{.Code-within-text} file, [147](#c07.xhtml#Page_147)--149]{#b02.xhtml#ind872}
30. [[`pitches.h`]{.Code-within-text} tab, [147](#c07.xhtml#Page_147), [149](#c07.xhtml#Page_149), [151](#c07.xhtml#Page_151), [254](#c11.xhtml#Page_254)]{#b02.xhtml#ind873}
31. [PitchFollower sketch, [153](#c07.xhtml#Page_153)--157]{#b02.xhtml#ind874}
32. [plan chests, [169](#c08.xhtml#Page_169)--170]{#b02.xhtml#ind875}
33. [plated-through hole (PTH) chip, [20](#c02.xhtml#Page_20)]{#b02.xhtml#ind876}
34. [Playground. *See* [Arduino Playground](#b02.xhtml#ind76)]{#b02.xhtml#ind877}
35. [pliers, needle-nose, [58](#c04.xhtml#Page_58), [61](#c04.xhtml#Page_61)]{#b02.xhtml#ind878}
36. [plumbing valves, automated, [120](#c07.xhtml#Page_120)]{#b02.xhtml#ind879}
37. [PNP-type transistor, [124](#c07.xhtml#Page_124)]{#b02.xhtml#ind880}
38. [point, [314](#c13.xhtml#Page_314)]{#b02.xhtml#ind881}
39. [Poke (creative company), [167](#c08.xhtml#Page_167)]{#b02.xhtml#ind882}
40. [Poke London, [167](#c08.xhtml#Page_167), [168](#c08.xhtml#Page_168)]{#b02.xhtml#ind883}
41. [polarity]{#b02.xhtml#ind884}
    1.  [changing, [119](#c07.xhtml#Page_119), [120](#c07.xhtml#Page_120), [143](#c07.xhtml#Page_143)]{#b02.xhtml#ind885}
    2.  [DC motors as not having, [121](#c07.xhtml#Page_121)]{#b02.xhtml#ind886}
    3.  [LEDs as having, [78](#c05.xhtml#Page_78)]{#b02.xhtml#ind887}
    4.  [reverse polarity, [22](#c02.xhtml#Page_22)]{#b02.xhtml#ind888}
    5.  [some piezos as having, [144](#c07.xhtml#Page_144)]{#b02.xhtml#ind889}
    6.  [swapping of, [104](#c06.xhtml#Page_104)]{#b02.xhtml#ind890}
42. [portable soldering iron, [180](#c09.xhtml#Page_180)--181]{#b02.xhtml#ind891}
43. [positive (+), [58](#c04.xhtml#Page_58), [70](#c05.xhtml#Page_70), [77](#c05.xhtml#Page_77), [138](#c07.xhtml#Page_138)]{#b02.xhtml#ind892}
44. [potentiometers (pots), [30](#c02.xhtml#Page_30), [103](#c06.xhtml#Page_103), [104](#c06.xhtml#Page_104), [114](#c06.xhtml#Page_114), [116](#c06.xhtml#Page_116), [129](#c07.xhtml#Page_129), [138](#c07.xhtml#Page_138), [199](#c09.xhtml#Page_199), [227](#c10.xhtml#Page_227)]{#b02.xhtml#ind893}
45. [[`potPin`]{.Code-within-text} variable, [131](#c07.xhtml#Page_131)]{#b02.xhtml#ind894}
46. [[`potValue`]{.Code-within-text} variable, [131](#c07.xhtml#Page_131)]{#b02.xhtml#ind895}
47. [[]{#b02.xhtml#Page_378 .pagebreak role="doc-pagebreak" title="378"}power (P)]{#b02.xhtml#ind896}
    1.  [calculating, [73](#c05.xhtml#Page_73)--74]{#b02.xhtml#ind897}
    2.  [colors of, [80](#c05.xhtml#Page_80)]{#b02.xhtml#ind898}
    3.  [as important to color code, [90](#c06.xhtml#Page_90)]{#b02.xhtml#ind899}
48. [power pins, [20](#c02.xhtml#Page_20), [22](#c02.xhtml#Page_22)]{#b02.xhtml#ind900}
49. [power rail, [58](#c04.xhtml#Page_58)]{#b02.xhtml#ind901}
50. [power strip, table top, [178](#c09.xhtml#Page_178)]{#b02.xhtml#ind902}
51. [power supply]{#b02.xhtml#ind903}
    1.  [external, [22](#c02.xhtml#Page_22)--23, [202](#c09.xhtml#Page_202)]{#b02.xhtml#ind904}
    2.  [for soldering workspace, [178](#c09.xhtml#Page_178)]{#b02.xhtml#ind905}
52. [pre-defined variables, [49](#c03.xhtml#Page_49)]{#b02.xhtml#ind906}
53. [pre-made multicore jump wire packets, [61](#c04.xhtml#Page_61)]{#b02.xhtml#ind907}
54. [Premier Farnell Group, [365](#c16.xhtml#Page_365)]{#b02.xhtml#ind908}
55. [pressure pads, [249](#c11.xhtml#Page_249), [250](#c11.xhtml#Page_250)]{#b02.xhtml#ind909}
56. [pressure sensors, [249](#c11.xhtml#Page_249)--251]{#b02.xhtml#ind910}
57. [printed circuit board (PCB), [7](#c01.xhtml#Page_7), [83](#c05.xhtml#Page_83), [191](#c09.xhtml#Page_191)]{#b02.xhtml#ind911}
58. [Pro (board), [26](#c02.xhtml#Page_26)]{#b02.xhtml#ind912}
59. [Pro Mini (board), [27](#c02.xhtml#Page_27)]{#b02.xhtml#ind913}
60. [probes, on multimeter, [63](#c04.xhtml#Page_63), [64](#c04.xhtml#Page_64)]{#b02.xhtml#ind914}
61. [Processing (open source software)]{#b02.xhtml#ind915}
    1.  [changing color and opacity with, [317](#c13.xhtml#Page_317)--320]{#b02.xhtml#ind916}
    2.  [described, [9](#c01.xhtml#Page_9), [305](#c13.xhtml#Page_305)--306]{#b02.xhtml#ind917}
    3.  [drawing a graph, [334](#c14.xhtml#Page_334)--344]{#b02.xhtml#ind918}
    4.  [drawing shapes, [314](#c13.xhtml#Page_314)--317]{#b02.xhtml#ind919}
    5.  [influence of on Arduino, [10](#c01.xhtml#Page_10), [15](#c01.xhtml#Page_15)]{#b02.xhtml#ind920}
    6.  [installing, [307](#c13.xhtml#Page_307)]{#b02.xhtml#ind921}
    7.  [making virtual button, [323](#c14.xhtml#Page_323)--334]{#b02.xhtml#ind922}
    8.  [playing with interaction, [320](#c13.xhtml#Page_320)--322]{#b02.xhtml#ind923}
    9.  [sending multiple signals, [344](#c14.xhtml#Page_344)--356]{#b02.xhtml#ind924}
    10. [showing results on bar graph using, [225](#c10.xhtml#Page_225)]{#b02.xhtml#ind925}
    11. [taking look at, [309](#c13.xhtml#Page_309)--311]{#b02.xhtml#ind926}
    12. [toolbar, [311](#c13.xhtml#Page_311)]{#b02.xhtml#ind927}
    13. [trying first sketch with, [311](#c13.xhtml#Page_311)--322]{#b02.xhtml#ind928}
62. [Processing Graph sketch, [340](#c14.xhtml#Page_340)--341]{#b02.xhtml#ind929}
63. [Processing PhysicalPixel sketch, [329](#c14.xhtml#Page_329)--332]{#b02.xhtml#ind930}
64. [Processing SerialCallResponse sketch, [348](#c14.xhtml#Page_348)--350, [352](#c14.xhtml#Page_352)--356]{#b02.xhtml#ind931}
65. [Processing-to-Arduino communication, [332](#c14.xhtml#Page_332)]{#b02.xhtml#ind932}
66. [programming languages]{#b02.xhtml#ind933}
    1.  [C, [44](#c03.xhtml#Page_44), [306](#c13.xhtml#Page_306)]{#b02.xhtml#ind934}
    2.  [C++, [306](#c13.xhtml#Page_306), [310](#c13.xhtml#Page_310)]{#b02.xhtml#ind935}
    3.  [Java, [306](#c13.xhtml#Page_306)]{#b02.xhtml#ind936}
    4.  [Max/MSP, [162](#c08.xhtml#Page_162), [308](#c13.xhtml#Page_308)]{#b02.xhtml#ind937}
    5.  [Max/Pure Data, [307](#c13.xhtml#Page_307)]{#b02.xhtml#ind938}
    6.  [openFrameworks, [175](#c08.xhtml#Page_175)]{#b02.xhtml#ind939}
    7.  [OpenFrameworks, [307](#c13.xhtml#Page_307), [310](#c13.xhtml#Page_310)]{#b02.xhtml#ind940}
    8.  [PureData, [308](#c13.xhtml#Page_308)]{#b02.xhtml#ind941}
67. [programming lines]{#b02.xhtml#ind942}
    1.  [AnalogInOutSerial sketch, [115](#c06.xhtml#Page_115)--116, [267](#c11.xhtml#Page_267)--268, [283](#c11.xhtml#Page_283)--284]{#b02.xhtml#ind943}
    2.  [AnalogInput sketch, [105](#c06.xhtml#Page_105)--106]{#b02.xhtml#ind944}
    3.  [Arduino Graph sketch, [336](#c14.xhtml#Page_336)--337]{#b02.xhtml#ind945}
    4.  [Arduino PhysicalPixel sketch, [326](#c14.xhtml#Page_326)--328]{#b02.xhtml#ind946}
    5.  [Arduino SerialCallResponse sketch, [346](#c14.xhtml#Page_346)--348]{#b02.xhtml#ind947}
    6.  [blinking better, [205](#c10.xhtml#Page_205)--206]{#b02.xhtml#ind948}
    7.  [BlinkWithoutDelay sketch, [208](#c10.xhtml#Page_208)--210]{#b02.xhtml#ind949}
    8.  [Button sketch, [101](#c06.xhtml#Page_101)]{#b02.xhtml#ind950}
    9.  [Calibration sketch, [233](#c10.xhtml#Page_233)--234]{#b02.xhtml#ind951}
    10. [CapPinSketch sketch, [259](#c11.xhtml#Page_259)--261]{#b02.xhtml#ind952}
    11. [checked for syntax errors, [125](#c07.xhtml#Page_125)]{#b02.xhtml#ind953}
    12. [clicking pushbutton, [222](#c10.xhtml#Page_222)--224]{#b02.xhtml#ind954}
    13. [comments, [46](#c03.xhtml#Page_46), [47](#c03.xhtml#Page_47)]{#b02.xhtml#ind955}
    14. [Debounce sketch, [214](#c10.xhtml#Page_214)--216]{#b02.xhtml#ind956}
    15. [[`delay`]{.Code-within-text} code, [51](#c03.xhtml#Page_51)]{#b02.xhtml#ind957}
    16. [DigitalInputPullup sketch, [241](#c11.xhtml#Page_241)--242]{#b02.xhtml#ind958}
    17. [DigitalReadSerial sketch, [111](#c06.xhtml#Page_111), [272](#c11.xhtml#Page_272)--273]{#b02.xhtml#ind959}
    18. [Fade sketch, [91](#c06.xhtml#Page_91)]{#b02.xhtml#ind960}
    19. [Fading, [95](#c06.xhtml#Page_95)]{#b02.xhtml#ind961}
    20. [Knob sketch, [140](#c07.xhtml#Page_140)]{#b02.xhtml#ind962}
    21. [Knock sketch, [246](#c11.xhtml#Page_246)--247]{#b02.xhtml#ind963}
    22. [[`loop`]{.Code-within-text} code, [50](#c03.xhtml#Page_50)]{#b02.xhtml#ind964}
    23. [[`for`]{.Code-within-text} loops, [96](#c06.xhtml#Page_96)]{#b02.xhtml#ind965}
    24. [MaxSonar sketch, [277](#c11.xhtml#Page_277)--278]{#b02.xhtml#ind966}
    25. [Motor sketch, [124](#c07.xhtml#Page_124)--125]{#b02.xhtml#ind967}
    26. [MotorControl sketch, [130](#c07.xhtml#Page_130)--131]{#b02.xhtml#ind968}
    27. [MotorSpeed sketch, [126](#c07.xhtml#Page_126)--127]{#b02.xhtml#ind969}
    28. [PitchFollower sketch, [155](#c07.xhtml#Page_155)]{#b02.xhtml#ind970}
    29. [Processing Graph sketch, [340](#c14.xhtml#Page_340)--341]{#b02.xhtml#ind971}
    30. [Processing SerialCallResponse sketch, [348](#c14.xhtml#Page_348)--350]{#b02.xhtml#ind972}
    31. [serial communication line, [117](#c06.xhtml#Page_117)]{#b02.xhtml#ind973}
    32. [Smoothing sketch, [227](#c10.xhtml#Page_227)--228, [229](#c10.xhtml#Page_229)--231]{#b02.xhtml#ind974}
    33. [StateChangeDetection sketch, [220](#c10.xhtml#Page_220)--221]{#b02.xhtml#ind975}
    34. [Sweep sketch, [135](#c07.xhtml#Page_135)--136]{#b02.xhtml#ind976}
    35. [toneKeyboard sketch, [253](#c11.xhtml#Page_253)--254]{#b02.xhtml#ind977}
    36. [toneMelody sketch, [144](#c07.xhtml#Page_144)--145]{#b02.xhtml#ind978}
    37. [updating [`ledState`]{.Code-within-text} variable, [212](#c10.xhtml#Page_212)]{#b02.xhtml#ind979}
    38. [virtual button sketch, [325](#c14.xhtml#Page_325)--326]{#b02.xhtml#ind980}
68. [progress bar, [42](#c03.xhtml#Page_42)]{#b02.xhtml#ind981}
69. [[]{#b02.xhtml#Page_379 .pagebreak role="doc-pagebreak" title="379"}projects. *See also specific projects*]{#b02.xhtml#ind982}
    1.  [packaging of, [202](#c09.xhtml#Page_202)--204]{#b02.xhtml#ind983}
    2.  [securing board and other elements, [204](#c09.xhtml#Page_204)]{#b02.xhtml#ind984}
    3.  [wiring of, [203](#c09.xhtml#Page_203)--204]{#b02.xhtml#ind985}
70. [proto shield kit, [191](#c09.xhtml#Page_191)]{#b02.xhtml#ind986}
71. [Proto shield kit Rev3, [288](#c12.xhtml#Page_288)--289]{#b02.xhtml#ind987}
72. [Proto-ScrewShield, [289](#c12.xhtml#Page_289)]{#b02.xhtml#ind988}
73. [ProtoSnap kit, [26](#c02.xhtml#Page_26)]{#b02.xhtml#ind989}
74. [prototyping]{#b02.xhtml#ind990}
    1.  [Arduino as device for quick, [38](#c03.xhtml#Page_38)]{#b02.xhtml#ind991}
    2.  [Arduino Nano 3.0 as ideal for, [25](#c02.xhtml#Page_25)]{#b02.xhtml#ind992}
    3.  [of circuits on breadboards, [58](#c04.xhtml#Page_58)]{#b02.xhtml#ind993}
    4.  [described, [57](#c04.xhtml#Page_57)]{#b02.xhtml#ind994}
    5.  [mechanical joints as great for, [177](#c09.xhtml#Page_177)]{#b02.xhtml#ind995}
    6.  [Skube project as example of using Arduino for, [161](#c08.xhtml#Page_161)]{#b02.xhtml#ind996}
75. [prototyping tools, [57](#c04.xhtml#Page_57)--67]{#b02.xhtml#ind997}
76. [PTH (plated-through hole) chip, [20](#c02.xhtml#Page_20)]{#b02.xhtml#ind998}
77. [Puckette, Miller (software developer), [308](#c13.xhtml#Page_308)]{#b02.xhtml#ind999}
78. [pull-down resistor, [53](#c03.xhtml#Page_53), [239](#c11.xhtml#Page_239)]{#b02.xhtml#ind1000}
79. [pull-up resistor, [239](#c11.xhtml#Page_239)]{#b02.xhtml#ind1001}
80. [pulse width modulation (PWM), [21](#c02.xhtml#Page_21), [87](#c06.xhtml#Page_87), [117](#c06.xhtml#Page_117), [128](#c07.xhtml#Page_128), [137](#c07.xhtml#Page_137), [234](#c10.xhtml#Page_234)]{#b02.xhtml#ind1002}
81. [[`pulseIn`]{.Code-within-text} function, [279](#c11.xhtml#Page_279)]{#b02.xhtml#ind1003}
82. [PureData (programming language), [308](#c13.xhtml#Page_308)]{#b02.xhtml#ind1004}
83. [Push Snowboarding project, [165](#c08.xhtml#Page_165)--167]{#b02.xhtml#ind1005}
84. [[`pushButton`]{.Code-within-text} pin, [273](#c11.xhtml#Page_273)]{#b02.xhtml#ind1006}
85. [pushbuttons]{#b02.xhtml#ind1007}
    1.  [on Button circuit, [98](#c06.xhtml#Page_98)]{#b02.xhtml#ind1008}
    2.  [complexity of, [238](#c11.xhtml#Page_238)]{#b02.xhtml#ind1009}
    3.  [as components in beginner\'s kit, [30](#c02.xhtml#Page_30)]{#b02.xhtml#ind1010}
    4.  [costs of, [238](#c11.xhtml#Page_238)]{#b02.xhtml#ind1011}
    5.  [in DigitalReadSerial sketch, [110](#c06.xhtml#Page_110)]{#b02.xhtml#ind1012}
    6.  [in Good Night Lamp, [171](#c08.xhtml#Page_171)--172]{#b02.xhtml#ind1013}
    7.  [in simple circuit diagram, [76](#c05.xhtml#Page_76)--77]{#b02.xhtml#ind1014}
    8.  [soldering of, [198](#c09.xhtml#Page_198)]{#b02.xhtml#ind1015}
    9.  [where to use, [238](#c11.xhtml#Page_238)]{#b02.xhtml#ind1016}
86. [PWM (pulse width modulation), [21](#c02.xhtml#Page_21), [87](#c06.xhtml#Page_87), [117](#c06.xhtml#Page_117), [128](#c07.xhtml#Page_128), [137](#c07.xhtml#Page_137), [234](#c10.xhtml#Page_234)]{#b02.xhtml#ind1017}
87. [PWR (source of power), [58](#c04.xhtml#Page_58)]{#b02.xhtml#ind1018}
:::

::: {.section}
## Q {.Heading-1}

1.  [Quad-band Cellular Duck Antenna SMA, [296](#c12.xhtml#Page_296)]{#b02.xhtml#ind1020}
2.  [quotation marks (\" \"), [118](#c06.xhtml#Page_118)]{#b02.xhtml#ind1021}
:::

::: {.section}
## R {.Heading-1}

1.  [Radiation Sensor Board, [297](#c12.xhtml#Page_297)]{#b02.xhtml#ind1023}
2.  [Radio Shack (retailer) (US), [14](#c01.xhtml#Page_14), [180](#c09.xhtml#Page_180), [202](#c09.xhtml#Page_202)]{#b02.xhtml#ind1024}
3.  [range finders, [274](#c11.xhtml#Page_274)--275]{#b02.xhtml#ind1025}
4.  [Rapid (electronics distributor), [29](#c02.xhtml#Page_29)]{#b02.xhtml#ind1026}
5.  [raw sensor value, [108](#c06.xhtml#Page_108)]{#b02.xhtml#ind1027}
6.  [[`reading`]{.Code-within-text} variable, [217](#c10.xhtml#Page_217)]{#b02.xhtml#ind1028}
7.  [[`readings`]{.Code-within-text} array, [228](#c10.xhtml#Page_228)]{#b02.xhtml#ind1029}
8.  [[`.readPin`]{.Code-within-text} function, [262](#c11.xhtml#Page_262)]{#b02.xhtml#ind1030}
9.  [read-write heads on hard disks, [120](#c07.xhtml#Page_120)]{#b02.xhtml#ind1031}
10. [Reas, Casey (developer), [9](#c01.xhtml#Page_9), [306](#c13.xhtml#Page_306)]{#b02.xhtml#ind1032}
11. [rechargeable lithium batteries, [165](#c08.xhtml#Page_165)--166, [295](#c12.xhtml#Page_295)]{#b02.xhtml#ind1033}
12. [rectangle, [315](#c13.xhtml#Page_315)--316]{#b02.xhtml#ind1034}
13. [rectifier diodes, [30](#c02.xhtml#Page_30)]{#b02.xhtml#ind1035}
14. [red]{#b02.xhtml#ind1036}
    1.  [as color of positive (+), [58](#c04.xhtml#Page_58), [80](#c05.xhtml#Page_80)]{#b02.xhtml#ind1037}
    2.  [as possible color of power, [90](#c06.xhtml#Page_90)]{#b02.xhtml#ind1038}
15. [reed switch, [162](#c08.xhtml#Page_162)]{#b02.xhtml#ind1039}
16. [relaying back data over network, [170](#c08.xhtml#Page_170)]{#b02.xhtml#ind1040}
17. [relays, [31](#c02.xhtml#Page_31)]{#b02.xhtml#ind1041}
18. [Remember icon, [3](#c00.xhtml#Page_3)]{#b02.xhtml#ind1042}
19. [remote controls, [203](#c09.xhtml#Page_203)]{#b02.xhtml#ind1043}
20. [reset button, [23](#c02.xhtml#Page_23)--24]{#b02.xhtml#ind1044}
21. [resistance, [63](#c04.xhtml#Page_63), [65](#c04.xhtml#Page_65)--66, [89](#c06.xhtml#Page_89)]{#b02.xhtml#ind1045}
22. [resistor color charts, [81](#c05.xhtml#Page_81)--83, [89](#c06.xhtml#Page_89)]{#b02.xhtml#ind1046}
23. [resistor values, [89](#c06.xhtml#Page_89)]{#b02.xhtml#ind1047}
24. [resistors]{#b02.xhtml#ind1048}
    1.  [built-in pull-down resistor, [53](#c03.xhtml#Page_53)]{#b02.xhtml#ind1049}
    2.  [color bands on, [82](#c05.xhtml#Page_82)--83]{#b02.xhtml#ind1050}
    3.  [as components in beginner\'s kit, [30](#c02.xhtml#Page_30)]{#b02.xhtml#ind1051}
    4.  [fixed, [30](#c02.xhtml#Page_30)]{#b02.xhtml#ind1052}
    5.  [light-dependant, [30](#c02.xhtml#Page_30), [225](#c10.xhtml#Page_225)--226]{#b02.xhtml#ind1053}
    6.  [packaging of, [83](#c05.xhtml#Page_83)]{#b02.xhtml#ind1054}
    7.  [passive, [66](#c04.xhtml#Page_66)]{#b02.xhtml#ind1055}
    8.  [photo, [30](#c02.xhtml#Page_30)]{#b02.xhtml#ind1056}
    9.  [reading value of, [66](#c04.xhtml#Page_66)]{#b02.xhtml#ind1057}
    10. [in simple circuit diagram, [76](#c05.xhtml#Page_76), [78](#c05.xhtml#Page_78)]{#b02.xhtml#ind1058}
    11. [variable, [30](#c02.xhtml#Page_30), [66](#c04.xhtml#Page_66), [103](#c06.xhtml#Page_103), [113](#c06.xhtml#Page_113)]{#b02.xhtml#ind1059}
25. [Restriction of Hazardous Substances Directive (RoHS), [183](#c09.xhtml#Page_183)]{#b02.xhtml#ind1060}
26. [reverse current, [122](#c07.xhtml#Page_122)--125]{#b02.xhtml#ind1061}
27. [reverse polarity, [22](#c02.xhtml#Page_22)]{#b02.xhtml#ind1062}
28. [reverse voltage, [73](#c05.xhtml#Page_73)]{#b02.xhtml#ind1063}
29. [[]{#b02.xhtml#Page_380 .pagebreak role="doc-pagebreak" title="380"}RGB LCD shield w/16 x 2 character display, [292](#c12.xhtml#Page_292)]{#b02.xhtml#ind1064}
30. [RoHS (Restriction of Hazardous Substances Directive), [183](#c09.xhtml#Page_183)]{#b02.xhtml#ind1065}
31. [RS Components (electronics distributor), [29](#c02.xhtml#Page_29), [202](#c09.xhtml#Page_202), [238](#c11.xhtml#Page_238), [365](#c16.xhtml#Page_365)]{#b02.xhtml#ind1066}
32. [RX LED, [23](#c02.xhtml#Page_23), [42](#c03.xhtml#Page_42)]{#b02.xhtml#ind1067}
:::

::: {.section}
## S {.Heading-1}

1.  [safety goggles, [190](#c09.xhtml#Page_190)]{#b02.xhtml#ind1069}
2.  [save button, [35](#c02.xhtml#Page_35)]{#b02.xhtml#ind1070}
3.  [schematics]{#b02.xhtml#ind1071}
    1.  [AnalogInput circuit, [105](#c06.xhtml#Page_105)]{#b02.xhtml#ind1072}
    2.  [Arduino with LED connected to pin 13, [324](#c14.xhtml#Page_324)]{#b02.xhtml#ind1073}
    3.  [dimmer circuit, [115](#c06.xhtml#Page_115)]{#b02.xhtml#ind1074}
    4.  [of diode, [121](#c07.xhtml#Page_121)]{#b02.xhtml#ind1075}
    5.  [potentiometer input, [336](#c14.xhtml#Page_336)]{#b02.xhtml#ind1076}
    6.  [of pushbutton circuit, [98](#c06.xhtml#Page_98), [110](#c06.xhtml#Page_110)]{#b02.xhtml#ind1077}
    7.  [two analog inputs and one digital, [346](#c14.xhtml#Page_346)]{#b02.xhtml#ind1078}
4.  [screen burn, [170](#c08.xhtml#Page_170)]{#b02.xhtml#ind1079}
5.  [screw terminals, [203](#c09.xhtml#Page_203), [204](#c09.xhtml#Page_204)]{#b02.xhtml#ind1080}
6.  [SD card reader, [289](#c12.xhtml#Page_289), [290](#c12.xhtml#Page_290)]{#b02.xhtml#ind1081}
7.  [SD cards, [289](#c12.xhtml#Page_289), [299](#c12.xhtml#Page_299)]{#b02.xhtml#ind1082}
8.  [SD library, [299](#c12.xhtml#Page_299)]{#b02.xhtml#ind1083}
9.  [SE-10 (PIR sensor), [270](#c11.xhtml#Page_270)]{#b02.xhtml#ind1084}
10. [Seeduino (board), [24](#c02.xhtml#Page_24)]{#b02.xhtml#ind1085}
11. [Seeed Studio (open hardware facilitation company), [24](#c02.xhtml#Page_24), [28](#c02.xhtml#Page_28), [298](#c12.xhtml#Page_298), [364](#c16.xhtml#Page_364)]{#b02.xhtml#ind1086}
12. [Seeed Studio blog, [298](#c12.xhtml#Page_298)]{#b02.xhtml#ind1087}
13. [sensing with style, [255](#c11.xhtml#Page_255)--264]{#b02.xhtml#ind1088}
14. [[`sensorMax`]{.Code-within-text} variable, [235](#c10.xhtml#Page_235), [236](#c10.xhtml#Page_236)]{#b02.xhtml#ind1089}
15. [[`sensorMin`]{.Code-within-text} variable, [235](#c10.xhtml#Page_235), [236](#c10.xhtml#Page_236)]{#b02.xhtml#ind1090}
16. [[`sensorPin`]{.Code-within-text}, [236](#c10.xhtml#Page_236)]{#b02.xhtml#ind1091}
17. [sensors]{#b02.xhtml#ind1092}
    1.  [ambient sensor, [281](#c11.xhtml#Page_281)]{#b02.xhtml#ind1093}
    2.  [calibrating, [231](#c10.xhtml#Page_231)--236]{#b02.xhtml#ind1094}
    3.  [capacitive sensors, [255](#c11.xhtml#Page_255)--256]{#b02.xhtml#ind1095}
    4.  [costs of, [238](#c11.xhtml#Page_238), [243](#c11.xhtml#Page_243)--244, [250](#c11.xhtml#Page_250), [256](#c11.xhtml#Page_256), [265](#c11.xhtml#Page_265), [270](#c11.xhtml#Page_270), [275](#c11.xhtml#Page_275), [281](#c11.xhtml#Page_281)]{#b02.xhtml#ind1096}
    5.  [force sensors, [249](#c11.xhtml#Page_249)--251]{#b02.xhtml#ind1097}
    6.  [infrared proximity sensor, [274](#c11.xhtml#Page_274)--275]{#b02.xhtml#ind1098}
    7.  [load sensors, [249](#c11.xhtml#Page_249)--251]{#b02.xhtml#ind1099}
    8.  [passive infrared (PIR) sensor, [269](#c11.xhtml#Page_269)]{#b02.xhtml#ind1100}
    9.  [pressure sensors, [249](#c11.xhtml#Page_249)--251]{#b02.xhtml#ind1101}
    10. [pushbuttons. *See* [pushbuttons](#b02.xhtml#ind1007)]{#b02.xhtml#ind1102}
    11. [smoothing of, [225](#c10.xhtml#Page_225)--231]{#b02.xhtml#ind1103}
    12. [ultrasonic range finder, [274](#c11.xhtml#Page_274)]{#b02.xhtml#ind1104}
18. [[`sensorVal`]{.Code-within-text} variable, [242](#c11.xhtml#Page_242)]{#b02.xhtml#ind1105}
19. [[`sensorValue`]{.Code-within-text} variable, [107](#c06.xhtml#Page_107), [109](#c06.xhtml#Page_109), [117](#c06.xhtml#Page_117), [235](#c10.xhtml#Page_235), [236](#c10.xhtml#Page_236)]{#b02.xhtml#ind1106}
20. [serial, [109](#c06.xhtml#Page_109)]{#b02.xhtml#ind1107}
21. [Serial (Arduino board), [19](#c02.xhtml#Page_19)]{#b02.xhtml#ind1108}
22. [serial communication, [112](#c06.xhtml#Page_112)]{#b02.xhtml#ind1109}
23. [serial communication library, [329](#c14.xhtml#Page_329)]{#b02.xhtml#ind1110}
24. [serial connections, [40](#c03.xhtml#Page_40)]{#b02.xhtml#ind1111}
25. [serial monitor, [109](#c06.xhtml#Page_109), [273](#c11.xhtml#Page_273), [278](#c11.xhtml#Page_278)]{#b02.xhtml#ind1112}
26. [serial monitor button, [35](#c02.xhtml#Page_35), [111](#c06.xhtml#Page_111)]{#b02.xhtml#ind1113}
27. [serial monitor window, [112](#c06.xhtml#Page_112)]{#b02.xhtml#ind1114}
28. [serial peripheral interface (SPI), [300](#c12.xhtml#Page_300)]{#b02.xhtml#ind1115}
29. [serial port, [40](#c03.xhtml#Page_40), [156](#c07.xhtml#Page_156)]{#b02.xhtml#ind1116}
30. [serial port object, [329](#c14.xhtml#Page_329)]{#b02.xhtml#ind1117}
31. [[`Serial.begin`]{.Code-within-text}, [112](#c06.xhtml#Page_112)]{#b02.xhtml#ind1118}
32. [[`Serial.list`]{.Code-within-text}, [330](#c14.xhtml#Page_330)]{#b02.xhtml#ind1119}
33. [[`Serial.print`]{.Code-within-text}, [331](#c14.xhtml#Page_331)]{#b02.xhtml#ind1120}
34. [[`Serial.printIn`]{.Code-within-text}, [113](#c06.xhtml#Page_113), [118](#c06.xhtml#Page_118)]{#b02.xhtml#ind1121}
35. [series, current as measured in, [65](#c04.xhtml#Page_65)]{#b02.xhtml#ind1122}
36. [servo library, [136](#c07.xhtml#Page_136), [141](#c07.xhtml#Page_141), [300](#c12.xhtml#Page_300)]{#b02.xhtml#ind1123}
37. [servo object, [136](#c07.xhtml#Page_136), [141](#c07.xhtml#Page_141)]{#b02.xhtml#ind1124}
38. [[`Servo.h`]{.Code-within-text} (servo library), [136](#c07.xhtml#Page_136), [141](#c07.xhtml#Page_141)]{#b02.xhtml#ind1125}
39. [servomotors]{#b02.xhtml#ind1126}
    1.  [as components in beginner\'s kit, [31](#c02.xhtml#Page_31)]{#b02.xhtml#ind1127}
    2.  [with control knob, [139](#c07.xhtml#Page_139)]{#b02.xhtml#ind1128}
    3.  [controlling, [138](#c07.xhtml#Page_138)--142]{#b02.xhtml#ind1129}
    4.  [getting to know, [132](#c07.xhtml#Page_132)--133]{#b02.xhtml#ind1130}
40. [[`setup`]{.Code-within-text} function, [48](#c03.xhtml#Page_48)--49, [92](#c06.xhtml#Page_92), [263](#c11.xhtml#Page_263), [279](#c11.xhtml#Page_279)]{#b02.xhtml#ind1131}
41. [Shamieh, Cathleen (author)]{#b02.xhtml#ind1132}
    1.  [*Electronics For Dummies*, [70](#c05.xhtml#Page_70)]{#b02.xhtml#ind1133}
42. [Shape (supplier), [275](#c11.xhtml#Page_275)]{#b02.xhtml#ind1134}
43. [shapes, drawing, [314](#c13.xhtml#Page_314)--317]{#b02.xhtml#ind1135}
44. [shields]{#b02.xhtml#ind1136}
    1.  [about, [11](#c01.xhtml#Page_11)]{#b02.xhtml#ind1137}
    2.  [as additional boards, [20](#c02.xhtml#Page_20)]{#b02.xhtml#ind1138}
    3.  [assembling, [191](#c09.xhtml#Page_191)--195]{#b02.xhtml#ind1139}
    4.  [considering combinations of, [286](#c12.xhtml#Page_286)--287]{#b02.xhtml#ind1140}
    5.  [costs of, [288](#c12.xhtml#Page_288)--297]{#b02.xhtml#ind1141}
    6.  [documentation of, [298](#c12.xhtml#Page_298)]{#b02.xhtml#ind1142}
    7.  [looking at, [286](#c12.xhtml#Page_286)--298]{#b02.xhtml#ind1143}
    8.  [reviewing the field, [287](#c12.xhtml#Page_287)--297]{#b02.xhtml#ind1144}
    9.  [staying current with, [297](#c12.xhtml#Page_297)--298[]{#b02.xhtml#Page_381 .pagebreak role="doc-pagebreak" title="381"}]{#b02.xhtml#ind1145}
45. [shopping, [27](#c02.xhtml#Page_27)--29. *See also* [suppliers](#b02.xhtml#ind1248)]{#b02.xhtml#ind1146}
46. [short circuit, [71](#c05.xhtml#Page_71), [120](#c07.xhtml#Page_120)]{#b02.xhtml#ind1147}
47. [short leg (cathode or -), [52](#c03.xhtml#Page_52)]{#b02.xhtml#ind1148}
48. [shortcut, creating, [33](#c02.xhtml#Page_33)]{#b02.xhtml#ind1149}
49. [signal wire, [90](#c06.xhtml#Page_90)]{#b02.xhtml#ind1150}
50. [signals, sending multiple, [344](#c14.xhtml#Page_344)--356]{#b02.xhtml#ind1151}
51. [SIM card, [296](#c12.xhtml#Page_296), [297](#c12.xhtml#Page_297)]{#b02.xhtml#ind1152}
52. [sine waves, [143](#c07.xhtml#Page_143)]{#b02.xhtml#ind1153}
53. [single-core equipment wire, [60](#c04.xhtml#Page_60), [189](#c09.xhtml#Page_189)]{#b02.xhtml#ind1154}
54. [single-line comment, [47](#c03.xhtml#Page_47)]{#b02.xhtml#ind1155}
55. [sketch twice, solder once, [199](#c09.xhtml#Page_199)]{#b02.xhtml#ind1156}
56. [sketches. *See also specific sketches*]{#b02.xhtml#ind1157}
    1.  [as made up of lines of code, [46](#c03.xhtml#Page_46)]{#b02.xhtml#ind1158}
    2.  [as names of Arduino programs, [10](#c01.xhtml#Page_10)]{#b02.xhtml#ind1159}
    3.  [tweaking, [53](#c03.xhtml#Page_53)]{#b02.xhtml#ind1160}
    4.  [uploading, [42](#c03.xhtml#Page_42)--43, [86](#c06.xhtml#Page_86)]{#b02.xhtml#ind1161}
    5.  [working with first Arduino sketch, [37](#c03.xhtml#Page_37)--44]{#b02.xhtml#ind1162}
57. [skip/dumpster diving, [366](#c16.xhtml#Page_366)]{#b02.xhtml#ind1163}
58. [Skube project, [161](#c08.xhtml#Page_161)--163]{#b02.xhtml#ind1164}
59. [SMA connector, [296](#c12.xhtml#Page_296)]{#b02.xhtml#ind1165}
60. [SMD (surface mount device) chip, [20](#c02.xhtml#Page_20)]{#b02.xhtml#ind1166}
61. [smoothing function, [263](#c11.xhtml#Page_263)]{#b02.xhtml#ind1167}
62. [smoothing of sensors, [225](#c10.xhtml#Page_225)--231]{#b02.xhtml#ind1168}
63. [Smoothing sketch, [225](#c10.xhtml#Page_225)--231]{#b02.xhtml#ind1169}
64. [snowboarding project, [165](#c08.xhtml#Page_165)--167]{#b02.xhtml#ind1170}
65. [sockets, on multimeter, [63](#c04.xhtml#Page_63)]{#b02.xhtml#ind1171}
66. [software]{#b02.xhtml#ind1172}
    1.  [configuring, [40](#c03.xhtml#Page_40)--42]{#b02.xhtml#ind1173}
    2.  [GitHub as repository of, [257](#c11.xhtml#Page_257)]{#b02.xhtml#ind1174}
    3.  [open source, [15](#c01.xhtml#Page_15)--16. *See also* [Processing (open source software)](#b02.xhtml#ind915)]{#b02.xhtml#ind1175}
    4.  [Processing. *See* [Processing (open source software)](#b02.xhtml#ind915)]{#b02.xhtml#ind1176}
67. [software framework, [310](#c13.xhtml#Page_310)]{#b02.xhtml#ind1177}
68. [SoftwareSerial library, [300](#c12.xhtml#Page_300)]{#b02.xhtml#ind1178}
69. [solar panel, [22](#c02.xhtml#Page_22)]{#b02.xhtml#ind1179}
70. [solder, [183](#c09.xhtml#Page_183)--184]{#b02.xhtml#ind1180}
71. [solder fumes, [179](#c09.xhtml#Page_179), [184](#c09.xhtml#Page_184), [190](#c09.xhtml#Page_190)]{#b02.xhtml#ind1181}
72. [solder joint, as pyramid-shaped, [198](#c09.xhtml#Page_198)]{#b02.xhtml#ind1182}
73. [solder stations, [179](#c09.xhtml#Page_179), [182](#c09.xhtml#Page_182)--183]{#b02.xhtml#ind1183}
74. [solder sucker, [187](#c09.xhtml#Page_187), [188](#c09.xhtml#Page_188)]{#b02.xhtml#ind1184}
75. [solder wick, [187](#c09.xhtml#Page_187)--188]{#b02.xhtml#ind1185}
76. [soldered circuit board, [178](#c09.xhtml#Page_178)]{#b02.xhtml#ind1186}
77. [soldering]{#b02.xhtml#ind1187}
    1.  [acquiring technique, [195](#c09.xhtml#Page_195)--198]{#b02.xhtml#ind1188}
    2.  [adhesive putty, [184](#c09.xhtml#Page_184)--185]{#b02.xhtml#ind1189}
    3.  [assembling shield, [191](#c09.xhtml#Page_191)--195]{#b02.xhtml#ind1190}
    4.  [assembly, [194](#c09.xhtml#Page_194)]{#b02.xhtml#ind1191}
    5.  [choosing soldering iron, [179](#c09.xhtml#Page_179)--183]{#b02.xhtml#ind1192}
    6.  [cleaning soldering iron, [190](#c09.xhtml#Page_190)]{#b02.xhtml#ind1193}
    7.  [don\'t eat solder, [190](#c09.xhtml#Page_190)]{#b02.xhtml#ind1194}
    8.  [equipment wire, [189](#c09.xhtml#Page_189)]{#b02.xhtml#ind1195}
    9.  [eye protection, [190](#c09.xhtml#Page_190)]{#b02.xhtml#ind1196}
    10. [fixed-temperature soldering iron, [179](#c09.xhtml#Page_179)--180]{#b02.xhtml#ind1197}
    11. [getting what you need for, [178](#c09.xhtml#Page_178)--189]{#b02.xhtml#ind1198}
    12. [handling soldering iron, [190](#c09.xhtml#Page_190)]{#b02.xhtml#ind1199}
    13. [header pins, [194](#c09.xhtml#Page_194)--195]{#b02.xhtml#ind1200}
    14. [laying out all pieces of circuit, [192](#c09.xhtml#Page_192)--193]{#b02.xhtml#ind1201}
    15. [as making project last longer, [61](#c04.xhtml#Page_61)]{#b02.xhtml#ind1202}
    16. [multimeter, [187](#c09.xhtml#Page_187)]{#b02.xhtml#ind1203}
    17. [needle-nose pliers, [187](#c09.xhtml#Page_187)]{#b02.xhtml#ind1204}
    18. [portable soldering iron, [180](#c09.xhtml#Page_180)--181]{#b02.xhtml#ind1205}
    19. [safety, [189](#c09.xhtml#Page_189)--190]{#b02.xhtml#ind1206}
    20. [temperature-controlled soldering iron, [181](#c09.xhtml#Page_181)--182]{#b02.xhtml#ind1207}
    21. [third hand/helping hand for, [184](#c09.xhtml#Page_184)]{#b02.xhtml#ind1208}
    22. [tinning the tip, [197](#c09.xhtml#Page_197)]{#b02.xhtml#ind1209}
    23. [understanding, [177](#c09.xhtml#Page_177)--178]{#b02.xhtml#ind1210}
    24. [ventilation while, [190](#c09.xhtml#Page_190)]{#b02.xhtml#ind1211}
    25. [wire cutters, [185](#c09.xhtml#Page_185)--186]{#b02.xhtml#ind1212}
    26. [wire strippers, [186](#c09.xhtml#Page_186)--187]{#b02.xhtml#ind1213}
78. [soldering gun, [177](#c09.xhtml#Page_177)]{#b02.xhtml#ind1214}
79. [soldering iron, [177](#c09.xhtml#Page_177)--183, [190](#c09.xhtml#Page_190), [195](#c09.xhtml#Page_195)]{#b02.xhtml#ind1215}
80. [solid core wire, [200](#c09.xhtml#Page_200)]{#b02.xhtml#ind1216}
81. [sound symbol, on multimeter dial, [67](#c04.xhtml#Page_67)]{#b02.xhtml#ind1217}
82. [sounding a tone, [63](#c04.xhtml#Page_63), [67](#c04.xhtml#Page_67), [143](#c07.xhtml#Page_143)]{#b02.xhtml#ind1218}
83. [sounding devices, [31](#c02.xhtml#Page_31)]{#b02.xhtml#ind1219}
84. [sounds]{#b02.xhtml#ind1220}
    1.  [with piezo, [243](#c11.xhtml#Page_243)]{#b02.xhtml#ind1221}
    2.  [playing of. *See* [noises](#b02.xhtml#ind807)]{#b02.xhtml#ind1222}
    3.  [as way to detect presence, [280](#c11.xhtml#Page_280)]{#b02.xhtml#ind1223}
85. [Source (Emitter), [124](#c07.xhtml#Page_124)]{#b02.xhtml#ind1224}
86. [source of power (PWR), [58](#c04.xhtml#Page_58)]{#b02.xhtml#ind1225}
87. [SparkFun color LCD shield, [292](#c12.xhtml#Page_292)]{#b02.xhtml#ind1226}
88. [SparkFun Electronics (distributor) (US), [24](#c02.xhtml#Page_24), [26](#c02.xhtml#Page_26), [27](#c02.xhtml#Page_27), [28](#c02.xhtml#Page_28), [289](#c12.xhtml#Page_289), [290](#c12.xhtml#Page_290), [291](#c12.xhtml#Page_291), [293](#c12.xhtml#Page_293), [295](#c12.xhtml#Page_295), [298](#c12.xhtml#Page_298), [310](#c13.xhtml#Page_310), [360](#c15.xhtml#Page_360), [364](#c16.xhtml#Page_364)]{#b02.xhtml#ind1227}
89. [SparkFun Electronics blog, [298](#c12.xhtml#Page_298)]{#b02.xhtml#ind1228}
90. [Speak & Spell (device), [13](#c01.xhtml#Page_13)--14]{#b02.xhtml#ind1229}
91. [[]{#b02.xhtml#Page_382 .pagebreak role="doc-pagebreak" title="382"}speaker, on multimeter dial, [67](#c04.xhtml#Page_67)]{#b02.xhtml#ind1230}
92. [speed, changing/controlling of on motor, [128](#c07.xhtml#Page_128)--132]{#b02.xhtml#ind1231}
93. [SPI (serial peripheral interface), [300](#c12.xhtml#Page_300)]{#b02.xhtml#ind1232}
94. [SPI library, [300](#c12.xhtml#Page_300)]{#b02.xhtml#ind1233}
95. [spinning, of DC motor, [121](#c07.xhtml#Page_121)--126]{#b02.xhtml#ind1234}
96. [Spitz, Andrew (developer), [161](#c08.xhtml#Page_161), [163](#c08.xhtml#Page_163)]{#b02.xhtml#ind1235}
97. [sponge (for soldering), [196](#c09.xhtml#Page_196)]{#b02.xhtml#ind1236}
98. [Spotify, [162](#c08.xhtml#Page_162)--163]{#b02.xhtml#ind1237}
99. [square brackets (\[\]), [150](#c07.xhtml#Page_150), [228](#c10.xhtml#Page_228)]{#b02.xhtml#ind1238}
100. [square wave, [143](#c07.xhtml#Page_143)]{#b02.xhtml#ind1239}
101. [stackable headers, [194](#c09.xhtml#Page_194)]{#b02.xhtml#ind1240}
102. [Starter Kit for Arduino (ARDX), [31](#c02.xhtml#Page_31)]{#b02.xhtml#ind1241}
103. [StateChangeDetection sketch, [218](#c10.xhtml#Page_218)--225]{#b02.xhtml#ind1242}
104. [Stepper library, [300](#c12.xhtml#Page_300)]{#b02.xhtml#ind1243}
105. [stripboard, [192](#c09.xhtml#Page_192), [204](#c09.xhtml#Page_204)]{#b02.xhtml#ind1244}
106. [stroke, [331](#c14.xhtml#Page_331)]{#b02.xhtml#ind1245}
107. [style, sensing with, [255](#c11.xhtml#Page_255)--264]{#b02.xhtml#ind1246}
108. [suffixes, [325](#c14.xhtml#Page_325)]{#b02.xhtml#ind1247}
109. [suppliers, [27](#c02.xhtml#Page_27)--29, [363](#c16.xhtml#Page_363)--366. *See also specific suppliers*]{#b02.xhtml#ind1248}
110. [surface mount device (SMD) chip, [20](#c02.xhtml#Page_20)]{#b02.xhtml#ind1249}
111. [Sweep sketch, [133](#c07.xhtml#Page_133)--138]{#b02.xhtml#ind1250}
112. [sweeping movements, [133](#c07.xhtml#Page_133)--138]{#b02.xhtml#ind1251}
113. [switches, compared to buttons, [238](#c11.xhtml#Page_238)]{#b02.xhtml#ind1252}
114. [symbols]{#b02.xhtml#ind1253}
     1.  [for integrated circuit (IC), [78](#c05.xhtml#Page_78)--79]{#b02.xhtml#ind1254}
     2.  [for simple circuit diagram components, [76](#c05.xhtml#Page_76)]{#b02.xhtml#ind1255}
115. [syntax errors, [125](#c07.xhtml#Page_125)]{#b02.xhtml#ind1256}
:::

::: {.section}
## T {.Heading-1}

1.  [tabs, [118](#c06.xhtml#Page_118), [147](#c07.xhtml#Page_147)]{#b02.xhtml#ind1258}
2.  [Tai, Steven (colleague of author), [183](#c09.xhtml#Page_183)]{#b02.xhtml#ind1259}
3.  [Tangible User Interface module, [161](#c08.xhtml#Page_161)]{#b02.xhtml#ind1260}
4.  [tap sensor, [162](#c08.xhtml#Page_162)]{#b02.xhtml#ind1261}
5.  [tape]{#b02.xhtml#ind1262}
    1.  [paper tape, [83](#c05.xhtml#Page_83)]{#b02.xhtml#ind1263}
    2.  [Velcro-type tape, [204](#c09.xhtml#Page_204)]{#b02.xhtml#ind1264}
6.  [tax benefits, for using lead-free solder, [183](#c09.xhtml#Page_183)]{#b02.xhtml#ind1265}
7.  [Technical Stuff icon, [3](#c00.xhtml#Page_3)]{#b02.xhtml#ind1266}
8.  [temperature changes, [269](#c11.xhtml#Page_269)]{#b02.xhtml#ind1267}
9.  [temperature for soldering iron, [195](#c09.xhtml#Page_195)--196]{#b02.xhtml#ind1268}
10. [temperature sensors, [30](#c02.xhtml#Page_30)]{#b02.xhtml#ind1269}
11. [temperature-controlled soldering iron, [179](#c09.xhtml#Page_179), [181](#c09.xhtml#Page_181)--182]{#b02.xhtml#ind1270}
12. [terminal blocks, [203](#c09.xhtml#Page_203)--204]{#b02.xhtml#ind1271}
13. [test leads, [63](#c04.xhtml#Page_63)]{#b02.xhtml#ind1272}
14. [testing presence, [280](#c11.xhtml#Page_280)--284]{#b02.xhtml#ind1273}
15. [text editor, [35](#c02.xhtml#Page_35)]{#b02.xhtml#ind1274}
16. [TFT (thin-film transistor), [293](#c12.xhtml#Page_293)]{#b02.xhtml#ind1275}
17. [TFT touch shield, [292](#c12.xhtml#Page_292)--293]{#b02.xhtml#ind1276}
18. [Theremin, Léon, [153](#c07.xhtml#Page_153)]{#b02.xhtml#ind1277}
19. [Theremin circuit, [154](#c07.xhtml#Page_154)]{#b02.xhtml#ind1278}
20. [the Theremin, [153](#c07.xhtml#Page_153)]{#b02.xhtml#ind1279}
21. [thermal printers, [174](#c08.xhtml#Page_174)]{#b02.xhtml#ind1280}
22. [thin-film transistor (TFT), [293](#c12.xhtml#Page_293)]{#b02.xhtml#ind1281}
23. [third ground by pin 13, [22](#c02.xhtml#Page_22)]{#b02.xhtml#ind1282}
24. [third hand/helping hand, [184](#c09.xhtml#Page_184), [195](#c09.xhtml#Page_195)]{#b02.xhtml#ind1283}
25. [[`thisReading`]{.Code-within-text} variable, [229](#c10.xhtml#Page_229)]{#b02.xhtml#ind1284}
26. [tick sound, [143](#c07.xhtml#Page_143)]{#b02.xhtml#ind1285}
27. [TimerOne/Timer 1 library, [302](#c12.xhtml#Page_302)]{#b02.xhtml#ind1286}
28. [TinkerKit, [364](#c16.xhtml#Page_364)]{#b02.xhtml#ind1287}
29. [tinning the tip (soldering), [197](#c09.xhtml#Page_197)]{#b02.xhtml#ind1288}
30. [tip cleaner (soldering), [196](#c09.xhtml#Page_196)]{#b02.xhtml#ind1289}
31. [Tip icon, [2](#c00.xhtml#Page_2)]{#b02.xhtml#ind1290}
32. [toggle buttons, [238](#c11.xhtml#Page_238)]{#b02.xhtml#ind1291}
33. [Tomlinson, Benjamin (developer), [176](#c08.xhtml#Page_176)]{#b02.xhtml#ind1292}
34. [tone, sounding of, [63](#c04.xhtml#Page_63), [67](#c04.xhtml#Page_67), [143](#c07.xhtml#Page_143)]{#b02.xhtml#ind1293}
35. [tone function, [157](#c07.xhtml#Page_157)]{#b02.xhtml#ind1294}
36. [toneKeyboard sketch, [251](#c11.xhtml#Page_251)--255]{#b02.xhtml#ind1295}
37. [toneMelody sketch, [143](#c07.xhtml#Page_143)--153]{#b02.xhtml#ind1296}
38. [toolbar, [35](#c02.xhtml#Page_35)]{#b02.xhtml#ind1297}
39. [tools, for prototyping, [57](#c04.xhtml#Page_57)--67]{#b02.xhtml#ind1298}
40. [[`total`]{.Code-within-text} variable, [229](#c10.xhtml#Page_229)]{#b02.xhtml#ind1299}
41. [[`total1`]{.Code-within-text} variable, [262](#c11.xhtml#Page_262)]{#b02.xhtml#ind1300}
42. [transistor circuit, [123](#c07.xhtml#Page_123), [129](#c07.xhtml#Page_129), [130](#c07.xhtml#Page_130)]{#b02.xhtml#ind1301}
43. [transistors, [31](#c02.xhtml#Page_31), [124](#c07.xhtml#Page_124)]{#b02.xhtml#ind1302}
44. [trenches, [59](#c04.xhtml#Page_59)]{#b02.xhtml#ind1303}
45. [triangle waves, [143](#c07.xhtml#Page_143)]{#b02.xhtml#ind1304}
46. [tri-board, [192](#c09.xhtml#Page_192)]{#b02.xhtml#ind1305}
47. [troubleshooting]{#b02.xhtml#ind1306}
    1.  [not seeing any lights, [23](#c02.xhtml#Page_23)]{#b02.xhtml#ind1307}
    2.  [not seeing blinking L, [44](#c03.xhtml#Page_44)]{#b02.xhtml#ind1308}
48. [turquoise, color of official Arduino board, [24](#c02.xhtml#Page_24)]{#b02.xhtml#ind1309}
49. [tutorials]{#b02.xhtml#ind1310}
    1.  [Adafruit FONA 800 shield, [297](#c12.xhtml#Page_297)]{#b02.xhtml#ind1311}
    2.  [Adafruit motor/stepper/servo shield, [294](#c12.xhtml#Page_294)]{#b02.xhtml#ind1312}
    3.  [I^2^C, [292](#c12.xhtml#Page_292)]{#b02.xhtml#ind1313}
    4.  [joystick shield, [293](#c12.xhtml#Page_293)]{#b02.xhtml#ind1314}
    5.  [[]{#b02.xhtml#Page_383 .pagebreak role="doc-pagebreak" title="383"}MIDI, [291](#c12.xhtml#Page_291)]{#b02.xhtml#ind1315}
    6.  [MP3 player shield, [290](#c12.xhtml#Page_290)--291]{#b02.xhtml#ind1316}
    7.  [RGB LCD shield, [292](#c12.xhtml#Page_292)]{#b02.xhtml#ind1317}
    8.  [TFT touch shield, [292](#c12.xhtml#Page_292)--293]{#b02.xhtml#ind1318}
    9.  [Ultimate GPS logger shield, [296](#c12.xhtml#Page_296)]{#b02.xhtml#ind1319}
50. [tweets projects, [167](#c08.xhtml#Page_167)--168]{#b02.xhtml#ind1320}
51. [twisting wire connectors, [203](#c09.xhtml#Page_203)]{#b02.xhtml#ind1321}
52. [Twitter, [168](#c08.xhtml#Page_168)]{#b02.xhtml#ind1322}
53. [TX LED, [23](#c02.xhtml#Page_23), [42](#c03.xhtml#Page_42)]{#b02.xhtml#ind1323}
:::

::: {.section}
## U {.Heading-1}

1.  [UHU (company), [184](#c09.xhtml#Page_184)]{#b02.xhtml#ind1325}
2.  [Ultimate GPS logger shield, [295](#c12.xhtml#Page_295)--296]{#b02.xhtml#ind1326}
3.  [ultrasonic range finder, [274](#c11.xhtml#Page_274)]{#b02.xhtml#ind1327}
4.  [unbroken tone, [67](#c04.xhtml#Page_67)]{#b02.xhtml#ind1328}
5.  [United Kingdom, Arduino suppliers in, [14](#c01.xhtml#Page_14)]{#b02.xhtml#ind1329}
6.  [United States, Arduino suppliers in, [364](#c16.xhtml#Page_364). *See also* [Adafruit Industries](#b02.xhtml#ind22); [Radio Shack](#b02.xhtml#ind1024); [SparkFun Electronics](#b02.xhtml#ind1227)]{#b02.xhtml#ind1330}
7.  [United Visual Artists (UVA), [163](#c08.xhtml#Page_163), [165](#c08.xhtml#Page_165)]{#b02.xhtml#ind1331}
8.  [universal serial bus (USB), [109](#c06.xhtml#Page_109)]{#b02.xhtml#ind1332}
9.  [[`unsigned long`]{.Code-within-text}, [210](#c10.xhtml#Page_210)--211]{#b02.xhtml#ind1333}
10. [upload button, [35](#c02.xhtml#Page_35), [42](#c03.xhtml#Page_42)]{#b02.xhtml#ind1334}
11. [USB (universal serial bus), [109](#c06.xhtml#Page_109)]{#b02.xhtml#ind1335}
12. [USB A-B cable, [22](#c02.xhtml#Page_22), [30](#c02.xhtml#Page_30)]{#b02.xhtml#ind1336}
13. [USB LiPoly charger, [295](#c12.xhtml#Page_295)]{#b02.xhtml#ind1337}
14. [USB ports, [122](#c07.xhtml#Page_122)]{#b02.xhtml#ind1338}
15. [USB socket, [22](#c02.xhtml#Page_22), [40](#c03.xhtml#Page_40)]{#b02.xhtml#ind1339}
16. [UVA (United Visual Artists), [163](#c08.xhtml#Page_163), [165](#c08.xhtml#Page_165)]{#b02.xhtml#ind1340}
:::

::: {.section}
## V {.Heading-1}

1.  [v (voltage)]{#b02.xhtml#ind1342}
    1.  [AC voltage, [64](#c04.xhtml#Page_64)]{#b02.xhtml#ind1343}
    2.  [DC voltage, [64](#c04.xhtml#Page_64)]{#b02.xhtml#ind1344}
    3.  [5v as required for Uno, [50](#c03.xhtml#Page_50)]{#b02.xhtml#ind1345}
    4.  [forward voltage, [73](#c05.xhtml#Page_73), [89](#c06.xhtml#Page_89)]{#b02.xhtml#ind1346}
    5.  [generated when electronic instrument generates sound, [12](#c01.xhtml#Page_12)]{#b02.xhtml#ind1347}
    6.  [measuring of in a circuit, [63](#c04.xhtml#Page_63)--64]{#b02.xhtml#ind1348}
    7.  [probe for measuring, [63](#c04.xhtml#Page_63)]{#b02.xhtml#ind1349}
    8.  [relationship among voltage, current, and resistance, [71](#c05.xhtml#Page_71)]{#b02.xhtml#ind1350}
    9.  [reversals of, [122](#c07.xhtml#Page_122)]{#b02.xhtml#ind1351}
    10. [reverse voltage, [73](#c05.xhtml#Page_73)]{#b02.xhtml#ind1352}
    11. [7-12v as recommended for Uno R3, [23](#c02.xhtml#Page_23)]{#b02.xhtml#ind1353}
    12. [as supplied to circuit through positive end of battery, [70](#c05.xhtml#Page_70)]{#b02.xhtml#ind1354}
    13. [voltage in (Vin), [22](#c02.xhtml#Page_22)]{#b02.xhtml#ind1355}
2.  [V&A Village Fete, [174](#c08.xhtml#Page_174)]{#b02.xhtml#ind1356}
3.  [vacuum pickup tool, [182](#c09.xhtml#Page_182)]{#b02.xhtml#ind1357}
4.  [[`val`]{.Code-within-text} variable, [142](#c07.xhtml#Page_142)]{#b02.xhtml#ind1358}
5.  [van der Vleuten, Ruben (developer), [161](#c08.xhtml#Page_161)]{#b02.xhtml#ind1359}
6.  [variable resistors, [30](#c02.xhtml#Page_30), [66](#c04.xhtml#Page_66), [103](#c06.xhtml#Page_103), [113](#c06.xhtml#Page_113)]{#b02.xhtml#ind1360}
7.  [variables]{#b02.xhtml#ind1361}
    1.  [[`average`]{.Code-within-text}, [229](#c10.xhtml#Page_229)]{#b02.xhtml#ind1362}
    2.  [[`brightness`]{.Code-within-text}, [92](#c06.xhtml#Page_92), [93](#c06.xhtml#Page_93)]{#b02.xhtml#ind1363}
    3.  [[`buttonState`]{.Code-within-text}, [100](#c06.xhtml#Page_100)--101, [113](#c06.xhtml#Page_113), [216](#c10.xhtml#Page_216), [217](#c10.xhtml#Page_217), [218](#c10.xhtml#Page_218), [274](#c11.xhtml#Page_274)]{#b02.xhtml#ind1364}
    4.  [[`fadeAmount`]{.Code-within-text}, [92](#c06.xhtml#Page_92)]{#b02.xhtml#ind1365}
    5.  [[`fadeValue`]{.Code-within-text}, [96](#c06.xhtml#Page_96)]{#b02.xhtml#ind1366}
    6.  [global variables, [211](#c10.xhtml#Page_211)]{#b02.xhtml#ind1367}
    7.  [[`inputPin`]{.Code-within-text}, [229](#c10.xhtml#Page_229)]{#b02.xhtml#ind1368}
    8.  [integer variables, [92](#c06.xhtml#Page_92)--94]{#b02.xhtml#ind1369}
    9.  [[`interval`]{.Code-within-text}, [210](#c10.xhtml#Page_210)]{#b02.xhtml#ind1370}
    10. [[`lastButtonState`]{.Code-within-text}, [216](#c10.xhtml#Page_216), [217](#c10.xhtml#Page_217), [218](#c10.xhtml#Page_218)]{#b02.xhtml#ind1371}
    11. [[`led`]{.Code-within-text}, [92](#c06.xhtml#Page_92)]{#b02.xhtml#ind1372}
    12. [[`ledPin`]{.Code-within-text}, [107](#c06.xhtml#Page_107), [108](#c06.xhtml#Page_108), [236](#c10.xhtml#Page_236)]{#b02.xhtml#ind1373}
    13. [[`ledState`]{.Code-within-text}, [212](#c10.xhtml#Page_212), [216](#c10.xhtml#Page_216), [248](#c11.xhtml#Page_248)]{#b02.xhtml#ind1374}
    14. [local variables, [211](#c10.xhtml#Page_211)]{#b02.xhtml#ind1375}
    15. [[`long`]{.Code-within-text}, [92](#c06.xhtml#Page_92), [210](#c10.xhtml#Page_210)--211, [216](#c10.xhtml#Page_216), [278](#c11.xhtml#Page_278)--279]{#b02.xhtml#ind1376}
    16. [[`motorValue`]{.Code-within-text}, [131](#c07.xhtml#Page_131)]{#b02.xhtml#ind1377}
    17. [[`numReadings`]{.Code-within-text}, [227](#c10.xhtml#Page_227)]{#b02.xhtml#ind1378}
    18. [[`outputValue`]{.Code-within-text}, [117](#c06.xhtml#Page_117)--118]{#b02.xhtml#ind1379}
    19. [[`potPin`]{.Code-within-text}, [131](#c07.xhtml#Page_131)]{#b02.xhtml#ind1380}
    20. [[`potValue`]{.Code-within-text}, [131](#c07.xhtml#Page_131)]{#b02.xhtml#ind1381}
    21. [pre-defined, [49](#c03.xhtml#Page_49)]{#b02.xhtml#ind1382}
    22. [[`reading`]{.Code-within-text}, [217](#c10.xhtml#Page_217)]{#b02.xhtml#ind1383}
    23. [[`sensorMax`]{.Code-within-text}, [235](#c10.xhtml#Page_235), [236](#c10.xhtml#Page_236)]{#b02.xhtml#ind1384}
    24. [[`sensorMin`]{.Code-within-text}, [235](#c10.xhtml#Page_235), [236](#c10.xhtml#Page_236)]{#b02.xhtml#ind1385}
    25. [[`sensorVal`]{.Code-within-text}, [242](#c11.xhtml#Page_242)]{#b02.xhtml#ind1386}
    26. [[`sensorValue`]{.Code-within-text}, [107](#c06.xhtml#Page_107), [109](#c06.xhtml#Page_109), [117](#c06.xhtml#Page_117), [235](#c10.xhtml#Page_235), [236](#c10.xhtml#Page_236)]{#b02.xhtml#ind1387}
    27. [[`thisReading`]{.Code-within-text}, [229](#c10.xhtml#Page_229)]{#b02.xhtml#ind1388}
    28. [[`total`]{.Code-within-text}, [229](#c10.xhtml#Page_229)]{#b02.xhtml#ind1389}
    29. [[`total1`]{.Code-within-text}, [262](#c11.xhtml#Page_262)]{#b02.xhtml#ind1390}
    30. [[`val`]{.Code-within-text}, [142](#c07.xhtml#Page_142)]{#b02.xhtml#ind1391}
8.  [Velcro-type tape, [204](#c09.xhtml#Page_204)]{#b02.xhtml#ind1392}
9.  [ventilated environment, [190](#c09.xhtml#Page_190)]{#b02.xhtml#ind1393}
10. [verify button, [35](#c02.xhtml#Page_35), [42](#c03.xhtml#Page_42)]{#b02.xhtml#ind1394}
11. [[]{#b02.xhtml#Page_384 .pagebreak role="doc-pagebreak" title="384"}Verplank, Bill (designer), [8](#c01.xhtml#Page_8)]{#b02.xhtml#ind1395}
12. [vibration, measurement of, [244](#c11.xhtml#Page_244)]{#b02.xhtml#ind1396}
13. [Vin (voltage in), [22](#c02.xhtml#Page_22)]{#b02.xhtml#ind1397}
14. [Vitamins Design Ltd., [165](#c08.xhtml#Page_165), [167](#c08.xhtml#Page_167)]{#b02.xhtml#ind1398}
15. [void, [47](#c03.xhtml#Page_47)--48]{#b02.xhtml#ind1399}
16. [void loop (section of code), [46](#c03.xhtml#Page_46), [47](#c03.xhtml#Page_47), [48](#c03.xhtml#Page_48)]{#b02.xhtml#ind1400}
17. [[`void loop`]{.Code-within-text} function, [48](#c03.xhtml#Page_48)]{#b02.xhtml#ind1401}
18. [void setup (section of code), [46](#c03.xhtml#Page_46), [48](#c03.xhtml#Page_48)]{#b02.xhtml#ind1402}
19. [voltage (v)]{#b02.xhtml#ind1403}
    1.  [AC voltage, [64](#c04.xhtml#Page_64)]{#b02.xhtml#ind1404}
    2.  [DC voltage, [64](#c04.xhtml#Page_64)]{#b02.xhtml#ind1405}
    3.  [5v as required for Uno, [50](#c03.xhtml#Page_50)]{#b02.xhtml#ind1406}
    4.  [forward voltage, [73](#c05.xhtml#Page_73), [89](#c06.xhtml#Page_89)]{#b02.xhtml#ind1407}
    5.  [generated when electronic instrument generates sound, [12](#c01.xhtml#Page_12)]{#b02.xhtml#ind1408}
    6.  [measuring of in a circuit, [63](#c04.xhtml#Page_63)--64]{#b02.xhtml#ind1409}
    7.  [probe for measuring, [63](#c04.xhtml#Page_63)]{#b02.xhtml#ind1410}
    8.  [relationship among voltage, current, and resistance, [71](#c05.xhtml#Page_71)]{#b02.xhtml#ind1411}
    9.  [reversals of, [122](#c07.xhtml#Page_122)]{#b02.xhtml#ind1412}
    10. [reverse voltage, [73](#c05.xhtml#Page_73)]{#b02.xhtml#ind1413}
    11. [7-12v as recommended for Uno R3, [23](#c02.xhtml#Page_23)]{#b02.xhtml#ind1414}
    12. [as supplied to circuit through positive end of battery, [70](#c05.xhtml#Page_70)]{#b02.xhtml#ind1415}
    13. [voltage in (Vin), [22](#c02.xhtml#Page_22)]{#b02.xhtml#ind1416}
20. [voltage in (Vin), [22](#c02.xhtml#Page_22)]{#b02.xhtml#ind1417}
21. [volume control knob, [103](#c06.xhtml#Page_103), [113](#c06.xhtml#Page_113)]{#b02.xhtml#ind1418}
22. [VΩHz socket, [63](#c04.xhtml#Page_63)]{#b02.xhtml#ind1419}
:::

::: {.section}
## W {.Heading-1}

1.  [Warning icon, [2](#c00.xhtml#Page_2)]{#b02.xhtml#ind1421}
2.  [Watson, Theo (developer), [310](#c13.xhtml#Page_310)]{#b02.xhtml#ind1422}
3.  [Watterott, Stephan (supplier), [28](#c02.xhtml#Page_28)]{#b02.xhtml#ind1423}
4.  [Watterott Electronic (supplier), [28](#c02.xhtml#Page_28)]{#b02.xhtml#ind1424}
5.  [watts (P), [70](#c05.xhtml#Page_70), [71](#c05.xhtml#Page_71)]{#b02.xhtml#ind1425}
6.  [Wave shield, [289](#c12.xhtml#Page_289)--290]{#b02.xhtml#ind1426}
7.  [waves, [143](#c07.xhtml#Page_143)]{#b02.xhtml#ind1427}
8.  [wearable electronics, [26](#c02.xhtml#Page_26)]{#b02.xhtml#ind1428}
9.  [WEEE (European Union Waste Electrical and Electronic Equipment Directive), [183](#c09.xhtml#Page_183)]{#b02.xhtml#ind1429}
10. [Weller solder stations, [182](#c09.xhtml#Page_182)]{#b02.xhtml#ind1430}
11. [Westaway, Adrian (cofounder Vitamins Design Ltd.), [165](#c08.xhtml#Page_165)]{#b02.xhtml#ind1431}
12. [[`while`]{.Code-within-text} loop, [235](#c10.xhtml#Page_235)]{#b02.xhtml#ind1432}
13. [white, as possible color of power, [90](#c06.xhtml#Page_90)]{#b02.xhtml#ind1433}
14. [White Tack (adhesive putty), [184](#c09.xhtml#Page_184)]{#b02.xhtml#ind1434}
15. [WiFi library, [300](#c12.xhtml#Page_300)]{#b02.xhtml#ind1435}
16. [WiFi Shield, [300](#c12.xhtml#Page_300)]{#b02.xhtml#ind1436}
17. [Windows]{#b02.xhtml#ind1437}
    1.  [installing Arduino, [33](#c02.xhtml#Page_33)]{#b02.xhtml#ind1438}
    2.  [Max/Pure Data, [308](#c13.xhtml#Page_308)]{#b02.xhtml#ind1439}
    3.  [menu bar in, [34](#c02.xhtml#Page_34)]{#b02.xhtml#ind1440}
    4.  [naming of serial ports, [40](#c03.xhtml#Page_40)]{#b02.xhtml#ind1441}
    5.  [OpenFrameworks, [310](#c13.xhtml#Page_310)]{#b02.xhtml#ind1442}
    6.  [Processing, [306](#c13.xhtml#Page_306)]{#b02.xhtml#ind1443}
18. [Windows Media Audio (WMA), [290](#c12.xhtml#Page_290)]{#b02.xhtml#ind1444}
19. [WingShield Industries, [289](#c12.xhtml#Page_289)]{#b02.xhtml#ind1445}
20. [wire cutters, [185](#c09.xhtml#Page_185)--186]{#b02.xhtml#ind1446}
21. [Wire library, [300](#c12.xhtml#Page_300)]{#b02.xhtml#ind1447}
22. [wire strippers, [186](#c09.xhtml#Page_186)--187, [200](#c09.xhtml#Page_200)]{#b02.xhtml#ind1448}
23. [Wiring board, [7](#c01.xhtml#Page_7), [9](#c01.xhtml#Page_9)--11]{#b02.xhtml#ind1449}
24. [Wiring project, [9](#c01.xhtml#Page_9)]{#b02.xhtml#ind1450}
25. [WMA (Windows Media Audio), [290](#c12.xhtml#Page_290)]{#b02.xhtml#ind1451}
26. [workshops on Arduino, [362](#c15.xhtml#Page_362)]{#b02.xhtml#ind1452}
27. [workspace]{#b02.xhtml#ind1453}
    1.  [preparation of general workspace, [32](#c02.xhtml#Page_32)--33]{#b02.xhtml#ind1454}
    2.  [for soldering, [178](#c09.xhtml#Page_178)--179]{#b02.xhtml#ind1455}
:::

::: {.section}
## X {.Heading-1}

1.  [XBee wireless module, [162](#c08.xhtml#Page_162), [174](#c08.xhtml#Page_174)]{#b02.xhtml#ind1457}
:::

::: {.section}
## Y {.Heading-1}

1.  [YouTube, [361](#c15.xhtml#Page_361)]{#b02.xhtml#ind1459}
:::

::: {.section}
## Z {.Heading-1}

1.  [zero indexing, [140](#c07.xhtml#Page_140), [150](#c07.xhtml#Page_150)]{#b02.xhtml#ind1461}
2.  [[`0`]{.Code-within-text} values, [111](#c06.xhtml#Page_111)]{#b02.xhtml#ind1462}
:::
:::

[]{#eula.xhtml}

::: {.section .EULAhead}
```{=html}
<header>
```
# WILEY END USER LICENSE AGREEMENT {.Chap-Title}

```{=html}
</header>
```
::: {.section .EULA}
Go to [www.wiley.com/go/eula](http://www.wiley.com/go/eula) to access Wiley's ebook EULA.
:::
:::
