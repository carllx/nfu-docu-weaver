classic_data <- RP$Classic %>%
mutate(type = "classic", label = Reference, size = Freq / max(Freq) * 80)
related_data <- RP$Related %>%
rename(Year = PY) %>%
mutate(type = "related", label = TI, size = TC / max(TC) * 80)
classic_data$Year <- as.numeric(classic_data$Year)
related_data$Year <- as.numeric(related_data$Year)
classic_data$y_position <-
seq(1, nrow(classic_data), length.out = nrow(classic_data))
related_data$y_position <-
seq(1, nrow(related_data), length.out = nrow(related_data))
classic_data$color <-
paletteer_d(palette = "ggsci::nrc_npg", n = nrow(classic_data))
related_data$color <-
"#040404"
return(list(classic = classic_data, related = related_data))
}
# Function to plot nodes with text labels only for classic nodes
plot_nodes <- function(p, data, node_type) {
if (node_type == "classic") {
# Classic nodes: with text
p <- p %>% add_trace(
data = data,
x = ~Year, y = ~y_position,
type = "scatter",
mode = "markers+text", # Adding text to markers for classic nodes
marker = list(size = ~size, color = data$color, line = list(width = 0)),
text = ~label,
textposition = "bottom center", # Position text below classic nodes
textfont = list(size = 8), # Text font size for classic nodes
hoverinfo = "text"
)
} else {
# Related nodes: without text
p <- p %>% add_trace(
data = data,
text = ~label,
x = ~Year, y = ~y_position,
type = "scatter", mode = "markers", # No text for related nodes
marker = list(size = ~size, color = data$color, line = list(width = 0)),
hoverinfo = "text"
)
}
return(p)
}
add_smooth_curved_edges <- function(p, related_data, classic_data) {
for (i in seq_len(nrow(related_data))) {
related_paper <- related_data[i, ]
classic_refs <- strsplit(related_paper$classicRef, ";")[[1]]
for (ref in classic_refs) {
classic_paper <- classic_data[classic_data$Reference == ref, ]
if (nrow(classic_paper) == 1) {
# Manually calculate intermediate points for a smoother curve
curve_x <- seq(related_paper$Year, classic_paper$Year, length.out = 100)
curve_y <- sapply(curve_x, function(x) {
start_x <- related_paper$Year
end_x <- classic_paper$Year
start_y <- related_paper$y_position
end_y <- classic_paper$y_position
mid_y <- max(start_y, end_y) + 4
((1 - ((x - start_x) / (end_x - start_x)))^2 * start_y) +
(2 * (1 - ((x - start_x) / (end_x - start_x))) *
((x - start_x) / (end_x - start_x)) * mid_y) +
(((x - start_x) / (end_x - start_x))^2 * end_y)
})
p <- p %>% add_trace(
x = curve_x, y = curve_y,
type = "scatter", mode = "lines",
line = list(color = classic_paper$color, width = 1, opacity = 0.5),
hoverinfo = "none"
)
}
}
}
return(p)
}
# Function to create kables with classic papers as headings
create_kable_per_classic <- function(data, classic_papers) {
tables <- list()
for (classic_paper in classic_papers$Reference) {
table_data <- filter(data, classicRef == classic_paper)
if (nrow(table_data) > 0) {
# Create table
table <- kable(
table_data %>%
select(TI, Publication_Years, Total_Citations),
caption = paste(classic_paper),
format = "markdown"
)
tables[[classic_paper]] <- table
}
}
return(tables)
}
get_reference_pyramid <- function(classic_num=4, dataFrame) {
# Generate Reference Pyramid top 4
# Also return plot on spectroscopy$spectroscopy
ref_pyramid <- reference_pyramid(top_n_ref = classic_num, dataFrame = dataFrame)
# May filter by H-index ...
# filter by TC > 40
ref_pyramid$Related <-
ref_pyramid$Related[
order(ref_pyramid$Related$TC, decreasing = TRUE) &
ref_pyramid$Related$TC > 40,
]
# Generate Plotly
# Prepare data
data <- prepare_data(ref_pyramid)
p <- plot_ly()
# Add classic and related papers as nodes
p <- plot_nodes(p, data$classic, "classic")
p <- plot_nodes(p, data$related, "related")
# Add curved edges
p <- add_smooth_curved_edges(p, data$related, data$classic)
# Layout adjustments
p <- p %>% layout(
title = "Reference Pyramid Graph",
xaxis = list(title = "Year"),
yaxis = list(title = "(H-index?)")
)
# Render the plot
# p
# Kable
# Process the data
processed_data <- ref_pyramid$Related %>%
mutate(classicRef = strsplit(as.character(classicRef), ";")) %>%
unnest(cols = c(classicRef)) %>%
group_by(classicRef) %>%
mutate(Publication_Years = PY, Total_Citations = TC) %>%
select(-classicRef) %>%
ungroup()
# Create tables
classic_papers <- ref_pyramid$Classic
all_tables <- create_kable_per_classic(processed_data, classic_papers)
# Display all tables
#  (in an R Markdown document, use 'knitr::kable' to render these tables)
return(list(
plotly_pyramid = p,
kable_pyramid = all_tables,
plot_spectroscopy = ref_pyramid$plot_spectroscopy
))
}
test <- function() {
# Read the data
options(repos = c(CRAN = "https://cran.rstudio.com/"))
Sys.setenv(LANG = "en")
thematic <- "Online education platform analysis"
dir_m <- paste0("/Users/yamlam/Documents/obsdiannote/🧪 Script Labs/Thematic/", thematic, "/exports/M.feather") # nolint: line_length_linter.
m_data <- read_feather(dir_m)
# Assign SR as column names
m_data <- as.data.frame(m_data)
rownames(m_data) <- as.character(m_data$SR)
# Get the reference pyramid
ref_pyramid <- get_reference_pyramid(classic_num = 4, dataFrame = m_data)
# Render the plot
ref_pyramid$plotly_pyramid
# Render the tables
ref_pyramid$kable_pyramid
# Render the spectroscopy
ref_pyramid$plot_spectroscopy
return(ref_pyramid)
}
# debug(create_kable_per_classic)
test_d <- test()
library(htmlwidgets)
htmlwidgets::saveWidget(as_widget(test_d$plotly_pyramid), "index.html")
htmlwidgets::saveWidget(as_widget(test_d$plotly_pyramid), "/Users/yamlam/Downloads/index.html")
htmlwidgets::saveWidget(as_widget(test_d$plotly_pyramid), "/Users/yamlam/Downloads/index.png")
htmlwidgets::saveWidget(as_widget(test_d$plotly_pyramid), "/Users/yamlam/Downloads/index.html")
orca(test_d$plotly_pyramid, file = "image.png")
install.packages(orca)
q
q()
# It's a structured approach using a "Impact Pyramid" model
# to categorize and prioritize research papers.
# Classic Paper (Apex of the Pyramid):
#   This is a foundational paper in the research field,
#   usually written by a highly respected scholar.
#   It introduces the fundamental concepts and theories
#   that define the entire research area. Citing this paper
#   helps to establish the domain of your research and pays
#   homage to its pioneering author.
# - Core Papers (Middle Layer of the Pyramid): These are four
#   significant papers written by leading scholars, often
#   current academic stars. These papers build upon the
#   classic paper's insights, offering more practical and
#   advanced theoretical frameworks and research methodologies.
#   They often lead current trends in the field.
# - Supporting Papers (Base of the Pyramid): These consist of
#   ten papers that apply the theories and methods from the
#   core papers to real-world issues, contributing tangible
#   case studies to the field. They help in identifying
#   research gaps and learning how to apply established
#   theories and methods to specific research questions.
# (-- `15篇文献的独门配方，产出一篇高质量rp！`[xiaohongshu](https://www.xiaohongshu.com/explore/64426cb900000000130126d5?app_platform=ios&app_version=8.23.2&author_share=1&share_from_user_hidden=true&type=video&xhsshare=CopyLink&appuid=61aa31f5000000000202472e&apptime=1706497377)) # nolint: line_length_linter.
# The following function is a test to hightlight the most
# referenced papers in a given dataset
# function name: Reference_Pyramid as helper to remember the
# purpose of the research
library(feather)
library(dplyr)
library(tidyr)
library(knitr)
library(plotly)
library(paletteer)
library(bibliometrix)
# Ensure necessary packages are installed and loaded
if (!requireNamespace("paletteer", quietly = TRUE)) {
install.packages("paletteer")
}
if (!requireNamespace("bezier", quietly = TRUE)) {
install.packages("bezier")
}
find_related_papers <- function(dataframe, reference_name) {
# Example: referenceName could be
# "BRAUN VIRGINIA 2006 QUAL RES PSYCHOL"
# "BRAUN VIRGINIA., 2006, QUAL. RES. PSYCHOL, V3, P77, DOI DOI ..",
# "BRAUN VIRGINIA 2006 QUAL RES PSYCHOL",
# "BRAUN VIRGINIA 2006",
# "FORNELL C 1981",
# Simplify the reference name for flexible matching
simplified_reference_name <- tolower(gsub("[[:punct:] ]", "", reference_name))
# Function to simplify the CR field
simplify_cr <- function(cr) {
sapply(cr, function(x) tolower(gsub("[[:punct:] ]", "", x)))
}
# Simplify the CR field in the data frame
simplified_cr <- simplify_cr(dataframe$CR)
# Find matches with the simplified reference name
matches <- grep(simplified_reference_name, simplified_cr)
# Select the relevant rows and columns from the original data frame
result_dataframe <- dataframe[matches, c("TI", "PY", "TC")]
# Add the SR field to the resultDataFrame$classicRef
result_dataframe$classicRef <- reference_name
return(result_dataframe)
}
# Reference_Pyramid, create a dataframe contain classicRef, relatedPapers
reference_pyramid <- function(top_n_ref, dataFrame) {
# find the top n referenced papers
spectroscopy <- rpys(dataFrame)
# Find the top 5 most referenced papers
cr <- spectroscopy[["CR"]]
cr <- cr[order(spectroscopy[["CR"]]$Freq, decreasing = TRUE), ]
cr <- cr[1:top_n_ref, ]
# create an empty dataframe
Related <- data.frame(
TI = character(),
TC = numeric(),
PY = numeric(),
classicRef = character()
)
Classic <- cr
# loop through the top 5 most referenced papers, and find the related papers
for (i in seq_len(nrow(cr))) {
# find the related papers
rp <- find_related_papers(dataFrame, cr[i, ]$Reference)
for (i in seq_len(nrow(rp))) {
ti <- rp$TI[i]
idx <- which(Related$TI == ti)
if (length(idx) == 0) {
# Title not seen before, append new row
new_row <- data.frame(
TI = ti,
TC = rp$TC[i],
PY = rp$PY[i],
classicRef = rp$classicRef[i],
stringsAsFactors = FALSE
)
Related <- rbind(Related, new_row)
} else {
# Title found, add to Classic with sep = ";"
Related$classicRef[[idx]] <-
paste(Related$classicRef[[idx]], rp$classicRef[[i]], sep = ";")
}
}
}
# return two dataframe contain classicRef and Related
return(list(
Classic = Classic,
Related = Related,
plot_spectroscopy = spectroscopy
))
}
# Plotting an Interactive Network Graph of Classic and Related Papers
# This code generates an interactive network graph using the plotly library
# in R. The graph consists of two types of nodes: classic papers and related
# papers.
# Classic papers are represented by gray circles, with the reference name
# extracted from RP$Classic$Reference. The size of the circles is determined
# by RP$Classic$Freq, and the x-axis represents the publication year of the
# classic papers. The y-axis position of the classic papers is arbitrary
# but non-overlapping.
# Related papers are represented by white circles, with the title extracted
# from RP$Related$TI. The size of the circles is determined by RP$Related$TC.
# Each related paper is connected to the corresponding classic papers
# (separated by ';') from RP$Related$classicRef using lines with arrowheads.
# The x-axis position of each related paper is aligned with its publication
# year (RP$Related$PY).
# Both classic and related papers can be moved within the graph. The x-axis
# represents the years, and the y-axis represents the number of citations.
# The range of the x-axis covers both the publication years of the classic
# papers (RP$Classic$Year) and the publication years of
# the related papers (RP$Related$PY).
# The resulting graph provides an interactive visualization of the relationships
# between classic and related papers based on their publication years and
# citation counts.# > str(RP)
# List of 2
#  $ Classic: tibble [5 × 3] (S3: tbl_df/tbl/data.frame)
#   ..$ Year     : chr [1:5] "2006" "1981" "1989" "2010" ...
#   ..$ Reference: chr [1:5] "BRAUN VIRGINIA 2006 QUAL RES " "FORNELL  ...
#   ..$ Freq     : int [1:5] 116 76 70 66 51
#  $ Related:'data.frame':	305 obs. of  4 variables:
#   ..$ TI        : chr [1:305] "STRUCTURING KNOWLEDGE-BUILDING  ...
#   ..$ TC        : num [1:305] 3 6 2 4 7 0 0 0 0 12 ...
#   ..$ PY        : num [1:305] 2023 2017 2022 2021 2021 ...
#   ..$ classicRef: chr [1:305] "GÜLER K, 2023, INT J ...
# Data Preparation
prepare_data <- function(RP) {
if (is.null(RP$Classic) || is.null(RP$Related)) {
stop("Error: 'RP$Classic' or 'RP$Related' is NULL. Please check your data.")
}
classic_data <- RP$Classic %>%
mutate(type = "classic", label = Reference, size = Freq / max(Freq) * 80)
related_data <- RP$Related %>%
rename(Year = PY) %>%
mutate(type = "related", label = TI, size = TC / max(TC) * 80)
classic_data$Year <- as.numeric(classic_data$Year)
related_data$Year <- as.numeric(related_data$Year)
classic_data$y_position <-
seq(1, nrow(classic_data), length.out = nrow(classic_data))
related_data$y_position <-
seq(1, nrow(related_data), length.out = nrow(related_data))
classic_data$color <-
paletteer_d(palette = "ggsci::nrc_npg", n = nrow(classic_data))
related_data$color <-
"#040404"
return(list(classic = classic_data, related = related_data))
}
# Function to plot nodes with text labels only for classic nodes
plot_nodes <- function(p, data, node_type) {
if (node_type == "classic") {
# Classic nodes: with text
p <- p %>% add_trace(
data = data,
x = ~Year, y = ~y_position,
type = "scatter",
mode = "markers+text", # Adding text to markers for classic nodes
marker = list(size = ~size, color = data$color, line = list(width = 0)),
text = ~label,
textposition = "bottom center", # Position text below classic nodes
textfont = list(size = 8), # Text font size for classic nodes
hoverinfo = "text"
)
} else {
# Related nodes: without text
p <- p %>% add_trace(
data = data,
text = ~label,
x = ~Year, y = ~y_position,
type = "scatter", mode = "markers", # No text for related nodes
marker = list(size = ~size, color = data$color, line = list(width = 0)),
hoverinfo = "text"
)
}
return(p)
}
add_smooth_curved_edges <- function(p, related_data, classic_data) {
for (i in seq_len(nrow(related_data))) {
related_paper <- related_data[i, ]
classic_refs <- strsplit(related_paper$classicRef, ";")[[1]]
for (ref in classic_refs) {
classic_paper <- classic_data[classic_data$Reference == ref, ]
if (nrow(classic_paper) == 1) {
# Manually calculate intermediate points for a smoother curve
curve_x <- seq(related_paper$Year, classic_paper$Year, length.out = 100)
curve_y <- sapply(curve_x, function(x) {
start_x <- related_paper$Year
end_x <- classic_paper$Year
start_y <- related_paper$y_position
end_y <- classic_paper$y_position
mid_y <- max(start_y, end_y) + 4
((1 - ((x - start_x) / (end_x - start_x)))^2 * start_y) +
(2 * (1 - ((x - start_x) / (end_x - start_x))) *
((x - start_x) / (end_x - start_x)) * mid_y) +
(((x - start_x) / (end_x - start_x))^2 * end_y)
})
p <- p %>% add_trace(
x = curve_x, y = curve_y,
type = "scatter", mode = "lines",
line = list(color = classic_paper$color, width = 1, opacity = 0.5),
hoverinfo = "none"
)
}
}
}
return(p)
}
# Function to create kables with classic papers as headings
create_kable_per_classic <- function(data, classic_papers) {
tables <- list()
for (classic_paper in classic_papers$Reference) {
table_data <- filter(data, classicRef == classic_paper)
if (nrow(table_data) > 0) {
# Create table
table <- kable(
table_data %>%
select(TI, Publication_Years, Total_Citations),
caption = paste(classic_paper),
format = "markdown"
)
tables[[classic_paper]] <- table
}
}
return(tables)
}
get_reference_pyramid <- function(classic_num=4, dataFrame) {
# Generate Reference Pyramid top 4
# Also return plot on spectroscopy$spectroscopy
ref_pyramid <- reference_pyramid(top_n_ref = classic_num, dataFrame = dataFrame)
# May filter by H-index ...
# filter by TC > 40
ref_pyramid$Related <-
ref_pyramid$Related[
order(ref_pyramid$Related$TC, decreasing = TRUE) &
ref_pyramid$Related$TC > 40,
]
# Generate Plotly
# Prepare data
data <- prepare_data(ref_pyramid)
p <- plot_ly()
# Add classic and related papers as nodes
p <- plot_nodes(p, data$classic, "classic")
p <- plot_nodes(p, data$related, "related")
# Add curved edges
p <- add_smooth_curved_edges(p, data$related, data$classic)
# Layout adjustments
p <- p %>% layout(
title = "Reference Pyramid Graph",
xaxis = list(title = "Year"),
yaxis = list(title = "(H-index?)")
)
# Render the plot
# p
# Kable
# Process the data
processed_data <- ref_pyramid$Related %>%
mutate(classicRef = strsplit(as.character(classicRef), ";")) %>%
unnest(cols = c(classicRef)) %>%
group_by(classicRef) %>%
mutate(Publication_Years = PY, Total_Citations = TC) %>%
select(-classicRef) %>%
ungroup()
# Create tables
classic_papers <- ref_pyramid$Classic
all_tables <- create_kable_per_classic(processed_data, classic_papers)
# Display all tables
#  (in an R Markdown document, use 'knitr::kable' to render these tables)
return(list(
plotly_pyramid = p,
kable_pyramid = all_tables,
plot_spectroscopy = ref_pyramid$plot_spectroscopy
))
}
test <- function() {
# Read the data
options(repos = c(CRAN = "https://cran.rstudio.com/"))
Sys.setenv(LANG = "en")
thematic <- "Online education platform analysis"
dir_m <- paste0("/Users/yamlam/Documents/obsdiannote/🧪 Script Labs/Thematic/", thematic, "/exports/M.feather") # nolint: line_length_linter.
m_data <- read_feather(dir_m)
# Assign SR as column names
m_data <- as.data.frame(m_data)
rownames(m_data) <- as.character(m_data$SR)
# Get the reference pyramid
ref_pyramid <- get_reference_pyramid(classic_num = 4, dataFrame = m_data)
# Render the plot
ref_pyramid$plotly_pyramid
# Render the tables
ref_pyramid$kable_pyramid
# Render the spectroscopy
ref_pyramid$plot_spectroscopy
return(ref_pyramid)
}
# debug(create_kable_per_classic)
test_d <- test()
library(htmlwidgets)
htmlwidgets::saveWidget(as_widget(test_d$plotly_pyramid), "/Users/yamlam/Downloads/index.html")
orca(test_d$plotly_pyramid, file = "/Users/yamlam/Downloads/index.png")
kaleido
# save as png
kaleido(test_d$plotly_pyramid, file = "/Users/yamlam/Downloads/index.png")
# save as png
save_image(test_d$plotly_pyramid, "/Users/yamlam/Downloads/index.png")
# save as png
save_image(test_d$plotly_pyramid, "/Users/yamlam/Downloads/index.png")
# save as png
library(reticulate)
install.packages('reticulate')
install.packages('reticulate')
save_image(test_d$plotly_pyramid, "/Users/yamlam/Downloads/index.png")
save_image(test_d$plotly_pyramid, "/Users/yamlam/Downloads/index.png")
# save as png
reticulate::install_miniconda()
reticulate::conda_install('r-reticulate', 'plotly', channel = 'plotly')
reticulate::use_miniconda('r-reticulate')
save_image(test_d$plotly_pyramid, "/Users/yamlam/Downloads/index.png")
q()
# save as png
reticulate::install_miniconda()
reticulate::conda_install('r-reticulate', 'python-kaleido')
reticulate::use_miniconda('r-reticulate')
q()
