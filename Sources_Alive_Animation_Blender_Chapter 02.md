
## 02-01-Object transformation

In blender almost any input can be animated. Whether it's an object position, the armature or a character, or even the color of an object. Let's start simple with object transformation. In this chapter, we will focus on object animation. An understanding what an object is, is crucial. An object in blender is a simple container and depending on what kind of object you've added it contains different objects datas like mesh datas, camera datas or empty datas. These datas can be transferred from one object to the other. The important thing regarding object animation are not these object on mesh datas, but the object transform data. The position of the object in space reserved of its location transform. Its orientation is based on its rotation values and size is the result of its original size multiplied by its current scale. For example, acute mesh that is one meter tall and has a scale of 1.5 will be 1.5 meter tolls in the viewport. These coordinates and transform information are affecting the origin of the object. So while the mesh object might look offset, its position is not linked to its geometry, but only to its origin point. So basically when transforming an object you're just transforming its origin point. We can see that everything rotates or scale around or toward the origin point. We can see this doted line between my mouse cursor and the origin point of the object, showing the pivot to use for this transformation. The current location of the object is based on this origin point. And it's measured based on the origin of the blender scene or the origin of old space. So by default the origin of an object is it's transformation pivot and what we are going to animate. even if an object seems to be made of multiple object the only important thing for animation is its origin point. You can use the different gizmos available in the tool panel to transform your object. I generally prefer to use the shortcuts G to move, S to scale and R to rotate combined with XYZ and shift to constraint around specific axis. To summarize, any kind of object has an origin point. When animating an object, we are manipulating its origin coordinate. So manipulating an object, is manipulating a single point in space.

## 02-02-Object transform channel

[Man] The previous video, we have seen that object transform is based on its pivot point. Now let's see what we are currently transforming. As a Blender user and a 3D artist, you know that in space we are using the x-, y-, and z-axis to move our objects. We can find the representation of those axes on the grid with the x- and y-axes being those red and green lines. And also on the view widget on the top right corner, that allow us to switch to the different views. When an object is not transformed, its position is aligned with the world origin. As soon as we input some values into its x-coordinate, for example, it will slide, moving along the x-ward axis, and it will behave the same whether we are playing with the y or z value. There is no limitation to those value, they can be positive or negative, and our object will move left, right, up, and down, or front and back, depending on those. If I enter a value of one and one on x and z, we can see our object offset from the center of our scene. When it comes to rotation, we don't rotate along an axis, but around an axis. If I rotate around the x-axis, I can see my x rotation value changing, and my object is currently rotating around the red arrow. And as always, the origin of the object is used as the origin of the rotation. If you have difficulties understanding on which axis you are going to rotate, you can activate the rotation gizmo that make it more obvious. If I now perform a scanning pressing S and concentrate it on the x-axis pressing x, you can see that I'm scaling my object along the selected axis. The same on the y-axis here or on the z-axis. So, scaling is along the object axis. One last option that is available for object is delta transform. When I go into the object properties, I can see this delta transform panel that looks like the classic transform panel. Delta transforms behave the same way as transform, but they are added on top of your transformation. So you can see here, when I add the delta transform of one and one on top of my one and one classic transform, my object is offset to the position two on x and two on z. To be honest, I almost never use the delta transform, and I don't think we will be using it during this course. It can be useful whenever you want to offset an existing object animation, for example. Let's say you have animate an up and down motion and you want to easily offset it on the side. Using the delta transform will make your life easier. But there are other way to do it, and we will see that during the course. To summarize, we have seen that location, transformation, and scaling are done along the axis, while rotation is done around the axis, and we can offset an animation using delta transform.

## 02-03-First Keyframe

[Pierre] Now that we have a better understanding of object transformation, let's start animating. We will work on the classic bouncing ball. Since I'd like to be able to squash and stretch the ball during the animation, using its very center as a pivot point is not ideal. What I'd like to do instead is adding its origin point on the base of the ball as this is going to be the contacting point of the ball with our imaginary ground. So I will simply enter edit mode, select every vertices and press G, Z, and one to move everything off one meter on the Z axis. When they get back into object mode, I still have the same sphere, but its origin is now on its place. By default, the timeline in Blender is in the bottom of the screen. When you press space, you can see that we are playing an animation, meaning that blender is going through the different frame of the document. The play head in the timeline indicate which frame you are currently reading. We can change the length of the animation by setting the end frame and the beginning frame. I will set the beginning frame to zero and end frame to 24. When I press play, we can see the play head moving till frame 24 and getting back to frame zero. This value indicates you in the current frame that is also alight on top of the play head. Animation in Blender is basically recording a different transformation to an object in time, meaning that we can recall the location, rotation or scale of an object on different frames. To insert a key frame, we simply need to have our object selected in space and press the I key. A menu will pop up asking you which kind of key frame you want to write. Basically, do you want to recall the location, the rotation, the scale of the object or a combination of those? When I select location, we can see that in the transform channel of my object, the location input turn to yellow. And on the timeline, I get a little yellow indicator that tells me we have recorded a key frame. The key frame is a simple registered value in time. In our case, we have registered or recorded the location of our object on frame zero. I will place to play head on frame 10 and move my object higher and insert a location key frame. Now I can see a new key frame on my timeline, and as soon as I move the play head from left to right, I can see sphere moving from its previous position on frame zero, to the next position we have key framed on frame 10. We have recorded two position on two different frame and what we are seeing now is Blender interpolating or creating an interpolation between those two position in space. key frames can be manipulated in the timeline as objects, so you can move them using G, you can press Shift + D to duplicate them. You can box select them, press X to delete them. You can insert a new key frame by simply hovering over a transformed channel and pressing I or right-clicking and choose between insert key frame or insert single key frame if you just want to add a key frame on the X location, for example. Right clicking will also hollow you to delete all the key frames from the selected channel or choose delete only single key frame to delete a specific X, Y, or Z channel. So let's start our exercise on frame zero and insert a key frame. Let's moved the play head to frame 12 and then move our sphere or ball on the Z axis by eight meters. We can see that our transformed channels have changed color. The X and Y are still on green, meaning that they have been key framed previously and their values haven't changed. And the Z key frame as turned to orange, meaning that we have transformed the Z value, but it's not recorded yet. And this is a big warning, because as soon as I will move the play head, my ball will return to its first key frame position, meaning that I have lost the Z transformation I've performed on frame 12 because I haven't recorded it. So I will jump back to frame 12, move my sphere of eight meters and then press I to insert a key frame. If I now scrub through frame zero to frame 12, I can see the ball rising in the air. So transformed channels are colored in yellow whenever I'm hitting a key frame and they are green whenever I'm in between or during an interpolation. I can select the first key frame, press Shift + D and move it onto the very last frame so that I have a looping action. To create a loop you just have to make your first and last frames being the same. You can move from frame to frame by pressing the left and right arrow. Whenever you will press the up and down arrow, you will jump from the previous to the next key frame. Pressing Shift + right and Shift + left will bring you to the very last of the very first key frame. You can perform all those play head manipulation using the UI in the header of the timeline. As we have seen before, anytime while I'm moving our object somewhere, we need to insert a key frame or we will lose the manipulation we have done. While it might be okay to press I each time we perform a manual manipulation on the single bouncing ball, when you will start animating a full character with thousands of controls, that's gonna be very tedious. Fortunately, there is the record button here that allow us to auto key any transformation. As soon as I move the sphere, you can see that new keys are being recorded for every channel of this fear automatically. Not that whenever you are using this option and moving your object in space, you are warned that there is an auto keying going on on the top right corner of your (indistinct) As explained in the beginning, we can keep frame mostly every kind of value in Blender, and it can be a color. If I select the material preview of my sphere and I click this little rounded icon, it will add a key frame on the color value. And I can find this key frame on the timeline. If I go a little further now and change the color, since the auto keying is on, it will insert a new key frame of this new color. And whenever I scrub through the timeline, I can see the color interpolation of the sphere. To summarize, we have seen that we can use the timeline to navigate through the different frames. We have seen that we can create a key frame by recording any value, whether it's a transformed channel, a color or whatever we want onto a specific frame. Blender will automatically create an interpolation between two key frames. Key framed values appear in yellow, animated values appear in green unrecording value changes are shown in orange and gray value are just unanimated values.

## 02-04-More about the timeline

[Pierre] As any Blender editor, you can navigate in the timeline using your middle mouse. You can move selected items by pressing G, you can scale them using S, which will push them further from the play head. But pressing R won't rotate the key frame. What it will do instead, it will all you to change the key frame type. Changing the key frame type won't affect your animation. It's only a visual modification of your key frames that may allow you to better organize your animation. I personally never use it (drowned out by whooshing) Pressing the zero key on the numpad will center your timeline position around the play head. When you have some key selected, pressing the dot key on the numpad will frame or focus the selection. Pressing the home key will frame the whole animation from the very first to the very last key frame. You can preview a part of your animation by pressing P and dragging and hold on the section you want to repeat. Press Alt + P to clear the preview. You can activate the preview range by clicking the clock icon and then setting the starting and ending frame. You can set the beginning of your animation, pressing Control + Home. And you can set the end by pressing Control + Home. When you activate the preview range with the clock icon is using Control + Home and Control + Home, will set the beginning and the end of the preview range. My timeline here is just showing me the key frame of the selected items. If I go into view and uncheck only key frames from selected object, every key frame in the scene will be displayed. My character currently I've a subdivision modifier. If I go to the rendering properties, I can see that simplify has been activated. It allows you to disable every subdivision modifier in the scene, increasing the playback performances. When deactivated, we can see that my frame range in the top left corner turned to red meaning that Blender is not able to reach the frame rate I've set previously. While this scene is supposed to run at 30 frames per second, here I am below 14 frames per second. While it is not optimal, Blender allow us to drop frames so that we have a bit sort of timing of the animation, meaning that it will drop some of the frame to make sure that the action run at the same speed as if we were displaying the 30 frames per seconds. To allow this, just go to the playback option, to the no sync and choose whether frame drop or AV sync. We can see that the animation timing has changed and it's trying to catch up with its regular speed. Hopefully you won't need to use this option as I will try to provide pretty low poly characters to be animated, but it's important to note it. With Control + Shift, plus left click, you can select all the keys after or before the play head. You can press B click and drag or just left click and drag to make a box selection. The timeline is mainly here to give you an overview of your animation. I never use it to work on my current key frame. The summary line is just here to let me know if there are a key frame on the current frame. Here, we can see we have a key frame on every single frame from zero to 30. This key frame belongs to different controller of our character and are stored into an action that is torn into the armature. We will discuss about armature later on, here I just want to show you the IRO key of the timeline. If I add a cube to the scene and add key frames to this cube you can see that now these keys are also displayed in the timeline. Selecting a key on the summary will select all the corresponding keys of the armature and the cube. This can be great to offset a whole set of keys. But if we want, we can only move, for example, the X location key of the cube. Another great feature of the timeline is that we can add markers. While you can use them only for organization's sake, they can be very useful to switch camera. When you add two camera into your Blender scene and press zero to go into camera view, you can switch from one camera to the other into the scene options. But if you will, you can go in the timeline and add a couple of markers. You can add them pressing M or going to Marker, Add Marker. Now, with one of my camera selected and one of the marker selected, I will go to marker and bind camera to marker. Now I will select the second marker, select the second camera and repeat the process or press Control + B in the timeline. In the 3D viewport, pressing zero, I will jump into camera view. And when I will play the animation, each time I will hit those marker, Blender will automatically switch to the bound camera. This is way easier and cleaner than trying to animate the camera. To summarize, we have seen that navigating the timeline is close to navigating any Blender editors. We have seen a bunch of different shortcuts. And we have seen that we can create different markers in the timeline and bind the multiple cameras to them so that we can jump from one camera to the other directly through the animation.

## 02-05-Understanding interpolations

Before we start animating our bouncing ball, one of the most important thing you have to understand is interpolation, timing and spacing. Timing and spacing are two of the 12 principles of animation. Interpolation is quite new since it's the computer that is doing the interpolation between two key frame while in the past, they used to animate everything by and adding drawings and drawings. Timing is the pace. It's the moment when the ball leave the ground, is up in the sky and then hit back the ground. It is defined by the key moment of the animation or in the extreme, the extreme high position and the extreme low position in this case. We have a timing of 12 frame to get to the highest position and 12 frame to get back on the ground. Spacing is the different of position of our sphere from one frame to the other. We can easily display the spacing by going into the object option, motion path, set the frame from zero to 24 and click calculate. Then there we create a curve that go through different point that mark the position of the origin of our sphere on each key frame. The distance between those points is our spacing and this spacing is based on the timing of our animation and the interpolation between two key frames. By default, blender interpolation is set to bezier. What it does is that it creates an acceleration when the object is moving from a key frame and a deceleration when it's arriving on the next key frame. These are known as easing out and easing in meaning that you are easing out of the key frame leaving it for an acceleration and you are easing into the next key frame slowing down before reaching or hitting its position. So basically with that we've a very slow motion and it accelerate along the way. On frame 12, it will reach its maximum speed. So the spacing will be the biggest. And when it will come close to frame 24, it will slow down. This is what the bezier interpolation does by default. You can change the interpolation mode by selecting all the key frame with A and pressing the T key. It will open the interpolation panel where we can choose which interpolation our key frame will be using. There are a lot of different pre-made interpolation but we only need to focus on very first one. To be perfectly honest, I never used all the others, but they can be very useful if you want to build fast motion for motion design, for example. But in our case, we will be mostly working using those three during the course. Let's select the linear interpolation. As soon as I will select it, the behavior of the ball will change and we will get a more robotic movement. In the motion path tab, I will click the update path and now we can see that the spacing between the different frames is always the same. The spacing is even. If we know compare and linear and bezier interpolation, we can see that the timing is the same. They reach the lowest and highest point at the same time but on the bezier, we have a variation of the spacing. So we have a variation of the speed of the ball while in linear it's constant. The linear interpolation is very useful for robotic moves or for wall cycles for example when the foot is on the ground. Back to our motion, I will select all the key, press the T shortcut and set it to constant. I will update the path and now we can see that the ball is changing position only when it reaches the next key frame. So it's considered a constant interpolation or no interpolation and it's perfect to focus on the timing of your animation. This is the kind of interpolation we use when we are blocking the animation. In most animation, blocking is the first stage and it's very important. And we will start blocking our bouncing ball animation in the next video. Stepped interpolation can also be very useful whenever you want to give the stop motion style to your animation like on this example. To summarize, we have seen that interpolation occur between two key frames, that we can change the interpolation mode using the T key, that the bezier interpolation allow acceleration and deceleration or easing in an easing out, that the linear interpolation has a constant speed while the constant interpolation doesn't show any interpolation and is good to check out your timing.

## 02-06-Blocking the bouncing ball

Let's start blocking animation of the bouncing ball. Here, I still have my basic interpolation. So with all the key frames selected, I will press T and switch to constant interpolation. This way our ball will snap on the different position we have previously set. The idea is not to get disturbed by any interpolation and focus on the timing and shapes of our ball. Since our animation will be cycling upon 24 frame, the frames zero and the frame So my timing will be a bit off if I read both frame zero and the frame 24. So I will reduce the length of my animation from frame zero to frame 23, talking about Shape. We will here now look at the squash and stretch. If you're into animation, I'm sure you already have heard about it. If you look for squash and stretch ball on YouTube, you may find this video. I put the link in the documentation . When the ball gets thrown at high speed on the surface, and it touches it, it squashes. With the power of the impact, the ball get tighter, but it's volume has to be preserved. So it also gets larger. But in this case, squashing will bring to us two information. The power of the impact, and the softness of the material of the ball. Regarding our animation, if we consider our frame zero to be the frame, where our object will touch the ground, we can go like one or two frame forward and start squashing the ball by scaling it on the Z axis down, but also scaling it on the X and Y axis. This way we will have some all volume preservation. You can see here that the key frame, hasn't been written, as I need to enable the auto recording. Since I haven't written any scaling key frame previously, you can see that the ball remained flat. I will just press ALT + S to reset the scale on the first frame and on all the other frames. As we have just created the scaling key frames, they have just been added to our animation. And so by default Lendo will switch their interpolation to basic. So we can see that our location is still in step mode, but we have a scaling interpolation. So I will select all the key frame press T and set them to constant. From there, we can work on the stretching of our ball. Stretching is physically less obvious when we are watching the tennis ball bouncing, but it's yet still here. So we can use stretching to input physical information to our bouncing ball, but we can also use it to input speed information. If we look at the very beginning of the video, we can see that the ball is blurry and it immediately translate to us some speed information. So why the ball is probably currently perfectly round, the way the camera is capturing it forms some kind of elliptic shapes. And we have the same feeling whenever we are watching something that goes fast. And if we watched a right hand of the scientist, we can see that his fingers are also blurred because his hand was moving very fast. It makes his finger looks a little larger and longer due to speed. When an object is falling and hitting the ground, it is at its maximum speed just before it hit the ground. On the frame zero, we can input stretching information by scaling the ball up and reducing it's scale on X and Y to preserve its volume. When the ball will leave the ground, it will also be it's highest speed. So I can duplicate frame zero and move it on frame three or frame four. The ball stretch, hit the ground, squash, and stretch again when leaving the ground. Just by looking those few frames, we start to have the feeling of the animation of the ball. And this is a very important input whenever we will be using the blocking method is that you have to feel your animation just through those poses. As told before, frame zero and frame 24 are supposed to be the same. So I will select frame zero, press Shift + D to duplicate it and move it on frame 20. From frame zero to frame four the ball is on the ground and then it's leaving the ground from frame four to frame 24. Timing wise, the ball should travel upward and downward almost evenly. So I can offset the up position to frame 14. This way, we have 10 frame and moving upward and 10 frame moving downward. As a more subtle detailed pass, what we can do is slightly squash the ball whenever it reaches its top position. This slight modification will translate the inertia of the ball whenever it's slowing down to its stop position. Currently our blocking is bringing the minimum information we need to go to the next step. All the extreme poses of the ball are keyed and we have a rough timing. For this very specific exercise, it could be enough for me to go into spline to go into the next step of the animation process but we can also input some more details into the blocking stage by inputting some intermediate poses or in-between. The in-between will help us figuring out the spacing of our ball whenever it's in the air. Our ball is making a eight meter high jump, so I will move it in between two, four meter and I will clear the scaling. Now, depending on where I will move this key frame, it will change the spacing of the animation. If I move this key frame closer up to frame four where it takes off, our spacing will be larger in the beginning of the jump than it is whenever it's reaching the highest point meaning that on frame seven, the ball will go faster than on frame 10, which is what we want because the ball is leaving the ground at full speed. So it will reach its mid-air position before frame nine. And when falling down it will be at full speed on frame 24. So it should be mid-air, closer to frame 24, than frame 14. I know spacing can be a bit complicated when you are on the blocking stage and it will be way more obvious in the next video. To summarize, during the blocking stage, we key frame the extreme poses, we make a rough timing paths, we can use breakdowns and in-between to input more spacing and timing informations. We can use squash and stretch to input speed and physical information.

## 02-07-Animation-curves

Animation curves is one of the beginners' nightmare. But I want them to become your best friends. To display the animation curve of our ball, let's go into the graph editor. Right now, our curve looks a bit boxy, not really curved, and this is because we are still in constant interpolation. But it will help us reading them. The curve are just a graphical representation of the value over time. The yellow controller point accurately the different key frame we have inserted before. If I select the yellow point on the blue curve at frame 7, it has a value of 4. such as the Z location of our ball. And if I now display all the object transform channel in the graph editor, we can see that the Z location is highlighted. So the control point I've selected in the graph editor is the key frame value of the Z location of our ball. If I double click on one of these channels, it will select all the control point of the current curve. You can hide and unhide curve as you would do with any object in the 3D view. If I press Shift + H, I will hide everything but the selected curve. Or you can click on the little eye icon to choose whether you want to see or not the curve. With G, I can move the curve. I can press G+Y to constrained the movement on the Y axis or G+X to constrained on the X axis. Before we start reading those curve, let's get rid of any of the curve we don't need. Since our ball is not rotating, we can get rid of all the Euler rotation curve by pressing X. And we can also get rid of the X and Y locations since our ball is just moving up and down. This is a good practice to get rid of any unwanted channel to keep your graph editor clean. We can find the Z corresponding value onto the control point of the curve, but also in the transform channel of the object. Pressing the N key will open the F-curve panel. This is a little (inexact) here to check the position value and interpolation mode of the key frame channel. Let's now select all the key frames, press T, and switch to Bayesian interpolation. If we now play the animation, we get way smoother motion of the ball. When you switch from step mode to Bayesian mode or curve mode, we call this the splining stage. If we have a quick look to our curve now, we can see that the Z location curve is getting higher value when the ball is getting higher. I will unhide the scale channel by clicking the eye icon. I will select the first controller point of those curve and press the dot key on the Num pad to zoom on it. You can easily identify the Z scale channel, which is in blue, allow us to control the height of the ball. And the X and Y that are one on top of the other that allow us to control the width of the ball. Let's check a couple of example to betterly understand the behavior of the curves. In this example, the curve is controlling the rotation of the arrow from a value of -90 degree to +90 degree. The curve is rising rapidly before easing into the frame number 24. And when we scrub through the animation, we can see that we have big spacing in the beginning of the animation, and it gets lower in the end. You seeing the motion we will have a preview on the spacing of this animation. And now, we can obviously see the difference of spacing during the animation. And the more vertical the curve is, the larger the spacing. The more horizontal it gets, the smaller the spacing is. In other word, the more vertical the curve, the faster the animation. The more horizontal, the slower. In the next example, let's consider the X location curve of the ball being the time. It goes forward in a linear fashion Now, if I activate the Z location curve, and I frame it properly, look at all the Z location curve and the motion path we on in the 3D view port align or are comparable. Again, when the curve is vertical, the sphere will rise rapidly. And as the curve gets more horizontal, the sphere rise slower. So if I now give an S shape to my curve, the ball will move slowly in the beginning, then in the middle of the animation, it will accelerate as the curve get more vertical, and in the end, it will slow down. We are creating an easing out from the frame zero into an easing in the frame 24. And since we still have the linear motion of the sphere on its X axis, we can see that the Z curve really looks like the motion path of the sphere. Since my sphere is moving on the X location in a linear fashion, any modification I will add to the Z curve will show in the 3D view as in the graph editor by updating the motion path. You can use the few example available in the file to play with the curve and recalculate the motion path and check out the spacing. Back to the rotation example, I've modeled the curve so that I have a fast acceleration in the beginning, then a plateau, and then an ease out and ease in. And it absolutely reflect on the motion path. The pretty vertical shape of the curve on the first two frame generate a big spacing. The plateau shape or flat shape of the curve indicate that the value is not changing over time, so the arrow will stop, while the final S shape of the curve show an acceleration then a deceleration into the final frame. To summarize, we have seen that a curve is just a representation of the evolution of a value over time. The more vertical the curve shape, the faster the value change. And it translates in bigger spacing. The more horizontal the curve, the slower the change. Motion wise, it translate in smaller spacing. A flat curve indicates that there is absolutely no change in the value and so no motion.

## 02-08-The graph editor

[Presenter] Let's have a deeper look to the graph editor. In the previous video, we have seen that those curve are just a value evolving over time, and those controller point are the keyframe values. Each of those controllers have two handles that can be used to change the way the interpolation is set. And they work exactly as handles will do whenever you are editing a 3D curve in the 3D view. Those vector handles has different pre-set behavior. We can access them by pressing the V key or going into the Key option of the editor of the graph editor. By default, all the keys are set to auto clamp. You can see the handle type of the selected keyframe in the F-curve panel. When the keyframe is set to auto clamp, Blender will try to interpolate from one key to the other in the smoothest fashion. But as soon as I try to move this key beyond the previews of the next frame, the handles will become flat. So, it's clamping the value of the curve to the current keyframe, avoiding any overshoot. If we swtich to automatic, we will have kind of the same behavior, Blender will try to keep as much interpolation between the previews and next frame, but in this case, it won't avoid the overshoot. Curve wise, an overshoot is a bump in the shape of the curve, making the value jumping up or jumping down. This is not a handle type I use that much because sometime I feel like it's behavior is a bit unexpected. As explained before, handle type are set to auto clamp by default, but as soon as I try to scale the handle or rotate them, you can see that it switched to aligned. The orientation in scale of the handle are no longer controlled by Blender, but by yourself, but Blender will keep the previews and next handle aligned one with the other. This allows you to keep a smoothest curve interpolation, but if I switch the handle type to free, then each handle can be manipulated freely without caring about the previews of next handle, allowing us to break the curve which in a lot of case can be very handy. The final handle type we have to see is the vector handle type. As soon as we select it, the curve will break into a odd angle. Each angle will point individually to the previews on next keyframe and as soon as I try to manipulate one of the handle, it will switch to free mode. It's a very useful type of handle whenever you want to rapidly create a linear interpolation. Setting to consecutive keyframe to vector will create a linear interpolation and then, the cool thing about vector handles is that whenever we are moving the keyframe, they will always be pointing one at the other. I use this type of handle a lot for impact frame. If we change the interpolation mode of our curve to constant or linear, we won't get any access to the handles, because the interpolation is pre-made. It's where there no interpolation or a linear one. Adding handles doesn't make sense in this case. In the previous video we have seen that we can double click onto a channel to select the curve, we can box select, press A, press control shift and click before on after a keyframe to select all the previews on next keyframe. If we click the little checkbox, it will deactivate the current channel. Now you can see that the Z location on the character is no longer animated and is not jumping anymore, which is kind of fun. The wrench icon allows us to activate or deactivate curve modifier. To add the modifier to a curve you just need to select one control point of the curve, then go into the end panel and switch to modifiers. There are a lot of different modifier, let's just add a noise modifier to understand what they do. As the modeling modifier, you can use them to procedurally generate new behavior for your item. The noise modifier is super cool to create camera shake or to bring texture to your animation. The lock icon will allow you to lock the current channel, making any further modification impossible until you disable it. The magnifying glass on the top left will allow you to search for specific channels. It's very handy whenever you want to isolate a channel like the location channel without having to hide everything else then un-hide everything. Just type what you want to work on, then everything else will disappear. All the previous navigation showed that we have seen when we have studied the timeline of the same, the home key will frame everything, the dot key on the notepad will zoom into the selection and you can use the P key to set a temporary preview range into your animation. Alt and P will clear. When working with curve, we are working with values, and fortunately those values can vary a lot. Some curve will have a small arrange of value, while other curve might have a big range of value. And in this case, you can see me struggling, going back and forth to select into different values. The normalize option allow us to convert to this big range of value to a range that goes from minus one to one. So it doesn't change the value of the curve, it changed the way the value is displayed. It makes it a bit handier to work on the higher range of values. If I disable the auto update, I can move any value beyond the threshold of minus one and plus one. Then I will add the vision of the modified curve, but if I enable it, as soon as I move beyond minus one, the curve is not canceling the move, but it's re-updating it's position into a minus one to plus one range. So as you can see, when I move the extreme position, it does quite change the shape of the curve in the inside. I don't use it that much, but it will make more sense if you manipulate it. By default you will see the curve of the transform channel of the displayed animated object, in this case, the controller of my character. If I hide everything but those few controllers, you can see that I only have those listed in my graph edit. When activated, the selection filter, only selected object will show their animation curve. When enabling to show hidden, it will show absolutely every control channels available, whether you hide those controller or not, the curves will still be displayed. The only show arrows options will show you curves or keyframes that are no longer assigned to anything. Can happen sometime during whenever you delete a bone in edit mode and you didn't clean the animation later on. It's very specific and we don't really need to know more about this right now. The ghost curve option will display you the previous unedited shape of the curve. This is something I never use, to be really honest, but it can be useful for you if you find any interest in it. Click back on the crossed button to get rid of it. I won't go through the whole effect of menus since there are a lot of options that are self explanatory. I believe this is cool if you are working on multiple object at once for motion design, for example, and you want to clean your selection. They are different ways you can snap your different keys on the grid. By default, it's set to nearest frame, meaning that whenever you're moving your key on the X axis, it will snap right onto a frame. This is the option I use 99% of the time. If I use the second step, it will snap on every second. So, in our case, every 30 frames. In the view option in the header, I can enable show seconds. Since my document is based to 30 frame per second, whenever I try to move the key, you can see that it's not to frame 30. You have seen previously that pressing M, we can add a marker on the timeline. You can add them also in the graph editor because the graph editor is just another version, in a way, of the timeline. And if I then switch to snapped to nearest marker as soon as I will move my key, it will snap on the nearest marker. Finally, you can get rid of the auto snap switching to no auto snap. It can be useful in certain case when you are, for example, scaling a wall animation and you don't want every keyframe to snap to the nearest frame, but don't forget that Blender will read the value on one frame, not reading between. Be cautious with it because the value read by Blender might not be the one on your key, this can be a bit confusing. As in the 3D veiwport, you can use different kind of pivot point to edit your curve. The bounding box center will take the most extreme keys you have selected and it will set the pivot point right in the middle. As in the 3D view, you can see this dotted line showing where is the pivot point compared to your mouse cursor. The 2D cursor, as act the 3D cursor, you can place it by shift right clicking on the grid and it's position is defined by those two blue lines, the play at and a given value. With my key selected, if I press S and Y to scale on the Y axis, you can see my keys are pointing toward the horizontal blue line. This is a good way to set the same value to several keyframes at once. The individual origin pivot point is the one I use the most. Each keyframe becomes independent and whenever your scaling or rotating, it's manipulating each keyframe handles separately, allowing you to scale them and manipulate them without moving them onto the timeline. Rotating the keys with the bonding box option also move them on the timeline. As in mesh edit mode, you can activate a proportional editing. As soon as I edit one of my keyframe I can see the aerial (indistinct) of the falloff and using the mouse wheel, I can increase or decrease the size of the area of the effect. I don't use it that much, but it can be very handy whenever you are dealing with high density keyframed curve like baked animation or motion capture. As the mesh editing falloff, it comes with different curves that will behave in a different manner whenever you are moving your point. You can access new display option in the view panel. Whether you want to show or not the sidebar you can access it by pressing N. You can enable the operator box that is available in the 3D veiwport too, but I don't think it's that useful on the graph edit. The show cursor option will hide or unhide the original line of the 2D cursor. You can activate the show sliders option if you want to access the value of the keyframe directly in the channels panel. I never use it, but it definitely is handy if you want to fine tweak your values. You will find other option to display or not the handles of the keyframe, but I do recommend you to keep them displayed and I also advise you to only display the selected keyframe in those or your graph editor will rapidly become a mess. To summarize, we have seen that we can change the handle type of our curve using the V key. We can use the normalize option to display a broad range of curved values into a minus one to one range curve value. We can see that through the graph editor we can hide or unhide curve, deactivate them, lock them or even add the modifiers. As in the 3D viewport, we can use different pivot point and constraint axis. We can use selection filter or quick search to make our selection easier. We can use proportional editing to edit multiple keys at once.

## 02-09-Polishing the bouncing ball

The time has come to give the final touch to our bouncing ball animation. To clearly understand what we need to modify, I will change the frame rate of the animation by going into the document option frame rate. Here, we can find a bunch of preset that will set the pace of our animation. We are currently using the classic 24 frames per second, but they generally use Here, I will select a custom frame rate and I will set it to five frames per second. Now, when I play my animation, it kind of play in slow motion. It's a good way to identify the different position of the bouncing ball, and it can be a method to spot spacing troubles. Switching back to 24 frames per second, I will select the object and go into the motion path panel. I will set the animation range from zero to 24 frames per second. And since this is a function I use a lot, I will right click on the calculate button and add it to my quick favorite. This way, when I press the cue key, I can access the calculate function anywhere in the 3D viewport. You can now see our spacing and try to see what's wrong with our animation. When an object is falling in space, it's accelerating until it touches the ground. The speed of an object might stabilize due to air friction. But unless there is a force pulling our ball up, it is simple to accelerate until it touches the ground. So the spacing should be increasing from one frame to the other while it's falling. And we can see this is what's happening on those frames. Each frames forward, the spacing is getting bigger. On the last frame, the spacing is getting smaller. It means that the ball is slowing down before hitting the ground and this is incorrect. And this is something that we can read on the curve. As explained previously, the curve should get more and more vertical as it get closer to the value zero, which is our ground value. While here we can see that it has this S shape that makes the ball slowing down before touching the ground. The curve is easing out toward the ground. But since we have made a good blocking of our animation, it doesn't look that bad. Those two breakdowns are currently helping us getting a better result. This is why blocking can be pretty important. To fix the ground key frames, we just need to switch the handle pressing V to vector. Now I no longer have this S shape on my curve. To make things even clearer, let's get rid of our two break down key frames by selecting them and pressing the X key. I've also switched back to basic ball handles. When I play the animation, you will better feel this ease in and ease out. You can see the ball accelerating when it's leaving the ground and before it hits the ground. While if I switch both handles to vector, now we can feel that the ball is bouncing. To get even a better feeling, I will also slightly raise the curve by moving both vector handles towards the outside. And by scaling the upper key, I will make the ball raising faster and holding a bit more in the air. I have bring more contrast into my animation by changing the shape of the curve, and now it's more stylized. A little touch we can add to make it even more appealing, is to slightly offset the upper key of one frame. This way we don't have the same timing when the ball is rising than when it's falling down. We can recalculate the motion path of our animation by clicking the update path button. And instead of the in range option, I've switched to around frame. From there I can choose how many frame I want to see on my motion path before and after the current position of the ball. Now, when I look at the spacing of my ball, we can see that when it's leaving the ground, it has the biggest spacing. And it's slowing down when reaching the highest position, which is correct. When the ball is falling down, we also get the proper spacing. It's getting bigger and bigger as we approach the contacting key frame. We now have a pretty cool bouncing rhythm, so let's work a bit on the scaling of our ball or more precisely on it's squashing and stretching. Pressing Alt+H in the graph editor will reveal all the curve. I can hide the Z location curve, so that we focus on the scale curve. Since our balls squashing is pretty brutal, we can switch those key frames to vector. If we have a very slow squashing, we will have kept them as it is, as the ball would be progressively absorbing the impact for its squash. Pardon for the animation, I'm trying to get a feeling of the motion of the ball. When the ball squash, we can imagine it's a continuity of its fall. And since we are working on the cycling animation, the latest frame is the same as the first. So if I check the frame before the latest, I can see that I have a big spacing between the base of my ball and the ground. So it will be better if I kept this thinner for the spacing of the squashing. Meaning that I will offset the squash pose of frame two on frame one. And we will have a very stretched pose on frame zero and a very squashed one on frame one. And so it will transition with the full better. We are now getting a more impactful squashing if we compare with previous version. But since we have offset one frame for the squashing, we should do the same for the stretching. As you can see my spacing between frame three and four is very small. So I want a faster animation. I will offset the keys one frame before, and I will also switch them to vector. Next is the air squashing. I offset the key frame where the ball recover its round shape and then it's getting squashed again with the inner star when it's reached the highest point. Since the highest point is on frame 15, I will make it squash on frame 15. I'd like to slightly delay the squashing, so what I will do is that I will duplicate all the keys on frame eight and offset them onto frame 10 or 11. It makes all the skate curve becoming flat, which means that from frame eight to frame 11, the ball is perfectly round. And as the ball will be accelerating to get back to the ground. I'd like to slightly offset the time it's starts to stretch by two frames because the ball is falling faster than it is raising. So making it stretching a little sooner does make sense. Animating is not a linear art, you will need to go back and forth a lot of time. And while the animation gets more appealing, I feel like there is something a little off and since we've been offsetting a lot of curve, the ball is starting to relax while it hasn't left the ground. Meaning that the ball should be in air on frame four. So I just need to re-edit the curve for the Z location and offset the stopping point by one frame. And now when they play again my animation, I feel like there is something a bit off on the air squashing. The ball slows and then it starts squashing. And if we double check the spacing of the base of the ball, we can see that as soon as it starts squashing, the easing gets stronger and that's better. The yellow arrows are getting smaller progressively, while there is a big difference between the two red arrows. So even if it's very subtle, it makes the animation a bit weird. So again I can fix this by simply offsetting the squashing key frames, the plateau we have created before just by one frame. Making it happening a little sooner, so that it will better blend while it's raising. I guess you may ask yourself how do I get rid of the grid of the motion path, et cetera my fried issue. It's by deactivating the overlay here. And since this is something I do all the time, what I did is that I set a shortcut onto the overlay. You can assign the shortcut to any tool or option in blender by simply right clicking on it and selecting assign shortcuts. I've personally used the shortcut power two which is just upon the tab key on my French keyboard. I'm pretty happy with this bouncing ball animation. And in summary we have seen that curve editing can dramatically change our animation. Good blocking makes your animation a little better when you switch to spline. It's important not to be afraid to break the curve using vector handles. Offsetting the key by one frame can really change your animation and make it look better on its troy. Don't forget that the devil is in the details.

## 02-10-Moving forward

[Instructor] We have left last video with our happy bouncing ball, bouncing and bouncing. But now, I'd like it to move forward a bit. So let's do that together. The first thing I will do is to press three on my num pad to switch to side view. Now, instead of making my animation loop over 24 frame, I'd like to make the animation a little bit longer. So I will re-open my timeline, and I'd like to repeat the animation four time. So I can tie in all time 24 frames to get to the right frame number. But the problem is that my bouncing ball animation is not repeating over those 96 frames. So the more logical method to make it repeat will be to select all my keyframe, duplicate them by pressing Shift + D, X to move them on the x-axis, and type in 24 so that they will be moved by 24 frame on the x-axis. Then, I can press Shift + R to repeat the operation. The problem with this method is that if we have any modification to be added to the animation, we will have to reduplicate everything or modify it on each bounce. While it's not super painful on such a simple animation duplicating only four time, this is not an efficient way to do it. So I will reset what I've done and with all my keys and curves selected, I will press Shift + E to open the keyframe extrapolation menu. By default our keyframe extrapolation is set to constant. It means that whenever I reach the very last keyframe in my animation, the value won't be changing anymore. That's why we get flat curve. But judging by this extrapolation menu, we can see that we can switch it to linear extrapolation or even make a cycle. You can also access the extrapolation operation through channel panel in the header of the graph editor. With all the curves selected, let's choose make cyclic. Boom, our animation is now cycling infinitely on the timeline. And the cool thing about using extrapolation is that modifying our animation will be repeating and updating the along the whole timeline. (graphic swooshes) With this problem fixed, I'd like my ball to move forward in space. So I'd like to animate the y-axis of the ball. So I will insert a single keyframe on the y-axis, go to frame 24, move the ball by about nine meters, go back onto the transform channel, right-click and insert a single keyframe. If I now play the animation, the ball will move forward only on the keyframe we have inserted, and since Blender is creating by default a new keyframe with the bezier mode, we have an acceleration and a deceleration of the ball so it doesn't look super unnatural. While this kind of locomotion could be a little more complex, we will consider that our ball is moving at a constant speed. So I will select both handle, press the V key and switch them to vector. You could have chosen to press the T key and switch to linear interpolation, but I prefer to use vector interpolation to keep the handles available. When I watch this motion, I feel like the ball should move a little further. So I can take my last control point and move it a bit up more or insert a new value in the transform channel and don't forget to insert the keyframe. Or we can directly change the value of the keyframe by going into the F-Curve properties and enter 10 meters in the value of the keyframe. This is a good method when you want to enter very precise values. Now, I'd like my ball to continue moving on on each bounce. So I could duplicate the last keyframe, offset it or insert a new a keyframe and set it to 20 meter. But again, if we want to modify the timing of our animation making the jump a bit a longer, I will have to modify those, too. And on a more complex animation, that would be very painful. So let's get rid of this and find another solution. If we go back to the extrapolation menu, we will find an option that allow us to create a linear extrapolation. Blender will take the last two keyframe of an animation, and it will do an extrapolation based on the value differences between those two. So that's a great step forward in our animation, but there is something that bother me. When our ball hit the ground, it stays on the ground for a few frame. The problem is that it's sliding currently, and it doesn't look good. I'd like the ball to stay where it is when it's on the ground and move forward whenever it's airborne. To fix it, I can simply duplicate the very first frame and move it on frame three, but I need this new motion to repeat along the full animation. So I will press Shift + E and choose constant extrapolation to get rid of the linear extrapolation. But now, my animation is no longer repeating, and whenever I'm re-adding a linear extrapolation, it will just continue on moving instead of stopping whenever the ball is contacting the ground. So I can try using a cyclic extrapolation, but the problem is that the ball will get back to its original position after each cycle. So I'd like it to cycle but with an offset. And what we can do is select one of the key of the curve an go to the modifier tabs here. And we can add a cycles modifier. So it works exactly as if we were adding the cyclic extrapolation, but we do now have option on the cycle behavior. I can change the way it act before and after the cycle. So if I go onto the after, I can ask Blender to use the repeat with offset. And what it does is that it takes the very last keyframe and use it as a new starting point. So offsetting the animation is currently adding it on top of the latest keyframe. (graphic swooshes) An extra motion is missing, though. If we watch this video, you'll find the link in the resources PDF, I'd like you to focus on the body shape and orientation of this lynx. During this gorgeous motion, we can see the squashing and stretching, but we can also see some rotation of the body. The body in the beginning is oriented toward the up point and then oriented toward the landing point. So we do need to input those information on our bouncing ball. To get a better preview of the motion of the ball, (graphic swooshes) I will calculate the motion path. As seen in the previous video, I will go into the object option, motion path and click calculate the path. I will change the path type to in range and change the end frame to 96. This will give us the motion path of our ball, and it's going to be easier for us to figure out how much we have to rotate it. The idea is to simply rotate the ball toward its next position or its next frame position. And once we have past the highest point, we will make the ball pointing toward the previous frame. Since our first frame is exactly the same (graphic swooshes) as the latest frame, or frame 24, I will jump to frame 24 and give the correct orientation to the ball. It seems that 11 degrees looks fine. Then, I will right-click and insert a single keyframe. A new channel has appeared in the graph editor. It's our X ruler rotation. So I will now go back to the frame where the ball is currently leaving the ground and rotate it by minus 12.5 degree toward its next position. So now as we have did before, I will duplicate the last frame, frame 24 of this ruler rotation, and move it onto frame zero, pressing Shift + D, X and moving it with the mouse. Now that the initial frame zero and final frame 24 are the same, I can select my curve and press Shift + E and make it cyclic, and it already looks pretty cool. So while the motion I'm seeing right now is pretty satisfying, you know that we need to check it frame-by-frame. As any craft, a perfect animation doesn't exist, and the level of quality you will reach depend on the time you can spend on your animation. In this case, I'd like to polish the animation a little more by making frame number one pretty flat, because I don't really like the fact that the ball is slightly leaning backward when it's getting in its flattest position. In the graph editor with the X ruler rotation curve selected, I will press I to insert a new keyframe and choose only selected. This way, Blender won't add any additional keyframes on the other curves and our graph editor will remain clean. Then, I can grab this key, move it on the y-axis, holding Shift to get a more precise movement. And I will call this first bouncing ball animation done. The technique we have used in this video, adding a rotation motion based on the location motion, the up and down motion of the ball, is called the layered approach. It means that you add layers and layers of motion during the polishing stage, not during the blocking stage. And we'll study this technique more in depth later on. To summarize, we have seen that we (graphic swooshes) can create cycles using the Shift + E shortcut and choose different extrapolation. We can access more advanced cycle option using modifiers. We can use current motion of the ball as the guide to add new motion to it in a layered approach.

## 02-11-Curve modifiers

In this video, we will have an overview of all the curve modified. In the graph-editor, whenever I select a curve, I can access the modifier in the end panel or properties panel. Why do we have already set a cycle modifier in the preview video? What you may haven't noticed is that we already using modifiers prior to this. As soon as we have used the extrapolation mode whenever we press the shift + E and make our curve cyclic, basically, we were adding a cycle modifier. Any modifier influence can be activated or deactivated by clicking the checkbox. The circle modifier repeat the animation from the first key to the last key. We can change the modifier behavior before the first key and after the first key, by default it's repeating the animation as it is. We can get rid of the cycle or use the cycle we've offset. If I use it right now, nothing will happen because it uses the position of the last key frame as the new starting point. But since my first and last key frame are same, it doesn't change. But as soon as I offset the value of the last key frame, you can see that I get some kind of ladder motion. The repeat mirror option will do what it says. It will repeat the curve but each time it will a mirror it based on the last frame. Changing the value will just set the number of repetition after or before your current animation. A value of zero will make the cycle repeat infinitely. The restrict frame range and use-influence properties are very useful but they are not the most abuse on the cycle modifier, so we will have a look to it later on. Let's have a look to the next modifier. I will get rid of the cycle modifier, and I add a built-in function. My animation curve as totally changed. And we now have a (indistinct) curve because the default function is seen. The first multiplayer will allow us to modify the frequency of the curve. While the amplitude will allow us to increase the value of the curve. The first offset will offset the curve on the X axis while the value offset will offset the curve on the Y axis. The restricted frame range option is a supercool additional tool as it is named, it will allow us to limit or restrict the influence of the modifier on the frame range. So we can set this frame range by tweaking the end value and the start value. The in and out value allow us to input easing, meaning that we can increase or decrease the influence of the modifier at the beginning and the end of the frame range. This way we can totally modify the behavior of the ball with a non-destructive workflow because I'm not currently working on any of the key frame, but only on the modifiers of that I can add or remove. By default The modifier is replacing our current animation but enabling the additive option will add the modifier behavior on top of our animation. So setting the amplitude of the modifier to zero is like removing it when it's in additive mode. And as soon as I increased its amplitude, you can see Oh, it's affecting the curve. While it works for the specific case, this is not the best way to play with the influence of the modifier. Fortunately, we have an influence factor that will increase or decrease the influence of the modifier on our curve. The dropdown menu upon the additive would enable us to change the type of functions. So if you remember your trigonometry classes you might recognize the tangent causing an (indistinct) curve This square root is a simple exponential function. So you can use it to make your ball rise like a balloon, with a constant easing, the natural logarithm does look like the square root but it has a slight offset and it ease more. Finally, the normalized scene looks like the scene function but it does ease very rapidly. So you can change this by moving the phase offset and the phase multiplier. So it can be hard to find a specific shoes for those modifiers, but you have to experiment with it. And when you do motion design, for example they are very useful. When adding the envelope modifier, We will see a couple of dotted lines appearing in our graph-editor lying with minus one and one value. These are scaling values or reference values, if you will. I will just a couple of points at the beginning and the end of my curve. Those control points will allow me to change the overall shape of my curve, also known as envelope. Those control points are defined by a minimum and maximum value that appears as little white dot on the graph-editor, they represent the current scale of the modifier. So, if I tweak the maximum value, I will see my curve scaling up and down, and we can clearly see the max point of the envelope modifier moving here. So it might look a bit abstract right now, so what I will do is that I will make the bonding box in a way of my envelop modifier as big as the curve. To do so I will set the minimum value to zero like the minimum value of my key frame and the maximum value around eight, like my key frame. I will add a couple of control points and I will give them the same value, zero and 8.4. Now you can think of your curve as being bound by your lattice modifier or being transformed as in Photoshop, we've an even transform. And by moving the value of the control point, it's like moving the corners of the bonding box. And as into a lattice we can add more than two control point. I can add a control point in the middle set its default value as the other. And when I move it, it will break the curve and deform it from its position. Very powerful modifier to modify the amplitude of the motion. The noise modifier is one of my favorite. And guess what? It noise to your curve. It's perfect to create camera shake Or if you are a shaky character you can use the noise modifier instead of Nkit. The scale will change the frequency of the noise, the phase we kind of change its shape or it seeds. The strength is the amplitude of the noise, the depth value is the smoothness of the noise. To see it properly, I will increase the scale and the strength. As I reduce the depth value, you can see the curves smoothing. The offset, allows you to offset the noise on the X axis or in time, if you prefer. So, using the noise modifier and the restrict frame range, I can create a slight shaking of the ball whenever it lands. The limits modifier works a bit as a limit constraint. Setting a minimum Y value and maximum Y value, will clump the value of the curve. Any value beneath the minimum value will be ignored, any value upon the maximum value will be ignored. It's like creating a roof and the ground that will bond your curve while the minimum X and maximum X value will currently ignore any values that is before the set frame or after the maximum set frame. So, what if I set the X maximum value to 10, any key frame value after the frame 10 will be ignored. This can be very useful if, for example, you don't want the ball to go under the ground. The next modifier is the stepped modifier, it's a very cool and intuitive modifier. The step size allow you to change the length in frame of the step in your animation. So, basically, this modifier is converting your curve as if we were blocking our animation with constant interpolation and it gives a fantastic stop motion style to your animation. So you can change the step size value, you can offset it in time. And this modifier comes with a built-in starting frame and ending frame. It's a bit like the frame restrict range but you can consider it as an additional restriction layer. On the full character, we will need to add this modifier on every single curve. What we can do instead is add the modifier on the NLA strip. Don't worry. We'll talk about the NLA editor later on, but just consider that we're applying the modifier to the wall animation instead of applying it to a simple curve. If we have a loop to this quick animation, I've made with one of my students, the step modify your really brings the stop motion feelings to the animation. As explained before those modifier act as object modifiers. It means that they can be layered, you can add multiple curve modifiers to get different results and the order in which you stack those modifier is important. If I add the limit modifier before the noise modifier, the noise will be applied after the limit and so I won't see any difference. I won't see the limits applied. At the time I'm recording this video on blender 2.91, I haven't find any way to move the position of those curve modifier. Hopefully this will be updated whenever you will be able to watch this video. We can copy a modifier by clicking on the little folder icon with the arrow getting inside. To paste the modifier on another curve just select two curve and click the second icon with the folder shape and the arrow, getting out. If you have multiple modifiers, they will be all copy and pasted onto the curve. To summarize, we have seen that we can use modifier to modify our curve behavior procedurally and in a non-destructive manner. Modifier can be stacked one on each other to get more advanced result. Modifiers can be copied and pasted from one curve to the other. We can add the modifiers on the whole action for the NLA editor.

## 02-12-Dope sheet

[Instructor] Before we go further and talk about the dope sheet, we need to talk a bit about Blender's data. If you're beginning with Blender, the most common data you are manipulating is the material of an object. You may have watched tutorial where you create a material and then you share it on multiple object. For example, we can see this blue material applied to the Suzanne head. If I select the cube, I can go into the library and apply to it the blue material too. Both object are now sharing the same material or sharing the same material data. With my cube selected, if I apply again the blue material, I will see the number two appearing next to the material name. This number indicate how many object or users are currently using this blue material and it's current two, the monkey head and the cube. It means that if I change the color of this material, it will be changing on both object because it's the same data that they are sharing. So as explained in the very first video of this chapter, objects are just containers and if I go to the mesh data, I will also find a data library that will allow me to source any other mesh data from any other object. With the cube selected, if I select the sphere mesh data, my cube will be transformed into a sphere and Blender indicates us that there are two objects using those mesh data. We have also seen that the object has changed color because the material is bound to the vertices. By loading new mesh data, we have also sourced the material data linked to it. If we now go back to our bouncing ball animation, with the graph editor open, I can see that I'm working on the ball but just under, we have the SphereAction.002 that we haven't talked about. And when we look at at our graph editor hierarchy, we can see our mesh object, the ball. The SphereAction.002 is bound to the ball and all the transformed channel keyframes are bound to this SphereAction. Instead of the graph editor, let's open the dope sheet. Let's consider the dope sheet as being like the timeline. All the shortcuts and features we have seen with the timeline works within the dope sheet. We can see our mesh object and the action in the hierarchy. If I now enable the collection cone, and I start animating the location of the cone by inserting a couple of keyframe, a new hierarchy appear in the dope sheet. We can find our cone object with a new action called coneAction. As soon as you insert a keyframe on an object that hasn't been animated yet, it will automatically create a new action. This action are the name of the container that contain animation data and the dope sheet is an overview of all the animation data that are being used in our scene. Here we can see which container is using the animation data and what action is being used but now what if I want to edit those animation data? We can access them through the action editor. With the action editor, we will be able to work on a specific action at a time. With the cone selected, I can see that I'm working on the cone action and as for any other kind of data, if I click the action icon, I will access our action library. So it means that as for material or any kind of data, I can share this animation to any other object. So I will select my SphereAction.002, rename it bouncing ball and when I play the animation, I can see that now my cone is moving as our bouncing ball. And near the action name, I can see that I have two users of the bouncing ball animation. So I can share this animation on as many object as I want. I can give it to Suzanne here and now we can see that we have three users and when I play the animation, our Suzanne monkey head will move as the bouncing ball too. Since I've given the bouncing ball animation to all my object, the point action, for example, has no more users. And if I brought my action library, I will see this little zero in front of the coneAction and you have to be very careful with that because whenever you have any kind of data that has a zero in front of its name, then they will get rid of this data as soon as you close the software. So if I revert my scene, now reopen it if you will, the coneAction marked with a zero has disappeared and I've lost this animation. To avoid losing an animation, you can click the little shield icon that will create a new fake user. Whether the data is used or not, then I won't flush it on restart. As we have seen before with the materials, as soon as a data or an action is shared, editing it on one of the object will affect any other container that is using the same action. If you want to duplicate the current action, you can click the number next to it's name. This become a new action or a new data that you can edit freely and you can see that there is not more multiple users on this one. And this new duplicated action has been added to the action library. To definitely get rid of an action, Shift + click the cross icon. When reverting the file or reloading Blender, the animation data or the action will be removed. If you're starting fresh and your object is not animating, you can press the New button to create a new action. I will insert a couple of keyframe to illustrate one thing. When you get this orange continuous line between two frames, it means that the value is not changing. As soon as I enter a value on one of the transform channel, we can see that now there is no more this orange line on the z location channel. Switching to constant or linear interpolation will create a green line between the different keyframes. So it basically tells you that you are not choosing Bezier interpolation. Changing the handle type of your keyframe will be also displayed in the action editor. You will see the shape of the key currently changing. The action editor will become our main editor when it comes to animation before we jump into the graph editor. To summarize, we have see that the dope sheet shows us all the current actions that are being used in our Blender scene, while the action editor allow us to edit one action at a time. Action is the name of the container for our motion or animation data and as any other data, an action can be shared by different object.

