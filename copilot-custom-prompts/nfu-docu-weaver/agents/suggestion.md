# Lesson-Weaver 使用经验与建议
ada, 可以询问用户是否已经存在该课程的教案和大纲 docx 文件, 如果存在, 
给用户提供 prompt, 让用户将docx 文档放在指定的地方. 如果用户已经有, 
那么提示用户可以将文档放进 Gemini chat , 通过 prompt 让 Gemini 提取
相关信息, 并将获取信息作为回答输入.  这是一种节省 token, 加快生成文档 
的方式. 所以你可以将预先需要的信息通过 prompt 让用户在 Gemini 中输
入, 然后通过 Gemini 提取信息,  prompt 中需要明确某些没有获取的值不能
编造, 如实回答"没有提供"

所以你在回答的时候, 需要提供一个 @Gemini 的 prompt 机制, 让用户能结合gemini 回答问题. 

## 💡 经验总结

### 经验 1: courses/ 目录检查
- **问题**：如果 courses/ 文件夹不存在会导致创建课程失败
- **解决方案**：创建课程前先检查并创建 courses/ 目录
- **实施**：使用 `mkdir -p` 命令确保目录存在

---

### 经验 2: 利用 Gemini 快速提取现有文档信息（节省 Token）

**适用场景**: 用户已有课程教案或大纲的 Word/PDF 文档

**核心价值**:
- ⚡ **节省 Token 消耗**：避免直接上传大文档到 Claude
- 🎯 **精准提取信息**：只提取结构化的必要信息
- 🔄 **加快生成流程**：一次性获取所有课程配置信息
- 📋 **保证信息完整性**：使用标准化 Prompt 确保不遗漏关键字段

**工作流程**:
1. 用户在 Gemini 上传课程文档
2. 用户使用标准化 Prompt 提取信息
3. Gemini 返回结构化数据
4. 用户将数据粘贴回 Ada
5. Ada 使用提取的信息创建课程工作空间

**关键原则**:
- Prompt 必须明确要求"不存在的信息如实回答'没有提供'"
- 不允许 AI 编造或推测信息
- 保持原文专业术语和表述

---

## 🤖 Gemini Prompt 模板库

### Prompt 1: 课程基本信息提取

**用途**: 从课程大纲或完整文档中提取课程配置信息

```
请从上传的课程文档中提取以下信息，并按指定格式输出。

**重要规则**:
- 只提取文档中明确存在的信息
- 如果某项信息不存在，请如实回答 "没有提供"
- 不要编造或推测任何信息

---

## 需要提取的信息：

### 1. 课程基本信息
- 课程名称：
- 课程代码/编号：
- 授课教师：
- 学期：
- 总周次/学时：
- 学分：

### 2. 课程描述
- 课程简介：
- 课程性质（必修/选修/专业核心等）：
- 适用专业：
- 先修课程：

### 3. 教学目标
- 知识目标：
- 能力目标：
- 素质目标：

### 4. 课程内容概览
请列出所有教学单元/章节，每个单元包括：
- 单元序号：
- 单元标题：
- 学时数：
- 主要内容（简述）：

### 5. 教学资源
- 教材：
- 参考书：
- 其他资源（软件、工具等）：

### 6. 考核方式
- 考核方式：
- 成绩构成：

---

**输出格式要求**:
请使用清晰的分类和缩进，便于我直接复制使用。
```

---

### Prompt 2: 单个教案详细信息提取

**用途**: 从已有教案中提取某一课的详细内容，用于生成 YAML 数据文件

```
请从上传的教案文档中提取第 X 课/第 X 单元的详细教学信息。

**重要规则**:
- 只提取文档中明确存在的信息
- 如果某项信息不存在，请如实回答 "没有提供"
- 不要编造或推测任何信息
- 保持原文的专业术语和表述

---

## 需要提取的信息：

### 基本信息
- 课次/单元编号：
- 课程标题：
- 课程名称：
- 学时数（总计）：
- 学时分配（理论/实践）：

### 教学目标
- 知识目标：
- 能力目标：
- 素质目标：

### 教学重点
- 重点内容：

### 教学难点
- 难点内容：

### 教学方法
- 教学方法：

### 教学手段
- 教学手段/工具：

### 教学过程
请按顺序列出所有教学环节，每个环节包括：
1. 环节名称（如：导入、讲授新课、实践练习等）
2. 教学内容（具体讲什么）
3. 教师活动
4. 学生活动
5. 时间分配

### 课后作业
- 作业内容：

### 教学反思（如有）
- 反思内容：

---

**输出格式要求**:
请使用结构化格式，便于我直接使用。
```

---

### 经验 3: 课程配置标准参考

**常见课时安排**:
- 一般周次：15~18 周
- 每周课时：3~4 节课
- 每节课时长：45 分钟

**⚠️ 重要约束**:
- 每周课时通常是**固定**的（如每周4学时）
- 在规划多周教案时，必须严格遵守每周固定学时
- 不能出现某周3学时、某周5学时的情况
- 如果章节学时不能整除每周学时，需要跨周分配

**course.yml 创建要点**:
- 使用 v2.0 Schema 格式
- 配置路径相对于项目根目录
- 数据目录相对于课程目录
- 包含完整的课程描述和教学目标
- 记录课程状态（已完成/待完成）

---

### 经验 4: 增量创建教案的处理

**场景**: 用户已有部分教案，只需创建剩余部分

**处理步骤**:
1. 在 `course.yml` 的 `status` 中记录已完成的教案数量
2. 在 `metadata.notes` 中说明特殊情况
3. 询问用户已完成的教案范围
4. 只为缺失的部分创建数据文件

**示例**:
```yaml
status:
  lessons_completed: 7
  lessons_total: 15
  lessons_to_create: "8-15"
  
metadata:
  notes: '课程已有前7周教案内容，需要创建第8-15周教案'
```

---

### 经验 5: Gemini 提取成功案例

**日期**: 2025-10-05  
**课程**: 三维动画基础-数字建模  
**提取周次**: 第8周

**成功要点**:
1. ✅ Gemini Prompt 设计合理，字段覆盖完整
2. ✅ 用户提取的数据结构清晰，直接可用于 YAML 生成
3. ✅ "没有提供"的字段处理得当（如签名信息）
4. ✅ 保持了原文的专业术语和教学设计细节

**关键发现**:
- 教案包含详细的思政融入点（每个环节都有）
- 时间分配非常精确（总计180分钟 = 4学时 × 45分钟）
- 六大教学环节结构完整（导入、复习、讲授、讨论、实践、小结）
- 课堂思考问题设计启发性强

**⚠️ YAML 格式注意事项**:
1. **引号转义**: `in_class_thinking` 字段不需要双层引号，直接使用单层引号即可
   - ❌ 错误: `in_class_thinking: ""问题内容？""`
   - ✅ 正确: `in_class_thinking: "问题内容？"`
   
2. **空值处理**: 空字段应使用 `""` 而不是空行
   - ❌ 错误: `value: "` (有换行)
   - ✅ 正确: `value: ""`
   
3. **中文引号处理** (关键!):
   - ❌ 错误: `value: "内容中有"中文引号"的文本"` (会导致 YAML 解析错误)
   - ✅ 正确: `value: '内容中有"中文引号"的文本'` (使用单引号包裹)
   - 💡 规则: 如果字段值中包含中文引号（""）或单引号（''），使用另一种引号包裹整个值
   
4. **嵌套引号处理**:
   - 如果内容同时包含中文引号和单引号（如：`'回家'主题`），去掉外层引号
   - ✅ 例如: `value: 回家主题的场景` (简化处理)

5. **Schema 验证经验**:
   - **类型错误**: `lesson_number` 和 `class_hours.total` 必须是字符串，不能是数字
     - ❌ 错误: `lesson_number: 8`
     - ✅ 正确: `lesson_number: "8"`
   - **结构问题**: `main_teaching_segments` 的结构必须严格按照 Schema 定义
   - **验证工具**: 使用 `python tools/generate_docs.py validate --batch` 进行批量验证

6. **字段映射修复经验**:
   - **问题**: Word 文档中模板变量未被替换（如 `{{main_teaching_segments[0].design_details.organization}}`）
   - **根本原因**: `get_nested_value` 函数无法处理数组索引（如 `[0]`）
   - **解决方案**: 修复 `tools/generate_docs.py` 中的字段映射逻辑，支持数组索引访问
   - **修复效果**: 所有模板变量现在都能正确替换
   - **关键代码**: 改进的 `get_nested_value` 方法能处理 `main_teaching_segments[0].design_details.organization` 格式

7. **字符串格式修复经验**:
   - **问题**: Word 文档中出现代码残余（如 `{'value': '...'}`）和转义符 `\n`
   - **根本原因**: 字符串处理逻辑不完善，没有正确处理转义符和字典格式
   - **解决方案**: 改进 `get_nested_value` 方法中的字符串处理逻辑
     - 将 `\n` 转换为实际换行符
     - 处理字典格式，提取 `value` 字段
   - **修复效果**: 文档内容格式正确，无代码残余
   - **关键代码**: `processed_value = value.replace('\\n', '\n')`

8. **Word 格式继承修复经验**:
   - **问题**: 替换文本继承前面文本的粗体格式，导致非粗体文本变成粗体
   - **根本原因**: `apply_run_format` 方法会继承 `base_format` 中的所有格式，包括粗体、斜体等
   - **解决方案**: 修改 `apply_run_format` 方法，注释掉格式继承代码
     - 不继承 `font_bold`、`font_italic`、`font_underline` 等文本格式
     - 只保留字体名称、大小、颜色等基础格式
   - **修复效果**: 替换文本不再继承前面的格式，保持原始格式
   - **关键代码**: 注释掉格式继承的 if 语句块

9. **Word 段落缩进继承修复经验**:
   - **问题**: 换行时第二行没有继承第一行的段落缩进（LINE INDENT）
   - **根本原因**: `add_formatted_text_to_paragraph` 方法在清空段落内容时丢失了段落格式
   - **解决方案**: 修改 `add_formatted_text_to_paragraph` 方法
     - 在清空内容前保存原始段落格式（缩进、对齐、间距等）
     - 清空内容后立即恢复段落格式
     - 确保所有行都保持相同的段落缩进
   - **修复效果**: 换行文本正确继承段落缩进，保持格式一致性
   - **关键代码**: 保存和恢复 `paragraph_format` 的所有属性

10. **Word 软换行符缩进修复经验**:
    - **问题**: 使用普通换行符（`\n`）时，第二行不会继承段落的首行缩进
    - **根本原因**: Word 文档中的普通换行符不会自动应用段落的首行缩进格式
    - **解决方案**: 修改 `add_formatted_text_to_paragraph` 方法
      - 检测文本中的换行符（`\n`）
      - 使用 Word 的软换行符（`<w:br>`）替代普通换行符
      - 软换行符会保持段落格式，包括首行缩进
    - **修复效果**: 多行文本正确继承段落的首行缩进，保持格式一致性
    - **关键代码**: 使用 `OxmlElement('w:br')` 创建软换行符

11. **Word 软换行符顺序修复经验**:
    - **问题**: 软换行符缩进修复后，文本仍然被合并成一行
    - **根本原因**: 软换行符的添加顺序不正确，应该在每行文本之后添加
    - **解决方案**: 修改软换行符添加逻辑
      - 先处理每行的文本和格式
      - 然后在每行之间添加软换行符（除了最后一行）
      - 确保软换行符在正确的位置
    - **修复效果**: 多行文本正确显示为独立行，每行都继承段落的首行缩进
    - **关键代码**: 调整软换行符添加的时机和位置

       12. **Word 多段落缩进修复经验**:
           - **问题**: 软换行符（`<w:br>`）不会自动应用段落的首行缩进
           - **根本原因**: Word 文档中的软换行符不会继承段落的首行缩进格式
           - **解决方案**: 将多行文本分割成多个独立的段落
             - 每行创建一个独立的段落
             - 每个段落都有自己的首行缩进
             - 在表格单元格中正确创建新段落元素
           - **修复效果**: 每行都正确显示为首行缩进，格式完全正确
           - **关键代码**: 使用 `OxmlElement('w:p')` 创建段落元素，并复制格式

       13. **Word 占位符格式保留修复经验**:
           - **问题**: 替换占位符时，占位符前面的文字（如 `重点：`、`难点：`、`必读书目：`）格式被破坏
           - **根本原因**: 原有的替换逻辑会清空整个段落，然后重新添加内容，破坏了原有的格式
           - **解决方案**: 实现精确的占位符替换逻辑
             - 只替换占位符部分，保留前后文字和格式
             - 使用正则表达式匹配占位符位置
             - 保存原始段落格式，清空后立即恢复
             - 对多行文本创建多个独立段落以保持首行缩进
           - **修复效果**: 所有字段的前缀文字和格式都正确保留，占位符被正确替换
           - **关键代码**: `replace_placeholders_in_runs` 方法实现精确替换

---

### 经验 6: 文件命名规范

**教案数据文件命名**:
- 格式：`lesson-XX.yml`（XX 为两位数字）
- 示例：`lesson-01.yml`, `lesson-08.yml`, `lesson-15.yml`
- 保持连续编号，即使中间有已存在的文件

**输出文档命名**:
- 格式：`lesson-XX.docx`
- 与数据文件编号对应

---

## 📊 工作流程最佳实践

### 标准工作流程（完整创建）

1. **需求理解** → 询问用户是否有现成文档
2. **信息提取** → 使用 Gemini Prompt 提取（如有文档）
3. **创建工作空间** → 创建课程目录和 course.yml
4. **生成数据文件** → 创建教案 YAML 数据
5. **验证数据** → 使用 Schema 验证完整性
6. **生成文档** → 批量生成 Word 文档

### 增量工作流程（部分创建）

1. **需求理解** → 确认已有和待创建的范围
2. **提取现有内容** → 使用 Gemini 提取已有教案风格
3. **创建工作空间** → 标记已完成状态
4. **生成新数据文件** → 只创建缺失部分
5. **验证数据** → 验证新创建的文件
6. **生成文档** → 只生成新教案

---

## ⚠️ 常见问题与解决方案

### 问题 1: 用户不确定需要多少周教案
**解决**: 查看课程总学时，根据每周课时估算周次

### 问题 2: 章节学时分配不均匀
**解决**: 某些章节需要跨多周，需要拆分成多个教案

### 问题 3: 已有教案与新教案风格不一致
**解决**: 先提取已有教案的结构和风格，作为新教案的模板

### 问题 4: Word 文档占位符替换后格式丢失
**问题描述**: 
- 模板中占位符前面的文字（如"**重点：**"）有特定格式（粗体）
- 占位符本身设置为非粗体
- 替换后，前面的粗体格式消失，或者替换内容错误地继承了前面的粗体格式
- 影响字段：`key_points`、`difficult_points`、`required_reading_list`、`recommended_reading_list`、`pre_class_reflection_questions`、`other_pre_class_preparation` 等

**根本原因**:
旧的替换逻辑会：
1. 获取第一个run的格式作为"base_format"
2. 清空整个段落
3. 用统一的base_format重建所有内容
4. 导致每个run的独立格式丢失

**解决方案** (2025-10-05):
实现了精细化的run级别格式保留机制：

1. **保留每个run的独立格式**
   - 不再使用统一的"base_format"
   - 为每个run单独记录格式信息（字体、大小、粗体、斜体、下划线、颜色等）

2. **精确拆分和替换**
   - 逐个处理每个run，只替换包含占位符的run
   - 将包含占位符的run拆分成3部分：
     * 占位符前的文字 → 保留原run格式（包括粗体）
     * 替换值 → 使用占位符自己的格式（明确设置为非粗体）
     * 占位符后的文字 → 保留原run格式

3. **明确格式控制**
   - 对于替换值，明确设置 `font_bold = False`
   - 不继承前面文字的装饰性格式（粗体、斜体、下划线）
   - 只继承基础格式（字体名称、大小、颜色）

4. **多行文本支持**
   - 替换值包含换行符时，自动创建新段落
   - 每个新段落继承原始段落格式（缩进、对齐、间距等）

**实施文件**: `tools/generate_docs.py` 中的 `replace_placeholders_in_runs()` 方法

**验证方法**:
```bash
# 生成单个文档测试
python tools/generate_docs.py generate \
  courses/course-002-三维动画基础-数字建模/lessons/lesson-09.yml \
  templates/lesson/lesson.docx \
  output/ \
  -o output/test.docx \
  --debug

# 批量生成验证
python tools/generate_docs.py batch \
  courses/course-002-三维动画基础-数字建模/lessons/ \
  templates/lesson/lesson.docx \
  output/ \
  --continue-on-error
```

**检查要点**:
- 打开生成的docx文件
- 检查"重点："、"难点："等标签文字是否保持粗体
- 检查替换后的内容是否为非粗体
- 检查多行内容的首行缩进是否正确

---

*更新时间: 2025-10-05*  
*记录者: Ada (Lesson-Weaver)*



