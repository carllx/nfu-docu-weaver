交互艺术与技术能对空间环境营造、增强公众体验带来积极影响，是包括博物馆在内的公共文化服务场所提升品质的重要手段。  

一龚良南京博物院名誉院长
		
# 交互艺术与技术

钱凤德洪天宇马镇宇编著

艺术与技术的交叉融合，是艺术教育创新的关键所在。本教材立足专业创新发展，是高校艺术设计教学改革的新探索，呼应了艺术设计专业建设的新需求。

—龙迪勇东南大学艺术学院院长

为交互设计师和艺术家开发的工具和方法一直在持续的更新中，这些工作使能和放大了他们的想象力和实现力。交互艺术创作是实践性非常强的工作，本书通过一个个生动的案例，让学生循序渐进地了解和掌握交互作品所使用的多种表现技术，在动手实践中感悟技术对于交互体验的基础性作用。

一顾振宇上海交通大学设计学院教授，交互设计研完所所长；中国工业设计协会信息和交互设计专业委员会执行主任当今的艺术设计与现代技术的融合已成为各个院校艺术设计教育的发展趋势，本教材根据艺术设计专业发展的新需求，从实践角度出发诠释了交互艺术设计中的主流技术，对培养集艺术与技术能力于一身的复合型人才具有重要意义。

-3吴国欣原同济大学创意设计学院教授

数字媒体的创新发展离不开高质量的专业教育，本教材由浅入深地讲解了交互艺术创作的技术实现问题，通过实验教学的方式加强学生动手能力的培养，对学生和专业从业人员是一本非常值得推荐的参考书。

-3权磊深圳市数字创意与多媒体行业协会创始会长

![images/3612db1a1d6a6e0f1a44fbc8995e3da4edf36016a72ecbd04b80a086c4cd6390.jpg](https://i.imgur.com/CIi0upJ.jpeg)

![images/5784a3c772583f470949860db774d18466725d6463e7d15f83f30d3db44d8002.jpg](https://i.imgur.com/nRaKNUY.jpeg)

源文件、驱动文件服务: 关注公众号“南工艺科”PPT课件支持: www.cipedu.com.cn

![images/a6e656b81676afac9d016498c917dbe83e8554b28196fab3d830f8b2e36d09fb.jpg](https://i.imgur.com/4UxCxsv.jpeg)
销售分类建议: 艺术设计

定价: 98.00元源文件、驱动文件服务: 关注公众号“南工艺科”PPT课件支持: wwww.cipedu.com.cn

普通高等教育一流本科专业建设成果教材化学工业出版社“十四五”普通高等教育规划教材

钱凤德　洪天宇　马镇宇编著

# 内容简介

《交互艺术与技术》从技术实现的角度系统讲解了交互艺术创作所需的表现技术，从Arduino开源硬件编程起步（打下程序设计基础），过渡到Mind+可视化编程（培养艺术专业学生的逻辑思维与程序设计能力），进一步讲解综合可视化编程软件Touchdesigner（交互艺术与技术的核心），最后讲解利用多种技术实现灯光控制的方法，打通主流信息控制技术在交互艺术创作中的应用。本书配套工程文件可通过扫描封底二维码获取。

本书可供高等教育和职业教育艺术设计类专业相关课程教学使用，也可供灯光、展览、影像创作和跨媒介设计等专业领域人员参考。

**图书在版编目(CIP)数据**

交互艺术与技术/钱凤德，洪天宇，马镇宇编著一北京: 化学工业出版社，2024.8普通高等教育一流本科专业建设成果教材ISBN 978-7-122-45644-1



中国国家版本馆CIP数据核字（2024）第096840号责任编辑: 李玉晖 装帧设计: 孙沁责任校对: 赵懿桐

出版发行: 化学工业出版社（北京市东城区青年湖南街13号邮政编码100011）印装: 中煤（北京）印务有限公司$787\mathrm{mm}\times1092\mathrm{mm}$ 1/16印张15字数351千字 2024年9月北京第1版第1次印刷购书咨询: 010-64518888 售后服务: 010-64518899网 址: http: //www.cip.com.cn凡购买本书，如有缺损质量问题，本社销售中心负责调换。

# 前言

艺术与科技作为高等教育的特设专业，于2012 年被教育部列入普通高等学校本科专业名录。该专业的前身为会展设计与数字音乐，从其源头可以看出，艺术与科技专业从事与展览展示、数字音乐及新媒体影像相关的研究和教学。

随着数字技术与信息技术的发展，智能模块化的产品不断迭代，极大降低了交互艺术创作的技术门槛，设计领域的创作开始将技术作为创意表达的重要手段，这给整个艺术设计的发展注入了全新的内容与活力。艺术与科技的融合成为了艺术设计学科共同关注的问题，艺术设计学科的发展也急需科学技术的支撑。

从当下艺术与科技融合发展的现状看，各层次院校艺术设计类专业的游戏设计、虚拟交互、数字媒体创作、信息可视化等课程已经开始广泛借助数字信息技术进行艺术创作，但总体上艺术与技术仍然属于两个完全不同的学科体系。现有的艺术设计学科教材绝大部分以创作方法论为主导，以应用软件使用为辅助，艺术类专业教学的内容大多聚焦在创意与视觉审美上，融合信息技术的跨学科教材相对较少。从学生专业知识结构看，如果让艺术专业学生完全从基础的信息控制原理与计算机编程开始进行系统学习几乎没有可能，这就需要一本适合艺术类专业学生进行技术学习的教材。本书的编写正是基于这种需求展开的。本书是南京工业大学环境艺术设计专业国家一流本科专业建设成果教材。

本书内容由浅入深，从开源硬件开始，一步一步引导学生进入程序设计的学习，通过对初级与中级程序设计的学习，让学生深度理解程序设计与运行的基本原理和逻辑，进而过渡到高级可视化编程软件Touchdesigner的学习，实现利用多种传感器和智能模块化产品进行交互艺术的创作。本书内容涉及主流的控制方式和媒体内容生产的具体方法，引导学生通过科学技术的加持，逐渐进入到一种全新的艺术创作领域，培养感性与理性相融合的思维模式，探索艺术创作的更多可能。

本书内容的展开建立在大量案例训练基础上，能够极大提升学生的实践能力。希望对交互技术的系统学习，能够为艺术设计专业学生的创作实践插上一双有力的翅膀。

# 目录

[1 交互艺术概述](#1-交互艺术概述)
[1.1 交互与交互艺术](#11-交互与交互艺术) 2
[1.1.1 交互设计](#111-交互设计) 2
[1.1.2 交互艺术](#112-交互艺术) 3
[1.2 交互艺术的发展](#12-交互艺术的发展) 4
[1.3 交互艺术的类型与形式](#13-交互艺术的类型与形式) 4
[1.3.1 物理对象类交互艺术](#131-物理对象类交互艺术) 4
[1.3.2 灯光照明类交互艺术](#132-灯光照明类交互艺术) 8
[1.3.3 视觉影像类交互艺术](#13- -视觉影像类交互艺术) 9
[1.3.4 其他新型的数字艺术](#134-其他新型的数字艺术) 12
[1.4 交互艺术的特征](#14-交互艺术的特征) 14
[1.4.1 技术实现是基础](#141-技术实现是基础) 14
[1.4.2 思想观念是关键](#142-思想观念是关键) 14
[1.4.3 显性隐性是途径](#143-显性隐性是途径) 15

[2 初级交互技术](#2-初级交互技术)
[2.1 Arduino 总体介绍](#21-arduino总体介绍) 18
[2.1.1 开发板](#211-开发板) 18
[2.1.2 相关附件](#212-相关附件) 20
[2.1.3 交互艺术中常用传感器和执行器](#213-交互艺术中常用传感器和执行器) 20
[2.1.4 驱动与开发环境](#214-驱动与开发环境) 23
[2.1.5 开发环境介绍](#215-开发环境介绍) 24
[2.1.6 基本语法结构](#216-基本语法结构) 25
[2.2 程序设计实践](#22-程序设计实践) 25
[2.2.1 案例 2-1: Blink 闪烁灯](#221-案例-2-1-blink-闪烁灯) 25
[2.2.2 案例-2-2: 点亮外部LED](#222-案例2-2-点亮外部led)  26
[2.2.3 案例2-3: 用按钮控制LED灯](#223-案例2-3-用按钮控制-led灯) 27
[2.2.4 案例2-4: 序列本输出](#224-案例2-4-序列本输出) 28
[2.2.5 案例2-5: 用可变电阻控制LED灯](#225-案例2-5-用可变电阻控制led灯) 29
[2.2.6 案例2-6: 音乐灯光的同步控制](#226-案例2-6-音乐灯光的同步控制) 30
[2.2.7 案例2-7: 用可变电阻控制伺服电机](#227-案例2-7-用可变电阻控制伺服电机) 35
[2.2.8 案例2-8: 用程序控制步进电机](#228-案例2-8-用程序控制步进电机) 36


[3 中级可视化编程](#3-中级可视化编程)
[3.1软件下载安装与界面](#31-软件下载安装与界面) 39
[3.1.1 软件安装](#311-软件安装) 40
[3.1.2 常见问题](#312-常见问题) 41
[3.1.3 软件界面](#313-软件界面) 42
[3.2工作模式与编程流程](#32-工作模式与编程流程) 43
[3.2.1 实时模式界面](#321-实时模式界面) 44
[3.2.2 上传模式界面](#322-上传模式界面) 45
[3.2.3 Python 模式](#323-python-模式) 49
[3.2.4 Mind+ 硬件编程流程](#324-mind-硬件编程流程) 49
[3.3可视化编程实践](#3-可视化编程实践) 50
[3.3.1案例3-1: 点亮LED灯并控制闪烁](#3-1-案例3-1-点亮led灯并控制闪烁) 50
[3.3.2 案例3-2: 用数字按钮控制LED灯](#3-2-案例3-2-用数字按钮控制led灯) 51
[3.3.3 案例3-3: 红外入侵检测装置](#3-3-案例3-3-红外入侵检测装置) 52
[3.3.4 案例3-4: 制作呼吸灯](#3-4-案例3-4-制作呼吸灯) 53
[3.3.5 案例3-5: 利用可变电阻制作旋钮可调灯](#3-5-案例3-5-利用可变电阻制作旋钮可调灯) 55
[3.3.6 案例3-6: 制作智能灯声控灯](#3-6-案例3-6-制作智能灯声控灯) 56
[3.3.7 案例3-7: 楼道自动控制灯](#3-7-案例3-7-楼道自动控制灯) 58
[3.3.8 案例3-8: 制作空中弹琴装置](#3-8-案例3-8-制作空中弹琴装置) 59
[3.3.9 案例3-9: 制作超声波测距仪](#3-9-案例3-9-制作超声波测距仪) 62
[3.3.10 案例3-10: 制作人数计数器](#3-10-案例3-10-制作人数计数器) 63


[4 高级可视化编程](#4-高级可视化编程)
[4.1软件介绍与安装](#41-软件介绍与安装) 65
[4.1.1 软件介绍](#411-软件介绍) 66
[4.1.2 软件安装](#412-软件安装) 66
[4.1.3 界面介绍](#413-界面介绍) 67
[4.1.4 界面介绍](#414-界面介绍) 67
[4.2 Touchdesigner基础](#42-touchdesigner基础) 70
[4.2.1 鼠标操作与快捷键](#421-鼠标操作与快捷键) 70
[4.2.2 元件的概念和分类](#422-元件的概念和分类) 70
[4.2.3 元件的属性](#423-元件的属性) 74
[4.2.4 元件的层级](#424-元件的层级) 76
[4.2.5 元件之间的引用](#425-元件之间的引用) 76
[4.2.6 实时视觉特效](#426-实时视觉特效) 77
[4.2.7 三维渲染五件套](#427-三维渲染五件套) 80
[4.2.8 影像输出设置](#428-影像输出设置) 86
[4.2.9 全屏自动播放设置](#429-全屏自动播放设置) 88
[4.2.10 常见问题与操作技巧](#4210-常见问题与操作技巧) 89


[5 数字生成与交互](#5-数字生成与交互)
[5.1 交互艺术的创意与设计流程](#51-交互艺术的创意与设计流程) 92
[5.1.1 创意来源](#511-创意来源) 92
[5.1.2 创作流程](#512-创作流程) 93
[5.2 生成艺术之“烟雨水墨”（案例5-1）](#52-生成艺术之烟雨水墨) 93
[5.2.1 概念创意与学习重点](#521-概念创意与学习重点) 93
[5.2.2 设计过程详解](#522-设计过程详解) 94
[5.3 手势交互之“淘气的粽子（案例5-2）”](#53-手势交互之淘气的粽子案例5-2) 100
[5.3.1 概念创意与学习重点](#531-概念创意与学习重点) 100
[5.3.2 设计过程详解](#532-设计过程详解) 101
[5.3.3 后期效果](#5-3-3-后期效果) 112
[5.4 体感交互之 "畅想雨季"（案例5-3）](#54-体感交互之畅想雨季) 116
[5.4.1 概念创意与学习重点](#541-概念创意与学习重点) 116
[5.4.2 Kinect 传感器](#542-kinect-传感器) 116
[5.4.3 设计过程详解](#543-设计过程详解) 118
[5.4.4 后期渲染与处理](#544-后期渲染与处理) 125

[6 物理交互艺术综合创作](#6-物理交互艺术综合创作) 129
[6.1 物体交互之“击战病毒”](#61-物体交互之击战病毒) （案例6-1） 130
[6.1.1 概念创意与学习重点](#611-概念创意与学习重点) 130
[6.1.2 设计过程详解](#612-设计过程详解) 130
[6.1.3 硬件准备与程序烧录](#613-硬件准备与程序烧录) 130
[6.1.4 影像内容制作](#614-影像内容制作) 13- 
[6.1.5 交互设置](#615-交互设置) 137
[6.2 激光雷达交互艺术之“物语”](#62-激光雷达交互艺术之物语) （案例6-2） 140
[6.2.1 概念创意与学习重点](#621-概念创意与学习重点) 140
[6.2.2 激光雷达的连接](#622-激光雷达的连接) 140
[6.2.3 设计思路分析](#623-设计思路分析) 145
[6.2.4 内容制作](#624-内容制作) 145
[6.2.5 交互设置](#625-交互设置) 149
[6.2.6 三维投影与效果展示](#626-三维投影与效果展示) 153

[7 灯光控制与交互艺术](#7-灯光控制与交互艺术) 157
[7.1 DMX通信协议与光源](#71-dmx通信协议与光源) 158
[7.1.1 DMX通信协议与光源](#711-dmx-通信协议与光源) 158
[7.1.2 DMX光源的写码步骤](#712-dmx光源的写码步骤) 159
[7.2 SPI通信协议与光源](#72-spi通信协议与光源) 162
[7.3 灯光控制之程序设计](#73-灯光控制之程序设计) 165
[7.3.1 FastLED 库与安装方法](#731-fastled-库与安装方法) 165
[7.3.2 灯控程序的语法与结构](#732-灯控程序的语法与结构) 167 （案例7-27） 203
[7.3.3 初步灯光动态控制](#73- -初步灯光动态控制)
（案例 7-1～案例 7-9） 168
[7.3.4 用不同的颜色模式控制灯光](#734-用不同的颜色模式控制灯光)
（案例 7-10～案例 7-14） 172 （案例7-28） 209
[7.3.5 常用灯光控制的内置函数](#735-常用灯光控制的内置函数)
（案例7-15～案例7-18） 176
[7.3.6FastLED库的内置色板的调用](#736-fastled库的内置色板的调用)
（案例7-19～案例7-21） 179
[7.3.7常用灯光控制函数的综合应用](#737-常用灯光控制函数的综合应用)
（案例7-29） 217
（案例7-22、案例7-23） 182
[7.4灯光控制之图像映射](#74-灯光控制之图像映射) 185
[7.4.1Touchdesigner 矩阵屏图像映射](#741-touchdesigner-矩阵屏图像映射) （案例7-24） 185
[7.4.2用LED控制器点亮矩阵屏](#742-用led控制器点亮矩阵屏) （案例7-25） 189
[7.4.3 控制器图像映射控制方案](#743-控制器图像映射控制方案) 192
[7.4.4 软件介绍](#744-软件介绍) 193
[7.4.5 灯光造型设置模块](#745-灯光造型设置模块) 194
[7.4.6 花样（灯效）设置模块](#746-花样灯效设置模块) 197
[7.4.7 灯光效果编辑](#747-灯光效果编辑) （案例7-26）200
[7.4.8 主控分控图像映射系统](#748-主控分控图像映射系统)
[7.5 灯光控制之机械灯](#75-灯光控制之机械灯) 208
[7.5.1灯具介绍及控制原理](#751-灯具介绍及控制原理) 208
[7.5.2用TD控制机械摇头帕灯](#752-用td控制机械摇头帕灯)
[7.6 其他专业灯光控制软件](#76-其他专业灯光控制软件) 213
[7.6.1MADRIX 灯光控制](#761-madrix-灯光控制) 213
[7.6.2 软件界面介绍](#762-软件界面介绍) 214
[7.6.3 3D灯光矩阵光影秀](#763-3d灯光矩阵光影秀)
[7.6.4 Depence 软件简介](#764-depence-软件简介) 220


附录 223

附录1 Touchdesigner 常用

表达式 224

附录2元件索引 225

附录3学习资源 226

附录4材料列表 228

参考文献 231

后记 232

![images/f2c59dcefb43d8f98796283df3f9b324751becfe17b89ffad17022c6410313d9.jpg](https://i.imgur.com/XOuTzN3.jpeg)

# 1 交互艺术概述

1.1交互与交互艺术
1.2交互艺术的发展
1.3交互艺术的类型与形式
1.4交互艺术的特征

## 1.1 交互与交互艺术

### 1.1.1 交互设计

交互设计（Interaction Design）是一种以人为中心的设计理念。目前学术界对交互的认知多指工业产品领域的人机交互，其主要研究人与机器之间的关系，具体表现在界面设计（图1-1），通过研究用户感知（feel）、认知（know）和操作（do）三个问题，解决工业产品功能使用方面的问题，即如何通过良好的视觉界面设计与认知逻辑，给用户提供一个好用、易用的软硬件产品，主要涉及如下几个方面的问题。

![images/e3387dd01085974f1ba9ed49fec255c0667d2aea0a4bf8b6ceb2c6729fa8e1fd.jpg](https://i.imgur.com/ML2TLBU.jpeg)
图1-1UI领域中的交互设计

用户研究: 理解和定义用户的需求、期望和行为模式。

2 用户界面设计: 创建直观、易用的用户界面，包括布局、颜色、字体等视觉元素，以科学的信息架构与认知逻辑，组织和标记信息，使其易于理解和导航。

用户体验评估: 用不同的交互模型，通过用户测试和反馈，评估设计方案的有效性。

交互设计最终实现的目标主要表现在以下几个方面: 

- 提升产品的吸引力，通过界面设计抓住用户的注意力，提升产品对用户的黏性。
- 提升产品的可用性，能够让用户快速理解如何操作产品，以最少的时间和学习成本使用产品。
- 提升用户满意度: 充分考虑人的行为习惯和心理预期，通过良好的使用体验，引起

用户的正面情感反应，提供愉快的使用体验。

### 1.1.2 交互艺术

交互是人类生存和发展的需要，是人类和其他动物适应自然和繁衍进化所必需的基本能力，也是艺术欣赏过程中的一种自发行为。例如观众在参观罗丹著名雕塑艺术作品《思想者》（图1-2）时，不同知识背景的参观者对作品的解读是不一样的，所获得的审美体验也是不同的，这种产生于参观者与作品之间的审美体验就是来自人本能的一种情感交互。这样的交互是以静态方式，单向地由参观者向展品发出自我情感的反馈。在这个过程中参观者处于主动地位，艺术作品处于被动地位。

本书所讲的“交互”主要是指具有交互特征的艺术和装置作品，即在欣赏艺术作品的过程中，能够引l发观众在行为方面的互动，同时在情感上也能与作品产生深度的交流。主要关注的问题是如何通过交互性来提升参观者的情感体验，如《畅想雨季》交互艺术作品（图1-3 ），作品借助声音与抽象雨滴的画面，创造出独特而又令人陶醉的雨季场景。参与者在影像前行走，雨水仿佛倾泻而下，可以让人体验到置身雨中的感受，唤起雨中玩耍的童年记忆，重现在雨中舞动的欢乐，能够让人释放压力、放松身心。

![images/23b2f1ebd6936c8dd4ceedf1564fb6dc2f2d51c98e6d391f112a22fc0e8ced83.jpg](https://i.imgur.com/qhnJMvN.jpeg)
图1-2思想者

![images/eb182fb41d50640285ec853e42b10032781d9faee66c7b43cc66b9238c4d225f.jpg](https://i.imgur.com/DkZJhYN.jpeg)
图1-3 畅想雨季（创作: 于淼）

传统艺术的交互是相对静态的情感体验，交互艺术的“交互”则更多强调通过参观者的行为与心理活动共同表达此类艺术作品的价值。在这个过程中，交互不是静态单向而是动态双向的，两者之间始终处在一个互相反馈的状态中，参观者的行为动作会通过传感器实时反馈到作品中去，作品的实时变化会同步激发观众的行为举动。

## 1.2 交互艺术的发展

从交互艺术的外在表现形式看，它与新媒体艺术是一脉相承的。20 世纪 60年代，欧美艺术家们开始使用新的媒介去进行艺术创作，如波普艺术家罗伯特·劳森伯格（RobertRauschenberg）、安迪·沃霍尔（Andy Warhol），钢琴家大卫·图德（David Tudor）等均尝试过与科学家合作探索新的艺术创作模式，试图用全新的思维模式和表现方式创造新的体验，他们在空间、光影、音效及装置艺术作品中取得了巨大成功，奠定了新媒体艺术的基础。

随着计算机科学的飞速发展和数字媒介的不断迭代，新媒体艺术的概念也在不断更新。早期美国学者 Mark Trible 曾认为新媒体艺术包含光盘（CD-ROM）、网络艺术（NetArt）、数字录像艺术（Digital Video）、网络广播（Net Radio）等；澳大利亚学者 Susan Acret认为数字化时代的新媒体艺术是一个非常宽泛的词，主要特征是利用先进的技术语言推动艺术创作，包括利用电脑、互联网、虚拟技术的艺术影像及多媒体互动装置；中国学者鲁晓波将其描述为以信息技术为依托，以文字、声音和图像等多媒体为载体，具有实时性、交互性、体验性的一种艺术。联合国教科文组织也曾指出，新媒体是“由数字技术支持的以数字化为基础的全球性的沟通媒介”，它具有双向传播性，颠覆了传统的传播理念。从新媒体艺术的发展和专家学者的论述中可以看出，新媒体艺术有“交互性、数字化、虚拟化和非线性”等诸多特点。

目前新媒体艺术开始将更多媒介融合在一起共同表达特定的思想观念，其表现形式逐渐由原来以互联网虚拟技术为核心的交互方式，转向了与实体环境相结合的物理交互，从而给观众带来了全方位的体验。例如物理空间中的交互装置、以数字音频视频为载体的影像艺术、以灯光媒介为载体的照明装置艺术，以水为载体的水秀作品等。新媒体艺术正在转换为以“交互”为特征的新形式，这就是我们所讲的“交互艺术”。

## 1.3  交互艺术的类型与形式

交互艺术作品的交互方式主要有以下四种基本类型。

### 1.3 .1 物理对象类交互艺术

此类交互艺术作品占据三维物理空间，是一组实体物理对象，将原本没有生命的物理对象转化为可以与人对话的装置作品，能够带给人出其不意的新奇感受，常用的技术是建立在计算机算法基础上的控制技术与人工智能技术。

#### 1.3 .1.1 电器机械类交互艺术

电器机械类交互艺术主要指通过机械结构进行人机互动，结合特定的艺术造型语言，产生具有节奏韵律美的动态艺术装置，此类作品一般通过各类传感器将人的行为动作转化成数字信号，经由计算机处理后，输出一系列控制指令，实现对物的控制，让人与作品之间建立起一系列的互动反馈，实现人与物在行为与心理层面的互动。例如交互装置作品《DiffusionChoir》（图1-4），作为机械交互艺术类的经典作品，它由 Sosolimited,Plebian Design 和Hypersonic共同创作，于2016年在美国马萨诸塞州剑桥市的一栋办公大楼内展出。

该雕塑通过可视化无形鸟群的运动来表达协作的有机美，四百个折叠元素形成了一个抽象的集群悬挂于阳光明媚的中庭空间中。每个元素都可以独立地打开和关闭，由运行群集算法的软件控制，雕塑的运动会不断演变，受到群集模拟的驱动，鸟群会流畅地在空中飞翔。每隔15分钟时段，每个个体会以特殊的姿态进行编排。该雕塑反映了建筑中正在进行的融合和创新，作品优美的姿态和呼吸般的运动为建筑创造了一个开放、沉思的空间。

![images/a44de337d48ace8cb647d40f8e87bf5873f19993ed89941b57653a49f506eab5.jpg](https://i.imgur.com/tDI10VA.jpeg)
图1-4Diffusion Choir（创作: Sosolimited等）

这件作品的灵感来源于自然界的群体行为，比如鸟群的飞行或鱼群的游动。艺术家们通过编程和机械设计，将这种自然现象转化为一种视觉艺术表达。它融合了科技和艺术，通过模拟自然现象，为人们带来了一种全新的视觉体验。这种具有节奏和韵律的变化产生了一般影像无法比拟的视觉效果。

韩国新媒体设计师U-RamChoe的灯光装置《发光的永生花》（图1-5），其通过缓慢的闭合动作实现了对开花过程的模拟，因为正常状态下我们无法直观感受到真实植物的开花过程，所以开花装置会给人带来一种不小的惊喜，该作品由多个用树脂和不锈钢制成的金属花蕾组成一个动态雕塑。艺术家用光和电赋予这些金属生命，使它们开始呼吸、绽放。作者专注于自然主题，擅长创作生物形态的机械动力雕塑。他认为一切生命都会运动，因此在创作机械新物种时，运动是他作品的重要组成部分，这种依靠机械运动给原本无生命的对象赋予新的生机、对原本不能轻易感受到的微观运动进行视觉化的方法，给我们了解微观世界打开了一扇窗。在影像内容极大丰富且日趋同质化的时代，朴素的物理机械装置带来的真实感更能从内心深处感染参观者情绪，也带来了与众不同的观赏体验。

![images/056c6070636379a30a211b3f9f7d0b538f32df67cbcec8ce5d153bfff7d34b8d.jpg](https://i.imgur.com/iHNFRbc.jpeg)
图1-5发光的永生花（创作: U-Ram Choe）

#### 1.3.1.2 实物声音可视化

实物声音可视化作品主要通过实物媒介，将原本通过听觉感知的声音内容以实物可见的方式呈现在参观者面前，颠覆了我们对声音的感知方式，如实物声音可视化作品《有声有色》（图1-6），它通过碳纤维作为振动的载体，将振动源传递出的特定频率传导在碳纤维棒上，当振动源发出特定频率的声波时，由于共振现象会让不同长度的碳纤维产生明显的振动，从而把只可听而不可看的声音转换成了可见对象。

![images/84e851bc54c762e9c26ad73632dc1596e946bfae18390bfa0ffd0f7686d1610b.jpg](https://i.imgur.com/uXLZP29.jpeg)
图1-6有声有色（创作: Ryan-追梦梭）

该作品利用了声学、材料学的知识，通过设计造型学的设计，将科学与艺术完美地融合在一起，以装置艺术的方式呈现在观众面前，从另一个维度诠释了装置艺术在感官交互方面的一种特殊形式，具有极强的探索性与表现力，为未来设计创作表现提供了新的思路。

#### 1.3.1.3 物体交互艺术

物体交互艺术是另一类依靠实物对象的交互艺术，它通过一系列物体的自然连接与组合，形成了既合乎情理又令人新奇的艺术效果，如作品《into thewind》（图1-7）。它表达了存在于我们中间的一种自然力量“风”，讲述了风产生的自然过程。参与者在一个装置前轻轻吹气，后方装置便会产生一股较大的气流吹起一个硕大的气泡，由此让参与者感受到自然界中风的形成过程并产生对自我力量的理解与深度体验。

该作品起初是一项试验，旨在基于技术手段和人类感知在空间中再现自然过程。主要焦点是风，一种在我们之间流动的简单自然力量。我们看不见它，但我们可以感受到它的存在，感受到它的运动与呼吸。这个装置邀请观众通过呼吸来复制并再现风的状态，通过吹泡泡来诠释风产生的过程。它通过计算机编程将人的呼吸变成控制信号驱动风扇形成风，然后通过泡泡表现出来，泡泡的形状和外形也会因观众吹气的方式而异，其每次互动的结果都是独特的。观众可以通过透明的结构体观察整个过程，既是参与欣赏者，也是装置构成的一部分，共同形成了这个完整的装置。

![images/f6dcd13004d47ff234bdc743245d93c619060506831278408d9780d8cf12a7b4.jpg](https://i.imgur.com/BcjB9qp.jpeg)
图1-7into the wind（创作:Witaya Junma）

#### 1.3.2 灯光照明类交互艺术

##### 1.3.2.1 公共灯光交互艺术

公共灯光交互艺术利用可编程LED 光源作为最终的表现载体，以计算机控制技术将人物的动作行为与灯光进行互动，在视觉与心理层面给参与者带来更多情感上的反馈，如灯光交互艺术作品《燃放》（图1-8）。该作品综合利用了灯光、声音和视觉影像的互动，利用体感传感器将人物动作捕捉后，通过可视化编程软件制作粒子系统，最后将视频信号转化为光电信号传输给LED 光源，通过大屏展现在参观者面前。参与者通过挥动双手即可实现燃放烟花的壮观场景。参与者的手势和运动速度都会随机控制烟花的颜色、形状和形态，创造出了独一无二的艺术效果，给参与者带来了强烈的交互体验。

![images/34f295c192a548a43b1112c69705458937509deffbb6fb4f967d5995bb8b590c.jpg](https://i.imgur.com/94h1lf8.jpeg)
图1-8燃放（创作: 洪天宇）

##### 1.3.2.2 灯光秀场交互艺术

在计算机控制技术支撑下，通过控制灯光的色彩和点亮方式，可以形成有别于其他艺术媒介的特殊效果，如在各种不同尺度空间中的灯光秀作品，特别是在商业项目上，它能将品牌特有的文化元素与灯光进行深度融合，能实现照明与品牌文化推广的多重功能，还能利用计算机控制技术制造出其他媒介所不具有的新鲜感。如《雀巢概念店》（图1-9），为了突出品牌创新、多彩、乐观的精神内涵，设计者把雀巢咖啡的包装瓶作为构成灯光交互艺术作品的基本元素，为雀巢量身设计了别具一格的多媒体“像素大门”和“隐形屏幕”。作品由3000颗多趣酷思咖啡胶囊组成，其中约1000颗的白色胶囊中被置入可编程的LED灯珠，每一个装载咖啡的塑料瓶成为了灯光的外罩，以一种“反复构成”的方式完成了整个店面的矩阵屏结构，品牌视觉冲击力极强。

该灯光装置利用灯光控制与传感技术，将街道上的环境信息实时地传送到店面的矩阵屏上，品牌与空间环境深度地融合到了一起，呈现出一幕幕有趣的动态图形，既充当了信息交流的媒介，又增加了墙体的多种功能。

![images/50adb73c805be33bd112076d95ce77e27b7af554037187d9624ef2f787e0ce3e.jpg](https://i.imgur.com/lffrb95.jpeg)
图1-9雀巢概念店（创作: SODA Architects）

#### 1.3.3 视觉影像类交互艺术

该类作品主要是通过数字生成的方式实现视觉与肢体动作交互的效果，显著特征是影像的形式与内容与参观者的心理活动形成一个有机整体，作品在情感体验上具有极强的沉浸感。

##### 1.3.3.1 数字生成交互艺术

以计算机技术为支撑，通过算法形成各种动态的数字影像，数字内容的形式表现与作品主题表达形成高度的一致性，给参与者的情感体验带来前所未有的沉浸性，如数字影像生成艺术作品《创伤（Trauma）》（图1-10）。它在几何体基础上采用粒子系统和形状的随机变化，配合各种富有情绪的色彩体系。当参观者凝视作品时，独有的医疗×光照射效果配合音乐，会让人体会到一种悲伤的美，随机生成无重复的视觉效果，让人产生连绵不断的好奇心与探索欲。

数字生成艺术的重要特点是画面精度容易控制，利用大尺度超清显示设备，配合高清影像内容，更容易给人带来震撼的视觉效果，如阿里未来酒店中的壁画作品（图1-11）。壁画主题为“取自然之沉静，集科技之灵动”，内容分为大海、白瀑和星空三个场景，特别是星空画面，它由成干上万个粒子组成始终在变化的抽象画。这些粒子犹如世间万物，在日夜变换的无穷岁月中生生不息。人走近屏幕，就会影响屏幕画面的呈现，每一次画面的变化都暗示着每一个人都有其存在的独特意义。整个壁画依靠唯美的画面和高清显示技术，为空间品位的提升起到了极大作用，为静止的建筑空间增加了灵动性。

![images/3caab394599e9f8b75ecc6d206684f3d164571b6321c254a0b5d555683c5d660.jpg](https://i.imgur.com/uTydGQl.jpeg)
图1-10Trauma（创作: Regen）

![images/2446f4c3da37f241ea5e5c322a24c701e998c419d496850f92da62dac06e7b61.jpg](https://i.imgur.com/D2CcjgX.jpeg)
图1-11阿里未来酒店中的壁画作品（创作: Wonderlabs）

##### 1.3.3.2 沉浸影像艺术

随着沉浸艺术在大量展馆和户外旅游项目中的流行，产生了一系列富有视觉震撼力和强烈情感体验的交互艺术作品。此类交互艺术主要通过巨型影像内容对人进行全方位包裹，将人完全置于影像世界当中，视觉与听觉艺术高度整合会给人带来前所未有的情感体验。如沉浸影像交互艺术作品《Time machinehelv relics museum》（图1-12），展示了吴都阖闾城（今无锡）从远古到现代发展的全过程。巨大的屏幕与地面融为一体，观众站在屏幕前完全置于场景中，场景画面展示的视角与观众正好相对，参观者仿佛在与历史对话，各种场景延伸到地面后，通过感应器捕捉观众的行为足迹，让观众与画面内容无缝互动，进一步增强了融入感与沉浸感。

另一件交互影像艺术作品《Edge of Government》（图1-13）占用 350平方米的面积，30个投影仪投射覆盖了整个地板、天花板以及墙壁，创造了一个沉浸式的环境。通过全空间投影的方式，随着访客的移动，地面粒子会随着访客的步伐在地板上形成一条色彩斑斓的道路，长时间没人经过时，地面道路的影像内容会逐渐恢复成粒子状。它用抽象化的视觉语言将观众带入到完全不同的时空中去，让人们不仅观察到影像的内容变化,还会与围绕在身边的影像进行互动。

![images/0eedbea72b74c8f0b0ad6af23bf0b49c82ccdcc5e1da67321bbdb7ba6776faf8.jpg](https://i.imgur.com/Bpgq4CH.jpeg)
图 1-12 Time machine helv relics museum ( 创作: Tamschick Media+Space GmbH)

![images/03dd454d16cbd1d29f1855a27a8299219e0e4a0f1c658468a10545e1419a597b.jpg](https://i.imgur.com/aaOWab7.jpeg)
图1-13Edge of Government（创作:Nohlab）

#### 1.3.4 其他新型的数字艺术

此类作品虽然没有与观众发生直接肢体行为方面的互动，但依靠前沿的数字技术，创造了有别于传统静态艺术形式的情感体验，从心理认知上给人带来了强烈的互动感，此处将其归为其他类型的交互艺术，原因在于其为当下主流数字艺术作品的一种特殊类型，如果用交互技术对其进行叠加，可以产生更加强烈的艺术效果。

##### 1.3.4.1 裸眼 3D 艺术

提到裸眼 3D必然绕不开经典作品《鲸（whale）》（图 1-14），D'strict 是一家整合内容与数字技术来创造新型空间体验的设计公司。该作品将纽约时代广场上的1400平方米广告牌屏幕转化为了一个三维起伏的海洋环境，其中一只鲸鱼自由地驰骋在波浪中。它利用了街道建筑环境的独特视角，创造了一个超现实的3D场景，巨大的鲸鱼以水元素渲染，在有限的空间内游动并融入波浪中。该作品希望将人们从过量的商业广告和充满光污染的城市环境中解救出来，从而获得片刻的放松，暗示了让人们从一个不眠之城中获得自由的瞬间。细腻的画质表现为3D效果增加了更多的真实感，汹涌澎湃的水体和巨大的鲸不断刺激着人们的心理承受力，实现了情感与视觉的强烈震撼。

![images/7f30f57944e08dc28537103c2137fcc86a1a22d6ed39fd1cac57e7e3c2ebf598.jpg](https://i.imgur.com/luUCAzA.jpeg)
图1-14whale（创作: D'strict）

##### 1.3.4.2AR增强现实

增强现实常见于在物理空间中增加动态的媒体内容，如在纸质书上扫描出立体的动态影像，或者通过AR眼镜将真实场景与动态影像进行叠加，将虚拟世界与真实事件进行混合，将真实的影像与虚拟影像处理成同一个视角，实时显示在屏幕上，达到增强现实的目的。如广州塔AR秀（图1-15），作品利用将虚拟世界和真实场景“无缝”融合，把预先制作的CG动画和光影特效叠加到真实环境中，通过AR眼镜或电视屏幕实时渲染出以假乱真的视觉场景，打造出一种超越现实的视觉盛宴。

![images/2b0ebd3eaf8b3869d4e487c2c437ea1a89ae25e7c93abfc21004bb818af623fc.jpg](https://i.imgur.com/WSPv1el.jpeg)
图1-15广州塔AR秀（创作: 投石科技）

##### 1.3.4.3 3DMapping

3DMapping技术是将投影画面的内容与投射对象完全拟合的一种技术，它的基本原理是:使用软件将预先制作好的 3D 图像投影到实际物体的表面上，通过计算机技术控制图像的透视与轮廓效果，使投影出来的图像严丝合缝地贴合在物体的表面上，产生逼真的3D 效果。这种技术可以让各种不规则的物体“变脸”，建筑物、汽车、人体等都可以作为 3DMapping 的投影媒介。通过在物体表面形成的逼真影像，可以实现惊艳的视觉效果。

如作品《物语》（图1-16），该作品将雨花石的纹理映射到一块光滑的石头上，同步有水流声，当用手触碰石头上的纹理时会产生涟漪形状的纹理变化，并伴随“哗啦啦”的戏水声，仿佛物体在与人对话，因此命名为《物语》，整个装置让人体验到在空中戏水的感觉。

![images/9a18b70dc612a866eff3383e4e12a5d2df0fbe5cd15c0bf760c3e2e6dab6a4f3.jpg](https://i.imgur.com/Evm13eR.jpeg)
图1-16物语（创作: 焦文博）

## 1.4 交互艺术的特征

### 1.4.1 技术实现是基础

在交互艺术中，交互技术是实现艺术作品互动的基础。它涉及多种技术手段，包括传感器、计算机视觉、语音识别、数字生成、人工智能等。通过这些手段实现人与作品之间的行为与情感互动。交互技术的应用不仅可以增强艺术作品的趣味性和吸引力，还可以让观众更深入地了解作品的内涵和意义，创造出独特且引人入胜的交互体验。在数字化时代，交互已经成为一种新的艺术表现形式，其应用范围越来越广，对于推动艺术与科技的融合具有重要意义。因此，我们需要不断探索和研究交互技术的应用场景和前沿发展，以便更好地发挥其在交互艺术中的作用。

### 1.4.2 思想观念是关键

在任何艺术形式中，思想观念是核心。交互艺术也不例外，它不仅是一种形式上的创新，更是一种表达思想观念的方式。思想观念与情感的共鸣是检验艺术创作质量的重要标志之一，思想观念的表达既要有纵向的深度，也要有情感的厚度。在交互艺术中，思想观念的表现方式非常多样，它不仅仅局限于作品本身，更重要的是如何引导观众参与其中，通过体验和互动来让受众理解和感受这些思想和观念，具体有如下几种方式。

创造引人入胜的交互体验: 交互设计应该引导观众参与其中，赋予他们一种探索和发现的感觉。设计应该直观易懂，让观众知道他们可以如何与作品互动，并通过互动得到反馈。

2 利用故事叙述创造悬念: 故事是传达思想和观念的强大工具。艺术家可以通过创造有吸引力的故事，引导观众在参与过程中理解其主题。

3创造社会互动: 鼓励观众之间的互动，增强他们对作品的参与感和共享感。例如，一些作品让观众共同完成某项任务或者分享他们的体验。

艺术作品往往能引发强烈的情感反应，这也是传达思想和观念的有效方式。设计可以创造出欢乐、惊奇、思考甚至不安等情感的体验，这样不仅仅是为了吸引观众的眼球，更是为了让观众更好地理解作品所要表达的思想。

在交互艺术中，思想观念需要与技术充分结合。艺术家需要运用各种技术手段来实现自己的创意，这样才能真正实现作品的价值。因此，技术和思想观念是相辅相成的。

### 1.4.3 显性隐性是途径

新媒体艺术创作目标主要表现在两个方面。一个是创造出强烈的视觉吸引力，通过具有震撼力的视觉效果征服观众，即显性表达。显性表达是指通过明确的符号、形式和语言来传达信息和意义。另一个是通过间接方式传递出具有深刻哲理的思想观念即隐性表达，主要通过暗示、模糊的隐喻来表达情感和思想。

显性表达是交互艺术中最直接的表现方式，创作者可以通过各种符号和外在的形式来传达他们所要表达的观点。在交互艺术中，显性表达是一种直接、清晰的表达方式，它对于传达艺术家的思想观念和引导观众与作品互动起着重要的作用。在观众与作品交流过程中它有如下几个方面的作用。

提供直观的内容理解: 显性表达直接呈现了艺术家的创作主题和意图，使观众能够迅速理解作品的基本内容和主题。这种直观的理解是观众进一步探索和参与作品的基础。

2 引导观众的互动行为: 在交互艺术中，显性表达可以明确地指示观众如何与作品互动。例如，作品可以通过视觉或声音提示，引导观众特定的行为。

激发观众的情感反应: 显性表达往往能够直接触动观众的情感，引发他们的共鸣。这种情感反应可以增强观众的参与感和体验感。

4 强化信息的有效传递: 显性表达可以强化艺术家想要传达的信息和思想。通过明确、直接的表达方式，艺术家可以确保自己的信息被准确地传达给观众。

然而，显性表达并不意味着艺术家要将所有的内容和意图都明确地告诉观众。艺术作品往往需要留给观众一定的想象空间，让他们在互动过程中自己去发现和理解作品的深层含义。

在交互艺术中，隐性表达是一种暗示性和隐秘性的表达方式，它对于创造深度、丰富体验和引发思考起着重要的作用。

1 创造深度思考: 隐性表达可以为艺术作品增加更多的层次和深度。它鼓励观众深入探索作品，发现隐藏在表面之下的意义和价值，激发观众的思考。通过提出难以直接回答的问题，或者呈现出复杂而微妙的情境，艺术家可以引导观众进行深入的思考和反思。

2 丰富情感体验: 隐性表达可以通过创造出不确定性和惊喜，丰富观众的体验。观众需要自己去发现、解读和理解作品，这个过程本身就是一种有价值的体验。

3建立个人联系: 隐性表达让每个观众都可以根据自己的经验和理解，对作品进行个性化的解读。这种方式可以帮助观众建立与作品的个人联系，增强他们的参与感和归属感。

总的来说，隐性表达是交互艺术中一种重要的表达方式。通过显性表达和隐性表达的结合，艺术家可以创造出丰富多元、引人入胜的交互体验。

$$
\ast
$$

# 2 初级交互技术

![images/5351341daf920976307569bb894c281fe7ba2435bb74f10a600d14185ee9c35c.jpg](https://i.imgur.com/wmuLtbR.jpeg)

![images/243f4588222f28c49cf72361f8c3647789e3632ce6a1fc1ec037709b181e8da0.jpg](https://i.imgur.com/tmGC75B.jpeg)

初级交互技术Arduino编程

2.1 Arduino 总体介绍
2.2 程序设计实践

## 2.1 Arduino总体介绍

Arduino 是一款开源电子原型平台，它基于简单易用的硬件和软件，为设计师、工程师、艺术家和电子爱好者等提供了一个灵活的、经济实惠的解决方案，包括以下两个主要部分。

1 硬件: Arduino 板是一款基于微控制器的开发板，有多种型号可供选择。这些板子通常具备输入／输出引脚，用于连接传感器、执行器和其他电子元件。常见的 Arduino 板有Uno、Mega、Nano 和 Micro 等。

②软件: Arduino 集成开发环境（IDE）是一个免费的软件，用于编写、编译和上传代码到 Arduino 板。它支持 $\subset++$ 语言，并提供了许多内置库，以便用户能轻松地实现各种功能，如控制LED、读取传感器数据等。在IDE 中编写程序代码，并将程序上传至 Arduino 控制板后（烧录进微控制器），控制板便会按照程序编写的内容发送各种指令，实现数据信息的输出。

### 2.1.1 开发板

（1）Arduino Uno在 Arduino 开发板家族中，Uno 开发板是最适合初学者的。它简单易学、稳定可靠，是一款基于微控制器 ATmega328P 的开发板，有14个数字输入／输出引脚（这些引脚中有6个引脚可以作为PWM 输出引脚），6个模拟输入引脚，支持在线串行编程以及复位按键，用户只需要将开发板与电脑通过USB接口连接就可以使用（图2-1为Arduino Uno 板，图2-2为扩展板）。

![images/d6970d1fcc893f75f8b330f4556f67af71db567592eb064e1f96addc53b366d3.jpg](https://i.imgur.com/aqYa1p3.jpeg)
图2-1Arduino Uno板

![images/c9781423f026c84564dab3e59dbf581e6f3e446ab8e11732882575ba3565341f.jpg](https://i.imgur.com/bTW3VV7.jpeg)
图2-2扩展板

（2）Arduino NanoArduino Nano（图 2-3）是一款类似 Arduino Uno 的开发板，也是基于ATmega328P，与后者的区别是尺寸更加小巧，Nano 没有直流电压供电接口，同时Nano通过Mini-BUSB接口与电脑连接。

（3）Arduino MegaArduino Mega 是一款基于ATmega2560 的开发板（图2-4）。它是为较为复杂的Arduino开发项目而设计的。它有54个数字输入/输出引l脚（其中有15个引|脚可用于PWM输出），16个模拟输出引脚，4个USART硬件串行接口，16MHz晶振，1个USB 接口，1个电源接口，支持在线串行编程以及复位按键。推荐将这款开发板应用于3D打印以及机器人项目，因为这款开发板具备足够的自由发挥空间。

（4）ESP8266-NodeMCUESP8266-NodeMCU也是一个开源硬件开发板（图2-5），它支持Wi-Fi功能，常用在物联网（IOT）领域。ESP8266-NodeMCU尺寸比Nano略大，虽然不是Arduino团队开发的，但也可以使用ArduinoIDE进行程序设计与开发，而且它还有一颗地道的“中国芯”一一ESP8266模块，最新升级款为ESP32。

![images/8ffe3383d1d9e650e18f78f79206c26d14f7b0bbfbc2b5e3a4759981750f6a85.jpg](https://i.imgur.com/AYhkL8X.jpeg)
图2-3Arduino Nano板

![images/a228d7d0b0021e9a2a5cf3dedc90cc8678f77a474cbb5b690a5a3e7d45b0140e.jpg](https://i.imgur.com/RKjSjOz.jpeg)
图2-4Arduino Mega 板

![images/176196f425ca61855e0910bd2cf68f54c49f3629540990c1b633fbd03867a9f2.jpg](https://i.imgur.com/x2yEVMl.jpeg)
图2-5ESP8266-NodeMCU 板

### 2.1.2 相关附件

（1）杜邦线 杜邦线是用来连接各类硬件的连接线，具体分为几种基本类型（图2-6\~图 2-9 ）。

![images/e5c829dccd9f193868a71c650d1469daf980aebcd5e0415e0de853ca4cfff5b4.jpg](https://i.imgur.com/X8zqO9v.jpeg)
图2-6双母口

![images/526b912110ecd63544e4bcb8e24bc1a7cb436d16866c4ebc7ff4c4e0badc1dcb.jpg](https://i.imgur.com/Ur6sFCf.jpeg)
图2-7公母口

![images/28e615622acc67549fcd26965ddb6590366d95cf776d34765116ccb53f51816c.jpg](https://i.imgur.com/QAuDFfo.jpeg)
图2-8双公口

![images/391c966a47375eebbebddd2f66e7d9d713149fa68c45cd128cfcdfeec0c1ebd8.jpg](https://i.imgur.com/znqJEGl.jpeg)
图2-9组合连接线

- 双母口: 两头都是插孔。

- 公母口: 一头插孔，一头插针。

- 双公口: 两头插针。

组合线: 是集正负极与信号线于一体的连接线。

（2）面包板 平台上面两行横向相连，中间部分竖向相连（图2-10、图2-11）。

![images/54b582eb2ff2280af20650a67bace7254300f946018ee3e40efb2293b176b0f7.jpg](https://i.imgur.com/6Hgn5zw.jpeg)
图2-10面包板正面

![images/d1931e176a6ba50908afe21f3cf11f6b5c7a80504761592b2bef5ddbaef507ac.jpg](https://i.imgur.com/MEMGwNy.jpeg)
图2-11面包板反面

### 2.1.3 交互艺术中常用传感器和执行器

数字信号的含义: 数字信号是一些离散的信号，数字信号通常使用1和0表示。数字信号由二进制编码表示，通常用于在计算机和数字系统中传输、处理和存储信息。与模拟信号相比，数字信号具有抗干扰能力强、精度高以及便于处理和复制等优点。

模拟信号的含义: 模拟信号是指在时间和幅度上可以连续变化的信号。在电子工程中，模拟信号是指用连续变化的电压或电流来表示信息的信号。这些信号可以是声音、图像、温度等。模拟信号通常需要经过模拟信号处理进行处理和分析。

交互艺术设计中常用的传感器和执行器见表2-1～表2-3，这些模块能够满足大部分人与物理对象交互设计的需要，其功能和使用方法详见第2、3章案例部分。

表 2-1信息感知模块与功能


<html><body><table><tr><td>模块名称</td><td>信号类型</td><td>实物参考</td><td>模块功能</td></tr><tr><td>触摸传感 模块</td><td>数字信号</td><td></td><td>人体或金属在传感器金属面上的直接触碰会被感应到，除了与金 属面的直接触摸，隔着一定厚度的塑料、玻璃等材料的接触也可以 被感应到，感应灵敏度与接触面的大小和覆盖材料的厚度有关</td></tr><tr><td>环境光 模块</td><td>模拟信号</td><td></td><td>基于PT550环保型光敏二极管的光传感器，可用来对环境光 的强度进行检测，常用来制作随光线强度变化产生特殊效果的互动 作品</td></tr><tr><td>超声波 模块</td><td>模拟信号</td><td></td><td>内置温度补偿，确保在温度变化的场景中也可以实现准确测距。 模块还具备舵机角度驱动测距的功能，可以通过外接一个舱机组成 一个空间超声波扫描仪</td></tr><tr><td>压电陶瓷 振动模块</td><td>模拟信号</td><td></td><td>利用压电陶瓷给电信号产生振动，当陶瓷片振动时就会产生电信 号，通过Arduino模拟口能感知微弱的振动电信号，可用于与振动 有关的互动作品，比如电子鼓等</td></tr><tr><td>人体红外 热释电 模块</td><td>数字信号</td><td></td><td>热释电传感器是对温度比较敏感的传感器，广泛用于红外光谱仪、 红外遥感以及热辐射探测，它可作为红外激光的一种较理想的探测 器，常用在楼道自动开关、防盗报警等场合</td></tr><tr><td>声音模块</td><td>模拟信号</td><td></td><td>声音传感器是一种能够检测声音并将其转换为电信号输出的传感 器，可以用于各种声音控制、语音识别、噪声检测等，通常由一个 麦克风、一个放大器和一个滤波器组成，可检测到特定范围内的声 音，并将其转换为电信号输出，供后续处理使用</td></tr></table></body></html>

表 2-2中部控制模块与功能


<html><body><table><tr><td>模块名称</td><td>信号类型</td><td>实物参考</td><td>模块功能</td></tr><tr><td>继电器开 关控制 模块</td><td>数字信号</td><td></td><td>继电器开关控制模块是一种常见的电子模块，用于控制高电压 或高电流的设备，通常由一个继电器和一个控制电路组成，可将低 电平信号转换为高电平信号，例如控制灯光、电机、加热器等</td></tr><tr><td>按压式大 按钮模块</td><td>数字信号</td><td></td><td>通常用于控制电路的开关，它具有一个大的按键，用户可以通 过按下或释放该按键来控制电路的开关状态。按压式大按钮模块通 常具有接线方式简单和易于使用的特点，可以广泛应用于各种电子 设备中，例如机器人、智能家居、DIY电子产品等</td></tr></table></body></html>

表 2-3信息输出模块与功能


<html><body><table><tr><td>模块名称</td><td>实物参考</td><td>模块功能</td></tr><tr><td>舵机模块</td><td></td><td>舵机模块由一个舵机和一个控制电路组成，是一种能够精确控制角度的电机， 常用于机器人、模型飞机、船舶等设备。可以通过输入控制信号来控制舱机的旋 转角度。舵机模块具有精度高、响应快速和稳定性强的特点，可以实现精确的位 置控制和运动控制</td></tr><tr><td>风扇电机模块</td><td></td><td>该模块不需要额外的电机驱动板，可使用Arduino轻松驱动起来，也可以使 用PWM脉冲宽度来调节电机转速，适合轻应用或者DIY小制作</td></tr><tr><td>液晶屏模块</td><td></td><td>12864带中文字库液晶显示器，可配合各种单片机完成中文、英文字符和图 形显示，该点阵屏显成本相对较低，适用于各类仪器，小型设备的显示。该屏在 显示汉字、图片时，需要专门的软件先对汉字以及图片进行处理</td></tr><tr><td>矩阵屏模块</td><td></td><td>支持单总线控制，仅需一根引脚即可控制所有LED，且模块支持级联控制， 可多个模块同时控制，不占用引脚资源，4块以上建议使用外接电源。拥有 Gravity接口，无需焊接就可以直插Gravity扩展板</td></tr><tr><td>全彩LED灯 带模块</td><td></td><td>由一系列彩色LED组成，模块支持5V供电，采用了性能更好的晶体管开关， 配上4米40灯的彩色柔性灯带，可装点房间烘托气氛</td></tr><tr><td>蜂鸣器发声 模块</td><td></td><td>通过Arduino或者其他控制器能轻松地控制蜂鸣器发出声音甚至MID音乐。 该模块与Arduino其他传感器结合使用，具有简单易用、音量大、功耗低等特点， 可以广泛应用于各种电子设备中，如闹钟、计时器、安防系统等</td></tr></table></body></html>

### 2.1.4 驱动与开发环境

（1）Arduino驱动安装需要下载CH340驱动（主芯片），可搜索相关驱动自行下载，也可从本书配套文件选择不同版本进行安装（图2-12）。

**开发资料**

技术手册: CH340D51.PDF ;

**驱动程序: **

1、 CH341SER.EXE(WindoWs系统驱动，包含WIN10/WIN11系统32/64位)；
2、 CH341SERANDROID.ZIP（安卓免驱应用库及例程）；
3、 CH341SER LINUX.ZIP（Linux系统驱动)
4、 CH34XSERMAC.ZIP（苹果系统驱动）
5、 CoMTransmit.ZIP（Windows串口调试软件）

原理图/PCB: CH340PCB.ZIP相关方案: 免外围电路的单片机串口一键下载方案

图2-12驱动下载

（2）开发环境IDE安装 Arduino为开源平台，所有软件和案例文件均可免费下载可在不同平台下载。

进入Arduino官网，点开SOFTWARE（图2-13）。

![images/01bfc659c370afcdde31811a8b272c402286fe7f2d8482df0e11bcb3f587fea6.jpg](https://i.imgur.com/J7bWrkH.jpeg)

根据计算机系统选择适配的版本下载安装包（图2-14）。

![images/acc52818702336632067f529e2c0f0018a81be64a9f54c7a45bb9838fc320ba4.jpg](https://i.imgur.com/NI0xbje.jpeg)

点击JUSTDOWNLOAD（仅下载），之后选择安装路径进行软件的安装（图2-15）。

![images/c4c2b4de5b5e99bea6ac42fb56832f3aeddc3669483e119290e70dcad4f32092.jpg](https://i.imgur.com/uD0UAUp.jpeg)
图2-15点击下载

### 2.1.5 开发环境介绍

（1）整体界面（图2-16）

![images/73bbfb9addd310090e1b1c703286e57134fb260e774149a5e47026dca565d5e1.jpg](https://i.imgur.com/vDtwKLg.jpeg)
图2-16整体界面

- 菜单栏: 常用的各类功能。

- 编程区: 程序编写区。

- 信息栏: 提示信息显示区。

- 信息面板: 编译时的信息提示区。

（2）快捷菜单（图2-17）

![images/abde8a80fd0218442bf0018812c9db8215feaf2e6502957e299f059cfd1e93bb.jpg](https://i.imgur.com/b4pgfjw.jpeg)
图2-17快捷键

验证: 对写好的代码进行编译。

- 上传: 将程序烧录到Arduino 开发板中。

- 新建: 新建文件。

- 打开: 打开项目文件。

- 保存: 保存项目文件。

（3）串口监视器 打开串口监视器可看见传输数据情况和程序执行情况，再次点击即可关闭（图2-18）。

![images/db091d04a8ecc9563f9a8ce71c457b7199db08e0396854d6cc88c7fb979c0c3c.jpg](https://i.imgur.com/fcvyYye.jpeg)

### 2.1.6 基本语法结构

$\hphantom{0}\hphantom{0}\mathrm{C}++$ 程序语言常用的符号与意义如表 2-4所示。

表2-4 $\hphantom{000}\mathsf{c}++$ 常用符号


<html><body><table><tr><td>符号</td><td>意义</td></tr><tr><td>//（双斜杠）</td><td>单行注释，程序不执行其后内容</td></tr><tr><td>/**/（单斜杠和星号）</td><td>多行注解，程序不执行其中内容</td></tr><tr><td>{}（大括号）</td><td>用来存放所有同一级的内容</td></tr></table></body></html>

程序中几个基本组成部分如下: 

int $\underline{{\underline{{\mathbf{\Pi}}}}}$ name //定义变量。

setup(）: I/初始化环境，当 Arduino 主控板通电或复位后，该部分会运行一次，通常用来初始化一些变量、引脚状态及一些将调用的功能库等。

loop(）: /程序主体（循环结构），该部分内容将会按顺序循环运行。

## 2.2 程序设计实践

### 2.2.1 案例 2-1: Blink 闪烁灯

控制 Arduino13号引l脚旁的内置 LED 灯每隔一定时间被点亮一次。

硬件连接: Uno 开发板1块、数据连接线1根（USB 数据传输线），用连接线将开发板与电脑进行连接。

（1）步骤

打开 Arduino IDE，菜单栏“工具”>开发板，选择 Arduino Uno。

2 “端口”选择Uno 板与电脑相连的COMP接口（不同的电脑端口不同，可以从设备管理器中查看开发板所在端口，通过插拔刷新可以发现开发板所处的端口）。

打开菜单栏“文件” $>$ 示例 ${>}01$ .Basics>Blink 文件。
根据示例代码修改如下。

1. void setup(){ //初始化，初始化只运行一次
2. pinMode(13,OUTPUT); // 将13号数字引脚设为输出模式
3.
1. void loop(）{ //循环运行以下内容
2. digitalWrite(13, HIGH); //打开LED点亮（HIGH是高电平）
3. delay(1000); //延迟（等待）1秒
4. digitalWrite(13，Low)；//写入LOw低电平关闭LED
5. delay(1000); //延迟（等待）1秒
6. }

同理，LED_BUILTIN（内置LED即13号引I脚）可以换成其他任意数字引I脚。如果控制外部的LED需要外部灯和面包板、电阻等元件。

“void setup(）{}”: 初始化只运行一次。2 “void loop(）{}”: 核心代码，循环运行的主程序。3pinMode(pin,OUTPUT): 定义输出引I脚（pin为引I脚号）。4 digitaIWrite(pin,HIGH/LOW):将数字引I脚写入HIGH（高电平）或LOW（低电平）。5 delay(ms): 延迟，延迟时间由 delay(）函数的参数进行控制，单位是毫秒（1秒=000 毫秒）。

### 2.2.2 案例2-2: 点亮外部LED

点亮外部的 LED 灯珠。

硬件连接: 所需材料为Uno开发板一块、开发板连接线一根、面包板一块、杜邦线若十、LED两个、电阻两个，连接方法如图2-19所示。

![images/7f0bed15fbc333fa134d265c511795dbbec9a006dbe2b50733d807fc7fa2a4f0.jpg](https://i.imgur.com/owbdTFu.jpeg)
图2-19两个LED的硬件连接图

注意: LED灯的点亮分正负极，一般情况下LED灯珠的长脚接正极，短脚接负极。

（1）程序代码 输入以下程序代码上传运行，观察效果。

7. void setup(）{
8. pinMode(12, OUTPUT); // 初始化12号数字引脚为输出模式
9. pinMode(11, OUTPUT); //初始化11号数字引脚为输出模式
10. }
11. void loop(）{
12. digitalWrite(12, HIGH); //12号引脚输出高电平，12连接的LED点亮
13. digitalwrite(11,LoW); $/./\AA$ 11号引脚输出低电平，11连接的LED熄灭
14. delay(1000); //延迟（等待）1秒
15. digitalWrite(12，LOW)；//12号引脚输出低电平，12连接的LED熄灭
16. digitalWrite(11，HIGH)；/／ 11 号引脚输出高电平，11连接的 LED 点亮
17. delay(1000); //延迟（等待）1秒
12.

（2）重点总结外部LED灯与电阻的连接方法，连接电阻主要为了防止烧坏LED。

### 2.2.3 案例2-3: 用按钮控制LED灯

用按键控制LED灯，当按下按钮开关时，13号引脚旁的内置LED 被点亮。

硬件连接: 所需材料为Uno 开发板一块、开发板连接线一根、面包板一块、杜邦线若干、按钮开关一个、电阻一个，连接方法如图2-20所示。

![images/865f53fe214f623f04f138a2039ad3ad247ef772e84eb5a4e79341e2ec046b13.jpg](https://i.imgur.com/fPVJCKn.jpeg)
图2-20 按钮开关的连接图

（1）步骤

- 打开示例文件，菜单栏“文件” $>$ 示例 >02.Digital>Button 文件。

- 根据示例代码修改如下，详细内容见每行注释。

18. int buttonon $=6$ //定义buttonOn为整数0
19. void setup(){
20. pinMode(13,OUTPUT); //初始化13号数字引脚为输出模式
21. pinMode(7,INPUT); //初始化7号数字引脚为输入模式
22. }
23. void loop(）{
24. buttonon $=$ digitalRead(7); $//\AA$ 读取数字引脚7号的状态
25. if (buttonon $==$ HIGH）{ //如果buttonOn为高电平
26. digitalWrite(13,HIGH); //13号引脚旁LED点亮
27. }
28. else { //否则执行下面的内容
29. digitalWrite(13, L0W); //13号引脚旁LED熄灭
13.
14.

（2）重点总结

- 按钮开关的用法: 按下一次信号发生一次跳变，未按时两个引脚连接，按下后四个引脚连接。

- int: 定义一个整数类型的变量，通常用来初始化对象的状态。

- if语句: 用来判定所给定的条件是否满足，后根据判定结果执行操作， $^{66}==^{2}$ ”的意 思为满足条件。

pinMode(pin, INPUT/OUTPUT/INPUT_PULLUP): 定义引I脚为输入 / 输出 / 输入上拉（pin为引脚号）。

5 digitalRead(pin): 常用于读取数字引I脚的状态HIGH（高电平）或LOW（低电平）（pin 为引脚号）。

### 2.2.4 案例2-4: 序列本输出

通过串口监视器查看程序的执行状态，按下开关1秒后观察串口窗口的输出信息。
硬件连接: 同案例2-3。

（1）步骤打开菜单“文件>”O1.Basics>DigitalReadSerial文件，根据示例文件重新编写以下代码完成序列输出。

30. int pushButton $=7$ ； //给按钮开关连接的7号引脚取名为pushButton
31. int buttonState $=0$ //按钮的状态，先为整数θ
3 . int beforeState $=6$ //按下按钮前的状态，为整数0
32. void setup(）{
33. Serial.begin(9600); //开放和电脑的通信，设置传输速率即比特率为9600
34. pinMode（pushButton，INPUT)；//将7号引脚设置为输入模式
35. }
36. void loop(）{
37. buttonstate $=$ digitalRead(pushButton)；//7号引脚检测到的按钮状态（1或0，有没有按）
38. if(buttonState $==1$ and beforeState $==-\theta$ )// 如果从没按变到按下的那一瞬间
39. Serial.println(buttonState)；// 串口输出 buttonState 即按钮状态
40. }
41. beforeState=buttonState; //将buttonState 数据储存在beforeState中，中断作用
42. delay(1000);
43. 8

（2）重点总结

Serial（串行通信）: 串行端口用于Arduino 和个人电脑或其他设备进行通信。9600为波特率，是指每秒传送的数据量即波特（Baud）数。

44) Serial.println(val): 打印数据到串行窗口，即向串口发送换行的数据（val 指任何类型的数据），完成通过串行监视窗口查看数据变化的过程。

### 2.2.5 案例2-5: 用可变电阻控制LED灯

用可变电阻控制调节LED 灯珠的亮度。

硬件连接: 所需材料为Uno 开发板1块、开发板连接线1根、面包板1块、可变电阻1个、LED 二极管1个、杜邦线若干、电阻1个，连接方法如图2-21 所示。

![images/6de033f2515445b44f3c795ccc33a7c29a9f9e93d974db92282a4dd07d6a86b8.jpg](https://i.imgur.com/pfCgPGZ.jpeg)
图 2-21可变电阻硬件连接示意图

(1)步骤 输入以下程序代码，上传烧录，扭动按钮观察效果。

45. int sensor $=A\theta$ ， //给Ao取名为sensor
46. int sensorRead $=\theta$ //设置sensor读到的数值为0
47. int newdate $=0$ ； // 新的数据先定义为0
48. void setup(）{
49. Serial.begin(9600); //开放和电脑的通信，设置传输速率即比特率为9600
6.
50. void loop(）{
51. sensorRead $=$ analogRead(sensor）；//由 Ao读取模拟信号数值赋值给 sensorRead
52. newdate $=$ map(sensorRead,0,1023,0,255)； //map 映射，将串口数据等比缩小在0～255之间
53. Serial.println(newdate);// 将读取到的数值输出到串口监视器
54. analogWrite(3,newdate)； //将读取到的新数值写入到3号引脚
55. delay(200); // 延时200毫秒

13.}

（2）重点总结模拟信号: 能够产生连续不断变化的数据的信息。数据读取函数:analogRead(pin)，读取模拟信号（pin 为引l脚号）。数据映射函数: map(0,1023,0,255),将某一数值范围从一个区间等比映射到另一个区间，如此处将0\~1023的范围等比缩小至0\~255。

### 2.2.6 案例2-6: 音乐灯光的同步控制

同时打开LED灯与蜂鸣器，并让灯光的闪烁状态与声音同步。

硬件连接: 无源蜂鸣器1个、LED灯1个、杜邦线若干、Arduino 主板1个，连接方法见图2-22。

![images/5dcb3e6ef5bf1b93fed42461a3e28210eeb1993273cbc970803f8b3ab50b9050.jpg](https://i.imgur.com/pu4wnyv.jpeg)
图2-22灯光音乐同步控制硬件连接图

注: 无源蜂鸣器正负极分别接入5V（6号引脚）和GND（负极），LED接入1号引引脚。

（1）基础知识 一般一个音由以下要素构成: 音高、音色、响度、音名、唱名和时值。

- 音高与频率: 声音是由物体的振动产生，振动频率越快音高越高，反之越低。

- 音色与材质: 振动物体的材质不同产生的音色（情感）不相同。

- 响度与振幅: 物体振动幅度决定响度，振动幅度越大，响度越大。

- 音名: 给特定频率产生的声音进行命名便于记忆，这个名称就是“音名”。例如规定 $\mathsf{A}\mathsf{=}440\mathsf{H}Z$ ，那么A就是一个音名。音名是唯一的，任何情况下，一个音名只能代表一个频率。

唱名: 音乐课上听到过的 do re mifa sol la si就是唱名。当然“do”可以对应不同的频率，可以是440Hz，也可以是880Hz……因此音名和唱名的区别为: 一个音名值对应一个频率，一个唱名可以对应多个频率。

时值: 一个音的时间长短。

要让无源蜂鸣器演奏音乐，首先要搞清楚各个音符的频率（详见表2-5～表2-7）。

表2-5低音音符频率表


<html><body><table><tr><td>音调音符</td><td>1#(do)</td><td>2#(rei)</td><td>3#(mi)</td><td>4#(fa)</td><td>5#(sol)</td><td>6#(la)</td><td>7#(si)</td></tr><tr><td>A</td><td>221</td><td>248</td><td>278</td><td>294</td><td>3- 0</td><td>371</td><td>416</td></tr><tr><td>B</td><td>248</td><td>278</td><td>294</td><td>3- 0</td><td>371</td><td>416</td><td>467</td></tr><tr><td>C</td><td>131</td><td>147</td><td>165</td><td>175</td><td>196</td><td>221</td><td>248</td></tr><tr><td>D</td><td>147</td><td>165</td><td>175</td><td>196</td><td>221</td><td>248</td><td>278</td></tr><tr><td>E</td><td>165</td><td>175</td><td>196</td><td>221</td><td>248</td><td>278</td><td>312</td></tr><tr><td>F</td><td>175</td><td>196</td><td>221</td><td>234</td><td>262</td><td>294</td><td>3- 0</td></tr><tr><td>G</td><td>196</td><td>221</td><td>234</td><td>262</td><td>294</td><td>3- 0</td><td>371</td></tr></table></body></html>

表2-6中音音符频率表


<html><body><table><tr><td>音调音符</td><td>1#(do)</td><td>2#(rei)</td><td>3#(mi)</td><td>4#(fa)</td><td>5#(sol)</td><td>6#(la)</td><td>7#(si)</td></tr><tr><td>A</td><td>441</td><td>495</td><td>556</td><td>589</td><td>661</td><td>742</td><td>83- </td></tr><tr><td>B</td><td>495</td><td>556</td><td>624</td><td>661</td><td>742</td><td>83- </td><td>935</td></tr><tr><td>C</td><td>262</td><td>294</td><td>3- 0</td><td>350</td><td>393</td><td>441</td><td>495</td></tr><tr><td>D</td><td>294</td><td>3- 0</td><td>350</td><td>393</td><td>441</td><td>495</td><td>556</td></tr><tr><td>E</td><td>3- 0</td><td>350</td><td>393</td><td>441</td><td>495</td><td>556</td><td>624</td></tr><tr><td>F</td><td>350</td><td>393</td><td>441</td><td>495</td><td>556</td><td>624</td><td>661</td></tr><tr><td>G</td><td>393</td><td>441</td><td>495</td><td>556</td><td>624</td><td>661</td><td>742</td></tr></table></body></html>

表 2-7高音音符频率表


<html><body><table><tr><td>音调音符</td><td>1#(do)</td><td>2#(rei)</td><td>3#(mi)</td><td>4#(fa)</td><td>5#(sol)</td><td>6#(la)</td><td>7#(si)</td></tr><tr><td>A</td><td>882</td><td>990</td><td>1112</td><td>1178</td><td>1322</td><td>1484</td><td>1665</td></tr><tr><td>B</td><td>990</td><td>1112</td><td>1178</td><td>1322</td><td>1484</td><td>1665</td><td>1869</td></tr></table></body></html>

续表


<html><body><table><tr><td>音调音符</td><td>1#(do)</td><td>2#(rei)</td><td>3#(mi)</td><td>4#(fa)</td><td>5#(sol)</td><td>6#(la)</td><td>7#(si)</td></tr><tr><td>C</td><td>525</td><td>589</td><td>661</td><td>700</td><td>786</td><td>882</td><td>990</td></tr><tr><td>D</td><td>589</td><td>661</td><td>700</td><td>786</td><td>882</td><td>990</td><td>1112</td></tr><tr><td>E</td><td>661</td><td>700</td><td>786</td><td>882</td><td>990</td><td>1112</td><td>1248</td></tr><tr><td>F</td><td>700</td><td>786</td><td>882</td><td>935</td><td>1049</td><td>1178</td><td>1322</td></tr><tr><td>G</td><td>786</td><td>882</td><td>990</td><td>1049</td><td>1178</td><td>1322</td><td>1484</td></tr></table></body></html>

我们知道了音调的频率后，下一步就是控制各个音符的音节，这样才能构成一首优美的曲子，而不是生硬地用一个调把所有的音符一股脑地都播放出来。

音节分为一拍、半拍、1/4拍、1/8拍。规定一拍音符的时间为1；半拍为 0.5;1/4拍为0.25;1/8拍为0.125·..·可以为每个音符赋予这样的节拍（时间长度即“时长”），这样音乐就可以播放出来。

接下来是乐谱解析。

从简谱看（图2-23），该音乐是C调，这里的各音符对应的频率对应的是表2-5～表2-7中C调的部分。另外，该音乐为 4/4拍，每个音节对应为1拍。音符说明如下:

不带任何标记的音符数字表示1个节拍；带下画线的音符表示0.5节拍（半拍）；3音符后面带一个点表示 $+0.5$ 个节拍；3音符后面带一条横线表示 $+1$ 个节拍；

5 两个音符上面带弧线，表示连音，可以稍微改下连音后面那个音的节拍，比如减少或增加一些数值（需自己调试），这样表现会更流畅，也可以不改。

**小星星**

1= C 4

![images/7ed3a1f09aa3b38421f4bad89b2e95971e19243eaa194f555ff6c53a3cb5bbdf.jpg](https://i.imgur.com/EAASwT4.jpeg)
图2-23 《小星星》简谱

(2)步骤 输入以下程序代码，上传烧录，观察灯光效果与声音是否同步。

1．／\*下面列出所有（调音符对应的频率（含中音，低音和高音），此处只用了C调中音的音符频率表，即第
2。 部分（tune 列表中的音符全部来自C调中音的频率表）\*/
3。 / /C 调中音的频率表
56. [[define]] NTC1 294
57. [[define]] NTC2 3- 0
58. [[define]] NTC3 350
59. [[define]] NTC4 393
60. [[define]] NTC5 441
61. [[define]] NTC6 495
62. [[define]] NTC7 556
63. //C 调低音的频率表
64. [[define]] NTCL1 147
65. [[define]] NTCL2 165
66. [[define]] NTCL3 175
67. [[defne]] NTCL4 196
68. [[define]] NTCL5 221
69. [[define]] NTCL6 248
70. [[define]] NTCL7 278
71. //C 调高音的频率表
72. [[define]] NTCH1 589
73. [[define]] NTCH2 661
74. [[define]] NTCH3 700
75. [[define]] NTCH4 786
76. [[define]] NTCH5 882
77. [[define]] NTCH6 990
78. [[define]] NTCH7 1112
79. // 以下定义了音节的长度，为后面 float 调用的
80. [[define]] WHOLE 1 //一-个节拍
81. [[define]] HALF 0.5 //半个节拍
82. [[define]] QUARTER 0.25 //四分之一拍
83. [[defne]] EIGHTH 0.125 //八分之一拍
84. [[define]] SIXTEENTH 0.0625//十六分之一拍
33． int tune[]= $1^{*}$ 根据C调的简谱列出各音节对应的频率，这是一个列表，灯带后面
85. 用tone这个函数调用并播放这个列表。这是小星星乐谱中的音符表 $^\ast/$
35 。[
86. NTC1,NTC1,NTC5,NTC5,NTC6,NTC6,NTC5, /\*一-句完整的音符，也可以全部排成一行，因为每个音
符的时长控制，是由节拍控制的（此处指float durt）\*/
87. NTC4,NTC4,NTC3,NTC3,NTC2,NTC2,NTC1,
88. NTC5,NTC5,NTC4,NTC4,NTC3,NTC3,NTC2,
89. NTC5,NTC5,NTC4,NTC4,NTC3,NTC3,NTC2,
90. NTC1,NTC1,NTC5,NTC5,NTC6,NTC6,NTC5,
91. NTC4,NTC4,NTC3,NTC3,NTC2,NTC2,NTC1,
92. 1;
43.float durt[] $=$ /\*根据简谱列出各音符节拍的长度，音符持续的时间长度，1指一个节拍，此
处其实也可以列成一行（这样比较好看）\*/
44.{
93. 1,1,1,1,1,1,1+1, /\*正常的为1; $^{+1}$ 是指增加一个节拍: 带下画线的表示0.5节拍（半拍）；
94. 音符后面带一个点表示+0.5个节拍；音符后面带一条横线表示 $+1$ 个节拍；
95. 两个音符上面带弧线，表示连音，可稍微改下连音后面那个音的节拍，
96. 比如减少或增加一些数值（需自己调试），这样会更流畅，也可以不改\*/
97. 1,1,1,1,1,1,1+1,
98. 1,1,1,1,1,1,1+1,
99. 1,1,1,1,1,1,1+1,
100. 1,1,1,1,1,1,1+1,
101. 1,1,1,1,1,1,1+1,
54.
102. int length; //定义一个变量名字为>length>
103. int tonepin $_{1=6}$ : //定义6号引脚接口音频
104. int ledp $^{=1}$ ； //定义1号引脚输出LED灯
105. //初始化程序
106. void setup()
107. {
108. pinMode(tonepin,OUTPUT);// 把变量名tonepin 定义为音频的输出引脚
109. pinMode(ledp,OUTPUT); // 把 ledp 定义为 LED 的输出引脚
110. length $|=$ sizeof(tune) /sizeof(tune[0]);
111. /\*这里用了一个 sizeof运算符，sizeof(tune)=42,tune[]=1，因此，此
处的返回值应该是 length=42\*/
65.}
112. //循环执行以下程序，主要控制灯的亮和灭的状态，让他与声音保持同步。
67． void loop()
68.{
113. for(int $x=0$ ;x<length; $\times{++}$ )/\*×初始值为θ（第一个音符），只要 $\times$ 小于length（42），就继续
循环，每循环一次，×自已增大1，然后再继续往下进行，直到遍历完所有tune 列表中的所有音符结束。然后停
2 秒再开始 重新遍历这个列表\*/
114. {
115. tone(tonepin,tune[x]);/\*tone 这个函数的作用是依次播放tune 序列里的数组，即先播放第
116. 一个， $^{+1}$ 后播放第二个，直到播放到最后一个: 并用 tonepin 这个引脚
117. 输出，上面定义了这个引脚是6\*/
118. digitalWrite(ledp, HIGH);
119. //将 LED 所在的引脚写入高电平，即点亮LED
120. delay(400\*durt[x]); $1^{*}$ 这个灯珠亮的时长，此处因为 durt[x] 的值均为1（见节拍列表
durt[]),
121. 如果要改变灯亮的时长，应该修改前面的数字 408（或者节拍列表 durt[］
122. 中的数值本身就不一样）。这里和下面灭灯后的 delay（1eα\*durt[x]）
123. 配合控制灯的亮和灭的状态和速度\*/
124. digitalwrite(ledp, LOW);
125. // 将 LED 所在的引脚写入低电平，即灭掉LED
126. delay(100\*durt[x])；// 灭掉灯时与亮灯的时间关系是1: 4，必须是这个关系才能保证音光同步
83 noTone(tonepin); //停止当前音符，进入下一音符
127. }
128. delay(2000); // 暂停 2 秒后再次循环
129. }
（3）重点总结
音符频率: 音符频率的对应至关重要，要在一个调中选择音符的频率。

音符节拍: 音符节拍的关键点一定要对应，要在节拍定义的时候定义正确。
线路连接: 一定要与程序里面定义的引脚相对应，连接正确。

### 2.2.7 案例2-7: 用可变电阻控制伺服电机

通过滑动可变电阻改变模拟信号数值，实现控制电机旋转的角度。

硬件连接: 将Uno开发板、伺服电机、可变电阻（电位器）用杜邦线在面包板上进行连接(图2-24）。

![images/4c73c5335f066bda2fd6f647c56a76f630ac95c883c4c91ae2e9d30d6630b883.jpg](https://i.imgur.com/IC6ve9X.jpeg)
图2-24伺服电机硬件连接图

（1)步骤打开菜单栏“文件”>示例 $>$ Servo>konb 示例文件（不同版本位置不同），根据示例代码修改如下。

130. [[include]] <Servo.h> //使用伺服电机时需先导入伺服电机函数库
131. Servo myservo; //为伺服电机取名myservo
132. int sensor $=0$ //可变电阻输入的模拟信号数值初始值为0
133. int angle $=0$ //定义电机旋转角度初始值为0
134. void setup(）{
135. myservo.attach(9); 7/设置该电机由9号引脚控制信号
136. }
137. void loop(）{
138. sensor $=$ analogRead(A0);
139. //由A0读取模拟信号数值
140. angle $=$ map(sensor，0,1023,0，180); $/^{*}$ 输入信号数值映射到
141. 0\~180的范围内，赋值给新的变量angle\*/
142. myservo.write(angle); $/^{*}$ 电机按照val数值度数旋转（电机最大旋
143. 转角度180度）\*/
144. delay(15); // 延迟15毫秒
145. }

（2）重点总结

伺服电机工作原理: 通常接线3条，控制电机旋转角度为 $0^{\circ}{\sim}180^{\circ}$

2 导入“库”的方法: 点击菜单栏“项目”中加载库，选择要导入的库（#include<Servo.h>）。库是能够完成一系列功能的程序模块，库由一系列函数构成。

myservo.attach(pin): 告知 Arduino 舵机的数据线连接在哪一个引引脚上。
myservo.write(angle): 控制舵机旋转角度（angle 指角度数值）。

### 2.2.8 案例2-8: 用程序控制步进电机

控制步进电机不停地旋转，并修改旋转的速度。

硬件连接: 将Uno开发板、步进电机（含ADC 转换器）用导线进行连接（图2-25）。

![images/6b63bb26c39985931429afead44c91ed06ff80c1092a7be6a0998acfa80a8adf.jpg](https://i.imgur.com/McCHkNA.jpeg)
图2-25步进电机硬件连接图

按照程序定义的内容，需要将8号引脚对应A，9号引脚对应B，10 号引脚对应C，11号引脚对应D,同时将电源的正负极接入模块上5√的正负极。注意:此模块电源处有个跳线夹,需要插上才能工作。

(1)步骤 将以下代码输入编辑区并进行上传烧录，观察电机的旋转效果。

此程序将延迟时间定义成了一个名为 delayTime 的变量，在循环体中引l用了这个变量,修改延迟时间只需要修改此处就可以，此处的最短时间为2mS，电机的转速最快，延迟越长转速越慢。

146. int apin $=8$ //定义步进电机黑线a对应8号引脚
147. int bpin $=9$ //定义步进电机粉线b对9号引脚
148. int cpin $=16$ //定义步进电机黄线c对应10号引脚
149. int dpin $\begin{array}{r l}{={}}&{{}11}\end{array}$ //定义步进电机橙线d对应11号引脚
150. //红线为电源的正极
151. int delayTime $=2$ ； // 转动时间间距
152. void setup(）{
153. pinMode(apin，OUTPUT)；//将四个脚位设定为输出模式
154. pinMode(bpin, OUTPUT);
155. pinMode(cpin, OUTPUT);
156. pinMode(dpin, OUTPUT);
12.
157. void loop(){
158. digitalWrite(apin, HIGH); $/^{*}$ 使A 线连接HIGH 正极，此时通过ADC 转换器完成
159. 正负转换，实现转动\*/
160. delay(delayTime);
161. digitalwrite(apin，Low)；//断开A线
162. digitalWrite(bpin，HIGH)；// 使B线连接 HIGH 正极
163. delay(delayTime);
164. digitalWrite(bpin，LoW)；//断开 B线
165. digitalWrite(cpin，HIGH)；// 使C线连接 HIGH 正极
166. delay(delayTime);
167. digitalwrite(cpin，Low)；//断开C线
24。 digitalWrite(dpin，HIGH)；// 使 D线连接HIGH 正极
168. delay(delayTime);
169. digitalWrite(dpin，Low)；//断开D线
27.

（2）重点总结步进电机工作原理: 通常接线为 4\~6 条，靠边红线连接电源，其余靠ADC 转换器实现轮流接地，以此控制电机旋转使其运动。步进电机一般需要电流量较大，需外接电源。

通过以上学习，需要掌握以下内容: 

程序的基本架构和组成部分。
2 C 语言的基本语法结构和规范。
$\mathbf{\delta}$ 程序执行的基本逻辑。函数的含义与调用。

# 3 中级可视化编程

![images/6a7da4361336dee985e662c8c5f6ff016ee637ebb79604cc4beaf80399c88da8.jpg](https://i.imgur.com/EVwp9Pj.jpeg)

![images/50a1f7a0101e8b35b72c15d3725c9930a406deadcd3a6c7ee9615571132744a6.jpg](https://i.imgur.com/yZd5ID5.jpeg)

中级可视化编程Mind+

3.1 软件下载安装与界面
3.2 工作模式与编程流程
3.3 可视化编程实践

本章主要介绍可视化编程软件 Mind+，它是一款拥有自主知识产权的国产青少年编程软件，为艺术专业学生快速掌握编程技术提供了良好途径。它集成了各种主流的主控板及上百种开源硬件，支持人工智能( Al)与物联网(loT)功能，可以通过拖动图形以积木的方式进行编程，还可以使用 $\mathsf{P y t h o n/C/C++}$ 等高级编程语言，让大家轻松体验到创造的乐趣。通过可视化编程可以更好地训练编程思维，深度理解程序运行的基本原理。

## 3.1 软件下载安装与界面

### 3.1.1 软件安装

(1 )Mind+下载安装进入 Mind $^+$ 官网mindplus.cC，选择适合自己电脑的版本下载。依次点击“OK”继续安装，待进度条走完即安装完成（图3-1、图3-2）。

![images/24abf1f5f84da1c5344875f07761c6ba2f60bff1c805e0251f811255329a0132.jpg](https://i.imgur.com/I21W3Cw.jpeg)
图3-1软件下载
图3-2软件安装

（2）安装串口驱动软件安装完启动后，点击“连接设备”〉“一键安装串口驱动”，之后根据提示操作一路确认安装即可，也可以观看菜单栏上的教程/视频教程（图3-3、图3-4）。

![images/0d84b8177a3ae6d123b11b6c6468af1845a7ddb0f3353a0645540101f098395e.jpg](https://i.imgur.com/xKfzqnP.jpeg)
图3-3安装串口驱动

![images/30d160500d8fb31739b98a5b2563b288610efd9da0a97f74c3535ef91a26c395.jpg](https://i.imgur.com/j37kjsm.jpeg)
图3-4安装串口驱动完成

注: 如果没有安装Arduino主板驱动，按2.1.4节内容安装Arduino驱动。

### 3.1.2 常见问题

（1）安装问题

安装时提示“无法写入文件”。答: 下载最新版本，重启电脑，关闭杀毒软件后再次安装。

安装Mind+时提示“安装已中止”

答: 未正常卸载旧版本。使用卸载工具清理注册表，如依然无法安装，可尝试在“历史版本”中下载使用绿色版。

（2）硬件支持问题 硬件列表中的硬件较少，很多硬件找不到？答: 打开上传模式，选择C 语言模式。Python 语言模式支持的硬件数量少。

（3）程序上传问题

使用 Arudino Uno上传程序时卡住，提示 not in sync: resp $=0\times00$

答: D0和D1在上传程序时不要连接其他元件，因为D0和D1是上传程序用的串口。如果拔掉所有接线依然无法上传，打开设备管理器检查驱动。

使用用户库的时候上传出错，提示 compilation terminated.exit status 1。

答: 用户库加载出现错误，升级软件到最新版本，删除此扩展库，重新在用户库通过搜索方式加载此用户库。

-  上传完打开串口监视窗口显示一串点（图3-5）。

答: 监视器波特率与程序不一致，点击右下角菜单修改波特率与程序一致，默认9600。

![images/a08ff593ded5d6f4f778501486764073051e0ff59aceebaa84327157c0289314.jpg](https://i.imgur.com/qYkiQ9o.jpeg)
图3-5串口监视窗口显示不正确

### 3.1.3 软件界面

如图 3-6 所示。

![images/c17b58f18ee64533fcbb25e7921420e61adb72c6d65db61625be75dfc1a288ba.jpg](https://i.imgur.com/xo9aOEV.jpeg)
图3-6软件的基本界面

（1）菜单栏

‘项目”菜单可以新建项目、打开项目、保存项目。

“连接设备”菜单能检测到连接的设备，并且可以选择连接或是断开设备。

“上传模式 $/$ 实时模式”，程序执行模式的切换。

“设置”按钮用于设置软件主题、语言，学习基本案例等。

（2）代码查看区 查看图形化指令的具体代码，可以与前面Arduino的程序进行比较。

(3）指令区 这里是所有可用的指令，在“扩展”里选择好不同硬件后此处就会出现硬件对应的指令集。

（4）脚本区 这里是程序编辑区，所有的指令模块在此处进行编辑排列形成完整的程序。

（5）串口区 查看程序“执行”的具体情况和状态，还有串口开关、滚屏开关、清除输出、波特率设置等（图3-7）。

![images/24dabf878c8176bd9c28069d04ec68dbef0544626ed3ce237da93dd4ed17a722.jpg](https://i.imgur.com/00twXOj.jpeg)
图3-7串口监视窗口及功能设置

## 3.2 工作模式与编程流程

Mind $^+$ 有两种工作模式，分别是“实时模式”和“上传模式”，在软件界面右上角可以切换(图3-8）。

![images/46139d51d564964894177961aefe134dd0bd4426fb0574379cc401b23e85ae98.jpg](https://i.imgur.com/KiUSl0a.jpeg)
图3-8工作模式切换

如果想不依赖硬件学习编程或者想制作交互类的动画作品需要用“实时模式”，相当于Scratch 的功能（图3-9）；如果想利用硬件模块进行编程创作并要脱离电脑运行，需选择“上传模式”（图3-10）。

![images/18ae7d74c952951fdb8a5f46da6dcf02cefae509747bb62efa85a1932365208d.jpg](https://i.imgur.com/zlZet4Z.jpeg)
图3-9实时模式

![images/13bb4a2f7cdf9acb5dee30c28202ae66004342a2a75bac8ab6cfa98c0cfeb1a5.jpg](https://i.imgur.com/FYacxhV.jpeg)
图3-10上传模式

### 3.2.1 实时模式界面

各个功能区的位置见图3-11，其能够完成的基本功能如下。

![images/9524ed3efd235adbbf2800b9757df0365fb75ca60af3fe565cdec2cb27a8d7fb.jpg](https://i.imgur.com/wI3ubgs.jpeg)
图3-11实时模式软件界面及功能分布

（1）菜单栏

项目: 新建项目，打开项目，保存项目，另存项目。

- 教程: 可以学习官方文档、在线论坛、视频教程、示例程序。注意: 其中示例程序是根据选择的主控板自动调整内容的

-  编辑: 打开和关闭“加速模式”以及恢复被删除的角色。

4 连接设备: 可连接或断开硬件设备，同时提供了快捷功能“打开设备管理器”以及“一键安装串口驱动”方便排查硬件连接故障。

- 意见反馈: 向官方发送意见和建议。注意: 如果不留邮箱没法获得答复。

- 模式切换: 用于切换及显示两个模式，编程前注意先选择使用哪个模式。

齿轮按钮: 用于打开设置界面，可以获取新版本、切换语言、切换主题、反馈意见、获取官方联系方式。

（2）功能区

模块: 进行编程的区域。

- 外观: 可以对当前选择的角色或背景的外观进行编辑。

- 声音: 可以对当前角色或背景的声音进行编辑。

Python: 可以使用代码式 Python 编程与硬件进行交互。注意: 运行在电脑端的Python 编辑器，有完整Python3 功能，目前暂无法对舞台进行控制，若需要进行硬件控制

及 Python 图形化编程，使用“上传模式”中的“microPython”功能。

（3）积木区

包含所有基础功能积木，额外增强了对硬件模块的支持。

注意: “画笔”“声音”以及硬件模块的支持都放到了“扩展”里面，需要额外加载。

（4）编程区

与 Scratch 相同，多事件驱动，对角色分开编程，各角色之间可以通过广播通信。

将模块从左边积木区拖出来即可，将模块拖回积木分类区即可删除。

注意: 将一个角色的程序复制到另外一个角色，可直接将此程序拖动到另一个角色上，不要用复制功能。

（5）舞台区

坐标原点位于舞台的中心位置。

上方可以调整舞台区的大小及显示硬件连接状态。

（6）角色及背景编辑区
可以添加或删除角色以及选择编辑的背景，被选中后有高亮的选中框。

（7）扩展积木
点击可以加载各种硬件模块以及声音、画笔、视频侦测等更多功能。

### 3.2.2 上传模式界面

上传模式的各个功能区位置见图3-12，其能够完成的基本功能如下。

![images/62ddfbe5861b2d57cd3b8c5d9eb15fcfb497a880ec483c10cbce6302fc36cb3c.jpg](https://i.imgur.com/JDr8MuP.jpeg)
图3-12上传模式的功能分布

（1）菜单栏 与实时模式界面菜单栏功能相同。

（2）图形模块区因上传模式是对硬件主控板进行编程，因此此处模块分类相对“实时模式”少了一些与舞台相结合的内容，同时运算符中增加了更多命令，并且变量具有“数字”和“字符串”两种类型。

（3）图形化编程区 此处编写代码，在右边“代码区”的“自动生成”标签下会自动生成模块对应的代码。

（4）代码区 软件右上方可以将代码上传到设备（图3-13），可以选择C或者是microPython 语言（注意 Arduino 板子和套件不支持microPython）。

隐藏功能: 在“上传到设备”前面图标上用鼠标右键点击，会弹出菜单（图3-14），可以实现无硬件驱动时的程序上传，具体先编译后打开，直接把生成的\*.hex文件复制到microbit板里面。板子插上USB后会在“我的电脑”里显示一个U盘的符号，最好通过驱动直接上传。

通过“手动编辑”可实现手写代码，在代码区右键可以调整字体大小或者设置主题。

注意: “上传到设备”上传的程序由下方代码区决定，即如果当前是“自动生成”，则上传的是图形化的程序；如果当前选择的是“手动编辑”，则上传的是手动编辑的代码。

![images/a3c4fb56423ceaaafc81087049964ea354c2cc54c12e157f51b3ed92bade1abc.jpg](https://i.imgur.com/t2U2Ul0.jpeg)
图3-13上传程序按键
图3-14隐形菜单功能

（5）串口监视窗口在ArduinoC模式下，此窗口是一个完整的串口调试器功能，上传时可以测试输出程序是否有错，配合“串口打印”语句可以很方便地调试程序或者显示数据，使用串口调试功能需要先打开串口（图3-15）。

![images/2d83f9800e3b04aa87304b609a86ce8232056fcfa8e1186f32b905843d4137b7.jpg](https://i.imgur.com/txVUYD4.jpeg)
图3-15打开串口监视窗口

（6）硬件扩展打开后可以选择主控板或各种传感器，分类为: 套件、主控板、传感器、执行器、通信模块、显示器、功能模块、网络服务、用户库（图3-16～图3-23）。

1 支持传感器和其他模块的数量由主控板决定，因此要先选择“主控板”或“套件”，才显示可支持模块。

2 microPython模式下支持的小模块比C 模式下的少，详细可以点击扩展界面上的帮助查看。

3 可以使用扩展界面右上角搜索需要的传感器。

![images/fac0cb28f1dfe544d38a4a957c720ed3bdec1df8e4e3061e0bd5234bc7844fcb.jpg](https://i.imgur.com/YxSHtft.jpeg)
图3-16支持的主控板

![images/11ae4ec3f7b9ccd8c3f416b554169b5cd0efe1c70b9a688b3ae0ef50340430c6.jpg](https://i.imgur.com/yQDhh3c.jpeg)
图3-17部分传感器

![images/4e829b11e392f621febb7d23a662a91e4933584cdaac082468f0dc9ce6ff6d9a.jpg](https://i.imgur.com/d2X8jVr.jpeg)
图3-18部分执行器

![images/35f5d6b23fe4012594eafc2786a9ad5ba9763d93020afcb433c9951d9ab3bca4.jpg](https://i.imgur.com/GTuPw3P.jpeg)
图3-19部分通信模块

![images/bb8e3eef52a79c17b21ee6e1ede1057d9b8dcd758849f20a2f87808c21e24434.jpg](https://i.imgur.com/HcT7KOH.jpeg)

![images/2dfac53b6782bd36ac0157a98c3e1e65ddfb0f283eccfdc45d6a8101bc2b1ac2.jpg](https://i.imgur.com/7lkpcN6.jpeg)
图3-20部分显示器

![images/894d306b4e9a02212254145d4962e32e34bcd61e3e7fda7bd2bd14821faf4244.jpg](https://i.imgur.com/zFdd5H2.jpeg)
图3-21部分功能模块

![images/3db24819b943d39582c7ee8332be58f02e1621856599dd2d3e00f648d57711e3.jpg](https://i.imgur.com/KFf5IS9.jpeg)
图3-22其他网络服务

![images/81770f36ca689fe47ec0c0e56d4820eead39902c5f91f53bb36c85a7f0aadc0d.jpg](https://i.imgur.com/ip0fVL1.jpeg)
图3-23 可以扩展的用户库

### 3.2.3 Python模式

Mind+升级到V1.7后加入了全新的Python模式，极大增强了Mino $^+$ 的功能。特点如下: 

基于Python3.x，运行于电脑上，可直接运行所有Python功能。2 内置Python包，无需额外下载安装及配置，打开Mind $^+$ 即可使用。3提供代码和模块两种方式，满足入门到高级用户的需求，方便高级用户快速编程的需要。4 代码模式提供库管理功能，常用库一键加载，并且提供了多种Python源，不用为网速担忧。模块模式提供扩展库，后期可扩展性强，支持自定义用户库（开发中），可以自行设计用户库。

注意:

Python与microPython不同，microPython为精简的Python，语法相同而运行环境不同，库也不同。

- Python运行于电脑上或树莓派等单板电脑，microPython运行于单片机上（例如Micro:bit、ESP32）。

-  在Mind $^+$ 中Python为单独的Python模式，microPython则位于上传模式各主控板的语言选项中。

### 3.2.4 Mind+ 硬件编程流程

（1）打开上传模式一定要在上传模式下进行硬件编程开发，同时选择C语言作为开发语言，否则支持的硬件会减少（图3-24）。

![images/5038d88cb876bd5392f1743a1f3d0edd31caa50f7f3006cd3e9a45a6eef78876.jpg](https://i.imgur.com/8kvRfOW.jpeg)
图3-24打开上传模式选择编程语言

（2）连接设备 保证Arduino主板和电脑串口连接成功，判断方法如图3-25所示，连接设备为灰色时代表连接成功。

![images/489459c10f8091918b66c7471bcf45fa2f909c122768c5d9c36607661370149c.jpg](https://i.imgur.com/Tpcoyvc.jpeg)
图3-25判断主控板是否与电脑连接成功

（3）选择硬件 选择顺序: 主控板 $^+$ 传感器 $^+$ 显示器 $^+$ 执行器 $^+$ 功能模块···

（4）编写程序编写程序采用搭积木的方式进行，主要看积木的外部形状是否可以连接，关键是理解程序执行的逻辑，Arduino 硬件编程的组件和注意事项如下:

增加的模块功能全部会显示在左侧模块栏内，旁边是每个模块的关键语句和功能。

在编程区对于不适用的模块可以直接选中删除。

几个主程序并列时可同时执行，没有先后顺序，先后顺序只存在一个程序内部。

（5）上传程序程序编写完一定要完成上传操作才能执行。上传时除了进度条显示外，串行监视窗口会显示是否成功上传或出现错误提示。

（6）执行调试上传完成后根据程序编写的情况测试是否能够按照程序设定的内容执行，有时程序上传完成后要稍微等几秒才能执行。

## 3.3 可视化编程实践

在本节中用可视化编程的方式实现第2章的一些案例，目的是在进一步熟悉硬件功能的基础上，深度领会程序执行的逻辑。在学习中要反复体会计算机程序运行的规律，即由上而下顺序执行，遇到条件根据条件选择性执行。

### 3.3.1 案例3-1: 点亮LED灯并控制闪烁

硬件连接: 通过扩展板将灯与开发板相连接，注意引脚的位置与程序保持一致（图3-26）。

![images/6665c7741f5ae3cfdfea0d825d7f991afbf3d0d5ecf44ddd68f841a25b48fe38.jpg](https://i.imgur.com/1YemaiT.jpeg)
图3-26LED灯的连线图

（1）程序设计初级程序: 按照顺序执行的原则，灯会闪烁。如果想让它执行100次并加快闪烁速度，一种办法就是把100个这样的模块前后连接在一起（图3-27），可想而知是非常麻烦的。图3-28是改进后的程序。

![images/a9a12f052142686eea8634911ecd5a5250d819dca419c2337db6400ac22ccee3.jpg](https://i.imgur.com/eA6MKBo.jpeg)
图3-27初级程序

![images/091adb94151265126f0793450ee5a63e93d03a37370962b74ce4560642420353.jpg](https://i.imgur.com/80Six2V.jpeg)
图3-28高级程序

高级程序: 灯的闪烁次数通过变量i来控制。所谓变量，就是在程序运行过程中大小会发生变化的量。循环执行过程中，变量i从1开始，每次减小0.1，直到减小到0，然后循环结束(图3-28）。

（2）知识点与问题思考 变量的意义与循环结构的用法。

### 3.3.2 案例3-2: 用数字按钮控制LED灯

用数字按钮控制LED灯，每次按下松开，LED灯发生亮灭。

硬件连接: 将数字按钮与LED模块按照如下方式连接，注意引脚的位置与程序保持一致(图3-29）。

![images/e3db8cae04eaa75435428263cfccb8cded9edb594d89b209c9b9295e6aecf8ca.jpg](https://i.imgur.com/zQXAfH0.jpeg)
图3-29灯与按钮的连接方法

（1）程序设计 前提知识: 数字开关不是一个简单的物理开关，它接入电极后可以输出开和关两个数字信号。电子按键输出的信号是按下时输出为0，松开时输出为1（运行时可以在串口监视窗口中查看）。

![images/1cd2f26169094aedc5f88c599bd0f391be658a1a2d5f101f2b3d1671f1b1a9c7.jpg](https://i.imgur.com/EJBHVVX.jpeg)
图3-30数字按钮控制LED的程序

这段程序中使用了定义变量的模块。变量的名称是i，此处设置i的初始值为〇，在整个程序运行过程中只执行一次。程序中等待0.5秒用于消除按键抖动（图3-30）。

（2）知识点与问题思考数字按钮元件的工作原理与用法。条件判断的用法，此处相当于if语句。

### 3.3.3 案例3-3: 红外入侵检测装置

本案例制作一个人走近灯亮，离开灯灭的装置。

红外接近开关的原理: 利用被检测物体对红外光束的遮挡检测物体的有无，红外接近开关一侧是发射器，一侧是接收器（图3-31）。可见光波长是380～780nm，红外线波长为780nm \~ 1mm。

![images/07dc0fc69743e9310763b9f54f1080a2c9404fbf767c992ddce00635463061d8.jpg](https://i.imgur.com/oBMNGOA.jpeg)
图3-31红外接近开关

硬件连接: 利用扩展板将红外入侵检测仪连接到3号引脚；LED 连接至10号引脚，连接方法见图3-32。

（1）程序设计 使用数字输入引脚，读取输入口数值1/0代表有无接收红外信号，用来控制灯的亮与灭（图3-3- ）。

红外接近开关是一种数字输入设备。具有未入侵（高）和入侵（低）两种状态。默认状态

为未入侵（高）。

红外接近开关能对所有反射光线的物体进行检测。

![images/9e09e8cb869ce54a06579d4aec6c96fc20d46ad63eaadc2298e1cbf7e9f90104.jpg](https://i.imgur.com/xezO9OR.jpeg)
图3-32红外开关与LED的连接
图3-3- 红外控制LED灯的程序

（2）知识点与问题思考 掌握红外传感器的用法，同时思考利用红外开关在交互设计中有哪些场景和可能的用法。

### 3.3.4 案例3-4: 制作呼吸灯

灯光由暗到亮，再由亮到暗地逐渐变化，实现呼吸灯的效果。这段程序中我们接触到了两个新的模块一—函数以及模拟输出。

硬件连接: 利用扩展板将LED模块接入到第10号引I脚（图3-34）。

![images/52f3241e6f52b66e6670a1cc6c4bbb4116c0da373abc3afa0730caf422a773e9.jpg](https://i.imgur.com/8SkZovx.jpeg)
图3-34LED连线图

（1）函数我们最初见到函数是在数学当中。 $y{=}f(x)$ 是函数的一种一般形式，它接收
变量×的值，经过对应法则 $f$ 的处理，返回结果值y。Mind $^+$ 程序中的函数，可以类比理解。（2）模拟输出脉宽调制（PWM，PulseWidthModulation）输出: 它是一种对模
拟信号电平进行数字编码的方法，简单来说就是通过一个时钟周期内高低电平的不同占空比来

表征模拟信号，图3-35 就是一个具体的编码样例。Arduino 使用 analogWrite（int value ）输出 PWM 信号，其中的value取值范围是0\~255。

Arduino 主控板只有有限个 GPIO 引I脚支持 PWM。观察一下 Arduino 板，查看数字引引脚,会发现其中6个引脚（3、5、6、9、10、11）旁标有“～”，这些引引脚不同于其他引脚，因为它们可以输出PWM信号。只有这些引脚才能输出类似呼吸灯的效果。

![images/fa848043559cdf3a4c054cbb026d0e263396c57780a5a23a43d650b60089471a.jpg](https://i.imgur.com/cdZmFRs.jpeg)
图3-35模拟输出原理

（3）程序设计 定义的两个函数见图3-36，右侧是主程序，它们是对左侧函数的调用。

两个函数分别用了一个重复执行模块，并设定了一个变量范围作为条件，直到条件不满足之后结束重复执行，由此实现一个灯的逐渐亮起和熄灭。此处用10号引脚（模拟信号输出口）进行输出，此处相当于将一个数值定义为0～255的范围，并将这个范围内的数据连续输出。

![images/cd72adcbf0a9610989b95f8c7b3b54195c19ccfc6b4b25b19909e31d240ffddb.jpg](https://i.imgur.com/SxHHwvg.jpeg)
图3-36呼吸灯程序

fadeon 函数的功能是让LED 灯逐渐变亮，要实现任务要求，还需要一个让LED 逐渐变暗的函数，这里要增加一个fadeof 函数（名字自定义），并且要将这两个函数增加到Uno主程序后才能执行，右侧是将fadeon与fadeoff置于Uno主程序。

（4）知识点与问题思考模拟信号的含义及输出。

函数的含义: 能够执行一定功能的模块集合。

- 先编写具有一定功能的模块函数，再放在一起执行这些函数。

主程序的模块名为“Uno 主程序”，一个程序里只能有一个主程序。

### 3.3.5 案例3-5: 利用可变电阻制作旋钮可调灯

实现功能: 通过模拟信号的旋钮，调节LED 灯的亮度。

“滑动变阻器”或“电位器”是一个模拟角度的电位器元件，通过调节旋钮，可以改变它接入电路的阻值大小。将其连到主控板所支持的模拟输入口上，就可以把阻值作为模拟信号输入到主控板上。主控板根据输入值的大小确定输出的值，输入值大，输出值也大；也可能另外一些程序希望输出值随着输入值变大而减小。

硬件连接: 用扩展板将滑动变阻器和LED灯按照图3-37方式进行连接，模拟角度电位器接入A0（只能接到模拟输入引脚），LED接入10号引脚（注意插线时的颜色是否对应）。

需要注意的是，主控板支持的模拟输入信号的大小范围是 $0{\sim}1023$ ，然而模拟输出大小是0\~255。因此，模拟输入的数值不能直接进行模拟输出，需要通过映射把0\~1023内的数按比例缩小，转化成0\~255之间的数再进行模拟输出。

![images/5c275c7846902e43a1c7095dcab67ef8a13fd74ebbe57ddf5427e0dde643a7bb.jpg](https://i.imgur.com/p3xjiD7.jpeg)
图3-37旋钮与LED的连线图

![images/faa54bf41c776b2c416026a55529c3421941b9e945fc72aec214ee606a0e6c84.jpg](https://i.imgur.com/dSMs6Wu.jpeg)
图3-38通过映射实现模拟数值转换

（2）知识点与问题思考模拟旋钮电位器的工作原理。

模拟输入与模拟输入引脚的标志是什么？

映射的含义与使用方法。

### 3.3.6 案例3-6: 制作智能灯声控灯

功能实现: 当有响声的时候灯亮并延续一段时间，让声音代替开关。这需要使用一个新的元件“模拟声音传感器”，它可以将声音的大小转化成模拟信号，在Arduino主控板上，仍然是输入0\~1023的数值。

硬件连接: 利用扩展板将模拟声音传感器接入A0，LED接入10号引脚，注意插线时的颜色对应（图3-39）。

![images/352ee9b4c71394be49a4c205bc401661d199dfad9788272ed4765bf746bf3ae4.jpg](https://i.imgur.com/K7nTwSX.jpeg)
图3-39声音传感器与LED的连接图

（1）程序设计读取声音数值并打开LED灯，设定最小声音（ $>300$ ），防止很小的声音就打开灯（图3-40）。

![images/f62f88896c691bd6443c47f21a9cfe13b31ebddd37721ce3c4d781b639838f90.jpg](https://i.imgur.com/Yhfc8rC.jpeg)
图3-40声控灯程序

模拟输入的信号可以使用“串口输出”把当前的数据显示出来，单击左下角的图标打开串口监视器窗口，可以显示实时上传的数据，便于查看数据的变化情况。

（2）知识点与问题思考

模拟声音传感器的工作原理和用法。

利用模拟声音传感器还可以做哪些交互设计？

### 3.3.7 案例3-7: 楼道自动控制灯

功能实现: 当亮度暗且有声音时灯才亮，同时利用模拟光线传感器和声音传感器，将周围的亮度和声音转化为模拟信号，输入到Arduino主控板上，共同来控制灯的开关。

硬件连接: 利用扩展板将模拟声音传感器接入AO，模拟光线传感器接入A1，LED接入10 号引脚。注意插线时的颜色对应（图3-41）。

![images/341121cbd912e6da392a237c775ca5731f728d7a3ef74e3b24d4b04dead723db.jpg](https://i.imgur.com/7xpqpDe.jpeg)
图3-41声音、模拟光传感器与LED的接线图

（1）程序设计读取两个传感器的数据并设定条件，当两个条件满足其一时即点亮LED灯，等待一段时间后自动熄灭（图3-42）。注: 条件判断“与”，代表满足其中一个条件即可。

![images/4adeb7247d65febe69b7130be1acf9f3d1b49b7ceebb5c4b54adda9bd7cc0cc9.jpg](https://i.imgur.com/u2j4PII.jpeg)
图3-42楼道灯程序

继续制作电子蜡烛。用上面硬件连接制作一个电子蜡烛，当环境亮度较暗时，电子蜡烛会“点亮”，火苗会闪烁。当检测到吹蜡烛的声音时，电子蜡烛会熄灭（图3-43）。

![images/1cc33acb0336c320af717d083d2c69c6b625a51286f71d190fbc79b286dd6650.jpg](https://i.imgur.com/LhzVkm7.jpeg)
图3-43电子蜡烛程序

此处使用了“随机数”模块，可以模拟真实蜡烛火苗闪动的效果。通过使用该模块，可以生成随机数值，用来控制灯光的亮度和闪烁效果，从而模拟出蜡烛火苗的真实效果。这种技术可以被应用于电子蜡烛、装饰灯光等产品中，为用户带来更加真实、有趣的视觉体验。

（2）知识点与问题思考 通过取随机值还可以实现哪些有意思的设计？（如闪亮的星空..·）

### 3.3.8 案例3-8: 制作空中弹琴装置

实现功能: 将超声波测量的距离与不同的音符进行对应，产生在空中弹琴的效果。

硬件介绍: 超声波测距仪是一款可以用来测量距离的传感器（图3-44）。超声波是一种频率高于声波的机械波，具有高频、短波长、小绕射和良好的方向性，可作为射线定向传播。

![images/d568c18309a00667ae59952b91adad253c0da45854752ea188cd70b2d61c4375.jpg](https://i.imgur.com/KCl3rbe.jpeg)
图3-44超声波传感器

工作原理: 通过超声波发射器向某一方向发射超声波，当声波遇到障碍物时会返回并被另一个探测器接收，通过计算发射和返回的时间差计算距离。因为超声波在空气中的传播速度

为 $340\mathrm{m/s}$ ，通过公式 $s=340\times\frac{t}{2}$ 可计算出距离 $S$ （t为从发射到返回的时间）。超声波技术可以广泛应用于测距、物体检测、避障等场景。

硬件连接: 利用扩展板将超声波传感器和蜂鸣器接入主板，Trig 接入4号引l脚，Echo 接入7号引引脚，正负对应接入（图3-45）。

![images/b66bd1d2eb5497538fd566ce831f0707a6d2810d49cefc75d400665d22c0e56b.jpg](https://i.imgur.com/JR4HuzS.jpeg)
图3-45超声波传感器与蜂鸣器的硬件连接

（1）程序设计 程序图如图3-46所示，基本思路和步骤如下: 

![images/c47d61426f3a58143fa1410bc556a5604018031caec117cd6bff5b0493439b17.jpg](https://i.imgur.com/h3UchFi.jpeg)
图3-46空中弹琴程序

设定超声波传感器的接线引脚位置。

输出距离值。

$\mathbf{\delta}$ 设定条件: 设定探测距离范围，在这个距离范围内会产生声音的变化。

映射数值，将距离 5\~40 映射为数字1\~7。

输出映射后的数值。

设定条件: 当数值为特定值时，蜂鸣器输出固定值，以此类推。

（2）知识点与问题思考．利用本书音乐与声音频率的相关知识，用蜂鸣器编制一首能够自动循环播放的乐曲（程序参考如图3-47）。比较语言编写与可视化编程的区别，从中体会计算机程序执行的过程。

![images/a75ef57032e2a01bba923ede18be55765f76741e11cc2414ce2f3ba5bf757ecd.jpg](https://i.imgur.com/njYtD40.jpeg)
图3-47自编循环播放的乐曲（两只老虎）

### 3.3.9 案例3-9: 制作超声波测距仪

功能实现: 通过声波传感器测量距离。

硬件介绍: 液晶显示屏: 该屏幕每行16个字符，共2行。若出现乱码，可在每次输出之前清屏。液晶屏的功能程序代码见图3-48。

![images/84ac474d81456f3e2e75362eb0a38a94b8386256a1adee2a1f785701762767a8.jpg](https://i.imgur.com/GdbS7vg.jpeg)
图3-48超声波模块的功能

![images/2a47d433152548e0be266fd610893691f72ed460b891413e48354e5c0a3d7de3.jpg](https://i.imgur.com/q83HVdT.jpeg)
图3-49超声波与液晶显示模块的连接图

硬件连接: 利用扩展板将超声波测距模块，液晶显示模块用连接线与主板相连，Trig 接入4号引I脚，Echo接入7号引I脚，正负对应接入；液晶屏模块的SDA接入A4，SCL接入A5正负对应接入（图3-49）。

（1）程序设计思路: 设定超声波传感器的接线引脚位置 $>$ 第一行显示的内容 $>$ 第二行显示的内容（图3-50）。

![images/c2a084d2659ce118c0327beea662f6f26a1fdf8ff3cc49820cb4d454604777aa.jpg](https://i.imgur.com/BRFaIH9.jpeg)
图3-50测距仪程序

（2）知识点与思考

借助激光笔的指示功能，制作一个便携式的测距仪（需要减掉设备自身的长度），更换不同单位实际测试一下测量的精度。

利用超声波测距功能作为条件，还可以做哪些有意思的装置？

### 3.3.10 案例3-10: 制作人数计数器

实现功能: 在公园、场馆入口处，每进入一位游客，显示屏上加1，不断统计进入的人数，可以实现在公共场所计算人流量。

硬件连接: 利用扩展板将液晶显示模块，红外接近开关模块按照以下方式进行连接（图3-51），红外接近开关模块与2号引脚对应的3个引脚相连（注意插线时颜色的对应）。新版的黑色为信号线，一般红色或棕色代表 $^+$ ，蓝色或绿色代表－，黄色或黑色代表信号线。

![images/300825afd18ed355637419c57fa89f2fa2b27da31e4594924dc28af11178ea85.jpg](https://i.imgur.com/7JrjlIU.jpeg)
图3-51计数器硬件接线图

（1）程序设计本程序使用了一个新的模块“中断”（图3-52）。“中断”是指在程
序顺序执行过程中，当主控板收到规定的某些数字输入信号时，会立即暂停当前执行的程序,
转而去执行中断部分的程序，当中断部分执行完毕，再回到刚才暂停的地方继续执行原来的程序。注意: 主控板上只有2号和3号引脚支持中断功能。

![images/86b5b6a200435cc2983b3628f546566a3aee1d9e9a416fc9434817ece82d595b.jpg](https://i.imgur.com/mU5bWSL.jpeg)
图3-52计数器程序

（2）高级功能实现进出分别计数，即进来1位游客（2号引脚触发中断），显示屏上公园人数加1；出去1位游客（3号引脚触发中断），显示屏上公园人数减1。

硬件连接: 在上面连接基础上，取出两个红外接近开关模块，用连接线分别将其与2号引脚、3 号引脚对应的三个引脚相连（注意插线时颜色的对应）。

（3）程序设计 初级程序见图3-53，可以完成基本的进出计数功能。

在完成基本功能的基础上，继续增加防干扰功能。方法: 如果 2号或3号引脚在一定短暂时间内数次触发中断，则不增加或减少计次，以此改进程序（图3-54）。

![images/0e9f7e8bf683ad37a0b296f4100af368617c80d409b45c9ba63bc5c685f2a635.jpg](https://i.imgur.com/vhQMefX.jpeg)
图3-53基本功能程序
图3-54改进功能程序

（4）知识点与思考在程序编写界面中，所有独立的模块都是同时执行的，此例中三个独立的模块都是同时执行，并不存在先后顺序，其他所有模块都是这样的原理，它们之间的信息是根据条件即时通信响应的，根据具体情况对程序逐渐优化（要从“实践”中不断发现问题）。


# 4 高级可视化编程

![images/fe3d2532823bab27f23aa74101741c9fd55c001b1b2934b9448d2730799cfd08.jpg](https://i.imgur.com/Hj4DFPh.jpeg)

高级可视化编程Touchdesigner

4.1 软件介绍与安装
4.2 Touchdesigner 基础

## 4.1 软件介绍与安装

### 4.1.1 软件介绍

Touchdesigner 不只是一个应用软件，它是一种可视化的编程语言或平台，可以创建令人惊奇的实时项目和丰富的用户体验。Touchdesigner 也不同于传统复杂的编程工具，它提供了一种利用可视化节点作为制作手段的全新创作方式，创作者和设计师不需要担忧底层的编程开发，可以把精力集中到如何将不同媒介装置整合起来去创造更有想象力的跨领域交互艺术作品，特别适合没有计算机编程基础的艺术家和设计师。同样它也给有 $\mathsf{C}\mathsf{+}\mathsf{+}$ 编程的人员更多的控制权，Python 作为内嵌编程语言，与 $\mathsf{A l}$ 的结合让人对Touchdesigner 运用人工智能有了更多的想象。

Touchdesigner 能够实现三维实时渲染、机械装置控制、实时灯光及声音特效输出。结合各类传感器，使用者可以制作出具有丰富交互效果的艺术作品。它在教学、实验室、舞台创作、灯光设计、声音制作、机械控制等领域都有广泛的应用。

无论是作为媒体服务器，还是信息集成及计算核心，Touchdesigner 都有着行业内较高级别的稳定性。目前Touchdesigner共有四种授权类型，分别为非商业版、商业版、教育版、专业版。

非商业版（Non-Commercial）: 开放使用 $95\%$ 以上的功能元件，最大可以输入输出的分辨率为 $1280\times1280$ ，个别专属商业版的元件名称显示为灰色无法使用。

商业版（Commercial）: 开放使用几乎所有大型展演所需的功能元件及软硬件接口，没有输出分辨率的限制，在显卡配置充足的情况下，单台服务器最大支持16 路的 8K 高清视频输出。

教育版（Educational）: 需提供高校教育证明，申请具有和商业版同样的功能，仅供在校学生和教师使用。

专业版（Pro）: 专业付费版，开放所有元件及软硬件接口，在商业版本功能基础上增加Notch、BlackTrax 等多服务器同步等高级功能，可对工程文件进行加密。

此外有Touchplayer 授权，可以理解为 Touchdesigner 的播放器，在现场不同机器上进行部署播放。版本需与Touchdesigner 授权的版本一一对应，价格基本上是对应Touchdesigner 版本的一半，国内授权查询 TEA 新媒体艺术社区。

### 4.1.2 软件安装

170. 软件下载: 在Touchdesigner 官网主页中点击“get it now”，可看到运行Touch-designer的电脑需要的最低配置，根据自己的电脑配置下载相应的版本。

171. 注册账号获取授权号: 在官网进行账号注册，完成后登录，点击“MYLICENSES”，查看自己的LicenSe，并在最下方点击“CREATKEY”，创建一个密钥（图4-1）。

![images/1574e6eae2f50c8131459c715ce3d43c756d05382022017608c00280ac251abd.jpg](https://i.imgur.com/Aye84Hp.jpeg)
图4-1登录获取密钥

172. 软件安装与激活: 下载完成后点击“安装”，可以自定义安装位置或默认安装路径。安装完成启动软件，初次运行需添加授权密钥，输入刚刚在官网上获得的密钥即可成功激活。

173. 禁用密钥: 一个密钥只能在一台电脑上使用，如要在另外电脑上用这个序列号，必须在原电脑上释放序列号。具体方法，打开菜单“Dialogs”中的“KeyManager”，选择自己的密钥后点击“Disable Key”就移除了。

### 4.1.3 界面介绍

软件整体分为控制选择区、插件区、可视化编程区、参数窗口、时间轴（图4-2）。

![images/1fd96039c65f20cea7d17f1304ba817ca97f99b3abc22176feecfd8b77b902b0.jpg](https://i.imgur.com/7VvCOMQ.jpeg)
图4-2软件界面的功能分布

（1）A: 控制选项区 页面上方的控制区，可以控制软件界面的整体效果、元件的层级状态等，如图 4-3。

![images/b8a9cf3f54769a4715b26dc90b235d69881fb72b7c844ca9a7f64a88febd4e83.jpg](https://i.imgur.com/KUHaxY7.jpeg)
TouchDesigner 2022.3- 600: C:/Users/DELLDesktop/NewProject.1.toe
图4-3 控制选项区的功能

WIKI: 打开维基页面，可以快速访问 Touchdesigner 的全面介绍。

FORUM: 打开官方论坛，里面是有关技术、硬件、初级和高级的各种问题，是学习的优质资源。

TUTORIALS: 打开官方教程，内含大量官方的视频教程。

FPS: 全称“frames per second”，即实时帧率（每秒播放的帧数），可在时间轴左侧区域修改。

5 Perform Mode: 以表演模式进入播放状态，只保留单个播放窗口，按Esc 键退出。

- Palette: 打开或关闭插件区。

- Pane layout: 窗口布局，可以分成不同数量上下左右几种情况，方便在不同级别元件内进行引用操作。

（2）B: 插件区插件是由一系列元件组成的具有一定功能的集合，如音频分析模块、VR 设备接入模块、Mapping 模块等，当再次使用时将其拖入编辑区内即可，可快速完成某些固定功能模块的创建（图4-4）。

自定义插件: 当完成特定功能的集合后，可选择将文件打包成插件便于后续继续调用，具体步骤如下。

新建插件文件夹: 在插件区 My components 上右键选择增加文件夹，输入自己的插件文件夹名称。

![images/8e9c780ab3b899db5c80b6766d4baa055aff97fd1f6798177a5fe751b8d3e355.jpg](https://i.imgur.com/MwIEyrB.jpeg)
图4-4插件存放位置

- 转成插件: 将自己完成的一系列功能集直接拖拽到所建的文件夹内，再次开启软件就可以随时调用（Base、Container等 Comp 元件都可以）。

-  存储插件: 如果给别人使用，可以单独存成一个文件，方法如下: 使用鼠标滚轮或u键退出到Project 页面（即Container容器）。右击project1并选择savecomponent.tox，选择要保存的地方即可。

- 调用插件: 直接拖拽\*.to×文件进工作区，并在工作区内将其拖拽到自己的插件文件夹内即可。

注意: 插件文件夹名称和插件名不可以是中文，否则无法显示。

（3）C: 可视化编辑区 此区域是工作台，所有元件的连接都在此区域内完成。元件的左边是输入接口，右边是输出口，数据从左向右流动，各个元件中的参数可以通过引用互相作用，共同组成具有特定功能和效果的工程文件（图4-5）。

![images/41ff3a528f941148e760d738578160c9d2d86ef76024cd061d0fdc8d7900b895.jpg](https://i.imgur.com/BRXaTrK.jpeg)
图4-5可视化编程区与元件之间的连接

（4）D: 参数窗口参数控制面板中包含了所有的控制参数，按“P”键或右击元件选择Parameter（参数）即可打开（图4-6）。注: 在元件上右键调出Parameter控制板可以方便地移动其位置。

![images/100830a2d31bea8839b5f049770e91a003ae53ef92ae6882460b5c063f2083b2.jpg](https://i.imgur.com/oZdxBo2.jpeg)
图4-6打开元件参数窗口

参数窗口的图标含义如下。（左边1\~3 是参考类的信息。右边 4\~9 是功能性按键。)

帮助: 维基帮助文档。Python 帮助。3元件信息框: 显示此元件的相关信息。3显示标签: 显示和编辑元件的标签。3注释: 显示和编辑元件的注释。3显示复制参数；显示通过右键菜单复制的参数。$④$ 语言: 选择使用 Python 或 Tscript 作为其脚本语言。$\mathfrak{G}$ 展开／折叠参数: 展开或折叠所有的元件参数。

- 非默认参数: 仅显示被修改参数，方便查看参数修改情况。

（5）E: 时间轴在界面底部，可实现播放、暂停、定位时间等操作（图4-7），通过按下空格键可以实现播放或停止。左侧区域能看到帧率，通过设置开始和结束帧，可以实现在特定区内播放。同时也可以修改FPS（每秒渲染帧数），以此让画面播放速度产生变化。

![images/95daf8488587ba6c31b357b75ae4b0ac8095cd630f7400e0a6a44277bde919b9.jpg](https://i.imgur.com/leLf22A.jpeg)
图4-7状态栏

## 4.2 Touchdesigner 基础

### 4.2.1 鼠标操作与快捷键

（1）鼠标的基本操作该软件需要一个带滚轮的鼠标进行操作，通过滚轮可以实现对元件、视图的大小进行缩放并在不同层级的元件中进行切换，基本操作方法如表4-1所示。

表4-1 鼠标的操作


<html><body><table><tr><td>左键</td><td>功能</td><td>右键</td><td>功能</td><td>中键滚轮</td><td>功能</td></tr><tr><td>工作区单击并按下 拖动</td><td>移动整个视图</td><td>工作区单击</td><td>显示工作区相关的 快捷菜单</td><td>元件上单击</td><td>显示元件信息</td></tr><tr><td>元件上单击</td><td>选择（移动元件）</td><td>元件上按单击</td><td>显示元件相关的 快捷菜单</td><td>元件开口处单击</td><td>新开一个路径并 添加新元件</td></tr><tr><td>空白处双击</td><td>新建元件</td><td>元件开口处单击</td><td>在同一路径上继续 添加新元件</td><td>前后滚动</td><td>缩放视图，进入或 退出不同层级</td></tr><tr><td>元件开口处 单击并拖拽</td><td>给不同元件 进行连线</td><td></td><td></td><td></td><td></td></tr></table></body></html>

（2）常用的快捷键 见表4-2。

表4-2 常用快捷键


<html><body><table><tr><td>按键</td><td>功能</td><td>按键</td><td>功能</td></tr><tr><td>空格键</td><td>播放/暂停</td><td>A</td><td>进入元件编辑模式</td></tr><tr><td>Tab</td><td>添加元件</td><td>S</td><td>连线方式切换</td></tr><tr><td>Shift+X</td><td>加载tox元件</td><td>X</td><td>数据箭头显示/隐藏</td></tr><tr><td>P</td><td>参数面板显示/隐藏</td><td>H</td><td>居中查看全部元件</td></tr><tr><td></td><td>跳出（上级）编辑区</td><td>Shift+H</td><td>居中查看所选元件</td></tr><tr><td>Enter</td><td>进入（下级）编辑区</td><td>W</td><td>线框显示物体（需打开SOP元件右下角+号）</td></tr></table></body></html>

### 4.2.2 元件的概念和分类

Touchdesigner 中的基本元件类型分为 6 种类型，分别是 COMP(Component Operator),TOP (Texture Operator), CHOP(Channel Operator), SOP(Surface Operator),

MAT(Material Operator)和 DAT(Data Operator)。另外一类自定义元件 Custom，如果没有自定义就是空的。每一类元件分别由不同的颜色进行区分（图4-8）。

图4-8所有元件列表


<html><body><table><tr><td>COMP TOP CHOP SOP MAT DAT</td><td colspan="4">Custom</td></tr><tr><td>Add</td><td>Fit</td><td>Multiply</td><td>PreFilter Map</td><td>SubstanceSelect</td></tr><tr><td>Analyze</td><td>Flip</td><td>Ncarn</td><td>Projection</td><td>Subtract</td></tr><tr><td>Anti Alias</td><td>Function</td><td>NDIIn</td><td>Ramp</td><td>Switch</td></tr><tr><td>Blob Track</td><td>GLSL</td><td>NDIOut</td><td>RealSense</td><td>Syphon Spout In</td></tr><tr><td>Blur</td><td>GLSLMulti</td><td>Noise</td><td>Rectangle</td><td>Syphon Spout Out</td></tr><tr><td>Cache</td><td>HSVAdjust</td><td>Normal Map</td><td>Remap</td><td>Text</td></tr></table></body></html>

(1） TOP(Texture Operator） TOP(Texture Operator) 是一类关于输入、输出平面图片或影像的元件，TOP 元件是基于像素（Pixel）的对象，这意味着可以通过GPU 进行计算，在图像处理和视频解析上具有超强的效率和灵活性。

TOP 元件的基本作用如下。常用元件如表4-3所示。

基本形态绘制: 如 Circle、Rectangle 等，可以利用这些基本形生成非常复杂的抽象动态视觉效果。

商用特效元件: 如 Nvidia Flow TOP，可通过简单参数调出复杂的火焰特效（需要商业授权才可用）。

后期效果调整: 类似 PS 的滤镜，如Level TOP、RGB Key TOP 等，让后期处理变得简单而清晰。

视频输入输出: 如 Movie File In/Out TOP，支持几乎市面上所有格式的视频导入与网络视频流处理。Video Device In TOP 可自动通过摄像头等硬件采集影像内容。

5 外界设备: 可以接入Kinect、Realsense Top、ZED Top 设备实时采集多种影像内容。

?其他: 同第三方软件的通信协议进行整合，如 Syphon Spout In/Out TOP，支持所有主流软件的图像同步通信，Notch TOP 的出现让视觉软件 Notch VFX与 Touchdesigner整合成为强大的视觉交互系统。

表4-3常用的TOP元件


<html><body><table><tr><td>Add</td><td>叠加</td><td>Constant</td><td>常量</td><td>Fit</td><td>自适应</td></tr><tr><td>Analyze</td><td>分析</td><td>Crop</td><td>裁剪</td><td>Flip</td><td>翻转</td></tr><tr><td>AntiAlias</td><td>抗锯齿</td><td>Cross</td><td>颜色调整</td><td>HSV Adjust</td><td>颜色调整</td></tr><tr><td>Blur</td><td>模糊</td><td>Displace</td><td>置换</td><td>Kinect</td><td>体感传感器</td></tr><tr><td>CHOP To Top</td><td>元件属性转换</td><td>Edge</td><td>查找边沿</td><td>MovieFile In</td><td>文件导入</td></tr><tr><td>Composite</td><td>整合</td><td>Feedbak</td><td>反馈循环</td><td>Transform</td><td>变换</td></tr></table></body></html>

(2 )CHOP(Channel Operator） CHOP(Channel Operator) 是数据通道元件类型,Touchdesigner 作为一款以交互和实时数据处理为核心的软件，本质上所有的输入和处理都可归结为对于数据的处理，在CHOP 元件中每一条数据变量都是一个通道。

CHOP 元件类型的常用元件如表4-4 所示，主要完成数据生成、采集（声卡数据）、读取传感器和硬件设备发送的信息等（如激光雷达、Kinect、Leapmotion 等）。

表4-4常用的CHOP元件


<html><body><table><tr><td>Analyze</td><td>分析数据</td><td>Kinect</td><td>体感传感器</td></tr><tr><td>Attribute</td><td>属性分析</td><td>Lag</td><td>滞后处理</td></tr><tr><td>Audio Device In</td><td>声音输入</td><td>Limit</td><td>限定数据</td></tr><tr><td>Audio Device Out</td><td>声音输出</td><td>Logic</td><td>逻辑</td></tr><tr><td>Audio Filter</td><td>声音过滤</td><td>Math</td><td>数据匹配</td></tr><tr><td>Delay</td><td>延迟处理</td><td>Merge</td><td>数据合并</td></tr><tr><td>Filter</td><td>平滑数据</td><td>Mouse In</td><td>鼠标输入</td></tr><tr><td>Noise</td><td>产生噪声数据</td><td>Mouse Out</td><td>鼠标输出</td></tr></table></body></html>

（3）SOP(Surface Operator）SOP是3D 模型制作、变换相关的一系列元件，具有 3D模型生成与编辑功能。SOP元件的编辑和计算是基于模型上的点（Point），也就是三维空间中的矢量数据，SOP类型元件的计算都是在CPU上进行的，常用的SOP元件如表4-5所示。

三维模型生成编辑: 如Sphere、Box、Torus 等，还可以对法线、曲面、线段等各种参数进行编辑调整。

2 动态形状生成: 如通过运用 Noise SOP、Copy SOP、Creep SOP 等元件可以创造出丰富的模型变化和动态效果；Metabal SOP与 Spring SOP 的使用更可以通过场域变化创造出流体和绸带的效果。

特殊对象制作: 如利用ParticleSOP制作粒子系统，结合一些外置设备去控制粒子并制作实时交互作品。

表4-5常用的SOP元件


<html><body><table><tr><td>Sphere</td><td>球体</td><td>Rectangle</td><td>方形</td></tr><tr><td>Circle</td><td>圆环</td><td>Line</td><td>线条</td></tr></table></body></html>

续表


<html><body><table><tr><td>Noise</td><td>噪声</td><td>File In</td><td>文件输入</td></tr><tr><td>Merge</td><td>合并</td><td>1no</td><td>输出</td></tr><tr><td>Tube</td><td>圆管</td><td>Align</td><td>对齐</td></tr><tr><td>Twist</td><td>扭曲</td><td>Extrude</td><td>挤压</td></tr></table></body></html>

（4）MAT(Material Operator）MAT（Material Operator）是材质元件，为三维物体提供不同属性的材质，还可以将影片或者动态视频作为贴图添加在不同物体上，这样就可以做出动态贴图效果。常用的MAT元件见表4-6。

表4-6常用的MAT元件


<html><body><table><tr><td>Constant</td><td>不受环境光影响、不分明暗面的材质</td></tr><tr><td>Phong</td><td>有高光等更多属性的光滑材质</td></tr><tr><td>Wireframe</td><td>线框材质</td></tr><tr><td>PBR</td><td>基于物理的渲染材质，有更加丰富的视觉效果</td></tr><tr><td>PointSprite</td><td>针对粒子系统的有专门材质</td></tr><tr><td>GLSL</td><td>通过编程来实现的材质</td></tr></table></body></html>

（5）DAT(Data Operator）DAT（Data Operator）可以处理不同类型的数据，所有的数据在DAT元件中均以表格形式存在。DAT可以当作一个信息中转站，对所有与字符、字符串有关的数据进行处理与收发。在Text DAT元件中可以执行任何Python3 的代码，Touchdesigner中的编程命令（Python指令）都是在DAT元件中运行的，常用的DAT元件见表4-7。

表4-7常用的DAT元件


<html><body><table><tr><td>Art-Net</td><td>接收来自Art-Net的信号</td><td>FileIn</td><td>引入纯文本</td></tr><tr><td>CHOPExecute</td><td>执行（常结合逻辑判断元件使用）</td><td>Convert</td><td>转换数据类型（如表格与文本）</td></tr><tr><td>Serial</td><td>接收来自传感器的数据</td><td>Select</td><td>选择需要的数据</td></tr></table></body></html>

（6）COMP(Component Operator）COMP 可以理解为是其他元件的“容器”，“容器”不仅具有将不同功能的元件进行整理归类的功能，也是进行窗口显示和渲染的必要条件。在这类元件中又有 4 个小类，分别是 3DObjects、Panels、Other和 Dynamics（动态）COMP。常用的 COMP 元件如表4-8所示。

表4-8常用的COMP元件


<html><body><table><tr><td>Light</td><td>灯光</td><td>Container</td><td>容器（工程文件的总容器）</td></tr><tr><td>Camera</td><td>相机</td><td>Button</td><td>按钮</td></tr><tr><td>Geometry</td><td>物体容器</td><td>Animation</td><td>动画元件</td></tr><tr><td>Base</td><td>基本容器</td><td>Window</td><td>屏幕输出</td></tr></table></body></html>

### 4.2.3 元件的属性

元件是Touchdesigner可视化编程平台的基本功能单位，深度了解并掌握各类元件的详细功能是进行交互艺术项目开发的基础，更多元件功能详解请扫描本书二维码查阅。

#### 4.2.3.1 元件的属性认识

（1）元件功能区（图4-9）

![images/1bd168cbe463fdfd8affc90c2969957f1c33ee2afe206b6314f55b4f31eb3c55.jpg](https://i.imgur.com/zy3IV7C.jpeg)
图4-9元件功能区

- 关闭／打开显示区: 关闭时只显示元件名称，可减少 CPU的计算量。

- 克隆免疫: 如果是克隆组件，打开后成为独立元件，不受克隆模式影响（类似3D软件中的实例化）。

- 跳过／连通元件功能: 跳过当前的元件功能，让本元件无效。

- 锁定: 将调好的结果进行锁定防止修改。

注: 如果是TOP或SOP元件引I入了外部对象，通过锁定相当于将其嵌入，但不能进行再次编辑或解锁，只能保持原锁定状态。

![images/141e11ef6415252762dea301d95687fec67045366928ef3ce5de7217976825a6.jpg](https://i.imgur.com/lPthU2D.jpeg)
（2）元件其他属性（图4-10）
图4-10元件其他属性

- 背景显示: 所有数据状态都会显示在这个区域。

- 元件名字: 可以自定义当前元件的名字。

- 绿色圆点亮: 表示当前元件被其他元件引用（只有当引l用方式为export时绿色会亮）。

- 蓝色圆点亮: 表示显示区1的内容正在编辑区中显示。

点击 $^{!}+^{!}$ ”号: 变为编辑状态，这时可将元件拖动到其他参数中进行引用。

注: “+”号打开后可用鼠标在元件窗口里调节各种视角并移动元件内的内容，如果要恢复为初始状态直接按H键。

![images/ce87de2e00815667b76ded442049abe5e4bd83cb84ade769c77b68e1936359ca.jpg](https://i.imgur.com/PJ5M2WL.jpeg)
（3）SOP元件的属性（图4-11）
图4-11SOP元件的属性

- Compare（比较）: 增加一个修改元件（比如Noise）后，打开这个可以看到本元件在修改前的状态(以网格形式显示)。

- Template（模板）: 打开后可以在渲染套件中的 Light 与 Camera 窗口中以线框形式显示该元件对象。

- Render（渲染）: 打开后会在最终渲染窗口中出现（即使不在渲染五件套内也会被渲染出来）。

- Display（显示）: 打开后会在五件套中的 Light 和 Camera 窗口中显示出来。

#### 4.2.3.2 元件的参数表达

参数表达方式如图4-12所示。

![images/3beaa9d029ff9ca611d876666aa1506b521ec947efeda12449ba0d675a81810b.jpg](https://i.imgur.com/xx9y2tG.jpeg)
图4-12参数表达方式

- Constant Mode 常量模式（灰色）: 可输入固定的数值等。

- Expression Mode 表达式模式（蓝色）:可通过Python 或 Tscript 语言设置变量。

- Export Mode 导出模式（绿色）: 直接引用 CHOP 的通道。

- Bind Mode 绑定模式（紫色）: 通常用于父子层级间，当其中任意一个发生变化，另一个都会随之改变（双向都可以）。

#### 4.2.3.3 元件之间的转化

在不同的元件类型中转换的方法: 在一个元件后的输出口右键，找到要转成元件的类型，然后选择××to元件，代表将其他类型的元件转成此类元件。几种转化元件的含义见表4-9。

表4-9转换元件的基本含义


<html><body><table><tr><td>CHOPtoTOP</td><td>将CHOP中的通道或数值转为TOP图像。所有CHOP中的数会转化为图像中的R（红） G（绿）、B（蓝）、A（透明度）四个通道并在TOP中显示。如CHOP是多通道组成的， 那生成的是一张含有多个像素的图像</td></tr><tr><td>DATtoCHOP</td><td>将数据表格转化为通道的形式进行输出</td></tr><tr><td>SOPtoCHOP</td><td>将所有空间三维的点×，Y，z以及法线坐标转化为数组形式</td></tr><tr><td>DATtoSOP</td><td>将数据表格中的顶点坐标转换为三维空间的模型</td></tr><tr><td>CHOPtoSOP</td><td>将不同数组转换为三维空间中的坐标点，并结合参照模型生成新的模型形态</td></tr></table></body></html>

#### 4.2.3.4 元件的连接

方法: 在前一个元件的输出口上点击左键拖动至另一输入口上（图4-13），注意以下问题。

![images/b63f6147b8b3db9d9cb170a173abef1a3c4b9558bc97fc7c459aee5638eb0e3e.jpg](https://i.imgur.com/SmrAESb.jpeg)
图4-13元件之间的连接方法

- 只有同种颜色的元件可以连接。

- 左边输入，右边输出，从输入连接到输出。

- 不要在元件之间形成环路，会造成出错。

- 如果左上角出现黄色叹号和红色叉号，黄色代表警告，能处理但是与预期不同；红色叉号代表出错，在符号上单击可以查看具体信息。

### 4.2.4 元件的层级

层级关系主要指元件之间的嵌套关系。最外层是里面一层的父级，反之为子级。如ContainerCOMP中放置了其他元件，Container就是内部元件的父级。层级关系涉及的问题是引用路径，分为绝对和相对路径。

（1）绝对路径绝对路径就是需要列出元件所有层级关系，优点是只要被选取对象的绝对位置不发生变化，那么这一路径在任何一层都是有效的，缺点是比较麻烦。获取元件绝对路径的方法是: 在元件上点击中间，第一行就是元件的绝对路径。

（2）相对路径相对路径是从当前所在的层级开始，通过上一级和下一级表示，标明元件的相对层级关系。优点是书写方便，特点是只要选取和被选取元件的相对位置不发生变化，路径始终有效。

表达方法是: ./background(background 是子集）;../background(background 是父集）。

### 4.2.5 元件之间的引用

（1）同级引用 同一级状态下的元件引用: 将一个元件的数据集用作另一个元件的某

个参数。

方法: 点开元件右下方的“+”使之进入到编辑状态，拖动这个元件放到目标元件的指定参数上即可（图4-14）。

![images/9d3db0e2237fef0aa02d4a5156ba85a85863fed97a0dda4eae12e041fa5d3d2d.jpg](https://i.imgur.com/ViBKlwT.jpeg)
图4-14同级元件的引用方法

（2）异级引用 在不同级别状态下的数据引引用（图4-15）。

将画面进行分屏，引引用元件和被引元件同时出现在平面上各占半屏。

点击被引元件右下角“+”，拖动到相应元件的参数上。

松开鼠标并选择引用模式。

![images/6653c4e2235f8aeefa208206a6e925f2c259db5ec9cc765c1e1ab043aff4bf0b.jpg](https://i.imgur.com/XGLmbG9.jpeg)
图4-15不同层级之间的引用方法

Export CHOP: 将元件数据实时调用给对象，表达式不可以修改。

- CHOP Reference: 以表达式方式引l用并可以修改，一般常用这个。（当被引l用的元件名称变更时会报错，需重新引用）。

? Current CHOPValue: 将瞬间数据以数值形式给对象，固定的数值，一般不用。

### 4.2.6实时视觉特效（案例4-1～案例4-3）

在影像创作过程中，为了增强画面的效果和视觉张力，很多 3D 和视频后期软件都可以对其进行特效处理来辅助增强效果，达到提升画面表现力的目的。Touchdesigner作为实时渲染软件同样具有强大的视觉特效处理能力，常见的如查找图像边沿、去色及拖尾效果等。有些效果可以通过独立的元件完成，而有些则需要用不同的元件进行组合设计。

（1）案例 4-1: 实时去除颜色类似 Photoshop 里面的去色滤镜，在已有的图片上直接加入去色元件就可以实现去色功能（图4-16）。

![images/7cc52bd19fcba8fd98dbf687eed6139390262b34e382081af7945e80b2700fc9.jpg](https://i.imgur.com/Oxf9CfN.jpeg)
图4-16去色处理

![images/0ff0f255c9e10f66d11e1ecaa10377171f159388fbc2badac05621b04dcffbfd.jpg](https://i.imgur.com/YiYIOlk.jpeg)
图4-17单色控制参数

去色方法: 

- 在默认案例文件中最后一个元件Out之后增加一个新的元件Monochrome（单色），参数见图4-17。

Monochrome参数，数字越大颜色越少。下面的二级参数RGB和Alpha（透明通道）的值可以精细控制颜色效果（图4-17）。

注: 类似的元件还有很多，可以在元件索引中查找。

（2）案例4-2: 查找边沿（图4-18） 方法与参数: 在默认的案例文件中最后一个元件out之后增加一个新的元件Edge（边沿），参数见图4-19。

![images/0e710498d2fd9b5a6c60bdfa4bb5f5569ddeeea6c9fe0b5a988128ba9d4e9fb4.jpg](https://i.imgur.com/5M3rzOv.jpeg)
图4-18查找边沿

![images/96cc4555f2dea6b1ca9583192afe4575ca610a519e415b79dfc0797ae6d5445c.jpg](https://i.imgur.com/oe1Obq6.jpeg)
图4-19Edge元件的参数窗口

- Select（选择）: 可以选择Luminance（亮度）、RGB 等多个参数单独调整。

- BlackLevel（黑色色阶）: 清晰程度。

- Strength（强度）: 线条的深浅。

- Sample Step（采样步骤）: 线条的粗细。

- Edge Color（边沿颜色）: 定义边沿的颜色。

- Alpha（透明通道）: 可以在透明和黑色之间切换。

$④$ Comp Over Input（重合输入对象）: 与原图叠加。

（3）案例 4-3: 拖尾效果拖尾效果的原理为循环反馈，即将一个图形改变状态后不断地循环，利用视觉停留的原理形成一种特殊效果，整个形成过程见图4-20。元件组合架构:添加 Moivefile inTOP 元件，继续添加 >transform1>feedback 1>blur1>level1>comp1。将 transform1 与 comp1 连接，在 Feedback 中将 Target TOP 选择为 comp1；也可直接拖动Compsite元件放在这个参数上完成引l用。

![images/35a5318d2499a4b764cea2617ea241ffad122e1d110eb6a6a5543a8cd1ade7ca.jpg](https://i.imgur.com/INIeQ1w.jpeg)
图 4-20Feedback的框架结构

![images/b29f426079372b92a0ecffa688fa891808410c39685f915f06be90ea6b5cea50.jpg](https://i.imgur.com/hXfmk1P.jpeg)
图4-21选择文件

制作步骤与流程如下。在上面架构完成后，对元件进行如下设置: 

在元件中点击file 后面的“+”号，选择图片（图4-21）。

![images/772e1b82932847c208b34cfe9c72436632bd22307def2dd65d402829135cd1d9.jpg](https://i.imgur.com/0xSaru9.jpeg)
图4-22改变图形旋转

transform1（变形）改变图片的状态（图4-22）。

- 在 Rotate 参 数 中 输 入 absTime.frame，让图片旋转起来（图4-22）。

![images/fb2d0e2f9786082064be6ba0a7c089527b014c96b3dc01c9a223d2b8655edeea.jpg](https://i.imgur.com/ZHnjaBB.jpeg)
图 4-23改变图形的状态

- FeedbackTOP（反馈）元件见图4-23。

![images/61e40e664d8b03da8b05a92ff4158b4daeaa420958ea3b520b407ee6011267b6.jpg](https://i.imgur.com/anioksF.jpeg)
图 4-24调节滤镜大小

- BlurTOP（模糊）元件见图4-24。

![images/87f53bc89f92b962f7eb455c16f2c021eebbe8151a7776d864e509019c72ed5c.jpg](https://i.imgur.com/cWkjmIA.jpeg)
图4-25调节透明度

- LevelTOP（色阶）元件，降低不透明度（图4-25）。

![images/91c65bcf48468a850a5cbe6b7fbfea44159f1141bc36f83988d58805cfd69dc2.jpg](https://i.imgur.com/k1zBiSY.jpeg)
图4-26整合设置

$⑦$ CompsiteTOP（组合）元件（图4-26）。

将Compsition元件的参数Operation（操作）改为Add（叠加模式），最终拖尾效果形成。注: 整个过程在Feedback和Compsite元件之间形成一个循环，每循环一次图像发生的变化不断叠加，因为循环速度比较快，类似动画形成的过程，因此会形成一个拖尾效果，这种效果在大量作品使用。

### 4.2.7 三维渲染五件套

以geo comp为中心的渲染5件套分别为 Geo（几何体）、Light（灯光）、Camera（相机）、MAT（材质）、Render（渲染），关系如图4-27所示。

![images/4dc605ff2066eb670c804b1785ad32cb3e05ca9ed72b573a56af617092cdff9a.jpg](https://i.imgur.com/vP4lM1O.jpeg)
图4-27渲染五件套的基本结构

#### 4.2.7.1 CameraCOMP（相机）

相机的用法与其他3D软件相同，主要用来观测最终输出图面的构图与效果。

进入相机视图的方法: 分屏显示〉在右侧窗口中的下拉框中选择 GeometryViewer 进入相机视窗，在这个视窗中可以详细观察相机的位置和状态并进行精确控制。另外在下拉菜单中可以选择各种不同的视图进行显示，以便观察最终的输出效果，比如相机视图、顶视图等（图4-28）。

相机参数控制板有如下几个标签（图4-29）: 

Xform: 对相机位置、旋转、缩放及朝向等一系列参数进行控制，用这个标签可以自由控制相机的状态，以便能够选择到合适的输出构图。

2） Pre-XForm: 在 XForm 之前对相机进行一系列预处理的操作，可实现更复杂和精确的控制（一般不用）。

View: 相机的视图选择，一般有四种方式。

Setings: 相机的配置选项和参数，主要用来控制相机的背景颜色，是否有雾气等。

5 Render: 渲染效果的各种优化程度（不常用）。

6 Extensions: 扩展设置，可用Python 等编程语言进行功能扩展（不常用）。

7 Common: 公共参数标签，设置组件的节点查看器和克隆关系，如各类常用的快捷键（不常用）。

![images/190f3587f67638901392b16b354d7684a6a294cf21f86be0da63cb2ba96f0fa2.jpg](https://i.imgur.com/NQgyE0n.jpeg)
图4-28框选标记红色
图4-29 相机控制面板参数

（1）Xform 标签（图4-29）

Transform Order（设定变换顺序）: 只有当一个对象的位移、旋转和缩放发生冲突的时候,此顺序才有作用（一般不用）。

Rotate Order（旋转顺序）: 只有当一个对象的旋转发生冲突的时候，此顺序才有作用（一般不用）。

- Translate（变换）: 沿着×,y,z 轴移动位置。

$\bigotimes$ Rotate（旋转）: 沿着×,y,z 轴旋转相机。

- Scale（缩放）: 沿着 $x,y,z$ 轴缩放，影响视图的输出效果。

- Pivot（中心点）: 中心点位置。

- Uniform Scale（等比例缩放）: 沿×，y，z三个轴等比例缩放相机（不会改变视图效果）。

- Constrain To（约束到）: 让相机附属到某个指定元件上，跟随指定元件运动（通常只能是Omp元件）。

- Look At（朝向）: 让相机在移动过程中始终面对指定的元件（通常只能是Comp 元件）。

- Forward Direction（向前的方向）: 定义相机面向的方向，可定义不同的轴（只有设置了.00kAt后才可选择几个轴向）。

- Look At Up Vector: 向上的矢量（有旋转和输入数字等方式）

- Path SOP（相机的路径）: 输入 SOP元件名字，能为相机指定运动的路径，路径必须是矢量的线条。

![images/5827cbaa018bddc51cefa51c367af9e9fbf2f26ea3083e79cc928d0a5123a51e.jpg](https://i.imgur.com/Kep6yhE.jpeg)
（2）View 标签（图4-30）
图4-30相机的View标签
(3）Settings 标签（图4-31）

- Projection（视窗显示方式）: 有透视、正交自定义等。

Ortho Origin（正交对齐方式）: 可以选择几种方式。

Viewing Angle Method（观看角度的方式）: 有水平和垂直等，下面的二级参数均为每种对齐方式下的可调参数。

FOV Angle: （视野角度）: 用来改变视野范围。

- FocalLength（焦距长度）: 相当于相机镜头的长度。

- Aperture（孔径）: 可以用来改变视野大小。

- Near（近处）: 配合使用用来改变视野大小。

- Far（远处）: 配合使用来改变视野大小。

- WindowRollPivot: 视窗旋转基点，下面二级参数详细控制相机如何旋转。

![images/f046a831124aa558323cd888a3154033d9df3428a89fa1dd5cba9c941dcc7331.jpg](https://i.imgur.com/zraTOev.jpeg)
图4-31相机的设置标签

- Background Color（背景色）: 以点选和输入选择背景色。

- Fog（设置雾气）: 三种产生雾气的不同算法。

- Fog Density（雾的强度）: 定义雾的强度。

- Fog Near（近雾）: 设置雾的最近处。

- Fog Far（远雾）: 设置雾的最远处。

- Fog Color（雾色）: 设置雾的颜色。

- Fog Alpha（雾的透明度）: 设置雾的透明度。

- Fog Map（雾的贴图）: （不常用）。

- Camera Light Mask（遮光罩）: 相当于照相机遮光罩（不常用）。

#### 4.2.7.2 Light COMP（灯光）

主要用来调整灯光的位置、朝向、颜色、强度等参数，为场景渲染提供光源。Xform 标签的功能和具体参数与Camera基本相同。

![images/dc3ff66819a3bfdbafe5249b8772ab093e89b866d853e1ffd959ab95e01cd312.jpg](https://i.imgur.com/HbI78Nl.jpeg)
（1）Light标签（图4-32）
图4-32灯光的 light 标签

- LightColor（灯光颜色）: 可以自定义输入R，G，B值，或者点选选择灯光颜色。

Dimmer（调光器）: 不影响色调的情况下改变光照强度。

- LightType（灯光类型）: 可以选择任意三种灯光类型。

- PointLight（点光源）: 所有方向均等发散的光。

- ConeLight（锥形光）: 光线呈锥形发散，类似聚光灯。

DistantLight（远光）: 从远方发射出的平行光类似太阳。

Distance-Attenuated（衰减距离）: 控制光线衰减的状态。

![images/a21615311b1517dffd6e25b7634e0169c51a1d4cdd44fc4f0faf6ca57a31d9e0.jpg](https://i.imgur.com/ZSYceWY.jpeg)
（2）Shadows 标签（图4-3- ）
图4-3- 灯光的阴影标签

- Shadow Type（阴影类型）: 有Hard,2DMapped（2D 硬）；Soft，2D Mapped（2D 软)以及Custom三种类型。

- ShadowCasters（阴影物体）: 指定哪些物体产生阴影，＊号代表所有物体。

Light Size（灯光尺寸）: 使用柔和阴影时用来控制灯光的大小，两个值差距越大阴影越柔和（一般最小值为0.05左右）。

4 Max Shadow Softness（软阴影的最大程度）: 当使用软性阴影时，对软阴影进行微调。5 Filter Samples（过滤采样）: 用软性阴影时阴影的采样率。3SearchSteps（搜索步数）: 使用软性阴影时控制遮挡部分的步数，可以轻微影响阴影的质量。3Polygon OffsetFactor（多边形偏移因子）: 多边形物体的偏移因子，数值越小越容易产生
阴影。$\mathfrak{G}$ Polygon OffsetUnits（多边形偏移单位）: 多边形物体本身形态的偏移量，数值越小越细腻，
越容易产生阴影。9 ShadowResolution（阴影的解析度）: 阴影的分辨率，决定着阴影的最终质量。

#### 4.2.7.3 MATCOMP（材质）

Constant 标签如图 4-34 所示。

![images/6948149ef903cb9206c18262a290e487d6b2e2bf6d091fa24963e1dbcfdcfd9c.jpg](https://i.imgur.com/EnaVNoV.jpeg)
图4-34材质的常量标签

- Color（颜色）: 调整材质的R，G，B颜色或点选颜色。2 Alpha（阿尔法通道）: 控制材质的不透明度。3Color Map（颜色贴图）: 使用TOP元件的图像作为材质的色彩贴图。

#### 4.2.7.4 Geometry COMP（容器）

Geometry可以理解为一个放置各种元件的容器，很重要的功能是完成实例化对象（Instance）。实例化就是将一个对象批量复制到母体对象节点上。母体主要为实例化对象提供一个骨架。依靠实例化可以创作出非常复杂、具有动感并具有颜色变化的复杂对象。

Instance 标签如图 4-35 所示。

![images/7e1355d1dd7348e55921b7664c73d6a7d6e7be005ab8597500bdefc4b82d3dcc.jpg](https://i.imgur.com/gFDE7Tc.jpeg)
图4-35容器的Instance标签

注: 其中 Instance 有三个标签，分别为 instance/instance2/instance3，根据前面的参数可以判断它可以实现哪些内容的引用（比如位置、旋转、大小、颜色）。

Instance Count Mode（实例计算模式）: 用来控制实例化对象产生的方式，下拉菜单有手动方式（Manual）和按总数量直接生成[Instance ${\mathrm{OP}}(\operatorname{s})$ Length] 两种。

Manual（手动方式）可以控制实例化对象的数量，比如有1000个节点，可以在0\~1000个节点中任意定义，但不能超过母体节点的数量。

②按总量生成的方式[Instance ${\mathrm{OP}}(\operatorname{S})$ Length]就是按照母体的节点总数直接生成，母体有多少个节点直接一次性全部生成完。当然手动方式也可以用Ifo（CHOP）元件生成一个数值，然后用 Math映射成一个范围，将其直接赋给Manual，就可实现自动的数值增长，当然这个数值范围不能超过母体节点的总数量。

Default Instance OP（默认实例参考选项）: 指定某个元件作为实例化的对象，直接把需要引l用的元件拖动到这个参数上就可以（这个被实例化的对象可以是DAT,SOP 或 CHOP）。

注: Instance2 标签主要用来定义实例化对象的颜色、纹理等。

#### 4.2.7.5 RenderTOP（渲染）

此元件较为常用的标签为Render/Common。

Render标签设置了哪些相机、物体、灯光需要渲染，渲染质量的抗锯齿情况。

②Common 标签主要用于控制渲染图像的最终分辨率大小、画面比例设置等（一般添加好元件会自动设置，基本参数无需调整，画面比例大小根据需要定义）。

![images/a6c4714586d6c2d4ade72fac95dc0a49162179ce457d5b5731323578fa098abf.jpg](https://i.imgur.com/PTxch8F.jpeg)
（1）Render 标签（图4-36）
图4-36渲染标签

- Cameras（摄像机）: 指定渲染场景使用的相机名称，可以直接将场景中的相机拖拽到此（\*号代表渲染所有相机）。

Multi-Camera Hint（多相机提示）: 使用多相机渲染的一种方法（一般不用）。

Geometry（几何形状）: 用于指定渲染的几何元件，输入对应元件的名字或直接拖拽到此处（\*号代表渲染所有对象）。

- Lights（灯光）: 指定渲染的灯光元件，直接输入名字或将灯光元件拖拽到此处（＊号代表所有灯光）。

5 Anti-Alias（反锯齿）: 消除锯齿使图像变得平滑，数字越大越平滑，但计算量也会更多，根据硬件条件选择。

- Render Mode（渲染模式）: 2D、Cube Map、鱼眼等，一般常用 2D。二级菜单均对应相应莫式进行调整。

7 Transparency: 此处的透明控制是对渲染结果处理而言的，不是对象的透明设置，下面的各种设置均为形成最终渲染效果而进行的一系列算法（一般不常用，直接选择 Depth Peel 为 off 状态即可）。

使用全局分辨率的方法: 在“编辑”菜单 $>$ 首选项 $>$ “TOPs”中找到全局分辨率倍增数（Global Resolution Multiplier），可以将其设置为多种倍增数如 1/2，1/4， $1\times$ $2\times$ 等，然后在此处勾选为On，这就是此时电脑的工作状态。

![images/d3b3ed90e5dd72c6f5cd4555868239f5782d9e4c1e86d50658c3bef7237179f8.jpg](https://i.imgur.com/CDWhLOx.jpeg)
(2）Common 标签（图4-37）
图4-37渲染的通用标签

- Resolution（分辨率）: 设定最终输出影像的大小。

- Use Global Res Multiplier（全局分辨率倍增）: 可以快速在不同电脑上改变工程文件的分辨率，以便适应不同电脑的算力，如在高性能台式机和办公笔记本电脑上编辑同一个文件，最好更改其分辨率以便更流畅地工作（方法见左侧）。

- Output Aspect（输出比例）: 共三种类型，Use input（使用前面元件的比例）、Resolution（绝对值）以及 Custom（自定义）。

- FilViewer（填充视口）: 有多种填充方式可选（算法），会影响流畅度。

- Pixel Format（像素格式）: 位数越大效果越丰富，但计算量也越大，速度越慢，需要更好的硬件支持。

### 4.2.8 影像输出设置

（1）内容导出设置将文件的最终内容保存成视频图片格式存在本地，需要用到MovieFileOut（TOP）元件，相当于对完成的图像进行录屏或截屏操作。

![images/65481221c289c8862debe3019a722b3005aef354a435729c403dde1940eaded1.jpg](https://i.imgur.com/G4dKhFR.jpeg)
各类参数如图4-38所示。
图4-38视频输出元件的标签

在Container（容器）元件后插入MovieFile Out TOP 元件。

Type(文件类型): 设置视频或图片类型,并选择下面的编码格式，通常为JPG，mp4，H.264，GIF等格式。

$⑤$ File(文件): 定义存放文件的路径与名称。

- MovieFPS（帧率）: 定义视频的帧率，一般在 $30\sim60$ 帧左右即可（导出图片不用选择）。

Audio CHOP（声音文件）: 如果有声音输入，可以指定音频文件的路径，直接将音频拖入AudioCHOP，通过改变上传速率从而提高音质。

- Record（录制）: 点击Record（on）后视频开始录制，关闭时停止录制（可以选自录制的时间长短）。

注: 输出的文件尺寸大小取决于Container和内部渲染元件所定义的尺寸，这两个尺寸需要相同。

（2）影像全屏输出全屏输出设置: 工程文件的层级逻辑是将所有元件最后全部放入容器（Container）元件中，最后连上Windows 元件，以便能够更容易控制播放状态，具体步骤如下。

![images/1f757021148a84c8be4889e5d7fd5c34f37f90fe6d967f1b202977c2427074dd.jpg](https://i.imgur.com/CJdYAdG.jpeg)
图4-39背景对象的设置

- 保证 Container 内的最后一个元件是Out（TOP）元件，能够输出内容。

在 Container 元件中将 Look 标签中的Background Top 中输入./out（ 具体为 Container容器里面最后一个输出元件的名称），此处就是指Container 的背景对象是什么（图 4-39）。

![images/26e8176e1bf5efdf6c57dc8f05d83e6d9c68df7eda73657eb93cb7191ae14157.jpg](https://i.imgur.com/qCG527c.jpeg)
图4-40输出视频的分辨率

-  设定 Container 的输出分辨率尺寸,需要同 out TOP元件设定的尺寸相同，此时 Container 元件窗口会显示正确的画面内容（图4-40）。

增加Windows（COMP）元件，将Container 元件拖拽到 Windows 内即可。

![images/dec7335b513fa642836074f7f0e59bb744fe5d87f8e0d0452519ad6d4ef51b23.jpg](https://i.imgur.com/XuiSGm3.jpeg)
图4-41去除边框的全屏设置

Window COMP 是 Touchdesigner 的 视 窗 元件，是工程文件中最后的输出窗口。主要作用是将最后文件以独立窗口的方式进行观看。默认的WindowCOMP是有边框的，去掉边框方法如下（图4-41）。

- 将 Window 菜单页面中的 Opening Size 模式改为Fill。

- 将 Borders（边框）改为 Off。

- 按下F1进行全屏观看（或者点击最下方的 Openas Perform Windows ）。

- 打开 Always on Top（总在最上层）。
- 按EsC 键退出全屏。

### 4.2.9 全屏自动播放设置

设置开机后自动播放功能，便于后期使用。

（1）设置 Touchdesigner 自动播放

- 打开想要开机自启的Touchdesigner 文件。

- 点击 Dialogs 菜单中的Window Placement（窗口布局），如图 4-42。

- 点选 Start in Perform Mode,方框中为 $\times$ 即为选中模式，点击“Close”，保存文件，如图4-43。

![images/9093152c37096399bfba473a3b9d5654dd082bda49d53cff7cbab1c9d2b793e0.jpg](https://i.imgur.com/dEXRGLY.jpeg)
图4-42窗口布局设置
图4-43设为开始运行模式

（2）设置播放画面在Window 元件的参数面板中关闭 Borders；Opening Size 设为Fill（图4-44）。（注意: 项目画面尺寸和屏幕尺寸比例要统一。）点击 Set as PerformWindow的Set键，这样开机将默认播放这个窗口（图4-45）。

![images/39edda13c5711f3eebb2bbb69a6709006f9a0602441797e3b9c55d5adae3f18d.jpg](https://i.imgur.com/8FH5gcB.jpeg)
图 4-44设为全屏填充模式
图4-45设为执行窗口

（3）开机自启设置

打开自启动文件夹: 按住组合键 $\mathsf{W i n+R}$ ，输入shell:startup，点击“确定”打开“启动”文件夹（图4-46）。

![images/9c15259c6f35b3f90f1f6293ac5fbadd8fa4030b30c29ad3ba063bd230dccdc5.jpg](https://i.imgur.com/4eoyq9L.jpeg)
图4-46打开“启动”文件夹

右击已经做好的工程文件并创建快捷方式，将其拖入“启动”文件就可以了。

### 4.2.10 常见问题与操作技巧

（1）如何管理程序元件在程序中利用注释元件把完成特定功能的元件集中放置到一起，便于查看和理解整个程序，移动该区域会同步移动所有元件，方便整个程序的管理。具体做法如下: 双击进入 COMP 分类，添加 Annotate 元件（此插件只在 2022.29850 以后的版本中，如图 4-47），图4-48 为 Annotate 的字体显示效果，修改参数可以得到不同的外观效果（图4-49）。

![images/132846a34d44b191fcde9d2464859b6f2c51da8d4f1908c3ae5b7148b1e23f00.jpg](https://i.imgur.com/sBBIcvb.jpeg)
图4-47Annotate元件的使用

![images/628c2f8e824cadfea08b0936cd59348f04af8f1a5734cd3e1df3e9464028c397.jpg](https://i.imgur.com/lDTwR1Y.jpeg)
图4-48Annotate的字体显示效果

**Text 标签:**

- Title Text: 标题内容，写入标题内容。

- Title Height: 标题字体大小。

-  Title Align: 标题字体对齐。

-  Body Text: 注释框内的文本。

- Body Font Size: 注释框内的文本字体大小。

- Limit Body Text Width: 注释框内的文本宽度限制。

Setting 标签:

![images/24ffa567f3855db2b66e9ad08d517362a4f7cb3fe538d75af2c1b92ea2f2940a.jpg](https://i.imgur.com/peJ3E4i.jpeg)
图4-49Annotate的显示模式设置

- Mode: 显示模式有三种（逐渐变得简洁）。

- Back Color: 本注释框的颜色。

- Back Color Alpha: 注释框背景颜色的透明度（字还在）。

- Annotate Opacity: 所有注释框的透明度。

（2）如何检查错误问题如某些元件修改后出现意想不到的错误不知道该如何排查，最简单的办法是重置这个元件的所有参数。

方法1: 直接在这个元件右键点击ResetAllParameters（重置所有参数）。

方法2: 勾选参数面板右上角的图标只显示修改过的参数，然后在修改过的参数上右键点击 Reset Parameter（重置参数），如图 4-50 所示。


# 5 数字生成与交互

![images/f3fb0fe9450742755758342456ae202e6300fb58caa2af7b6f373a8ebe788923.jpg](https://i.imgur.com/il6jVsV.jpeg)
图4-50参数显示模式

![images/0d423b98acc0e4313ca7f4917569b789d057f3cec642200a124fe4d2ff4ea738.jpg](https://i.imgur.com/dOcQhlN.jpeg)

**数字生成与交互艺术创作**

5.1交互艺术的创意与设计流程
5.2生成艺术之“烟雨水墨
5.3手势交互之“淘气的粽子
5.4体感交互之“畅想雨季

本章主要通过对Touchdesigner视觉特效与Arduino各类传感器获得的数据进行整合，将来自物理世界的传感信息与虚拟对象建立连接，形成人与物、人与人以及物与物的互动，创造给人带来新奇情感体验的交互装置艺术作品。

## 5.1 交互艺术的创意与设计流程

### 5.1.1 创意来源

优秀的作品需要巧妙的创意与构思，任何艺术作品的创作都源于对事物的看法和态度，交互艺术设计以其多媒介、多感官的综合利用，最大程度地激发参观者的反应，以行为和思想交互实现创作者与参观者之间的沟通。优秀的创意构思要求其思想“内核”要有深度，创作者要坚持以视觉效果服务作品内涵，而不是一味地追求绝对炫酷的视觉效果，交互艺术的创意构思一般源自以下几个方面: 

（1）源于对社会现象的深刻洞察对社会发展趋势和人性特点的敏锐观察，可以激发富有深意的创意构思。社会上发生的现象或积极或消极，或多或少都会让人产生触动，以此作为创意点，通过艺术创作的手法，表达自己的态度。例如对互联网的一些负面现象，比如说网瘾过度、迷恋手机、追逐网红等，可以发出自己的声音，艺术创作就提供了一个很好的途径和方法。当艺术家从社会现象中获取创意灵感时，需要进行观察、思考与推理，形成自己的见解与立场。然后选择合适的艺术形式与手法，如装置艺术、行为艺术与概念艺术等，将这些观点表达与传达出来。这不仅需要技法上运用自如，更需要思想上有深度，以视觉效果服务于作品的思想内核。总之，社会现象是艺术创作的重要灵感源泉，艺术家需要关注时代变化，表达真挚的人性关切。应选择恰当的艺术形式，将独到的见解与思考诠释于作品之中，从而引发观众的思考，推动社会进步，实现艺术的社会责任与使命。这体现了艺术与社会、创作与思想之间的密切互动关系。

（2）源于对生活的体验．随着年龄的增长，每个人都会在不同阶段产生对生活的不同感悟，如挫折、悲伤、快乐、幸福、无聊·….…针对生活体验进行艺术创作，也是与别人分享生活的一种方式。通过艺术和媒体的传播，很有可能会形成一定的文化现象，进而引导公众的情绪向积极方向发展。利用艺术创作来分享这些体验，不仅是一种自我表达的方式，也可以产生更广泛的社会影响。这种类型的作品既可以让其他人产生共鸣，分享类似的体验，减轻人的负面情绪；在传播的过程中，也可能会形成一定的文化现象或潮流，从而影响和引导公众的集体情绪。

（3）优秀的创意还源于对文化的理解我国有着悠久的历史文化，中华文化博大精深,有无数个闪光点可以引发我们对民族文化的情感认同。深度理解阐释中华文化，可以为我们的艺术创作带来源源不尽的资源，其前提是要对中华文化有足够深的理解，有发自内心的敬仰与认同。让文化成为我们创意的来源，需要广泛研读中华文化的理论和史料，理解其思想脉络和精髓，要以适当的方式去表达和转译，与观众产生共鸣。

（4）巧妙的创意还会来自一些具体的商业诉求当下交互装置艺术在商业上开始有大量应用，商业需求常常表现在引流（吸引人流）和品牌形象塑造两个方面。在商业区与旅游区,装置艺术常常作为引流的工具，也有将其作为旅游产品进行开发的现象，比如旅游景区中的灯光秀、水秀作品。大量品牌发布会现场也会经常看到交互类的新媒体作品。

### 5.1.2 创作流程

整个创作流程分为以下5个部分。

（1）脚本创意与材料准备创造完整的故事剧本，并对故事脚本进行分镜头处理。绘制出每个分镜头的具体构图，以便绘制某些角色的概念草图，同时根据作品的表现需要准备所需要的硬件材料。

（2）视觉内容设计制作 详见本章综合创作实践案例。

（3）交互硬件接入一件交互装置作品必须有来自参观者的信息与之产生互动，参观者的行为举止能够让作品本身产生反馈，这就需要借助各种传感器来采集参观者的信息，常见的传感器有整合度较高的Kinect,Leapmotion或Arduino支持的其他各种开源平台的传感器。

（4）作品测试利用硬件交互的交互艺术作品需要借助硬件设备进行测试，主要验证是否根据前期的设想进行了反馈，并对反馈的敏感度和反馈时长、动态效果等做进一步调整。

（5）技术路线图绘制一件完整的作品除了最终效果的展示外，还需要将技术实现的路径及程序设计等全面呈现给观众，特别是硬件的整合设计与程序部分，需要详细介绍各类感应器的连接方式和程序执行逻辑。


## 5.2 生成艺术之"烟雨水墨"
（案例5-1）
### 5.2.1 概念创意与学习重点

（1）概念创意该作品的灵感来源于中国传统水墨画，水墨画以其独特的意境和笔墨表达方式，传递着深邃而抽象的情感。通过现代科技把传统水墨带入一个新的维度，为观众创

造一种身临其境的艺术体验。

作品利用计算机图形技术和随机算法，实现了水墨效果的动态生成。每一次呈现的水墨画面都是独一无二的，仿佛在每一刻都重新绘制着自己的艺术之旅。观众在水墨的流动与蔓延中感受水墨带来的神秘氛围。它不仅仅是一幅动态的艺术作品，还可以借助交互技术将其演变成一个交互装置，让观众通过交互手段，探索和影响水墨效果的变化。

（2）学习重点学习数字生成艺术的基本原理以及如何进行音画互动。重点学习Audioanalysis 插件、Filter CHOP、Blur TOP、Displace TOP 等元件的应用方法。

### 5.2.2 设计过程详解

程序设计总体上分为5个部分，分别为: 

球体模型初步处理。球体模型渲染。3 音画互动设置。烟雨水墨效果生成。后期效果处理。

程序总体设计如图5-1所示。

![images/7aac46264872e370c10604099069bd684dfd2f7593a485609a78aabaab8bb956.jpg](https://i.imgur.com/b51BBv7.jpeg)
图5-1程序总体设计

（1）建立球体模型 创建基本对象: 在空白处新建sphere1SOP，继续添加transform1>null SOP（图5-2）。

![images/14ee5b63b63c7fa7245210268251082b4673005d3d20146f2bddbdf6693a067a.jpg](https://i.imgur.com/S18Vbwz.jpeg)
图5-2球体的建立过程

**sphere1SOP: ** 建立一个球体，调整参数（图5-3）。

![images/d343d2b909d17733752722b71be481060e3889eb6ddffe9fd7b2cd9050f1195f.jpg](https://i.imgur.com/ZJWrssY.jpeg)
图5-3调整球体半径

Radius（半径）: ×，y，z轴均调整为O:1（将球体调整到画面合适大小）。

transform1 SOP: 让音乐影响其Uniform Scale，目前无需调整。

- 添加一个 null SOP。

(2）球体模型渲染设置渲染: 在 null SOP 后右键添加 geo1 COMP>cam1COMP>constant1 MAT>render1 TOP（图5-4）。

![images/8aed495aa05cf81d19e76cdd88fde9acb22cfbe1f4841472453d329e0509de2d.jpg](https://i.imgur.com/qS8jm2M.jpeg)
图5-4增加渲染组件进行渲染

geo1 COMP: 参数无需调整，将 constant1 MAT拖拽给Geol赋上材质即可。

cam1COMP: 通过调整方便看到完整画面（图5-5）。

![images/df691d9d7b995ed46fb33bef3f684272f8ff0b572d0bb80f5f05e99967c1b1bd.jpg](https://i.imgur.com/wwGFx7j.jpeg)
图5-5调整相机位置

该对话框数据为鼠标随机调节。相机调整方式: 

- 旋转相机调整构图。点开 cam1 右下角的“+”号，在元件框内按H，相机显示在整个画面内。通过鼠标按键和滚轮调整至最合适的位置（优点是比较方便，缺点是不够精确）。

- 进入 cam1窗口，通过观察相机的三个方向上的坐标轴，分析相机和球体的相对关系，通过输入数值调整相机的位置（优点是比较精确）。

- render1TOP: 调整参数（图5-6）。

![images/509a1e3ccd3353de21bb0656ccdb045d61f4bee3e048dc9288c20001b03c960d.jpg](https://i.imgur.com/8Vjrd8Q.jpeg)
图5-6设置分辨率

Resolution（分辨率）: 改为 $1280\times720$ （根据最终的输出需要调整分辨率）。

(3 )音画互动设置在空白处新建 audiofilein1 CHOP,后面添加插件 audioanalysis>select1 CHOP>filter1 CHOP>math1 CHOP>limit1 CHOP>null CHOP， 在 audiofilein1CHOP后用鼠标中键添加 audiodevout1CHOP（图5-7）。

![images/eb8fe577db8a0eadfbfc0bc26525c8816502c95d4f81840618fe731d9f6e3127.jpg](https://i.imgur.com/G5qJtGZ.jpeg)
图5-7增加音频处理元件

- audiofilein1CHOP: 导入准备好的音频文件，无需调整。

在Touchdesigner的自带插件中找到Tools>Audioanalysis，将它拖入到工作空间 中与 audiofilein1 CHOP 连接。

- Controls 标签: High Active（高音激活），开启On 状态，打开音频的高音部分，目的是让球体的大小变化更加明显，体现音画互动的效果（图5-8）。

![images/4a3b5563ac33e601df78fafce557e98ad8e7798b27d1f07de107927877e0d4ba.jpg](https://i.imgur.com/8NGDsT7.jpeg)
图5-8激活高频

注: 这个插件的功能是快速选择音频文件的低音、中音和高音，并可通过多项二级参数进一步调整想要的数据，比如阈值（Threshold）、获取（Gain）、增强（Add）、平滑（Smooth）等。

**select1CHOP: 选择出高音数据（图5-9）**。

![images/4dc219d65b3f22671ff237be4fdd86e0b56a8f1277fa7783ddf77117f7d514a1.jpg](https://i.imgur.com/HqtlNWx.jpeg)
图 5-9选择声音的高频部分

Channel Names（通道名称）: 选择 high。

fiter1CHOP: 通过滤波器，使音频的高音部分变化稍加柔和，具体操作见图5-10。

![images/3e1f8e7aa4ab63a3278e3671d0296b64a9301842e7013051cef633fba97105de.jpg](https://i.imgur.com/XpPkoqs.jpeg)
图5-10调整滤波参数

FilterWidth（滤波器宽度）: 调整至0.2（数值越小音频数据变化越稳定）。

math1CHOP: 通过Math来放大数据，为了使得球体模型的缩放更加明显（这组数据最终将被应用于影响球体的缩放），具体操作见图5-11。

![images/2d7c664d369ee915b686a1b436a07e15492770074532312f5051870428150a17.jpg](https://i.imgur.com/xC6Ly9U.jpeg)
图5-11调整强度倍增数

Multiply（倍数）: 数值调整为7。

limit1CHOP: 将数据波动限制在一定范围，具体操作见图5-12。

![images/596346dd15fdca45418e84e077c63cae77cd57a4341fe881b72e40c2b1f243f4.jpg](https://i.imgur.com/cudfMs7.jpeg)
图5-12声波范围限定设置

- Type（类型）: Clamp（夹住、固定在某个区间）。

- Minimum（最小值）: 设置为0.2（让球体在音乐最小的时候也有数据）。

- Maximum（最大值）: 设置为20（观察 Math 的数据，只要大于最大值即可，让最大数据能够被使用到）。

- 添加一个 null CHOP，并将 null CHOP 数据引I用给 transform1 SOP 的 UniformScale，操作如下。

![images/225f43262e63a8f061b44056a4850dd071928767d5190b64baefafd2d56acb34.jpg](https://i.imgur.com/hwtmH2k.jpeg)
图5-13参数引用

将 null2（音频处理的最终数据）引l用到球体统一缩放上。

方法: 直接拖拽或者输入（图5-13）的表达式。

（4）烟雨水墨效果生成 通过 Feedback 与 Displace TOP 进行一种反馈循环，形成烟雾效果，注意设置各个元件（图5-14）。

174. 在 render1 TOP 之后新建 blur1 TOP>comp1 TOP，在空白处新建 ramp1 TOP,comp1 TOP，并将 blur1 和 ramp1 接入 comp1。

175. 在 comp1 TOP 后面添加 Feedback TOP，在空白处新建 noise1 TOP，displace1TOP，将 noise1 TOP 接入 displace1 TOP的下输入接口,feedback1 接入 displace1的上输入口。

176. 在 displace1 TOP 后新建 over1 TOP，将其连入到 over1 的下输入口，将 comp1TOP 接入 Over1 的上输入口。

177. 再将 over1 TOP 拖动给feedback1 TOP 形成一个完整的反馈结构（或者将feedback1 的 Target TOP 选为 over1 ）。

![images/dadb60fcb69d55bc594b8a624a50d63a1ac7849e1e465d0b7eb3f55edebc0e59.jpg](https://i.imgur.com/QvJ2FmW.jpeg)
图5-14反馈效果的完整设定

blur1TOP: 让球体变模糊，为接下来的烟雾效果做准备（图5-15）。

![images/efc2803080e1326b9f52372b7b9bb7d18995b7d06633079c7aaf32d68e609730.jpg](https://i.imgur.com/fjqcIQF.jpeg)
图5-15模糊元件的参数设置

- Pre-shrink（预收缩）: 数值调整为 5。

- Filter size（滤波器尺寸）: 数值调整为 25。

BlurTOP在此次案例中对最终的效果改变很大，可以尝试调整参数实现不同的效果。

ramp1TOP: 配置一组喜欢的颜色，并让其运动起来（图5-16）。

![images/0971a8e6e78ae0ae0c3f9d2ac0d0e0592d3739803422bb623ac940e15ac3c0e9.jpg](https://i.imgur.com/cQmt85g.jpeg)
图5-16渐变色的动态设置

- 配色效果如图5-16，选择几个颜色做渐变。

调整Phase（相位）: 输入代码absTime.seconds $^{\star}0.3$ （后面参数的大小用来改变颜色变化的快慢）。

分辨率调整为 $1280\times720$ 。

comp1TOP: 无需调整（把两个元件组合起来）。
feedback1TOP: 无需调整（feedback1的TargetTOP选为over1形成反馈效果）。
noise1TOP: 对数据进行调整，获得一定的模糊效果（图5-17）。

![images/b64ead7a6c83fb0f5bc0a50c32bb6e3bffc0e0cec83a8fab93f00810e6cec291.jpg](https://i.imgur.com/3L8YPcz.jpeg)
图5-17噪波元件参数的设置

Harmonics（谐波）: 数值调整为4（波动大小）。

- Amplitude（波幅）: 数值调整为0.1（运动幅度大小）。

Monochrome（单色）: 关闭（显示彩色）。

- Translate（位置）: tz 轴输入 absTime.seconds $^{\star}0.1$ （沿着z轴运动）。

- Resolution（分辨率）: $1280\times720$

NoiseTOP此次案例中对最终效果影响很大，可以尝试调整参数实现不同的效果。

displace1TOP: 注意置换的基本原理是用下面的颜色数据替换上面的颜色（图5-18）。

![images/862746dcbeace97d6a673c5e7573e6a26286b94f8f9920fe9d1bfe9147e2379c.jpg](https://i.imgur.com/ic58OMs.jpeg)
图5-18置换参数设置

DisplaceWeight（置换重量）: 数值均调整为0.007（可自行调整观察效果）。Displace TOP 在此案例中对最终的效果改变很大，可以尝试调整参数实现不同的效果。

●over1TOP: 将displace1TOP与comp1TOP 连接进over1TOP（两者叠加），注意上下输入端的顺序（叠加效果受到顺序的影响，类似Photoshop 中的图层关系）。（5）后期效果处理在over1TOP后面继续添加 level1TOP>transform2 TOP>null3TOP（根据自己所需效果任意调整），如图5-19。

![images/f60792bb58a05af305183b16eebc2d4accab0015e9e08deddf30881bed00b39b.jpg](https://i.imgur.com/jSBnwIl.jpeg)
图5-19后期处理

level1TOP: 调整亮度（图5-20）。

![images/edd6223af443915f2f6a7becf34af03b9ddb46ea1f43ffcd1578d73297d1c280.jpg](https://i.imgur.com/74JbqEh.jpeg)
图5-20色阶元件的调整

Brightness（亮度）: 参数调整为1.2。

transform2 TOP: 给画面添加白色背景，参数如图5-21。

![images/542aa9a7b942bf8b671a6f39189c3f3147551b5b18fd224508ac1fbb8e645d22.jpg](https://i.imgur.com/XTUNNuT.jpeg)
图5-21背景色调整

- Background Color（背景颜色）: 四个参数分别代表了RGBA，当数值均为1时呈现白色背景。

- Comp Over Background Color（ 背景颜色的合成）: 开启On。

一般给对象添加背景色均用TransformTOP元件。

添加—个 null TOP。

最终效果呈现如图5-22所示。

![images/23e2f5e9c1c13d3147641582ee48ee59a017796187312a2f3a0688814116bf90.jpg](https://i.imgur.com/JSqRReJ.jpeg)
图5-22最终效果呈现

## 5.3 手势交互之“淘气的粽子”（案例5-2）

### 5.3.1 概念创意与学习重点

（1）概念创意”在中国传统节日端午节期间，人们会探讨粽子的吃法和相关文化。为了增加节日期间公众与粽子之间的互动话题，设计师决定将粽子进行拟人化处理，创造一个趣味十足的交互装置。粽子会随声音的变化产生形态上的变化，参观者也可以通过手势的运动实现人与粽子的趣味互动，人与粽子仿佛在玩捉迷藏的游戏。

（2）学习重点

掌握模型导入的方法。
Leapmotion 的数据引l入与处理。
两组画面的组合方法。

### 5.3.2 设计过程详解

本案例先从粽子的模型导入入手，通过一些简单的调整让其旋转并发生形变。接着制作文字环绕的效果，然后将Leapmotion 引l入并处理成我们需要的数据。引l入音频，通过处理将其赋给粽子模型形成音画互动。最后对模型进行渲染，强化效果。

设计整体主要分为以下几个部分，逻辑框架见图5-23。

![images/e2b169c3e89646e260a5ec85cb55884f039a47f83ff250bbf47d47060a8c286c.jpg](https://i.imgur.com/tDeHsxL.jpeg)
图5-23逻辑框架

#### 5.3.2.1 硬件准备

Leapmotion 传感器是一种能够精确追踪手部运动的控制器，可以与Windows 和 MacOS $\bigtimes$ 等操作系统兼容，并且支持多种编程语言和开发工具，它可以将手势识别和控制功能带入虚拟空间中。使用Leapmotion 传感器可以实现用手势自然直观地控制游戏、应用程序和其他软件。该传感器使用红外摄像头和红外线LED 捕捉手部动作，将其转换为计算机可以理解的数据指令集，用来做交互艺术方面的二次开发（图5-24）。

![images/ed98b1d8bd7d395a75583064f320e04cb242d8c6692723b853dc660fe7fa1d2f.jpg](https://i.imgur.com/P11geHF.jpeg)
图5-24Leapmotion产品

#### 5.3.2.2 粽子模型的导入

基础准备: 首先在 3D 软件（如 SU，3Dmax，C4D 等）中制作粽子模型，存成obj格式（还支持fbx等）。

目的: 导入粽子模型并进行处理后打包成base1COMP和base2COMP。

创建和调整模型，主要元件集如下: 空白处新建一个filein1SOP，后面右击继续添加transform1 SOP>transform2 SOP>noise1 SOP>null1 SOP>out1 SOP ( 图5-25）。

![images/59f3fd91ca27283f6f3491055874c35aad0cedf19dd9b10be87c40f5a3832b43.jpg](https://i.imgur.com/hYK8jXp.jpeg)
图5-25模型文件的导入过程

filein1 SOP: 导入模型（图5-26）。

![images/af02b509aba46b9f0a99320cce08c128c0ee1aca912d50ea671bb8793838123a.jpg](https://i.imgur.com/EiP9p17.jpeg)
图5-26模型导入与设置

- 把文件直接拖入得到以3D文件命名的SOP元件。或点击 GeometryFile（几何文件）中的“+”选择模型。

Flip PrimitiveFaces（翻转原面）: 一般默认关闭。

Compute Normals if None Exist ( 如果不存在法线则重新计算法线）: 一般默认打开。

Refresh（刷新）: 如果更换模型，点击Pulse即可。

obj格式的模型导入Touchdesigner后会变成白模，如想导入带有材质贴图的模型，可选择fbx格式或通过SubstanceTOP进行材质贴图。

transfom1 SOP: 让粽子模型的位置放到 Touchdesigner 的坐标原点，Touchdesigner的坐标与3D建模软件的坐标一致，建模时最好将模型中心置于坐标原点。配套文件中的模型没有将其置于原点，可做如下调整（图5-27、图5-28）。

![images/c7eef2923958a0b009f046c292212bb4dde7ff4a05cb3e4dacea6bc4006cd2db.jpg](https://i.imgur.com/6YFw84e.jpeg)
图5-27模型的位移设置

![images/fbd9fbb291bac708d21f0691c4055e6e7c442e3dbdb1db6692706a0428ad0e0b.jpg](https://i.imgur.com/PhWgUeb.jpeg)
图5-28调整模型的位置

调整对象的位置: 

肉眼观察法，在transform1视窗中点击‘+”号进入，调整translate 中 tx，ty，tz的数值让模型回归原点，不同的模型参数不同，此处只作参考，具体以观察结果为准（这种适合对象在建模阶段没有在世界坐标原点上的情况）。

参数归0法，通过transform1中的Post 标签页，将 Post Translate $\bigtimes$ ，Y，Z都改为 Origin（原始点），这样模型也会自动回到原点（只适合在3D建模软件中已经放置到世界坐标原点的对象）。

有些模型因为其Pivot（中心点）不在模型正中心，利用第二种方法无法正确移到真正的中心点位置，因此在建模时最好保证模型的Pivot（中心点）在模型的正中心位置。

transform2SOP: 让模型进行匀速旋转。

![images/3174dde3eab196d1eb333705fe4ba4660bf336a81cc17df30b5dba3014c6d484.jpg](https://i.imgur.com/g9i25pL.jpeg)
图5-29设定模型的动态

在rx，ry，rz方向上引用代码，如图5-29。

- Translate（位置）: ty 轴为 16（上移模型）。
- 分别在 transform2 的 Rotate 参数中,将 $r\times$ ,ry,rz输入代码 absTime.frame(图5-29）。

在Touchdesigner 中有两个用于物体位移、旋转与缩放的常用代码，分别是 absTime.seconds 和absTime.frame，其本质就是为对象提供一个不断匀速变化的数值变量。

一般情况 absTime.seconds 多数用于位移与形变，absTime.frame 多数用于旋转（如果要改变速度可以直接在后面加入运算，如 absTime.frame $^{\star}0.5$ 降低一半，absTime.frame $^{\star}5$ 提高至5 倍）。

absTime.seconds 指工程文件从打开到现在经过的绝对时间，不受文件暂停的影响（以秒为单位逐渐累加）。

absTime.frame 指工程文件从打开到现在经过的绝对帧数，不受文件暂停的影响（以帧数为单位逐渐累加）。

- noise1 SOP: 目的让粽子产生随机的形状变化（最后用背景音乐的数据来影响形状变化），参数见图5-30。

nullSOP（null相当于前一个元件的替身，一般在完成后添加便于后续调整）。

![images/1af20c38c384e7dc8780c23e3f8614448e8f04cfe3d0766cad6e6deebdfca515.jpg](https://i.imgur.com/JAB46GM.jpeg)
图5-30模型的噪波设置

- Exponent（高低峰值的平滑度）: 设为1.82（数值越大形变越强）。

- Amplitube（倍增强度）: 目前无需调整（此处数据来自背景音乐）。

out SOP 元件（用于图形的输出）。

- 选中所有元件，在空白处右击 Collapse Selected 将这些元件打包成 Base1（Base作为COMP元件相当于把所有元件打包，便于简化管理）。

复制base1得到base2（旋转粽子），进入base2，删除其中的noise1，base2中的内容即为旋转粽子（退出base2）。

#### 5.3.2.3 粽子模型渲染

将 base1与base2 中不同状态的粽子用Geometry COMP 渲染出来。

在 base1 与 base2 之后新建 switch1 SOP>ge01 COMP>cam1 COMP>light1 COMP>pbr1 MAT>render1 TOP>null1 TOP （图5-31）。

![images/f76b6deef02ed9d3ec76b6c5af2a768b3771d56ea3177ae938f6e8971542c6c2.jpg](https://i.imgur.com/l104mr0.jpeg)
图 5-31渲染组合元件5 件套

switch1SOP: 将base1与base2连接上去，用于bas1和bas2之间切换，具体操作如图5-32。

![images/e415a09cd02a042f2a0b53b40843f162c3f0d04b7004fdb12f8000c6c8fd7710.jpg](https://i.imgur.com/Dg2lnYx.jpeg)
图5-32开关切换的设置

SelectInput（输入端选择）: 目前无需操作（此处受Leapmotion数据影响）。

SwitchSOP的用法十分简单，根据输入端的先后决定对应的数字。需要注意的是第一个输入端口对应的数字是0而不是1。

**geo1COMP** : 作为盛放渲染对象的容器（图5-3- ）。

![images/aef83c815f791d4cf58a3a455b2141ee27805f33c6f4fd8fce10c0abd35e3d06.jpg](https://i.imgur.com/U3IzXzJ.jpeg)
图5-3- Geometry元件的设置

- Translate（位置）: 此处不做调整（具体数值来自 Leapmotion）。

Uniform Scale（整体缩放）: 此处不做调整（具体数值来自Leapmotion）。

- Material（材质）: 将 pbr1MAT拖动到此处。

pbr1 MAT: 调整对象增材质效果（图5-34）。

![images/010558ffd65cdf721040084f248644ec03f7aab0dae81a953bc7d295ce573013.jpg](https://i.imgur.com/ZTHOoAu.jpeg)
图5-34PBR材质的设置

- Base color（基础色）: 按照自己所需调整。

Metallic（金属）: 调整为0.268。

Roughness（粗糙度）: 调整为 0.095（数值越低粗糙度越低，金属感越强）。

- Emit（自发光）: 依据自己所需调整。

cam1COMP: 调整相机位置进行构图（图5-35），具体数值根据观察确定。

![images/fac8ac277442bc7ec6355e3adc0a5f28f1a629541c856d93ae15b5ee13c69698.jpg](https://i.imgur.com/7qfgazr.jpeg)
图5-35相机元件的位置设置

Translate（位置）: z数值调整为 120。

- Rotate（旋转）: $r\times$ 数值调整为-1.6,ry 数值调整为 0.6。具体观察 Render 窗口的效果调整。

light1COMP: 照亮粽子模型，调整灯具位置（图5-36）。

![images/ddd1b07a518af5b864f291cf0426b1c920c0b826151eff2e73029323c918a07a.jpg](https://i.imgur.com/GPpt8DS.jpeg)
图5-36灯光的位置设置

Translate（位置）: ty 数值调整为 62。

Rotate（旋转）: $r x$ 数值调整为-90。

具体观察 Render 窗口的效果调整。

render1TOP: 渲染输出，具体参数调整见图5-37。

![images/59a28b31e3e6509f2eefaff111ae2753d2209d3a2a1509ffc097b9ff1aff3bb2.jpg](https://i.imgur.com/M6Th8ce.jpeg)
图 5-37渲染输出设置

- Geometry（物体）: 输入geo1（或将geo1拖进来，正常自己默认）。

Resolution（分辨率）: 调整为1280 $\times$ 720。

- null1 SOP 进行备份。

#### 5.3.2.4 环绕文字制作

空白处新建一个 tube1 SOP，在它之后添加 transform1 SOP>null2 SOP>geo2COMP。另在空白 处新建 text1 TOP，在它 之后继续添加 phong2 MAT>>render 2TOP>null TOP (图 5-38）。

![images/43e39a306f1a332e94d17e3e23d215c5aeacf3d158f96df13f1138c9cec1a978.jpg](https://i.imgur.com/A6I9T4t.jpeg)
图5-38环绕文字制作

tube1SOP: 增加一个tube1元件（管状物），见图5-39。

![images/02c2419bc08fbc8cba47129ac9f2b0e82a23f407f52bd01c09a0aa8fece401b1.jpg](https://i.imgur.com/ZjU0kZ5.jpeg)
图5-39Tube物体的设置

- Radius（半径）: 数值修改为0.5（两个值分别上下两个圆的半径）。

Height（高度）: 数值修改为0.16。

Columns（列数）: 数值修改为 20。

transform1SOP: 调整Tube的位置和大小（图5-40）。

Translate（位置）: ty数值修改为 19。

![images/01a44dcf327eaa035051b851793c9c6e4bc66cf0059150823b637cc71f3e622c.jpg](https://i.imgur.com/PYK0g1a.jpeg)
图5-40tube的位置和动态设置

Rotate（旋转）: $\propto$ 数值修改为30，ry标签页输入代码 absTime.frame\*-1或-absTime.frame（让其动起来）。

- Uniform Scale（整体缩放）: 数值修改为 50。

geo2COMP: 用于盛放TubeSOP具体参数（图5-41）。

![images/518e8edd59e18703af9373bc4bf7ca1dfb2f76f451e391964495e59cd052b788.jpg](https://i.imgur.com/GU5id3e.jpeg)
图5-41Geo2的设置

- Translate（位置）: 目前无需调整（后续均来自 Leapmotion）。

Uniform Scale（整体缩放）: 目前无需调整（后续均来自Leapmotion）。

Material（材质）: 目前无需调整（后续来自文字的贴图）。

text1TOP: 输入所需文字并调整文字颜色、字体、大小等作为贴图（图5-42）。

![images/556ca1ec0c5999c74541c959aac5562730266ffb02e10acbbc4cac70b8e590a5.jpg](https://i.imgur.com/EGp78pE.jpeg)
图5-42文字特性的设置

- Text（文本）: 输入DRAGON BOATFESTIVAL ANKANG。

Font size $\bigtimes$ （字体尺寸）: 将单位修改为 Px，数值改为 72。

- Font color（字体颜色）: RGB 分别为0.92、0.25、1。

- Resolution（分辨率）: 调整为 $1280\times65$ （字体的清晰度）。Text TOP 是 Touchdesigner 里的平面文本元件，多用于做动态海报、音乐字幕和小游戏文本,TextTOP中可以选择字体样式、描边、大小、位置、对齐方式等。

phong2 MAT: 为材质增加材质贴图，具体调整见图5-43。

![images/84db394520c8e0ac04811278316dc80116696c4d9c5cd9722a840b7fb0f2ad2b.jpg](https://i.imgur.com/aO6p55a.jpeg)
图5-43材质设置

方法: 将上面的文字元件拖放到 phong2 内做材质贴图，选第1个贴图方式 Parm: Color Map（颜色贴图）。

- 为 geo2 赋材质。

方法1: phong2 拖动到 ge01 内，选择 Parm:Material（图5-44）。

方法 2: 将 phong2 拖动到 ge02 的 Render 中（图5-45）。

![images/66426cb936d1280e6ccc73fc6ff3fe86f91aed862f3a8e83377deaad9f25269d.jpg](https://i.imgur.com/a3Z0iE3.jpeg)
图5-44赋材质的方法1
图5-45赋材质的方法2

render2 TOP: Render TOP 参数（图5-46）。

![images/0513135b3b621ab82dcd8137fd2c162e2fe7caede7716ce937ac0e68f4b28275.jpg](https://i.imgur.com/4Ss9QpH.jpeg)
图5-46渲染输出设置

- Geometry（物体）: 输入geo2（或将geo2拖进来）。

Resolution（分辨率）: 调整为1280 $\times$ 720。

#### 5.3.2.5 音效处理

采集音频中所需的特定数据，为交互做数据准备。

空白处新建 audiofilein1 CHOP，在它之后添加 select1 CHOP>audiofilter1 CHOP>math1 CHOP>analyze1 CHOP>null3 CHOP。在 audiofilein1 CHOP 后用鼠标中键添加audiodevout1 CHOP 用于播放声音（图5-47）。

![images/0ce0116d0f08ce195257dc8261ba683dc185a149c24b7346297629469451d2dd.jpg](https://i.imgur.com/YN2x6dP.jpeg)
图5-47音频梳理元件组合

audiofilein1CHOP: 导入mp3格式的音频文件（图5-48）。

![images/f476400f20ece7567f9fab52333150ed193c1445ed8fa3be7880978441aa9385.jpg](https://i.imgur.com/RaIVnMU.jpeg)
图5-48声音的导入

File（文件）: 点击“+”号导入一段音频（详见本书配套文件）。

select1: 选择所需要的声音通道（图5-49）。

![images/cbed95d29d5b3435f5c19a78d5ec652f8a91ed9e01ff18d9a58ac3ed1c1ca297.jpg](https://i.imgur.com/CdngayQ.jpeg)
图5-49选择声道

Channel names（通道名称）: 选择chan1。

audiofilter1: 选取音频的高音部分（图5-50）。

![images/f646cfa1eeba492a3d8f746a992a8b89517b7f83526cc48079d616aff20430b1.jpg](https://i.imgur.com/rYnZxG5.jpeg)
图5-50选取高频数据

Filter（滤波器）: 选择High PasS。

math1: 重新定义音频数据的范围（图5-51）。

![images/c270ed7687196363c79e874132c3e6ece41d4e4683894083ed44680811491970.jpg](https://i.imgur.com/OyAXXOW.jpeg)
图5-51重新定义音频范围

- From range（范围）: 输入0与0.4。$\textcircled{\scriptsize{\ge}}$ To Range（范围）: 输入0与20。
- From range 的 0～.0.4 代表音频的最小值到最大值。
- To range 的 O～ 20 代表新生成的音频数据（也就是为了给 base1 中 noise1 提供所需数据的最大与最小值。）

analyze1: 分析音频通道，使之变成可直接引l用的数据（图5-52）。

![images/3c70f32bd731e6454be7c7b8d8871853cdd9820dabeb9de83ab45ec2407ea910.jpg](https://i.imgur.com/tR5rGSN.jpeg)
图5-52音频分析设置

Function（功能）: 选择Maximum，提取音频中的最大值。

#### 5.3.2.6 Leapmotion的引l入与处理

此部分主要是将来自Leapmotion 传感器的数据处理成所需的数据（图5-53）。

在空白处新建leapmotion1 CHOP，在后面继续添加 select2 CHOP>分别添加 se-lect3、4、5 CHOP>并在其后面分别添加 math2、3、4 CHOP>继续在各自后面分别添加null4、5、6 CHOP，在 leapmotion1 CHOP 后中键添加 select6 CHOP。

![images/12b43e4c3c1ed25e95176d59485a0bb3680b96d6414019e501203a9d0d026c27.jpg](https://i.imgur.com/USoObtj.jpeg)
图5-53Leapmotion的引l入与数据处理

leapmotion1 CHOP: 用于引l入 Leapmotion 传感器的数据（连接好设备后即可以

获取数据，不做调整）。

select2 CHOP: 选出手掌数据（图5-54）。

![images/60a2987d9abe737618ca925501627ffabb0f2a8e5a914088aca5e49728f7d1a4.jpg](https://i.imgur.com/X5SlSlE.jpeg)
图5-54 选择手掌数据

Channel names（通道名称）: 输入\*palm\*。

select3、4、5CHOP: 用这几个元件分别选出手掌的tx，ty，tz轴的数据（图5-55）。

![images/380355987ce74d45abe58dd667ad4365dc86e99e8638da1defc2e797949b26ce.jpg](https://i.imgur.com/LqGkljf.jpeg)
图5-55选择控制轴

Channel names（通道名称）: 分别输入hand0/palm: tx; hand0/palm: ty; hand0/palm: tz。

参数含义: 第一个手的／手掌数据: 三个方向上的坐标。

math2、3、4CHOP，将这三个元件获取的数据重新映射出新想要的数据范围（图5-56\~图5-58）。

如图5-56所示，From Range（范围）: 输入-200与 200;ToRange（范围）: 输入-20与 20。参数含义: 将 select3 提取的tx（代表水平方向）值映射成新的范围， $-200{\sim}200$ 代表Leapmotion获取到实际空间中×轴的位置； $-20{\sim}20$ 代表屏幕中粽子在×轴上的移动所需要的范围。

![images/62c979081a14dbbc6fafb224861ead144e1e9cca2276d4d5aaaf5838e0879adc.jpg](https://i.imgur.com/JUg03iN.jpeg)
图5-56 $\pmb{x}$ 轴数据重新映射

如图5-57所示，From Range（范围）: 输入60与450；ToRange（范围）: 输入-44与 4。参数含义: 将 select4 提取的ty（代表垂直方向）值映射成新的范围， $60{\sim}450$ 代表Leapmotion获取到的y轴的实际空间位置； $-44\mathrm{{\sim}}4$ 代表屏幕中粽子在y轴上的移动范围。

![images/cdb605b153e093f6b65cd7406802da12b6a26e4dcc9a2ea901e57f08dfcc8c33.jpg](https://i.imgur.com/E4qMNKC.jpeg)
图5-57y轴数据重新映射

如图5-58 所示，From Range（范围）: 输入-180与180；To Range（范围）: 输入0.5与1.5。参数含义: 将 select5 提取的tz（代表纵深方向）值映射成新的范围，-180\~180代表Leapmotion获取到z轴的实际空间位置; $0.5{\sim}1.5$ 代表屏幕中粽子在z轴上的移动范围。

![images/762383bdde349320c8e729560b030eb9bfdb71e1d7d621bb5676556a74e266e3.jpg](https://i.imgur.com/w6QjVkG.jpeg)
图5-58z轴数据重新映射

Math CHOP 中的 Range 标签页是 Touchdesigner 中最常用的范围映射功能。在确定From Range 和To Range 的范围时一定要清楚具体需要什么样的数据内容，用在哪里，执行什么效果。例如在这一案例中，需要将Leapmition 手掌数据的 t女，ty，tz分别映射到粽子和环绕文字的女，ty，忆上。在确定数据之前可以通过观察数据的变化确定所需数据的最大值及最小值，在本案例中需要移动手掌观察元件数据的变化情况，再用鼠标滚轮拖动粽子和环绕文字对应的坐标数据。确定了这两者的关系,就可以确定From Range和To Range 对应的数据了。

select6CHOP: 用于提取手被检测到时的数据（图5-59）。

![images/902bdbd8e9f81815fddca54b2006d4e0b952aaa5152a8469350179ecac46aa3a.jpg](https://i.imgur.com/xO0MKNA.jpeg)
图5-59选择数据

Channel names（通道名称）: 输入。
handO: tracking 表示第一只手被检测到的状态。
hand1: tracking 表示第二只手被检测到的状态。

#### 5.3.2.7 交互设置

Noise: 数据引l用，处理数据与对象的引l用关系（图5-60）。

![images/565e2c09a2f50c7c7217dedfd4430000b4a6394749fa93ca93890fbee0faa80d.jpg](https://i.imgur.com/umj1up2.jpeg)
图5-60Noise 数据的引|用

目的: 让音频的高音影响粽子的形变强度，形成音画互动。

方法: 双击 base1进入，找到 noise1，将处理好的音频数据 null3 赋给 Amplitude（ 通过拖拽实现引用）。

![images/dcc078bd71338c1b9f0344394fa579b550935b4cc3f56456d94f0bad14eb728b.jpg](https://i.imgur.com/wSEcx1D.jpeg)
图5-61Switch元件的设置

目的: 当手不被检测时播放base1的画面，被检测时播放base2的画面。

方法: 拖拽引用，选择 select6（来自Leapmotion 的数据），将数据赋给 switch1 的Select Input。

**geo1: 数据引l用（图5-62）**。

![images/6fd6109ffdd44032e4d4e2e735f80a2e08b4fdff84954f76671ab5e8d92316a6.jpg](https://i.imgur.com/OvcDnYd.jpeg)
图5-62geo1手掌的数据引l用

目的: 让手掌的位置影响 geo1 中的粽子。让Leapmotion 中手掌的×，y，z 轴影响 geo1 中粽子的×；y，Z 轴。

方法: 点击 geo1，将处理好的手掌数据“来自 math2、3、4 之后的 null"”赋给 translate 的tx, ty, tz。

**ge01: 数据引l用（图5-63）**。

![images/e23f536d4718a1dbc1a2cce2c258c7c17e804f3c17e7b3d0dfe1cf69bc86020f.jpg](https://i.imgur.com/LRy72s4.jpeg)
图5-63手掌的z轴数据引l用

目的: 让手掌前后移动时粽子跟随手掌放大缩小，即让 Leapmotion 中手掌的 tz 轴影响粽子的整体缩放。

方法:将 null6 CHOP（数据来自 Leapmo-tion ）赋给 geo1 的 uniform scale。

geo1: 数据引l用（图5-64）。

![images/83617543637056140c66d45cf75f0934aa0419667381d0e42b7b4ac9b595706b.jpg](https://i.imgur.com/BgcNMk7.jpeg)
图5-64手掌数据的引引用

目的: 让手掌的z轴影响环绕文字的整体缩放，让Leapmotion 中手掌的×，y轴影响 geo2中环绕文字的×，y轴，实现粽子和环绕文字两者的同步运动。

**方法** :

- 将 null4 CHOP（来自 Leapmotion）赋给 geo2 的tx轴。

将 null5 CHOP（来自 Leapmotion ）赋给 geo2 的 ty 轴。$⑤$ 将 null6 CHOP（来自 Leapmotion）赋给 geo2 的 Uniform Scale 。

### 5.3.3 后期效果

给一个后期效果的参考，分为两个部分（图5-65）。读者可以根据自己的需求去做更多的变化。

feedback环路创建发光。

增加星空背景。

![images/8479802efe9cac1efedd79a5ca2ee2864ffa247e8967579c3a915f52f5345790.jpg](https://i.imgur.com/OPW8kl7.jpeg)
图5-65后期效果处理

（1）创建发光效果nul1TOP（最后一个完成的元件）之后添加feedback1TOP>blur1 TOP>level1 TOP>comp1 TOP，将 nul1 TOP 与 comp1 TOP 连接起来并将cOmp1 TOP拖给feedback1TOP形成环路（图5-66）。

![images/2f07a507550bd4f113c5eb6a099c35d70f6d23cbfc1a47f609a98f485bd735c4.jpg](https://i.imgur.com/npWm34A.jpeg)
图5-66反馈效果结构

![images/9decd0d1ed22b98610bffc481e1392b3ca9712678ff5dd4515332dc180d686ab.jpg](https://i.imgur.com/sfWiVEY.jpeg)
图5-67Feedback的目标设置

blur1TOP: 让物体产生模糊的效果（图5-68）。

![images/1544e738805b10db98f82d22ac3307a8fcd4038e47529f681c5d93dc4cf7dae7.jpg](https://i.imgur.com/klGMIcT.jpeg)
图5-68blur元件的模糊设置

Pre-Shrink（预收缩）: 数值调整为7。3Filter Size（滤波器尺寸）: 数值调整为15。

level1TOP: 改变透明度形成的拖尾效果（图5-69）。

![images/fa358d4f5423259469917e4da478aa11d4120706eea18ae065a639b711a9cde7.jpg](https://i.imgur.com/bsBn9aF.jpeg)
图5-69透明度设置

- 修改Post标签页的 Opacity参数Opacity（透明度）: 数值调整为0.779。

Operation（操作）: 选择Add 方式。

![images/41f94176375262e3e61e1fdb4471b7901d049adf263e8f0beecbbb295a75c703.jpg](https://i.imgur.com/wTkMdCe.jpeg)
图5-70组合方式设置（叠加模式）

在 comp1 TOP后面添加null7 TOP（名字）。
comp2TOP: 新增comp2，将粽子与环绕文字相结合（图5-71）。

![images/b319124c70941d37cb331ed9d9920d889c9a3611a5364b80ce83d67ebeba6996.jpg](https://i.imgur.com/HfCbHCZ.jpeg)
图5-71元件的组合应用

comp2选择重叠方式Operation（操作）:选择Add方式。

（2）添加星空背景 空白处新建 noise1 TOP，继续添加 function1 TOP>null9 TOP（图5-72）。

![images/0c8acc1a177e6e61b9133da1abdb6474802aee041d7b3969c17c3c62992e4144.jpg](https://i.imgur.com/j1qlJHL.jpeg)
图5-72 星空背景元件组合

noise1TOP（噪波）: 星空背景的基础，参数见图5-73。

![images/d344a1849c0b14abbb2c53b8843da89b654d2ef528be457819b9ae5484236512.jpg](https://i.imgur.com/kqrAHku.jpeg)
图5-73噪波的状态设置

- Period（周期）: 数值调整为0。3Exponent（高低峰值的平滑度）: 调整
为 2.4。3Translate（位置）: tx，ty，tz 轴全部
输入 absTime.seconds 。3Resolution（分辨率）: 1280 $\times$ 720。

function1TOP: 创建黑色星空（图5-74）。

![images/db513f5f2cfb02c3af3a36b07b3726b2aa35b3695f5f2ac8b0998f283e78fc9d.jpg](https://i.imgur.com/LsEuV4Z.jpeg)
图5-74function元件设置

FunctionRGBA（函数RGBA）: 选择pow $(\times)$ Input1^Exponent。此选择表示次方运算，Exponent为指数，这里计算了input1的10次方。

Exponent value（指数值）: 数值调整为 10。

Over1TOP: 创建oVer1TOP，组合“星空背景”和“粽子”（图5-75）。

![images/be46edd99758c0827807f26a990b17e9a4f28d0b40bfd972243bdecb4959a98a.jpg](https://i.imgur.com/lVtpYTk.jpeg)
图5-75元件叠加方式

- 参数无需调整。

注意上下端点，将input1 置于input2之上。

（3）最终效果·第一种情形，没有人参与，受声音的影响，粽子会即随着音乐的变化产生形变和尖刺效果；第二种情形，当有人进入时，“粽子”会跟随手的移动而发生位置、远近与大小的变化，与人产生互动（图5-76）。

![images/25ea88bc038d9fd5742c8ad35774bf4c9fb2c10af2d604952f9a7aaa6ca5313a.jpg](https://i.imgur.com/fBm0KqT.jpeg)

图5-76最终效果

## 5.4 体感交互之"畅想雨季"
（案例5-3）

### 5.4.1 概念创意与学习重点

（1）概念创意想象一下站在雨中嬉戏的样子，雨水不断从身上流下，用力挥动双臂，雨水会被抖落到空中。本创意借助声音与抽象雨滴的投影画面，创造出一个独特而又令人陶醉的雨季场景。参与者在空间中行走，儿时雨中玩要的记忆被唤起，好像在雨中自由舞动，尽情释放压力。

（2）学习重点 掌握Kinect 的用法与综合调试；掌握粒子系统的应用。

### 5.4.2 Kinect 传感器

Kinect是一种体感传感器技术，最初由微软公司于 2010 年推出，用于Xbox 360 游戏机。后来它的应用领域扩展到了其他平台和行业。Kinect的核心功能是捕捉人体的运动和姿势,从而实现无需手柄或其他设备的自然交互。每台 PC 至多只能连接一台Kinect一代或二代产品，最新第三代产品是 Azure Kinect（图5-77 右）。它是一款用于 Azure 云计算平台的深度感应相机，这款设备主要面向开发者和企业客户，用于开发各种深度感应的应用，可以实现多台同时接入到Touchdesigner 中，以便能够实现更多人的交互（图5-77）。（注: 在 Mac下无法使用 Kinect TOP 和 Kinect CHOP 节点。)

![images/5e0576df278edac6fc292ba3c7fff6904a796f867f0959ae138a15214b6d28b3.jpg](https://i.imgur.com/d56BZO4.jpeg)
图5-77 Kinect 产品

（1）技术原理，Kinect主要由三个部分组成: 彩色摄像头、红外深度传感器和多路麦克风阵列。彩色摄像头用于捕捉视频图像；红外深度传感器计算物体与传感器的距离；多路麦克风阵列用于捕捉声音，实现语音识别。

（2）功能特点

- 骨骼追踪: 可以识别并追踪用户的关键骨骼节点，如头部、手腕、肘部、膝盖等。

- 手势识别: 能够识别特定的手势，如挥手、捏取等，用于实现基本的交互操作。

-  面部识别: 可以识别用户的面部特征，如眼睛、鼻子、嘴巴等，用于表情追踪和身份识别。

- 语音识别: 可以实现语音识别，支持多种语言。

（3）应用领域

- 医疗康复: 利用Kinect捕捉病人的运动数据，为康复治疗提供定量分析和个性化训练方案。

- 教育: 结合虚拟现实技术，利用Kinect实现沉浸式教学体验。

- 艺术表演: 通过捕捉舞者或演员的动作，将其转化为视觉特效或音乐表演。

- 机器人控制: 利用Kinect获取环境信息，实现机器人的自主导航和避障功能。

- 安防监控: 利用Kinect的人体识别和追踪功能，实现智能监控系统。

（4）软件安装 下载适合版本的安装软件SDK（设备版本分为V1和V2），安装完成后有三个应用（图5-78）。

![images/174730c1ce43b846048d00e255e9b36e9ca62ccce1c0f708f42383f2df0f07ca.jpg](https://i.imgur.com/poIk9F5.jpeg)
图5-78下载网址和应用

（5）工具索引丨SDK Browser v2.0 是所有工具程序的索引l（图5-79）。其中KinectConfigurationVerifier是设备配置状态的验证程序，如有异常会出现叹号，打开可以看到具体问题（图5-80）。

![images/5b47fd4b02f5fa67eb8cd3da7b392c834ef558e711fbece613edac294e0b5c53.jpg](https://i.imgur.com/YhzhyOd.jpeg)
图5-79工具索引
图5-80异常状态显示

注意: Kinectv2.O最好接在USB3.0上的高速USB 接口，保证供电量，否则会出现间歇性、有规律地断开自动连接现象。

（6）设备连接测试 图5-81是KinectStudio2.0的连接调试界面，在里面可以看到监视的各项设置。

![images/c02fd2b46eab58507b39aad312fda68be75d795bf9a7fefe8f8a5b2e5ee4e04c.jpg](https://i.imgur.com/V7htAHK.jpeg)
图5-81Kinect连接测试

先执行左上角的建立连接按钮并进行监视器设置。

注意:

设置前先拔下设备，设置好后再插入设备。一定要等监视器内容显示后再继续其他参数的设置，顺序不能颠倒，否则在监视窗口看不到已经连接的设备。

有时在连接设备状态下点击左上角的连接按钮会无法连接。

- 此软件也可以进行图像录制和回放，存储位置详见默认目录（可更改）。

完成以上测试连接后就可以将 Kinect 接入到Touchdesigner 里面，通过 Top 或Chop元件获取数据。

另外还有VisualGestureBuilder-Previes主要用来配合制作手势动作识别，即定义手势为某种操作命令。

### 5.4.3 设计过程详解

本案例的设计逻辑是先使用ParticleSOP生成粒子做出背景中类似瀑布的效果，然后连入Kinect在粒子场景中加入人像，使粒子与人像边缘产生碰撞效果，经后期处理形成雨滴效果，再加入音频提升沉浸感。整个作品的程序设计总体分为五个模块（图5-82）。

雨幕粒子系统。
- 背景音乐处理。
- 音画互动设置。Kinect人体互动设置。渲染与后期处理。

![images/d562216f6c394bfb88908d69f8bd3f1b4a7f88797dd7ac8a8fc3a446c72866ed.jpg](https://i.imgur.com/gk0kFsy.jpeg)
图5-82程序逻辑结构图

#### 5.4.3.1 硬件准备

KinectV2可以抓取人体的图像和关节点的位置信息，用自带软件测试保证控制器能够与电脑正常连接。

#### 5.4.3.2 雨幕粒子系统

通过网格系统生成粒子系统，在空白处新建 grid1 SOP，继续添加 sort1 SOP>particle1SOP>point1 SOP>null1 SOP (图5-83）。

![images/16ff86b6d7e787fcfa26043eda2d33da2678bc02cdf1c4bc2a94170ccfc015ca.jpg](https://i.imgur.com/PusoigS.jpeg)
图5-83粒子系统的生成

grid1SOP: 建立网格作为粒子产生的基础（图5-84）。

![images/c377649675d775b8ff2f713792ca3ed37279e87dbb00269d761c8df2d5cc62e9.jpg](https://i.imgur.com/dPqNwO2.jpeg)
图5-84网格元件的设置

- Size（尺寸）: $\times$ 轴调整为 8，y 轴调整为1。Rows（行）: 调整为90。Columns（列）: 调整为 60。

注意: 网状格栅与正方形不同，网状格栅可以加入无限的网格。通过参数面板里的RoWS、Columns 调节来控制最终网格点的数量，网格点就是粒子系统形成的基础，Texture Coordinates 选择Off关闭 UV 纹理坐标。

SOrt1SOP: 用来改变粒子的运动轨迹，以改变粒子起始点的方位（图5-85）。

![images/5f64d9d5cb268b6f0350b060c640939c2def720dacb6c4b14faf79a3517e8d51.jpg](https://i.imgur.com/60IxhD2.jpeg)
图5-85粒子排列方式选择

![images/5a43962b7cfa39eb9fc74bc2fc15bc2a7295a37e2a2ab53f460bd54512e06b3b.jpg](https://i.imgur.com/VNVjYfg.jpeg)
图5-86显示设置

Point Sort(点的排列）:选择为 Random（使节点随机排列）。

- 此时上面修改后看不到Grid SOP与Sort SOP的区别，我们可以点开两个元件右下角的 +”，分别在窗口内按W或者右击选择Toggle Shaded/Mireframe，这样窗口内的内容会以线框的形式呈现。

在元件窗口内按下P，选择PointNumber就可以观察到对象上的节点序号及分布情况（图5-86）。

particle1 SOP: 粒子系统的控制面板，渲染方式为点渲染，同时修改外力、风力、湍流、拖拽、数量、粒子生命周期等参数来改变粒子形态（图5-87）。

![images/71fc18daffbd9fb1b282d451eddec849822bf6c84e871181cafbe072ad6f38a5.jpg](https://i.imgur.com/39e8Y5q.jpeg)
图5-87粒子系统设置

- ParticleType（粒子形式）: 选择Render as Point Sprites 。
- TimeInc（时钟频率）: 数值修改为0.17（控制粒子快慢）。
- External Force（外力）: 数值修改为0.2、-1.5、0。
- Wind（风力）: 数值目前无需调整（最终数据来自处理好的音频文件）。
- Turbulence(湍流): bx ，bz修改为0.8。
- Drag（拉力）: 数据修改为4。
- Birth（诞生）: 数值目前无需调整（最终数据来自处理好的音频文件）。
- Life expect（生命周期）: 数据调整为 25。
- Hit Behavior（碰撞行为）: Bounce on Contact（碰到弹回）。

Particle SOP 是Touchdesigner 中不常用但非常强大的粒子效果，可以将多种不同的数据接入来影响粒子的形态和动作。

point1SOP: 调整修改粒子大小（图5-88）。

![images/fa79378bfea8e7f71b0ea5cbaa3fc495b976628861735797ceeb8af8a8d28b86.jpg](https://i.imgur.com/DXdTFkO.jpeg)
图5-88粒子大小设置

Scale（缩放）: 数据修改为8。

nullSOP阶段备份。

#### 5.4.3.3 背景音乐处理

这部分的音频数据处理分为两个部分，一是常开的背景音乐，另一个作为变量被引用到ParticleSOP中的多个参数，用来控制雨水的数量和下落效果。

空白处新建 audiofilein1 CHOP，后面继续添加 audiospect1 CHOP>analyze1 CHOP>lag1 CHOP>math1 CHOP，在 audiofilein1 CHOP 之后 鼠标中 键添加 audiodevout1CHOP（播放声音），见图5-89。

![images/46679bf2c0a539067169573201ceec47ba31031dd721942a974d947d89718350.jpg](https://i.imgur.com/9No61jj.jpeg)
图5-89音频处理元件

audiofilein1 CHOP: 添加音频，具体参数调整见图5-90。

![images/c9ea1ea67ed30f70b2a6721241909f34dd1bbcf8b69d2831e7f150a57147920a.jpg](https://i.imgur.com/BtbEAWc.jpeg)
图5-90导入音频

- File（文件）: 点击 $^{6}+$ ”号选择提前准备好的音乐（详见配套文件）。Mono（单音道）: 打开（方便后续音频做平滑处理）

audiodevout1 CHOP: 将音乐通过扬声器播放出来。
audiospect1CHOP: 将通道数据样式转换为声波样式并重新采样（图5-91）。

![images/78a4b670dde99c442cb72ca666659fd100a263f52c77c03f3e98fac85ceced4c.jpg](https://i.imgur.com/sbUJHMX.jpeg)
图5-91音频数据转为声波样式

其中 High Frequency Boost（ 高频部分增强）默认值为0.75，为了使声音更为平滑。

Audio Spectrum CHOP 的功能是将通道数据样式转换为声波样式，主要用来方便形象地观察数据的状态。

analyze1 CHOP: 分析音频，将音频模式改变，具体调整见图5-92。

![images/7d3fb6bb5dabe70939950ca086e6f1e03243513a35d1a971efb4ba7a06c1e75e.jpg](https://i.imgur.com/WVfZfsa.jpeg)
图5-92音频分析处理

Function（功能）: 改为RMS Power（选择音频的有效值）。

Lag CHOP: 增加通道数据缓动的效果，参数默认无需调整（图5-93）。

![images/5df348d7fb7ae362e5c228a18b444fed22c769ee9dca8e8f121f183ed84a9582.jpg](https://i.imgur.com/p7TKhPs.jpeg)
图5-93增加音频缓动效果

将原本变化很尖锐的通道数据变成圆滑形态的数据。

Method（方法）: 通道滞后缓动的方法（多种算法可选）。

Lag（滞后）: 第1个是数值向上增加时滞后的最大范围，第2个是数值向下递减时滞后的最大范围。

Overshoot（过冲）: 第1个数值向上增加时向上过冲的最大范围；第2个数值向下递减时向下过冲的最大范围。

Clamp Acceleration（斜率）: 在最大斜率中列出中间值。3Max Acceleration（最大加速度）: 第1个值在加速度上升时限制加速度，第 2个值在加速度下降时限制加速度。

- LagperSample（样本）: 将滞后应用于通道的每个样本，而不是整个通道。

$⑦$ Reset（重置）: 重置效果。

- MathCHOP: 观察音乐的数值为 $0{\sim}0.4$ ，通过Math来改变音乐的大小以控制粒子的数量，所以需要将数据放大（图5-94）。

![images/8bf2a167df401cf6d4ea136ac35819bc8d461e8c1a1057cb0a24b03f3b96aec9.jpg](https://i.imgur.com/neWUDBC.jpeg)
图5-94音频放大

- Multiply（倍数）: 参数修改为 40。To Range（范围）: 参数修改为0～300。

#### 5.4.3.4 音乐互动设置

第一种情况，背景音乐常开，直接播放即可。

②第二种情况，将上面处理好的音频数据赋予 particles1 SOP 中的Force 和Particles标签中的各项参数，形成雨滴随着背景音乐发生变化。

![images/5020a9994df4bc270b55af0d5ddfa7bf949115fbbbb773954005ee8cd0f4180d.jpg](https://i.imgur.com/RvoS2dk.jpeg)
图5-95粒子系统设置

Particle: 让粒子中的风力与湍流受到音乐的影响形成音画互动，修改particles1的Force标签页（图5-95）。

将lag1CHOP的数据，分别赋予Wind标签页的x轴与 z 轴和 Turbulence 的y 轴。

引引用方法: 直接拖拽，之后也可以在各项参数后面增加倍数，用以增加力度，此次在Turbulence 的y轴后 $^{\star2}$

让粒子的生成数量受到音乐的影响:修改 particles1 SOP的 Particles 标签（图5-96）。

![images/b98aa9f08c32b13c14ded7f6e9a03711b1c3de5c3f163616c6c885c96fd16608.jpg](https://i.imgur.com/UcWfiYb.jpeg)
图5-96粒子数量设置

将上面处理好的math1 CHOP数据赋予Birth。

注意: 数据在不同阶段都有不同的特征，要根据最终效果的需要选择不同的数据类型赋予不同的对象，此次选择的是math1CHOP的数据而非最后处理完成的lagCHOP数据。

#### 5.4.3.5 人体互动设置

接入 Kinect 数据使之与粒子产生互动，在空白处新建 kinect1 TOP，在后面继续添加thresh1 TOP>trace1 SOP>extrude1 SOP>transform1 SOP (图5-97）。

![images/140a7645e9a6874a2a5c7828a3a0bc771faa628677fd43dcbdf6bbb9327ed064.jpg](https://i.imgur.com/h9TI7v2.jpeg)
图5-97Kinect数据引l入与图形处理

kinect1: 打开运行状态，将显示模式改为 Player Index（索引模式），对用户轮廓粗略绘制（图5-98）。

![images/382a610f7bd437185ec1014e51d5cd45941f72e12ee7acb0360f634a084ecd3b.jpg](https://i.imgur.com/avDzYlc.jpeg)
图5-98 显示模式设置

- Image（图像）: 调整为 Player Index。
- Mirror Image（图像镜像）: 打开（左右手形成对应关系）。

threshold1: 增强人像的明暗对比度，将人的图像抠出来（图5-99）。

![images/f905fcc19445f3880b4f2b4682f4db1e083a404e1d89dfdd49295f2d92849cbd.jpg](https://i.imgur.com/k3vovPB.jpeg)
图5-99 图形明暗阈值设置

Threshold（阈值）: 调整为0.05。在 Kinect 中抠除人像的 Threshold 基本都设置为0.05（也可视情况而定）。

trace1 SOP: 将Kinect 检测的人像绘制成三维图像（图5-10o）。无需调整。

![images/a9243c4bbf8657806b54725166a0f05af20367ace899572355cb4b658f938421.jpg](https://i.imgur.com/i7WpgvU.jpeg)
图5-100图形呈现方式

extrude1 SOP: 对Trace SOP里的图像进行厚度挤出，控制应如何构建挤压面(图5-101 ）。

![images/b7997ab4f6abf2c8e3cca46cb5c4c52b23e50bb0b354bb47a0897bbd7f25e1fd.jpg](https://i.imgur.com/POGI6sI.jpeg)
图5-101图形挤压设置

- Front Face（正面）: 选择 No Output。Back Face（背面）: No Output。3Side Mesh （侧面）: Altermating trian-gles（交替三角面）。

选择No Output，因为有些面在制作动画时实际上是看不到的，如果开着的话，只会增加额外运算量。

transform1SOP: 调整人像在雨幕中的大小、位置、角度（图5-102）。

![images/e23922f701dc8efd39dd329aa575f2e244411b572aa0eb7324513b6c08f0316e.jpg](https://i.imgur.com/sjR4zHo.jpeg)
图5-102人像的位置大小设置

- Translate（位置）: tx，ty，tz分别修改为 0.5，-3.6，1.3。

Scale（大小）: 全部调整为3.5（具体均可视情况而定）。

最后将TransformSOP连接到ParticleSOP的第二个输入端口（图5-1o3）。

![images/c9dc330ea9656b2f94cf9920af6c6c3d756b515efa9cdd2f1fc08b6d53190c1a.jpg](https://i.imgur.com/Be0f7CU.jpeg)
图5-103数据组合设置

该元件四个输入接口的作用如下:

第 1 个接口: input O particle source，作为粒子源。

第 2 个接口: input1 collision，产生碰撞的对象。

第 3个接口: input2 forcce，力的输入口,通常与metaballSOP（质量球）+forceSOP配合使用，为其提供一个质量力。

第 4个接口: input3 surface attractors，表面吸引|，通过一个球体或者面为粒子提供一个吸引|的面。

### 5.4.4 后期渲染与处理

后期渲染预处理主要分为两个部分: 雨幕粒子的渲染与Feedback 形成雨点粒子拖尾效果。后期效果处理见图5-104。

![images/39fb57a4c9b9ede5f699f51287dc2b9874f274d273f473d34534152857fad3f8.jpg](https://i.imgur.com/haC8qjg.jpeg)
图5-104后期效果处理

#### 5.4.4.1 雨幕粒子的渲染

构建渲染五件套，通过调整相机位置等操作将粒子调整到合适的位置。在 nul1 SOP 之后添加 ge01 COMP>cam1 COMP>pointsprite1 MAT>ramp1 TOP>render1 TOP (图5-105 ）。

![images/6a31e70c40e8b63669e777f2857de7e1ad6b676fe5a6fdf0100ccdacebf816b7.jpg](https://i.imgur.com/cYfwPDT.jpeg)
图5-105渲染五件套设置

geo1: 无需调整。
cam1: 通过调整方便看完整画面（图5-106）。

![images/6546d45b8481259c170695f15d012bce157b455434e1781b094ab6b03c2b8199.jpg](https://i.imgur.com/lt18lwy.jpeg)
图5-106调整相机位置

可以通过两种方式进行视图的调整。

- 旋转相机调整构图: 图中所示参数并不是输入进去，通过点开 cam1右下角的 $^+$ 号，在元件框内按H，这样Camera 会显示整个画面，接着在cam1元件框内通过滚轮调整画面至最合适的位置（优点是比较方便，缺点是不够精确）。

- 也可以进入cam1窗口，通过观察相机的三个方向上的坐标轴，分析相机和球体的相对关系，通过输入数值调整相机的位置（优点是比较精确）。

pointsprite1 MAT: 为粒子添加材质，把 Pointsprite1106 拖动到 GeometryCOMP上（图5-107）。

![images/9ef4ee6a48f6a71eff7eb669b677f1448acc55b3a26b4bee9158f9067bd0138e.jpg](https://i.imgur.com/PeJHY5o.jpeg)
图5-107粒子材质设置

- Alpha（透明度）: 数值调整为0.8。
- Color Map（颜色贴图）: 由ramp1作为贴图。
- OffsetLeft（左偏移）: 数值调整为0.5。
- Offsetright（右偏移）: 数值调整为 0.8。

增加RampTOP，给材质赋予颜色（图5-108）。

![images/8e057c440b41059c1813bb6c5a019e4853d48ecae63ed06187dea4bc6758fc06.jpg](https://i.imgur.com/ITgv4PB.jpeg)
图5-108材质颜色设置

Type（类型）: 选择vertical（垂直方式）。
颜色根据需要修改。

#### 5.4.4.2 Feedback拖尾效果

在 render1 TOP 之 后 继 续 添 加feedback1 TOP>blur1 TOP>level1 TOP>comp1TOP>out1TOP，并将render1TOP与comp1TOP连接（图5-109）。

![images/9ce5c7a7d268a4aa13a3cc72d7233986082447783c7a0104042f07a2cad6180f.jpg](https://i.imgur.com/sTQB7rf.jpeg)
图5-109拖尾效果设置

feedback1TOP: 选择循环的目标（图5-110）。

![images/9b12c528febb27d17c4e7e86135805d51d2e7054062db675770dab2ba8dd0d94.jpg](https://i.imgur.com/Za4WCTK.jpeg)
图5-110选择循环目标

Target TOP（目标TOP）: 将comp1拖动给 feedback1 TOP。

blur1 TOP: Filter Size 调整雨滴拖尾效果，值越大拖尾越模糊（图5-111）。

![images/4f3488db291c79c7f00b5d4ab822969db270703ac4bacbbc01352cec2c9713bd.jpg](https://i.imgur.com/j7gp4ui.jpeg)
图5-111拖尾大小设置

Filter size（滤波尺寸）: 数值调整为 10。

level1TOP: 通调整数值使雨滴之间的界限越清晰（图5-112）。

![images/32f3c2aa35763f4198443b3756a62fc1cd99f1b807ffd2974d3652244840d30a.jpg](https://i.imgur.com/AnM9uP5.jpeg)
图5-112透明度设置

Opacity（透明度）: 数值为0.9。

cOmp1TOP: 将其拖动给feedback1TOP（图5-113）。

![images/634f539aa843696a9a6cec9610802c1b452c0da9333cdf80eecb7b58459db98e.jpg](https://i.imgur.com/MW5WqgH.jpeg)
图5-113叠加模式设置

Operation（操作）: 选择 Add。

rgbkey1TOP: 增加黑色背景，参数无需调整。
Out1 TOP。

#### 5.4.4.3 最终效果呈现

人在雨中自由穿梭和嬉戏，完全沉浸在雨中（图5-114）。

![images/1ef211a9eea2ff342048456c843c2a7fe2dac808bc73ea2972b1051a4e93c5a8.jpg](https://i.imgur.com/d4en0bO.jpeg)
图5-114最终效果

![images/8810b2567d3f9ed334dac8919dbd32c557621a713cc75e030c5a9a1cecc640d1.jpg](https://i.imgur.com/dQn3dSg.jpeg)

![images/6657a607538a979abf1eeda8aec7cc25eac0947b07f52bed9f9c3c951bc8c285.jpg](https://i.imgur.com/pRt50wN.jpeg)

# 6 物理交互艺术综合创作

6.1 物体交互之“击战病毒
6.2 激光雷达交互艺术之 “物语

## 6.1 物体交互之 “击战病毒”（案例6-1）

### 6.1.1 概念创意与学习重点

（1）概念创意在一个充满科技感的未来世界，病毒正在威胁着人类的健康。玩家将扮演一名病毒战士，通过打击屏幕上的病毒，表达保卫人类健康的决心。装置让参与者用橡胶鼓槌捶打由亚克力覆盖的电视屏幕，通过附着在亚克力板上的传感器接收振动数据，捶打的压力大小影响画面内容，使病毒造型产生形变和破碎效果。

（2）学习重点3传感器的数据引入和处理。Instance（实例化）功能的使用。

### 6.1.2 设计过程详解

本次案例首先对外部输入的传感器数据进行处理，然后利用Instance实例化的方式，将外部导入的病毒触角模型与球形结合在一起组成完整的病毒模型，接着进行渲染，通过数据的引用实现交互，最终根据需要进行后期效果调整。设计整体分为五个部分（图6-1）。

硬件准备与程序烧录。
- 传感器数据的接收与处理。
-  影像内容制作（实例化）。交互设置。后期效果处理。

![images/580f3ec64db70d0f3c251e16a144e395e27dd8eef67aa3374d4dd108a8453e02.jpg](https://i.imgur.com/6ePGh11.jpeg)
图6-1整体逻辑结构图

### 6.1.3 硬件准备与程序烧录

（1）硬件准备准备模拟压电陶瓷传感器（图6-2）和Uno板各1个、杜邦线若干，模拟压电陶瓷传感器用来收集振动数据信息，具体接线方法见图6-3。

传感器的接线引|脚要与程序设定的引脚号相一致，注意正负极端口的位置。

![images/f8006d74fc28189ebdcaee7074c3aa7e6bbe30fca378abb039637f6770b6166f.jpg](https://i.imgur.com/5hOpoBp.jpeg)
图6-2陶瓷振动传感器
图6-3硬件连接方式

（2）程序设计烧录 利用ArduinoIDE对传感器进行程序的编写，程序内容如下。

```c
//不对压电陶瓷片施加压力时，输出的模拟量为0；
//当对压电陶瓷片施加压力，输出模拟量会发生变化，而且随着压力增大而增
int sensorPin = A0;  //定义传感器引脚为A0

void setup() {
    Serial.begin(9600);  // 串口波特率9600
    pinMode(A0, INPUT);  //设定A0为输入引脚
}

void loop() {
    int val;
    val = analogRead(A0);  //读取传感器的模拟值并赋值给val
    Serial.println(val);   //输出模拟值
    delay(100);           //延迟为100毫秒
}
```

编写好之后点击“验证”确认无误，点击“上传”，完成烧录。

（3）程序测试

![images/fabdeca387af1a5530be5f38958835dc7b314a84780b5c8a4af1dfb4c4d02e6e.jpg](https://i.imgur.com/w4Kr1PS.jpeg)
图6-4串口数据输出测试

- 打开ArduinoIDE的串口监视器，用手按压传感器陶瓷片，看到有数值在不断变化，说明传感器连接成功。

观察变化的阈值范围，并进行记录（图6-4）。

（4）数据的接收与处理导入和控制数据，主要元件如图6-5所示。关闭串口监视器，新建 serial1 DAT，在后面右击依次添加 datto1 CHOP>math1 CHOP>filter1 CHOP>nul1CHOP。

![images/1ab0e39d82d9e8dc3dd8d9ea8839c5dd9106916c877cb1bfbcfb1a6933c77b31.jpg](https://i.imgur.com/E3fGRhx.jpeg)
图6-5数据导入与处理

serial1 DAT: 获取传感器接收到的外部数据（图6-6）。

![images/69cf87de84841a6b6012ecbc93c05311750399a62d003948899c61fbb2891fc0.jpg](https://i.imgur.com/i7k8Zpn.jpeg)
图6-6传感器数据输入设置

- Port（端口）: 此处的端口与Arduino开发板在电脑上的端口（USB）保持一致。

- 查看传感器的端口号: 选择Arduino IDE 编辑器菜单栏的“工具”选项，下划到“端口”可查看具体端口号。

- Calbacks DAT（回调数据）: 一般为元件默认状态。

- MaximumLines（最大行数）: 将数值改为1（让来自传感器的实时数据均显示在第一行）。

- datto1CHOP: 将来自传感器的数据转换成通道数据处理（图6-7）。

![images/45ff0fa84a7bb5aaf7946d937f82e5efbff7bcdfa1ef5e6da49265b21a8e549f.jpg](https://i.imgur.com/VaeJtbI.jpeg)
图6-7数据转化设置

- DAT（数据来源）: Serial1（通信串口）。

- Select Rows（选择行的方式）: 标签页改为 by Index（通过索引选择）。

Start Row Index（开始行）: 将数值改为1。

- End Row Index（结束行）: 将数值改为 1。

- First Cloumn is（第一列）: 标签页改为values（定义第1列的属性是数值）。

math1CHOP: 将得到的传感器数据范围进行控制（图6-8）。

![images/32241212b9cc5cc0d6d28e62e285cea21a3bd9241ed158f0ef665a00f064d662.jpg](https://i.imgur.com/a8je5Ie.jpeg)
图6-8数据范围映射

FromRange（从.…范围）: 将数值调整为0到100（此数据范围因传感器差异会有所不同，设定这个范围前可事先通过敲击传感器观察可能的范围，将这个范围输入到这里）。

To Range（至...范围）: 将数值调整为0到20（后续可根据效果调整此范围）。

filter1CHOP: 让数值变化更加平滑一些，让效果更加舒适（图6-9）。

![images/64a949b1880461b03397a3ea033f780d14ed45e304d2a1a72cd129141194197a.jpg](https://i.imgur.com/FjEELwW.jpeg)
图6-9增加声音平滑效果

- Filter width（滤波宽度）: 调整至0.8（数值越大越平滑）。

- Time Slice（时间切片）: 默认是打开状态。

null1 CHOP 备份。

### 6.1.4 影像内容制作

178. 整体过程为制作一个球形母体 $>$ 导入外部病毒触角模型 $>$ 对病毒触角模型进行实例化完成整个病毒模型制作 $>$ 加入材质灯光进行渲染 $>$ 后期处理（图6-10）。
179. 建立病毒母体: 新建 sphere1 SOP，依次添加 attribcreate1 SOP>noise1 SOP>null2 SOP>ge01 COMP。
180. 建立实例化对象（病毒触角）: 新建filein1 SOP，在后面右击依次添加attribcreate2SOP>transform1 SOP（病毒触角模型详见配套文件）。
181. 进行实例化: 实例化对象（病毒触角）的transform1 SOP后面添加 geo2 COMP。
182. 效果渲染与后期: 添加 movefilein1 和 phong1 MAT，继续新建 cam1 COMP、light1 COMP、render1 TOP 和 null3 TOP。

![images/094c64cbaafdf1da290ddd124bdb00808c58bb7b22bde9df9097f14afd0d0036.jpg](https://i.imgur.com/iBtIpCw.jpeg)
图6-10内容制作构成

（1）建立母体

sphere1 SOP: 创建一个球体为基本形（图6-11）。

![images/4673b5c4ffd86be239d5a1650a21e8785d581ba06e921163c2bd0f6d068cb93b.jpg](https://i.imgur.com/xe9FHsS.jpeg)
图6-11球体参数设置

- Primitive Type（原始类型）: 改为Polygon（多边形）。

- Radius（半径）: 将×，y，z轴数值都调整至8。

Attribute Create1 SOP: 增加模型的切线属性，保证后面能够正确贴图，否则贴图会产生错位（图6-12）。

![images/8cc6fa99c4e89ba365b1f5eca1932d69c262b8f9688a52dde30e11a66a329e9c.jpg](https://i.imgur.com/jRkYWHI.jpeg)
图6-12增加切线处理

ComputeNormals（计算法线）: 在几何体上创建法线（选择关闭，off）。

ComputeTangents（计算切线）: 在几何体上创建切线。

Use MikkTSpace（使用 MikkTSpace）:一般默认关闭。

Attribute Create SOP 用于向三维物体添加法线或切线。

添加 noise1 SOP: 使物体产生形变效果。
null2 SOP 备份。
ge01COMP: 为合并渲染做准备（图6-13）。

![images/e4837cc7201f2188163fca9de2277ee7fcdfbe766b5955b25045a4215b6befa6.jpg](https://i.imgur.com/eMMC5NP.jpeg)
图6-13物体状态设置

Rotate（旋转）: 在Xform 标签页下将x,y，z 轴都输入代码 absTime.frame/8（/8 意为降低旋转速度）。

（2）建立实例化对象

filein1 SOP: 导入模型，或把文件直接拖入Touchdesigner 中得到以 3D 文件命名的SOP元件（图6-14）。

![images/d59f76023ebe69693dbdc5c8745a297e6509bb92ba19a909fdab9e0f5094c536.jpg](https://i.imgur.com/OivpNZY.jpeg)
图6-14模型导入

GeometryFile（几何图形文件）: 点击后面的 $^{66}+^{,}$ ’号选择模型文件。病毒触角作为实例化对象。

attribcreate2SOP: 增加模型的切线属性（图6-15）。

![images/beaef62cb4e40b8f284b61cada1aaac805a8de88a6aa4ded3029808143bb0c05.jpg](https://i.imgur.com/JsU60B6.jpeg)
图6-15增加切线属性

Compute Tangents（计算切线）: 打开选项。

transform1SOP: 对模型的位置进行调整（图6-16）。

![images/6a4de9be17a06890398a41d2386a195d8a2bd5879ad5a1c31ac548fa5800885d.jpg](https://i.imgur.com/jE1vFCL.jpeg)
图6-16模型位置调整

通过旋转缩放将其调整至正确状态，待实例化完成后可再次进行调整，使之垂直于母体（根据观察效果调整）。

1 Translate（位置）: 将z 轴数值调整至-1。2 Rotate（旋转）: 将×轴数值调整至-90。Uniform Scale（整体缩放）: 将数值调整至7.6。（3）进行实例化将null2 SOP（带有位置和法线信息的母体）拖入 geo2 COMP中的 Instance 标签 >Default Instance OP。

geo2COMP: 作为盛放渲染对象的容器（图6-17）。

![images/1157a65047debf1fde9989c977ec4fc02bd31d60a596be096886c2a17848d8d9.jpg](https://i.imgur.com/bSPZ8r4.jpeg)
图6-17物体状态设置

- Rotate（旋转）: 在Xform 标签页下将x,y，z轴都输入代码为 absTime.frame/8（保证母体与病毒触角同步旋转）。

- Instancing（实例化）: 开启选项。

- Default Instance OP（默认实例化元件）: 确保为 null2。注意: 接着用 instance1标签定义“位置”，用instance2标签定义“方向”。

- Translate $\bigtimes$ （×轴位置）: 点击右侧箭头标志选择P（O）。P代表位置信息（Position）。

- Translate $\curlyvee$ （y轴位置）: 点击右侧箭头标志选择P（1）。

- $\otimes$ Translate Z（z轴位置）: 点击右侧箭头标志选择P（2）。

- Rotate toVector $\times$ : 点击右侧箭头标志选择N（O）。N代表法线信息（Normal）。$\mathfrak{G}$ Rotate toVector Y: 点击右侧箭头标志选择N（1）。3Rotate toVector Z: 点击右侧箭头标志选择N（2）。$\Phi$ Material（材质）: 将 phong1拖动到此处。

（4）效果渲染

movefilin1 TOP: 添加凹凸贴图（图6-18）。

![images/30251769ca219f0aaf5544edca18b566005ef7dc404dfa0d70df492b1ff5966a.jpg](https://i.imgur.com/Qo22vPJ.jpeg)
图6-18图片输入

File（文件）: 点击后面的加号选择图片文件（见配套文件）。

phong1 MAT: 增加材质效果（图6-19，图6-20）。

![images/5b0542c33f9912e54608f288a2b5de6a96baa965c60186fa0bd0c932be417923.jpg](https://i.imgur.com/pIdyRjm.jpeg)
图6-19材质调整

增加材质贴图: Normal Map (Bump)，法线贴图（凹凸），将movefilein1拖动到此处，给材质赋上贴图。

![images/d2250c90953e0ac46c6085c84d2a295138647b7240c21334189691185c73973a.jpg](https://i.imgur.com/59FWUkz.jpeg)
图6-20赋材质操作

方法: 将 phong1 MAT元件拖给 geo1和geo2，选择Parm:Material方式。

cam1 COMP: 让 ge01和 ge02同时被观察到（图6-21）。

![images/776092acacbb2d6f8eaa294758f094368ab4bcdee74558cbb242135e2bd079c8.jpg](https://i.imgur.com/d3ejU9B.jpeg)
图6-21调整摄像机视图

Translate（位置）: tz数值调整为50（根据情况调整）。

light1 COMP: 让 ge01和ge02同时被照亮（图6-22）。

![images/52844bac9196103f718056e3e02440cd64d0ee7c25d89aa98c01cf0c5edce8cd.jpg](https://i.imgur.com/tEElAjg.jpeg)
图6-22调整灯光位置

根据实际需要对Translate（位置）、Rotate（角度）和Pivot（中心点）进行调整，数据仅供参考。

- Dimmer（调光器）: 将数值调整为1.36。

- ShadowType（阴影类型）: 标签页调整为 Hard，2D Mapped。

render1TOP: 渲染画面（图6-23）。

![images/d3d1a77af8e30a24160c1508ad03c3d2bc7678337635bf5fc6ff9b1957928d7f.jpg](https://i.imgur.com/ZOnLeS8.jpeg)
图6-23渲染设置

- Camera（摄像机）: 输入cam1，一般默认会自己显示。

Geometry（物体）: 输入geo1和geo2（将 ge01和 geo2共同渲染出来）。

- Resolution（分辨率）: 调整为 $1280\times$ 720。

null3 TOP 备份。

### 6.1.5 交互设置

（1）音效处理主要构成元件见图 6-24。在空白处新建 audiofilein1 CHOP（敲击音乐），后面右击添加 audiodevout1 CHOP（播放）；再新建 audioflein2 CHOP（背景音乐），后面右击添加 audiodevout2CHOP（播放）。

![images/6778d67737a8b8b7aefb2fe3d27e1f9026638b50b5c7c6970719cd0d1da2deea.jpg](https://i.imgur.com/ucXbELK.jpeg)
图6-24音效处理

audiofilein1 CHOP: 当打击时产生敲击音效（图6-25）。

![images/5808e44467591bbb86f39ff36809115f2f886116ab63d6eb6d64410807cd1c27.jpg](https://i.imgur.com/qATgGU5.jpeg)
图6-25声音输入

将最初处理好的传感器数据nul1CHOP赋给audiofilein1。

- File（文件）: 点击后面的“+”号选择音乐文件。

- Repeat（重复）: 打开nul1（传感器数据)右下角的 $^{66}+^{57}$ 号，将数据拖给 repeat 标签页,选择CHOPReference引I用方式。

- audiodevout1CHOP: 使音效文件通过扬声器输出。

- audiofilein2CHOP: 添加背景音乐（图6-26）。

![images/395a0becb882f13e56a1434aa5ca99e3391e0752f35ff2cc65be6a28607f3e6f.jpg](https://i.imgur.com/FKQHAag.jpeg)
图6-26背景音乐引入

File（文件）: 点击后面的“+”号选择音乐文件。

audiodevout2 CHOP: 使音效文件通过扬声器输出。（2）模型形变处理 将最初处理好的传感器数据nul1CHOP赋值给noiseSOP，用于控制球体的变形效果（图6-27）。

![images/52d25e7c2b2d3d4c67cca87856deb8caf23bd4f2570927aae3bf64a0d109f53d.jpg](https://i.imgur.com/zXOCSbI.jpeg)
图6-27模型形状变化设置

Amplitube（振幅）: 打开nul1右下角的“+号，将数据拖给 amp，选择 CHOP Reference引用方式。

（3）后期效果处理为画面增强表现效果，主要元件结构见图6-28。在空白处新建ramp1TOP，其次添加lookup1 TOP。最后将null3TOP连入lookup1TOP的上端口，ramp1TOP连入下端口，最后在lookup1TOP后面添加out1TOP。

![images/e49b2006b04d574d0a233ca0f1fbd709d7f3c02cfd2d6b31291212a1e9384875.jpg](https://i.imgur.com/FGjytyX.jpeg)
图6-28后期效果处理

ramp1TOP: 自定义一个色谱（图6-29）。

![images/2ca10b40bcfa00b502436a96f06deb63bb4a2a6b412d5fd06d18d1d0e2a1cd14.jpg](https://i.imgur.com/uzu6F7d.jpeg)
图6-29渐变色设置

根据实际需要对色谱的Hue（颜色）、Sat（饱和度）、Value（明暗）和Alpha（透明度）进行数值调整，数据仅供参考。

lookup1TOP: 进行画面上色（图6-30）。

![images/4b53b52e220ed347f4f8d8196f2c0f8ccc712958a7329a6eba1c420ec034f49a.jpg](https://i.imgur.com/9me1mAI.jpeg)
图6-30 画面上色处理

- 填色原理: 根据上输入端的明暗值，用下输入端的颜色去填充上端的图形。

- 填充规则: 上端越亮的部分用下端越右的颜色填充，越暗的部分用下端越左的颜色填充。

2 填色依据: Lookup TOP 的两个输入端，上端为填色提供依据，Lookup TOP 会分析上端每一帧图像中每一个像素点的Value 值，也就是我们常说的明度值，越亮的部分Value 值越大，越暗的部分 Value 值越小。

- 添加 out1 Top，图像输出。

- 滚轮返回到/project1 层级，利用表达式使 project11与其内部的 out1 长宽保持一致，方便后期图像分辨率调整（图6-31）。

![images/fde6f336f996e15aa377f6641c34072d35c9d098dd8c20caab70b2bbfb284e5d.jpg](https://i.imgur.com/v6u5Nkx.jpeg)
图6-31输出设置

获取子级中最后一个输出元件的长宽值。

Width（宽度）: 输入表达式op("./Out1').width。

Height（高度）: 输入表达式 $\mathrm{{op}(^{1}./}$ Out1').height.

最终效果呈现见图6-32、图6-3- 。没人参与时病毒会随着音乐的节奏运动，当有人击打时病毒会呈破碎状并伴有破碎的声音。

![images/e1141e8924e2e576480eaa78817a26d2c541a2f553b50ba01d40934d210e6a53.jpg](https://i.imgur.com/fgImlQ0.jpeg)
图6-32静态效果

![images/7fb318432dae928ccaf3bf45112669843a124f7ccf8e21febf91dd4bbedc2147.jpg](https://i.imgur.com/PsqAjeV.jpeg)
图6-3- 动态效果

## 6.2 激光雷达交互艺术之“物语” （案例6-2）

### 6.2.1 概念创意与学习重点

（1）概念创意大自然中的雨花石干干万万，纹路千变万化、数不胜数，显示出大自然神奇的创造。想象一下如果在一块雨花石表面上抚摸，上面的纹理会随着手的运动产生相应的变化，同时伴有“哗哗啦啦”的水流声，正如人在和石头对话，因此本作品被命名为“物语”，通过人与物的沟通创造一种新奇的体验。

（2）学习重点

动态纹理的生成方式，掌握图像的置换功能。

激光雷达的调试及应用。

Mapping 技术的使用方法。

### 6.2.2 激光雷达的连接

（1）硬件连接本案例采用G4激光雷达作为对象，其网口转接板（图6-34）的一端连接雷达，另一端连接网线，网线与电脑网口相连。同时接入DC5V2A电源适配器。（2）激光雷达的配置 首先安装配置工具软件NetModuleConfig0403.exe。

![images/01801fdb68bc1d67be3d2bece1c687da70736b3366b0c306a684bdc7f6613441.jpg](https://i.imgur.com/ZLquuRR.jpeg)
图6-34激光雷达

安装雷达配置软件，搜索到雷达设备 $>$ 查看IP地址（双击设备） $>$ 设置网络模式>端口（8000），设置串口波特率（230400），配置参数（确定参数配置）。

更改电脑端的IP，找到设备管理器 $>$ 网络适配器>属性查找（internet TCP/IPV4) $>$ 修改电脑端IP地址（根据雷达的IP地址修改电脑的IP，同一个域不同地址号,192.168.1.XXX），实现雷达和电脑的通信。测试过程如图6-35。

![images/1261adea58c6fd7f2c57dc0d15b5712e16c8bb1f5eb02c4d1fa1bae77edc910f.jpg](https://i.imgur.com/q7vXIyT.jpeg)
$①$ 点击“搜索设备”识别设备
$②$ 双击设备，获取参数

![images/24d899ec81f97f7e2eda6121186fed1f9847713ef96922296108725d087e8af5.jpg](https://i.imgur.com/KD3zzxH.jpeg)
$③$ 修改网络模式为TCPSERVER（服务模式）
$④$ 修改本地端口，建议修改为8000

![images/51a530520b82cd89626a838f4439f22773082273cabaee551cdbefede370e5bc.jpg](https://i.imgur.com/k6e7tWG.jpeg)
$⑤$ 修改串口波特率230400（G4）

![images/c873c27253af935b02933872a4e6d55988ec09c0dd349e69f6c743504c68ed4e.jpg](https://i.imgur.com/EeGPj4K.jpeg)

$⑥$ 点击配置设备参数，结束后可双击设备再次验证是否修改$⑧$ 修改电脑IP，让电脑和雷达在同一个域下，实现两者通信

![images/c6b26293f0177370f3510f63c4195e8693cee161553eb07a8ebb8af9c7002e42.jpg](https://i.imgur.com/ieuGhe3.jpeg)
$⑦$ 查看网络适配器属性，选择Internet协议版本4
图6-35激光雷达的测试过程

![images/a75d4bbccd4ca64a567356a5e9e71d8e04d9cdee69461db9e21f415204bfc38c.jpg](https://i.imgur.com/9X2tQk7.jpeg)

（3）雷达运行测试

安装雷达扫描检测软件PointCloudViewer，输入对应设备的IP 并选择对应的雷达型号，此处选择G4（图6-36）。

启动扫描界面，点击左上角播放键进行扫描，雷达转动开始扫描图像（图6-37）。

![images/635f7d1d18499dea68df3b04ff6007a39f8c169e790aae9ab78f932986bd7158.jpg](https://i.imgur.com/g0vjATS.jpeg)
图6-36连接设置
图6-37信号扫描图像

（4）雷达信号转换打开雷达鼠标转换软件（图6-38），界面显示雷达探测的范围（图6-38），不同物体会用不同颜色显示，通过观察雷达扫描的图像可以判断实际的空间或物体，竖直安装会探测到屋顶或两边的墙面，水平放置可以探测出房屋结构。

![images/180b3ec98d2c72a5951e527c187a02b61e4085cb67fee9376a4713a2d397e5c1.jpg](https://i.imgur.com/VcXjk2b.jpeg)
图6-38 雷达探测软件界面

如雷达显示区域大小不合适，可拖动最右边红色框内的滚动条调到合适大小（图6-39）；如角度不合适，可拖动最右侧黄色方框内的滚动条调整雷达角度，使雷达轮廓与想要的角度基本平行（图6-40）。

角度调整结束后，将现实中手的位置与电脑界面中的位置对应起来完成操作空间的校准。

![images/aae980354ffd7513600d1f59f52be683531bd2b5772ced60ddbc8fed357fb43b.jpg](https://i.imgur.com/yugul1S.jpeg)
图6-39调整视图到合适大小
图6-40调整节点位置与实际空间边线平行

方法: 将现实中的手放在投影的左上角，在雷达界面中找到手所在的位置，从操作界面中拖动白色控制框左上角的红色点放置到手所指的位置（图6-41），同理完成其他三个点的校准。

![images/0739fec495e9fe88a57306c33ad823b4db7e712ffe884b0f086e330b1d2945d6.jpg](https://i.imgur.com/utZfUel.jpeg)
图6-41调整控制节点让实际空间与软件控制区域相对应

雷达操作界面中的不同颜色圈代表不同位置，分别为红色（左上）、绿色（右上）、蓝色（左下）、黄色（右下），根据雷达正装或反装的不同方式，雷达扫描图像的左右或上下位置也有可能是镜像的，可以调整雷达镜像将位置修正后便于操作（图6-42）。

如要提高扫描区域的可靠性，可以添加“无效区域”排除无用的范围。方法: 点击鼠标右键拖动以橡皮擦的方式建立连续无效区，滚动鼠标可以改变显示区域的大小（图6-43）。

![images/13ac1139b1304c2727f11b6a51749d807d74be59c1627b5b218402dabe3192bb.jpg](https://i.imgur.com/WAcW4Ym.jpeg)
图6-42镜像设置

![images/b23b0f0ea94d4a5feee3e813b966fa687f123b6fa1a1c57e0e11a630891e5a9e.jpg](https://i.imgur.com/YgkENpu.jpeg)
图6-43增加无效范围

调整完这些后，开启模拟触控的选项便可以开始使用了。

注意: 模拟鼠标分为移动或不移动两种方式；点击分为模拟连续点击和拖拽、智能识别模式三种。模拟鼠标移动和模拟鼠标点击可以排列组合使用（图6-44）。

举例: 开启“鼠标移动”及“模拟点击拖拽”，即可实现手接触到触摸区时，模拟出鼠标按下的操作；手移动时模拟按住鼠标、移动鼠标的操作；手离开触摸区则模拟抬起鼠标按键完成拖拽过程（图6-45）。

![images/c95a009cdf7ceebc1fc7179bd9f40f7e107253a8f3087d2c97a6e597e1a2ac6d.jpg](https://i.imgur.com/opnwrFg.jpeg)
图6-44鼠标工作模式

![images/fdcd4f8a66e48e5eb047435e659237a15fe0d5ad2607cbfcf08c8462fcfb4668.jpg](https://i.imgur.com/0bjOjHg.jpeg)
图6-45 鼠标模拟结果显示

如软件只打开模拟鼠标移动，不开启鼠标点击，则软件只模拟鼠标移动的行为，不模拟任何点击操作。在本案例中只需模拟鼠标移动功能，通过雷达捕捉手的位置模拟鼠标位置的变化实现波纹变化。

### 6.2.3 设计思路分析

本案例在一个雨花石的外形上通过Mapping 投射出一个高清雨花石纹理影像，影像内容随着鼠标操作会产生涟漪互动，将激光雷达探测信号转换成鼠标指针，用手代替鼠标指针，在物理雨花石上触碰产生涟漪效果。设计整体分为五个部分（图6-46）。

183. 动态石纹。
184. 动态涟漪。
185. 石纹上的动态涟漪。
186. 交互设置。
187. 三维投影（Mapping）。

![images/77f20280515ad06b1e2ce9da4bdd2477441a5074e04ac7b060ef92c58e767289.jpg](https://i.imgur.com/uAoenDu.jpeg)
图6-46程序设计思路

### 6.2.4 内容制作

（1）动态石纹 制作动态石头纹理，主要元件结构见图6-47。

空白处新建 movefilein1 TOP、noise1 TOP 和 displace1 TOP，将 movefilein1 TOP连入 displace1TOP上端口，noise1 TOP 连入下端口，最后在 displace1 TOP 后面添加null1 TOP。

![images/4ef51c7c9d9a4e97087f306ccc510f93003441a71036e89a5a9675c97e26d437.jpg](https://i.imgur.com/BWWAs97.jpeg)
图6-47动态石纹的元件组合

movefilein1TOP: 导入图片（图6-48）。

![images/a192ae1081b628dfa223c023347bbbd6725a073814d62cc1cd9f2d064bb85110.jpg](https://i.imgur.com/DtiGTl0.jpeg)
图6-48导入图片

- File（文件）: 点击后面的“+”号选择图片文件。

- Output Resolution（输出分辨率）: 改为 Custom Resolution 模式。

- Resolution（分辨率）: 调整为1280 $\times$ 720。

- noise1TOP: 制作动态效果（图6-49）。

![images/dbbe96aaa522f883e91ffd72312eaba42b8053626e96a547549e6d5646476902.jpg](https://i.imgur.com/uh0zaBD.jpeg)
图6-49 噪波动态效果参数

- Period（周期）: 将数值调整为1.47。

- Harmonics（谐波）: 将数值调整为0。

- Harmonic Spread（谐波扩散）: 将数值调整为 0。

- Harmonic Gain（谐波增益）: 将数值调整为 0。

- Exponent（指数）: 将数值调整为0.94。

- Amplitude（振幅）: 将数值调整为0.35。

- Offset（抵消）: 将数值调整为0.35。

- Translate（位置）: 在tx输入表达式absTime.seconds $^{\star\left(\right).2}$

- Rotate（谐波）: 在 $\cap X$ ，ry和rz输入absTime.seconds $\star0.2$ 。

- Pivot（中心点）: 在px，py和 pz 处输入1，1和0。

- Output Resolution（输出分辨率）: 改为 Half 模式。$①$ Resolution（分辨率）: 调整为 $1280\times720$

displace1TOP: 对效果进行置换（图6-50）。

![images/5459e4c0fd695766fa2dfe1917443a60ebbfad68a33277f036f8422829070333.jpg](https://i.imgur.com/hDT259E.jpeg)
图6-50置换效果设置

- Displace Weight（置换权重）: 将数值都调整为1.2。

- Offset Weight（偏移权重）: 一般默认数值为 0。

- Extend（延伸）: 标签页改为 Repeat模式。

null1 TOP 备份。

（2）动态涟漪 制作动态连漪效果，元件结构见图6-51。空白处新建 sphere1 SOP，在后面右击依次添加 noisel2 SOP 和 geo1 COMP，再新建light1COMP、cam1COMP和render1 TOP完成渲染。接着添加null2TOP，在后面搭建feedback 框架，依次添加 feedback1 TOP，继续添加 edge2 TOP，blur1 TOP,level2 TOP 和 add1 TOP，将 add1 TOP 拖给 feedback1 TOP，最后将 null2 TOP 与add1TOP相连。

![images/3d51088794dfce0ff87041a146025b0f135decd7c6f5e03d090d377241bee5d1.jpg](https://i.imgur.com/tenGFKN.jpeg)
图6-51涟漪效果的元件构成

Sphere1 SOP: 创建球体（图6-52）。

![images/0807c2f864606aa07a678438196f33c8eefdda3e0b93a38c5b7440a7f90a4d60.jpg](https://i.imgur.com/aeDIqG7.jpeg)
图6-52球体参数

Radius（半径）: 将数值都调整为0.1。

noisel2 SOP: 添加形变效果（不做参数调整）。

geo1COMP: 作为盛放渲染对象的容器（不做参数调整）。

cam1COMP: 用于观察ge01COMP（图6-53）。

![images/f86c30493841e6d2dd39d871317d4bfc92fe761802b9b16015a271587ee6a946.jpg](https://i.imgur.com/gt0CKNQ.jpeg)
图6-53相机位置调整

Translate（位置）: 将tz的参数调整为 5（视具体情况调整）。

light1COMP: 用于照亮模型（图6-54）。

![images/d7a96beea3c9e37d403e4485c28802ba1a8e0cf9b14bdf15b5288dac712f64e6.jpg](https://i.imgur.com/utTjcoh.jpeg)
图6-54灯光位置调整

Translate（位置）: 将tz的参数调整为 10（也可以视具体情况调整）。

render1TOP: 将物体渲染出来。

null2 TOP 备份。

edge2TOP: 增加拖尾效果的边线感（图6-55）。

![images/3bdf52593aff82757c16fa8de5510aae4031bcff6abcb7f6942f7d8fd16f731e.jpg](https://i.imgur.com/crCGbWA.jpeg)
图6-55边线元件的调整

Sample Step（样本大小）: 将数值调整为6。

Blur1 TOP: 增加模糊效果（不做参数调整）。

level2TOP: 调整透明度（图6-56）。

![images/d820ed64f5bf6760e5a6708f8deb7d7c0c3ac2c51e8fbac76e8a6454a4305a82.jpg](https://i.imgur.com/vhUhccl.jpeg)
图6-56透明度调整

Opacity（透明度）: 将数值调整为0.645。

(3）石纹上的动态涟漪空白处新建 displace2 TOP，让 nul1 TOP 接入上输入端，add1 TOP 接入下输入端，在 displace2 TOP 后面加入 null3 TOP（图6-57）。

![images/ed6961ad667cb396e5b938f12ec66415f6381a8476b86489bd0535a0bc6b5695.jpg](https://i.imgur.com/SYruESS.jpeg)
图6-57置换效果的接入方式

displace2TOP: 进行图像置换（图6-58）。

![images/f7a260cbdaccf8cab2e3b95bc42b09d704b87137a93f377faf0f4325abd849f2.jpg](https://i.imgur.com/2EYOCa5.jpeg)
图6-58置换参数设置

- SourceMidpoint（中心源）: 将数值都调整为0（坐标原点为左下角）。

- Displace Weight（置换权重）: 将数值都调整为0.2（置换时的偏移量）。

- OffsetWeight（偏移权重）: 数值默认为 0。

- displace TOP 是根据下输入端的每个像素颜色的变化，对上输入端的像素点进行置换，置换的依据是上输入端越亮的部分用下方输入端越右边的颜色进行替换，越暗的部分用下方输入端越左边的颜色替换。

null3 TOP 备份。

### 6.2.5 交互设置

（1）音效处理

1 创建鼠标数据: 在空白处新建mousein1CHOP，右击添加 selsct1 CHOP和 selsct2CHOP，在后面分别添加 math1 CHOP>null4 CHOP，math2 CHOP>null5 CHOP（图6-59）。

2 创建声效与背景音乐: 在空白处新建 audiofilein1 CHOP（声效）和 audiofilein2CHOP（背景音乐），在后面分别添加 audiodevout1 CHOP 和 audiodevout2 CHOP（播放声音）。

- 条件判断: 在空白处新建 constan1 CHOP 和 constan2 CHOP，在后面分别添加 logic1 CHOP>null6 CHOP>chopexec1 DAT, logic2 CHOP>null7 CHOP>chopexec2DAT。

![images/e279f9fb1d6069853e5f0a7dfcd03b4e4960770419ca7fe5ab03cf7759d4d2f0.jpg](https://i.imgur.com/qR1refv.jpeg)
图6-59音效处理元件组合

（2）创建鼠标数据

mouSein1CHOP: 创建鼠标移动数据（图6-60）。

![images/d181c7ae9f749967135dc5a361111cac89ee91cb685d64dc8cb65ea96355a187.jpg](https://i.imgur.com/UCt5PRW.jpeg)
图6-60 鼠标数据元件设置

- Position $\bigtimes$ （ $\bigtimes$ 位置）: 数值默认为tx。

- Position $\curlyvee$ ( $\curlyvee$ 位置）: 数值默认为ty。

- Sample Rate（样本速率）: 数值默认为 60。

- Time Slice（时间切片）: 默认开启。

- Export Method（导出方法）: 默认为DAT Table by Name。

selsct1 CHOP: 选择出需要的通道（图6-61）。

![images/92d039928a8f377eb972b287ca1012627e70290b506c4260aa21cb1432c7af8e.jpg](https://i.imgur.com/cBw8Aeh.jpeg)
图6-61通道数据选择

Channel Names（通道名词）: 点击右侧箭头标志选择tx。

math1CHOP: 将得到的鼠标数据范围进行控制（图6-62）。

![images/cf188484e2bda3078fbe72a757f2cef40bb9d75172f7bb870d4200a8e6791f64.jpg](https://i.imgur.com/FRtPqC7.jpeg)
图6-62范围映射与控制

To Range（至范围….到..….）: 将数值调整为 0\~2。

为了让鼠标在石头图像的指定范围内产生0与1的逻辑判定条件，用于音效的播放，故设置范围为 0\~2。

null4 CHOP 备份。

selsct2CHOP: 选择出需要的通道（图6-63）。

![images/d328dead42f4991648b98b49fb3b21eda2d0cdb100537d94b800556d707d72db.jpg](https://i.imgur.com/ahHrdxW.jpeg)
图6-63选择通道数据

Channel Names（通道名词）: 点击右侧箭头标志选择ty。

math2CHOP: 将得到的鼠标数据范围进行控制（图6-64）。

![images/a420922a2a5af4aa14ccd8988f0709ed8906e66a9a670e013e5ecc7e08e7e46d.jpg](https://i.imgur.com/nJo38PU.jpeg)
图6-64数据映射设置

To Range（至范围....到...）: 将数值调整为 0\~2。

为了让鼠标在石头图像的指定范围内产生0与1的逻辑判定条件，用于音效的播放，故设置范围为 0\~2。

添加 null5 CHOP。

（3）创建声效与背景音乐

audiofilein1CHOP: 播放水流声效（图6-65）。

![images/995b6fc6de7a45ac87a6668d12e6e1a5a9e9831fd6230f5c10e4d80a49dfcd33.jpg](https://i.imgur.com/xF7zkBP.jpeg)
图6-65水流音效导入

- File（文件）: 点击后面的“+”号选择音乐文件“水流声.mp3”。

- Repeat（重复）: 调整为 off。

- Volume（音量）: 调整为0.2。

- audiodevout1 CHOP: 使音效文件通过扬声器输出。

- audiofilein2 CHOP: 播放背景音乐（图6-66）。

![images/31ba0ac0c18c33dd2f3d0544942770cd8b5cb395a434f074b80fd444f209456e.jpg](https://i.imgur.com/anE11iO.jpeg)
图6-66背景音乐导入

- File（文件）: 点击“+”号选择音乐文件“雨花石背景音乐.mp3”Volume（音量）: 将数值调整为0.528。

-audiodevout2CHOP: 使音效文件通过扬声器输出。

（4）条件判断

constant1 CHOP: 创建数据控制器，并和鼠标移动数据绑定（图6-67）。

![images/4fc70b356af3259d7df12c19b025daa74882376cce118ef97d747cf02fbd0e90.jpg](https://i.imgur.com/8O7plMA.jpeg)
图6-67常量数据引用鼠标移动数据

Name O（名称 O）: 将 Name O改为TX。

打开 null4 CHOP 右下角的 $^+$ 号（鼠标数据），将数据拖给value O标签，选择CHOPReference 引l用方式。

Sample Rate（样本速率）: 数值默认为 60。

logic1 CHOP: 对数据建立逻辑判断（图6-68）。

![images/8d6a47869f167a9aebdb2d14f0f8bcfb1be5b0efc72832101199b21c6b616dc9.jpg](https://i.imgur.com/cfCgWlQ.jpeg)
图6-68逻辑判断条件

Convert Input（转换输入）: 调整为Off When Outside Bounds 模式（ 当超出边界关掉）。

Bounds（界限）: 数值调整为 $-1.3$ 和1.3（该范围来自鼠标的t女轴的坐标，希望在这个范围内有水流声播放，该值通过移动鼠标观察constant1 得来）。

Time Slice（时间切片）: 默认开启。

null6 CHOP 备份。

chopexeC1 DAT: 进行逻辑判断代码编写（图6-69、图6-70）。

![images/ecce5697a58cb62a580d8ad0c9c5b529479f120de1e966268c07bb87440a97a3.jpg](https://i.imgur.com/9YiApdV.jpeg)
图6-69执行元件设置

- CHOPs（通道），确保是null6。

- Off to On（从关到开），点击开启。

- Value Change（数据变化），点击关闭。

点击右下角 $^{6}+^{,5}$ 号，在"def onOffToOn (channel,samplelndex, val, prev): ” 的下一行输入 op(‘audiofilein1’).par.cue.pulse( )。

![images/77c2acf40e635933326e39776fb247e2f4a775fc8bd68a2689acb2a29dae5f9e.jpg](https://i.imgur.com/kQxQPnq.jpeg)
图6-70 逻辑执行代码编写

def onOffToOn: 代表从关（off，0）到开（on，1）的时候执行下面一句话的内容（相当于给出了一个条件）。0和1的参考值来自元件null6。

2 op(‘audiofilein1’).par.cue.pulse( ): 元件 audiofilein1 中的 cue 参数后的 pulse 执行一次,相当于用鼠标点击了一次pulse，完成了播放一次水流声的音频文件。

本界面内的文本缩进不能用空格键，必须用TAB键，如return前面的缩进必须用TAB键。

- 按以上过程再次设置 constant2。

constant2CHOP: 创建数据控制器，和鼠标移动数据绑定（图6-71）。

![images/8f780f5e9b9ea5f64b00bf214cad432e739a331914e28b6ab0c14e2c9c87371c.jpg](https://i.imgur.com/JNYtHVf.jpeg)
图6-71 常量数据引用鼠标移动数据

NameO（名称O）: 将nameO改为 TY。

- 打开nul5CHOP右下角的“+”号，将数据拖给value O标签页，选择CHOPReference引l用方式。

- Sample Rate（样本速率）: 数值默认为60。

logic2CHOP: 对数据建立逻辑判断（图6-72）。

![images/7ac347aaa726fa70f8c017c1a339dd110513567f783018011ce3e06183172c21.jpg](https://i.imgur.com/Tx44hVz.jpeg)
图6-72 逻辑判断条件设置

ConvertInput（转换输入）: 标签页调整为OffWhenOutsideBounds模式（当超出边界时关闭）。

Bounds（界限）: 数值调整为 $-0.8$ 和0.8（该范围来自鼠标的ty轴的坐标，希望在这个范围内有水流声播放，该值通过移动鼠标观察constant2得来）。

Time Slice（时间切片）: 默认开启。

null7 CHOP 备份。
chopexec2DAT: 进行逻辑判断代码编写（图6-73、图6-74）。
- CHOPs（通道），确保是null7。
- Off to On（从关到开），点击开启。
- Value Change（数据变化），点击关闭。

![images/1c3f26d475b077f073d8d131af50fe0cf50296710530436cd9357de1b93df0af.jpg](https://i.imgur.com/C1nStkG.jpeg)
图6-73执行元件设置

![images/772123d7ade87b4b90fe05c9054598592dd3f06f294b9435141e9ee4f441d0bb.jpg](https://i.imgur.com/PdYQMMk.jpeg)
图6-74逻辑执行代码编写

![images/4a9227d731b8ee0d0d6514bf08ad6d4b19073e061c519e949e49cee9ecc96b2c.jpg](https://i.imgur.com/NYlcNgN.jpeg)
图6-75播放设置

点击右下角 $^{6}+{}^{n}$ 号，在 defonoffToOn(channel, samplelndex,val,prev): return 段落中输入op(‘audiofilein1’ ).par.cue.pulse(),见图6-74。

op(‘audiofilein1' ).par.cue.pulse(）意思为执行元件 audiofilein1CHOP 中 的 cue 参 数 后 面 的 pulse选项（图6-75），也就是播放一次audiofilein1的音乐。

pulse（），这里的（）代表“执行”的意思。

（5）涟漪位置移动处理

- 将最初处理好的鼠标数据null4CHOP和null5CHOP分别赋值给sphere1 SOP中Center参数中的tx和ty，用于控制涟漪位置的效果移动（图6-76）。

![images/9d5d89a3c0fb66e8ed62531a1a03763f7aa716afa813ded3f5fd7b70ccb5da68.jpg](https://i.imgur.com/OTib8vb.jpeg)
图6-76球体位置数据引用

Center（中心）: tx和ty 对应球体的×轴和y轴位置变化。null4 和 null5 分别为鼠标数据。

### 6.2.6 三维投影与效果展示

(1) Mapping 设置 三维投影技术，也称光雕艺术，它是除了常规屏幕显示和平面投影外，借助 Projection Mapping 的形式将画面投影到三维物体上的技术。目前行业主流的Projection Mapping 方法有 kantanMapper（平面三维映射法）和 camSchnappr（三维立体映射法）两种，本案例使用前者，具体操作如下。

![images/986736bc99143f4df3e1b24ca443246f7b555bc96c5b2cd5c4e4de6b05f1b8d0.jpg](https://i.imgur.com/YbxUjtb.jpeg)
图6-77Mapping 插件位置

在工作区左侧的 Palette 插件库中找到 Mapping，再找到kantanMapper 插件，将插件拖入工作区（图6-77）。

![images/439489207e821d836fb1cea34a3ba7256762df39a62559e98fee6e097ad02f87.jpg](https://i.imgur.com/GM9LPOD.jpeg)

点击元件，打开右边面板点击Open Kantan Window 后的 Pulse（启动），打开kantanMapper元件的Window界面，测试投影仪的连接情况（图6-78）。

![images/8a62295bbcbdc8822a072bda6b3f9754bfb033bc051f346b59bb6401d2a41e76.jpg](https://i.imgur.com/J8SaYSp.jpeg)
图6-78打开插件窗口

![images/46a54f618f9a586d8bfa00046ffa2051914dec28d489bc820436b53f2b7982cb.jpg](https://i.imgur.com/j8YzYF7.jpeg)
图6-79设置分辨率

![images/99692ed02a97d36f006588f7e1cde49b6f546676f4d87fe8fb72721585c4e536.jpg](https://i.imgur.com/56jgbuo.jpeg)
图6-80窗口设置

在操作界面左上角的项目设置区域，点击Reslution设置分辨率: 根据投影仪的分辨率进行设定 ( $1920\times1080$ ），见图6-79。

点击下方的WindowOptions选项，对画面显示进行设置（图6-80）。

![images/d39357102a915b0133d4baa8742a7ecca9d2969da0f484ec7f68ff7a82da5748.jpg](https://i.imgur.com/dRi75ei.jpeg)
图6-81选择监视器

将Monitor（监视器）参数设置为投影设备的连接口号，如有多台投影可用此参数选择切换（图6-81）。

![images/94b598d5bb0607ad0d5cafddbc7e10e655c305d96afaa46906da9b82a99f303d.jpg](https://i.imgur.com/UP3razr.jpeg)
图6-82输出设置

设置完成后，点击kantanMapper元件的Window 界面的Toggle Output 选项，进行视频信号的输出验证（图6-82）。

![images/11c7409874c712de672d204a5d12ee02c83adf0ef795a5f20deeaef1a8c57d00.jpg](https://i.imgur.com/307F8Fd.jpeg)
图6-83显示验证

检查投影仪投出的橙色实线位置是否与电脑屏幕内的图像一致，如果显示一致说明设置成功，否则，返回修改Monitor的数值找到正确的输出设备（图6-83）。

![images/d158070ae81c03e9bf1e5e347ffda527fc7165c16505ae1444809d29ba0109ff.jpg](https://i.imgur.com/bbr2cIb.jpeg)
图6-84显示区域绘制工具

在 kantanMapper 操作界面进行投影范围的绘制与编辑。

点击左侧工具栏中的创建多边形（CreateFreeform），在红色线框内用锚点画出一个椭圆形投影面（图6-84）。

在制作圆形时可以按住 Ctr 键再点击鼠标左键，可以生成锚点。

![images/d38cb742f809307bab536ea0f296a3834f85628374022f8654c50df8ac3f17bd.jpg](https://i.imgur.com/wnlHfOy.jpeg)
图6-85调整显示区域形状

粉红色锚点为确定位置点，蓝色锚点可以进行弧度调节，具体需要不断调整投影的边界位置不断进行修正，适应物理环境中的物体轮廓（图6-85）。

![images/784585c5a4f9f74d310489fe85b78ab341058b45aa27c62565dc5306323386ce.jpg](https://i.imgur.com/PJczqKv.jpeg)
图6-86 显示材质设置

继续在这个页面将前面石纹上涟漪模块中的最后一个null3TOP（输出图像的元件）拖入Texture（纹理）选项内，完成引用。

单击其右侧的“”来显示贴图材质（点击后即为绿色“”），完成Mapping投影（图6-86）。

（2）最终效果展示人站在雨花石面前可以听到潺潺的水流声，在安静的环境下能够体验自然的美好。当参观者用手轻轻抚摸雨花石时，会伴有“哗哗”的水声和石头上扭曲颤动的画面，犹如人的手在水中滑动时水面泛起阵阵涟漪，整个过程就像人与石头在对话，因此本作品命名为“物语”（图6-87）。

![images/b374e875c849fd2b46eda67fc136ac1ce6c865d344fa15ec3ba1d1634de97bf6.jpg](https://i.imgur.com/pv6fuYL.jpeg)
图6-87 最终效果呈现



![images/6e1202587f22f0751112ae3734393ade84415bab0e592205496a5c5e346ea67d.jpg](https://i.imgur.com/OCgJbF5.jpeg)

# 7 灯光控制与交互艺术

7.1DMX通信协议与光源
7.2SPI通信协议与光源
7.3灯光控制之程序设计
7.4灯光控制之图像映射
7.5灯光控制之机械灯
7.6其他专业灯光控制软件


交互艺术作品中常常会应用多种多样的硬件以增强参与者的体验感，其中包括各种舞台灯具、数控电机、机械臂、激光投影等。DMX是控制这些硬件的主流协议，利用集成的DMX节点，Touchdesigner 可以作为一个中枢，协调多种硬件设备进行演出和展示。目前LED灯光控制的通信协议主要有: $①$ DMX协议。 $②$ SPI 协议。 $3$ Art-Net 协议。

## 7.1 DMX通信协议与光源

### 7.1.1 DMX通信协议与光源

（1）DMX协议也称DMX512协议，最初是由USITT（美国剧院技术学会）拟定的灯光信号传输标准，用来作为灯光控台与设备之间的标准传输协议，后来随着设备型号和种类的不断增加，DMX512协议在各类灯光、机械装置及控制设备中被广泛应用。在当下的舞台演出和展览展示领域，DMX512已经成为一个不可替代的通用协议。有了这个标准协议，硬件与软件之间可以实现无缝对接，交互模式也变得更加方便与简洁。

DMX512协议指的是由512个通道组成的一个集合，每个通道的数值范围是 $0\sim255$ 将一个DMX512包发出的时候，接收端会收到一个带有512个通道的数组，对应的设备会在这个数组中选择相应的通道作为参数进行使用。

（2）DMX光源DMX灯珠一般情况下由三个颜色红（R）、绿（G）、蓝（B）或四个颜色红（R）、绿（G）、蓝（B）、白（White）组成，每个颜色就是一个通道。比如一条 60个灯珠的 RGB 灯带共有 60× 3=180个通道；一条 60 个灯珠的 RGBW灯带共有$60\times4{=}240$ 个通道（图7-1）。

![images/974900989f6fce1978b0d34852b4809c7df632a472cfa323c3fde944b28d3a89.jpg](https://i.imgur.com/mQUuMOy.jpeg)
图7-1DMX灯带

DMX灯带的每一个灯珠都有一个独立的固定地址码，如要控制灯带上的灯珠亮度和顺序，必须保证每个灯珠有一个固定的地址码。地址码一般有两种状态，即自动编码和人工写码。自动编码的灯带延长后会自动顺序编写自己的地址码，人工写码状态的灯带要通过写码器人工写入地址码。

### 7.1.2 DMX光源的写码步骤

DMX灯带在出厂时一般都是将所有灯珠的地址码统一写成〇号，这时的灯带基本相当于一条普通的非编程灯带，所有灯珠只能统一控制。如果设计项目需要对个别灯珠进行单独控制，就需要对所有灯珠进行写码操作，也就是要给每一个灯珠写入一个唯一固定的地址码，这就需要一台DMX写码／控制器（图7-2）。目前市面上的写码器品牌型号很多，但基本功能及写码的原理与步骤基本相同。

![images/a43fe5eb8392d830a5c6d83ae8bfb2c024f43a2137ad341e637115c12c7c0ae0.jpg](https://i.imgur.com/UAify7J.jpeg)
图7-2DMX写码器

长按“模式 $+\mathrm{~}^{,}3$ 秒后进入写码操作。模式 $+$ : 菜单项目循环选择。模式 $-\backslash$ 速度 $^+$ : 数值加或减。速度－: 确定键，在菜单3写码时有效。

菜单的基本内容见表7-1。

表7-1写码器菜单与功能介绍


<html><body><table><tr><td>菜单</td><td>菜单项目</td><td>范围</td><td>功能及说明</td></tr><tr><td>1</td><td>UCSC</td><td></td><td>DMX5112芯片选择:UCSC，UCSD，UCS，t-AL，t-AC，Snn1</td></tr><tr><td>2</td><td>4CH</td><td>0~144</td><td>通道间隔设定；0CH时接连的灯具全部写为相同地址码</td></tr><tr><td>3</td><td>001</td><td>1~512</td><td>设定起始地址码，按ENTER确定开始写码</td></tr><tr><td>4</td><td>C001</td><td>001~512</td><td>发送测试信号，堆积点亮；C---，从1自动累加到512</td></tr><tr><td>5</td><td>RGBW</td><td></td><td>灯珠颜色通道排序选择: 定义颜色的排列顺序，有如下几种情况 RGBo:rGboObGr:WBGRo:W单色 CO: C冷色（W: 暖色） rGb:RGB rbG:RBG Grb:GRBGbr:GBR brG:BRG bGr:BGR</td></tr><tr><td>6</td><td>B-32</td><td></td><td>软件版本号，无法修改</td></tr></table></body></html>

（1）接线 按图7-3连接好写码器、灯具和开关电源，写码器 $\lor+$ 接电源正极，GND 接电源负极。

![images/b33b9dfbea4cb21e79884cdd08823662f51a4376f90382f503da483690c9273b.jpg](https://i.imgur.com/t6cVXPp.jpeg)
图7-3DMX灯具写码时的接线方式

注: AB线写码的产品写码器和第一台灯之间的PI线不接，其他型号要将写码器的PI和灯具的PI相连。TM512AL/UCS512A写码时，写码器的GND必须和电源板的GND相连，否则会写码失效。

（2）选择芯片 长按“模式 $+$ ”键，直到显示UCSC（或是其他芯片型号），显示菜单1内容，松开按键，按“模式－\模式 $+^{\prime}$ 选择芯片型号，型号如下。

UCSC: 联芯科UCS512C0/C1/C3/C4等C系列芯片。
UCSD:联芯科UCS512D/UCS512DH。
UCS: 联芯科UCS512A（PI线写码，必须接PI线）。
t-AL: 天微TM512AL（PI线写码，必须接PI线）。
t-AC: 天微TM512AC0/TM512AC/TM512DH等AB线写码芯片。
Snn1: 明微SM185X/SM175X/SM16500X等AB线写码芯片。

联芯科、天微、智芯AB线写码的芯片,其写码的协议是相同的,都可以选UCSC进行写码。

（3）选择通道数．按“模式+”键，显示菜单2内容，按“模式-\速度+”选择每个512 芯片占用多少个 DMX512 通道: 1\~144CH 表示1\~144 通道；0CH将全部灯具写成统一的地址，此功能方便出厂时将全部灯具地址重置为1号默认地址。

一般驱动及多段洗墙灯如下: 单白光1CH；冷暖白2CH；RGB3CH；RGBW4CH。对于512C0转码芯片，需要根据灯具段数及颜色设定，如8段RGB，设为8段×3通道=24通道；8段RGBW，设为8段 $\times4$ 通道 $=32$ 通道。

（4）选择起始地址按“模式 $+^{\prime}$ 键，显示菜单3内容，按“模式 $-\backslash$ 速度 $^+$ ”选择每个起始地址码（默认为001），然后按“速度－”键确定写码，直到重新显示为设定的起始地址码，则写码完成。一般写码都是从001开始写码。对于单独写码的产品，地址码可参考如下计算公式: 起始地址 $=$ （灯号 $-1$ ） $\times$ 通道数 $+1$ ，如: RGB（3通道）的10号灯 $=$ (10-1) $\times3+1=28$ ；RGBW（4通道）的20号灯 $=(20-1)\times4+1=77$ 。

（5）地址校验按“模式 $+^{\mathfrak{N}}$ 键，显示菜单4内容，进行地址码校验。用“模式－\速度 $+^{\prime}$ 键从000至512进行选择，手动逐个地址进行点亮测试，检查有无重码、漏码等情况。如果有重复码，尝试再次写码。

校验为地址堆积点亮的模式， $\mathsf{C}^{\star\star\star}$ 为目标地址，即只要灯具的地址码低于目标地址，灯具就会被点亮。C000为全灭状态，C001只点亮1#地址码的灯具，C100表示从1到100#地址码的灯具都点亮。C--－为自动模式，自动从1～512循环点亮。

（6）灯珠通道排序按“模式 $^+$ ”，显示菜单5内容，进行灯珠通道排序的设定，用“模式一\速度 $^+$ ”键进行选择。部分产品的灯珠排列顺序并非RGB/RGBW排列，需了解灯具三种颜色的正确排列方式，选择正确的顺序，控制器变化模式才能正确。

（7）效果测试本部分功能主要用来检测灯带是否正确写码成功。长按第一个键“模式 $+^{\mathfrak{N}}$ 退出写码状态，并保存当前的所有设置，下次长按“模式 $+^{\mathfrak{N}}$ 选择内置效果进行测试（菜单功能如表7-2），方法如下: 

- 写码器屏幕上前2位数字显示为模式效果，后2位显示效果变化速度。
- 模式 $+/ $ 模式－: 向上、向下选择效果模式。
- 速度 $+/ $ 速度－: 加、减变化速度，静态颜色时进行亮度调节。
写码器灯光模式的代码与功能见表7-2。

表7-2写码器灯光模式的代码与功能


<html><body><table><tr><td>模式</td><td>功能</td><td>速度控制说明</td><td>其他说明</td></tr><tr><td>1</td><td>R</td><td>00~15，数值越大，亮度越高</td><td>静态颜色</td></tr><tr><td>2</td><td>G</td><td>00~15，数值越大，亮度越高</td><td>静态颜色</td></tr><tr><td>3</td><td>B</td><td>00~15，数值越大，亮度越高</td><td>静态颜色</td></tr><tr><td>4</td><td>W（RGB三色时，RGB全亮）</td><td>00~15，数值越大，亮度越高</td><td>静态颜色</td></tr><tr><td>5</td><td>R+G+B+W</td><td>00~15，数值越大，亮度越高</td><td>静态颜色</td></tr><tr><td>6</td><td>R+G</td><td>00~15，数值越大，亮度越高</td><td>静态颜色</td></tr><tr><td>7</td><td>G+B</td><td>00~15，数值越大，亮度越高</td><td>静态颜色</td></tr></table></body></html>

续表


<html><body><table><tr><td>模式</td><td>功能</td><td>速度控制说明</td><td>其他说明</td></tr><tr><td>8</td><td>R+B</td><td>00~15，数值越大，亮度越高</td><td>静态颜色</td></tr><tr><td>9</td><td>G，B，W全亮、全灭跳变</td><td>00~15，数值越大，变化越快</td><td>动态变色</td></tr><tr><td>10</td><td>七彩跳变</td><td>00~15，数值越大，变化越快</td><td>动态变色</td></tr><tr><td>11~14</td><td>渐变</td><td>00~15，数值越大，变化越快</td><td>动态变色</td></tr><tr><td>15~25</td><td>颜色追逐跑动效果</td><td>00~15，数值越大，变化越快</td><td>动态变色</td></tr></table></body></html>

注: $1{\sim}8$ 模式必须设置正确的灯珠通道颜色排序，并且写码后才可以正常控制，如果颜色不对应，请按第（6）步重新设定灯珠颜色排序。

## 7.2 SPI通信协议与光源

（1） SPI 通信协议SPI 是一种高速、高效率的串行接口技术（Serial PeripheralInterface），通常由一个主模块和一个或多个从模块组成，主模块选择一个从模块进行同步通信，从而完成数据的交换。SPI是一个环形结构，通信时需要至少 4 根线（事实上在单向传输时3根线也可以），如图7-4所示。

SPI协议定义了一组规范和标准，以实现多个设备之间的数据传输和通信。它常用于连接微控制器、传感器、存储器和其他外围设备等。SPI协议通过使用时钟信号、数据输入和输出线以及控制信号（如片选、使能等）来进行数据传输和设备控制。SPI协议具有简单、高速和灵活的特点，在许多嵌入式系统和通信应用中被广泛使用。

Wiring Diagram

![images/a310974ce7a6d2a817d3c7cf6e2317bbd3ba28bd4e807b9c5320e5febb5f409e.jpg](https://i.imgur.com/Q9eAgZo.jpeg)

![images/b4730595f3c37368f2bd26f014ce879bb0faf26d2b91a804f2e40579bc0baf08.jpg](https://i.imgur.com/sDDYrUX.jpeg)
图7-4SPI协议的灯带接线方式

WiringDiagram一接线图；SCconnectwithSPIspotlight（TM1803)一用串口连接支持SPI通信协议的，芯片为TM1803的聚光灯;SCconnectwithSPIpixelstrip（LPD6803）一用串口连接支持SPI通信协议的，芯片为 LPD6803 的像素灯带；Power Supply 5-24VDC Constant Voltage一5\~24 伏恒定电压电源； SPIsignal—SPI信号;SPI spot light一SPI 通信协议的聚光灯;LED pixel strip一LED像素灯带；AC 100-240V-100\~240V的交流电； $\mathsf{V}\mathrm{+}\mathrm{-}$ 电源正极；V-一电源负极；CK一时钟线；DA一数据线；RUN一运行；MATCH一匹配

信号控制原理: 信号经过一个灯珠被截取一段控制信息，逐步往后一直到最后，灯珠之间有先后顺序。

（2）SPI光源型号支持SPI通信协议的灯带芯片与型号有几十种之多，常见的有WS2801，APA102，SK9822，LPD8806 等。

WS系列灯珠的特点: 

无需写码，顺序控制。

2 单点单控，每个灯光颗粒有一个独立的控制芯片（图7-5），灯珠（图7-6）参数及引脚如图7-7所示。

![images/ff5f4596da844ac4ff3cd88033c4895fe70d23aa9230f9d2ad672f4cff9b94e4.jpg](https://i.imgur.com/345WCzG.jpeg)
图7-5SPI灯带

![images/5bda04e7476511064f231792c9b5ae2b9a2bee5c06e218cbde79f98370df9ea9.jpg](https://i.imgur.com/ko7ExMb.jpeg)
图7-6RGB 灯珠实物

![images/bc297cc7afff336af966f04bf422450af808d28974b2243c94950b9efc50cf6c.jpg](https://i.imgur.com/B6CXHq3.jpeg)
图 7-7RGB 灯珠参数及引脚
1—DI; 2—GND; 3—VDD; 4—DO

（3）供电与连接方式WS2812LED 灯带上每一个灯珠都需要 60mA 左右的电流强度，为了确保灯带正常工作，控制电路所配备的直流电源要能提供充足的电流强度为灯带供电。例如，一条带有 30个灯珠的灯带，需要直流电源的输出电流强度为 $1.5\sim$ 2A 左右。

接线方式: 开发时和使用时的接线方式有一个区别就是Arduino 主板的供电方式不同，开发时的接线见图7-8，使用时的接线方式见图7-9。

![images/459375f620139bdc98905a0630030630a76b0cd1a93dbb31393056ddb17d0b1b.jpg](https://i.imgur.com/wGYNTjn.jpeg)
图7-8开发时Arduino控制WS2812LED灯带的接电方式（无需面包板方式）

![images/d05894a842770f3d9bf3c14aa4ddeb247b43683475dac4e1fe2e081bb353c0fe.jpg](https://i.imgur.com/bydh5v4.jpeg)
图7-9工作时电源供电的接电方式

## 7.3 灯光控制之程序设计

### 7.3.1 FastLED库与安装方法

（1）FastLED库利用开源平台可以进行简单的灯光效果控制，而开源库的设计为灯光控制和灯效设计提供了更加丰富的资源，可以用一系列数学函数来实现复杂灯光效果的控制，在 Arduino 开源平台上就有大量为灯光控制开发的第三方库，其中FastLED 就是一个优秀且比较容易掌握的第三方灯光控制库。它可轻松地编程控制LED 灯带和灯珠，创建各种炫目的光效和动画，用于交互艺术、灯光秀、DIY项目等，该库具有广泛的社区支持，提供了丰富的示例代码和文档，使初学者和专业开发者都能快速上手和应用。作为控制LED灯带的开源库，它为 Arduino 和其他兼容的开发板提供了简化和高效的LED 控制功能。该库支持各种常见的LED芯片类型，如WS2812、WS2811、APA102等，能使用不同通信协议控制LED，该库的主要特点如下。

188. 快速高效: FaStLED能以极快的速度控制LED 灯光，可实现流畅的动画和快速的色彩变换。

189. 灵活多样: 该库支持多种LED 布局和排列方式，包括线性布局、网格布局、环形布局等。

190. 高级特效: FastLED 库提供了丰富的特效函数和动画效果，例如渐变、闪烁、呼吸灯、彩虹效果等，使用户可以轻松实现各种华丽的灯光效果。

191. 内存优化: 该库在设计时考虑了内存的限制，采用了高效的内存管理策略，在有限的存储空间下能够处理更多的LED灯珠。

192. 跨平台支持: 不仅支持 Arduino，还可以在其他兼容的平台上运行，如ESP8266、ESP32、Teensy 等。

（2）在线安装 通过库管理进行安装（图7-10）。

![images/512f6c7bb320c3da46302a96a415b04c1bfa2279ea22db8972c98e69b75eaee2.jpg](https://i.imgur.com/gTD1FcK.jpeg)

![images/185fb480ae15bbbe512412df2033940d4377d738154b36149f08757c7e17336d.jpg](https://i.imgur.com/qSIJTd0.jpeg)

图7-10FastLED库的在线安装过程

（3）下载后安装下载后点击可执行文件安装，重新启动IDE会自动加载。也可以在项目／加载库中添加，即可实现库文件的安装（图7-11）。安装完后如能在项目菜单／包含库中找到安装库的名字说明安装成功（图7-12）。

![images/ca494d1f5e34905f181bf3bb41f647bda095cbf6cbffb7bafb07e18a156c619a.jpg](https://i.imgur.com/HSpigBr.jpeg)
图7-11FastLED的下载安装
图7-12检查FastLED 是否安装成功

（4）Fast库的测试可以打开FastLED库自带的程序进行测试，文件／示例/FastLED/DemoReel100.\*。注意程序中的引脚号与实际板子输出的引l脚一致，从本章案例中可以看出这个库的丰富表现力。

### 7.3.2 灯控程序的语法与结构

程序设计语言 $\subset++$ 的基本语法结构与规则如下。

（1）注释


<html><body><table><tr><td>符号</td><td>意义</td></tr><tr><td></td><td>单行注释: 以双斜线（/）开头，用于注释单行内容</td></tr><tr><td>**</td><td>以斜线和星号（/*）开头，以星号和斜线（*/）结尾，用于注释多行内容</td></tr></table></body></html>

（2）文件头引用


<html><body><table><tr><td>符号</td><td>意义</td></tr><tr><td>#</td><td>处理器执行的指令。一般放在程序的第1部分，用来定义各种变量、加载各种库文件，放</td></tr></table></body></html>

（3）主函数

<html><body><table><tr><td>符号</td><td>意义</td></tr><tr><td>intmain():</td><td>程序的入口点，其中int表示返回值类型（整数型），main是函数名</td></tr></table></body></html>

（4）变量声明和定义

<html><body><table><tr><td>符号</td><td>意义</td></tr><tr><td>typevariableName;</td><td>声明一个变量，其中type是变量的类型，variableName是变量名</td></tr><tr><td>typevariableName=value;</td><td>声明并初始化一个变量，其中value是变量的初始值</td></tr></table></body></html>

（5）数据类型 int: 整数类型。float: 单精度浮点数类型。double: 双精度浮点数类型。char: 字符类型。bool: 布尔类型，表示真或假。string: 字符串类型。此外有其他自定义的数据类型。

（6）运算符 $^+$ : 加法运算符。-: 减法运算符。＊: 乘法运算符。/: 除法运算符。 $\%$ 取模运算符。=: 赋值运算符。 $==$ : 相等运算符。!=: 不等运算符。>、<: 大于、小于运算符。

$>=$ $<=$ : 大于等于、小于等于运算符。&&: 逻辑与运算符。Ⅱ: 逻辑或运算符。

（7）控制语句

if，else: 条件语句，根据条件执行不同的代码块。

for，while，do-while: 循环语句，用于重复执行一段代码。

常用控制语句在以下案例中均有所涉及，具体用法详见案例。

（8）灯光控制程序的结构 Arduino采用的程序编写语言为 $\mathsf{C}\substack{++}$ ，所有的程序分为三个部分。

- 定义变量: 把所需要的函数、对象的名字、库文件的引I入全部放在第一部分。

- 初始化环境: 以void setup（）开头的内容，让程序做好各种准备。

-  主程序: 程序的循环体部分，以void loop（）开头，详细写出程序的内容，自上而下顺序执行。

### 7.3.3 初步灯光动态控制
（案例7-1～案例7-9）

（1）案例7-1: 点亮一个红色闪烁的LED 将以下代码输入编辑区。

```c
[[include]] "FastLED.h"  // 载入库文件，此示例程序需要使用FastLED库
[[define]] NUM_LEDS 60   // 定义LED灯珠数量
[[define]] LED_DT 9      // 定义Arduino输出控制信号引脚9号
[[define]] LED_TYPE WS2812  // 定义LED灯带型号
[[define]] COLOR_ORDER GRB  // 定义RGB灯珠中红色、绿色、蓝色LED的排列顺序

// LED亮度控制变量，uint8_t这种类型可以使用数值0~255来定义灯光亮度
// 数值越大则光带亮度越高
uint8_t max_bright = 128;  

// 建立灯带leds对象，这个对象的名字就叫leds
// 因为上面定义了NUM_LEDS 60，所以leds这个灯带里面有60个灯珠
CRGB leds[NUM_LEDS];

void setup() {
    Serial.begin(9600);  // 启动串行通信，一般9600
    delay(1000);         // 稳定性等待，让程序暂停1秒
    
    // 初始化灯带的各项参数(灯带类型、引脚号、颜色顺序)(灯带名称，灯珠数量)
    LEDS.addLeds<LED_TYPE, LED_DT, COLOR_ORDER>(leds, NUM_LEDS);
    
    // 设置灯带亮度，前面已经定义过这个参数了，为128
    FastLED.setBrightness(max_bright);
}

void loop() {
    // 设置灯带中第一个灯珠颜色为红色，leds[0]为第一个灯珠，leds[1]为第二个灯珠
    // Red为红色是这个库定义好的，不能用其他名称，因为所有颜色的名称都在库里定义好的
    leds[0] = CRGB::Red;
    FastLED.show();  // 更新LED色彩
    delay(500);      // 等待500毫秒
    
    // 设置光带中第一个灯珠颜色为黑色，为第一颗灯珠熄灭
    leds[0] = CRGB::Black;
    FastLED.show();  // 更新LED色彩
    delay(500);      // 等待500毫秒
}
```

（2）案例 7-2: 让红色LED动起来 将循环部分调整为如下。

193. void loop(）{
194. for(int i = 0;i<NUM_LEDS; ${\bf i}{+}{+}$ $/^{*}$ 使产生“移动”效果，循环里面，灯珠的起始位置是第
- 。 1（0）个，执行一次就向前增加 ${\leavevmode{1}}^{\ast}/$
195. leds[i] $=$ CRGB::Red; //设置光带中第i个灯珠颜色为红色
196. FastLED.show(); //更新LED色彩
- . delay(50); //等待50毫秒
197. leds[i]=CRGB::Black;; //设置光带中第i个灯珠颜色为红色
198. FastLED.show(); //更新LED色彩
199. delay(50); //等待50毫秒
200.  }
201.  delay(500); //等待500毫秒
12

（3）案例7-3: 让单个运动的LED同时变色 继续将循环部分调整如下。

202. void loop(）{
203. for(int i $=$ 0;i<NUM_LEDS; ${\mathrm{i}}{+}{+}$ $/^{*}$ 使产生“移动”效果，循环里面，灯珠的起始位置是第
- 。 1（0）个，执行一次就向前增加 $^{1^{*}}$
204. leds[i] $=$ CRGB::Red; //设置灯带中第i个灯珠颜色为红色
205. FastLED.show(); //更新LED色彩
- . delay(20); //等待 20毫秒
206. leds[i]=CRGB::Green; //设置灯带中第i个灯珠颜色为绿色
207. FastLED.show(); //更新LED色彩
208. delay(20); //等待 20毫秒
209.  leds[i] $=$ CRGB: :Blue; //设置灯带中第i个灯珠颜色为蓝色
210.  FastLED.show(); //更新LED色彩
211.  delay(20); // 等待 20毫秒
212. leds[i]=CRGB::Black;；// 设置灯带中第i个灯珠颜色为黑色

213. FastLED.show(); //更新LED色彩
214. delay(20); //等待20毫秒
13.
215. delay(500); //等待500毫秒
18.}
（4）案例7-4: 让多个运动的LED变色 继续将循环部分调整如下，将上面的单个LED 改成连续几个 LED。

216. void loop(）{
217. for(int i $=$ 0;i<NUM_LED: ${\dot{\bar{1}}}++$ $/^{*}$ 使产生“移动”效果，循环！
- . 1（0）个，执行一次就向前增加
218. leds[i-1] $\l=$ CRGB: :Red; //设置灯带中第i-1个灯珠颜色为红色
219. leds[i]=CRGB::Red; //设置灯带中第i个灯珠颜色为红色
220. leds[ ${\dot{1}}+1]=1$ CRGB::Red; //设置灯带中第i+1个灯珠颜色为红色
221. FastLED.show(); //更新LED色彩
222. delay(50); //等待50毫秒
223. leds[i-1] $=$ CRGB: :Green；//设置灯带中第i-1个灯珠颜色为绿色
224. leds[i]=CRGB::Green; //设置灯带中第i个灯珠颜色为绿色
225. leds[i+1] $=1$ CRGB: :Green；//设置灯带中第i+1个灯珠颜色为绿色
226. FastLED.show(); //更新LED色彩
227. delay(50); //等待50毫秒
228. leds[i-1] $\l=$ CRGB: :Blue；//设置灯带中第i-1个灯珠颜色为蓝色
229. leds[i]=CRGB::Blue; //设置灯带中第i个灯珠颜色为蓝色
230. leds[i+1]=CRGB: :Blue；//设置灯带中第i+1个灯珠颜色为蓝色
231. FastLED.show(); //更新LED色彩
232. delay(50); //等待50毫秒
233. leds[i-1] $\Bumpeq$ CRGB: :Black；//设置灯带中第i-1个灯珠颜色为黑色
234. leds[i]=CRGB::Black; //设置灯带中第i个灯珠颜色为黑色
235. leds[i+1]=CRGB::Black；// 设置灯带中第i+1个灯珠颜色为黑色
236. FastLED.show(); //更新LED色彩
237. delay(50); //等待50毫秒
238. }
239. delay(500); //等待500毫秒
240. }

（5）案例7-5: 让所有灯珠同时闪烁（一）将循环部分调整如下，所有灯珠先全部点亮，再全部熄灭。因为间隔的时间很短（500毫秒，可以继续减小这个时间），虽然看上去好像同时闪烁，但是灯珠亮起和熄灭是有先后顺序的。

241. void loop(){
242. for(int i = 0;i<NUM_LEDS;i++){ // 当i 小于灯珠总数量时，i 增加 1，一直循环到条件不成立
- . leds[i] $=$ CRGB::Red; //设置灯带中第i个灯珠颜色为红色
243. FastLED.show(); //更新LED色彩
244. }
245. delay(500); //等待500毫秒
246. for(int i =0;i<NUM_LEDS;i++){// 当i 小于灯珠总数量时，i增加1，一直循环到条件不成立
8.
247. leds[i]=CRGB::Black; //设置灯带中第i个灯珠颜色为黑色
10.
248. FastLED.show(); //更新LED 色彩
249. }
250. delay(500); //等待500毫秒
251. }

（6）案例7-6: 让所有灯珠同时闪烁（二）·修正以上效果（灯珠并不是同时亮起来，而是逐个亮起来），让所有灯珠同时闪烁。这里应用一个fil_solid 函数（实体填充），其功能是同时将灯带上所有灯珠同时点亮。

将循环部分调整如下，可以实现所有灯珠同时闪烁，用fl_solid 函数把所有灯珠填充为同一个颜色。

252. void loop(）{
253. // 利用 fll_solidsection 全部点亮／熄灭
- . fll_solid（leds,30,CRGB::Red)；//填充（灯带的名称，灯珠的数量，填充的颜色）
254. FastLED.show(); //刷新
255. delay(500); // 延时500毫秒
256. fll_solid（leds,30,CRGB::Black);/／填充（灯带的名称，灯珠的数量，填充的黑色）
257. FastLED.show(); //刷新
258. delay(500); //延时500毫秒
259. }

（7）案例7-7: 让开头一段灯珠闪烁利用fll_Solid 函数点亮指定个数的灯珠，此处将前3个点亮（只能从头开始）。需将循环部分调整如下。

260. void loop(）{
261. //从灯带头开始，点亮熄灭3个LED
- . fll_solid (leds,3,CRGB: :Red); $//\AA$ 填充（灯带名称，点亮个数，颜色为红色）
262. FastLED.show(); //刷新
263. delay(500); // 延时500毫秒
6.
264. fll_solid（leds,3,CRGB::Black);//填充（灯带名称，点亮个数，颜色为黑色）
265. FastLED.show(); //刷新
266. delay(500); // 延时500毫秒
10.

（8）案例7-8: 让特定位置的一段灯珠闪烁上面的案例是从开头亮几个，此处用来自定义从任何位置同时点亮N个灯珠，将循环部分调整如下。

267. void loop(）{
268. /\*从开始的第6个灯珠开始，点亮并熄灭3个LED，括号内
- . 的+5 就是指对前5 个灯珠不做任何操作，而是从第6个灯珠
269. 开始算起点亮3个灯珠\*/
270. fll_solid（leds+5,3,CRGB::Red)；//填充（起始位置，点亮个数，颜色为红色）
271. FastLED.show(); // 刷新
272. delay(500); / / 延时 500 毫秒
8.
273. fll_solid（leds+5,3,CRGB::Black);/／填充（起始位置，点亮个数，颜色为黑色）
274. FastLED.show(); //刷新
275. delay(500); // 延时500毫秒
12.

（9）案例7-9: 让一段灯珠来回摆动色条反复摆动的原理: 第1段循环从头开始逐渐点亮熄灭（运动状态），一直到灯带尾端，这时条件不满足了，开始进入第二段循环。第2段循环从尾部逐渐移动位置点亮熄灭（运动状态），一直到条件不满足，再进入第一个循环（此时条件满足第一个循环）。具体将循环部分调整如下（修改上面的程序）。

276. void loop(）{
2 /\*（也就是i一直加1，加到i不小于NUM_LEDS-3时就停止
- . 循环了，这时就进入第2段循环），因此可以在这个区域见
4。 摆动，同样修改延迟时间可以调整移动速度\*/
277. for(int i=0;i<NUM_LEDS-3;i++){ //循环条件，后面的循环都要符合这个条件，逐渐增加
278. fll_solid (leds+i,3,CRGB::Red); 1/填充（起始位置，点亮个数，颜色为红色）
279. FastLED.show(); //刷新
280. delay(50); // 延时500毫秒
9.
281. fll_solid（leds+i,3,CRGB: :Black)；//填充（起始位置，点亮个数，颜色为黑色）
282. FastLED.show(); //刷新
283. delay(50); // 延时500毫秒
284. } // 内部 for 循环
285. /\*上面是从头部开始点亮熄灭3颗灯珠，一直运动到灯带末尾，
286. 上一个循环结束（条件终止），开始进入下一个循环\*/
287. for(int i $=$ NUM_LEDS-3;i>0;i--){// 循环条件，后面的循环都要符合这个条件，逐渐递减。
288. fll_solid (leds+i,3,CRGB::Red); //填充（起始位置，点亮个数，颜色为红色）
289. FastLED.show(); //刷新
290. delay(50); // 延时 500 毫秒
20.
291. fll_solid（leds+i,3,CRGB: :Black);//填充（起始位置，点亮个数，颜色为黑色）
292. FastLED.show(); //刷新
293. delay(50); //延时500毫秒
294. } // 内部循环体，对应的是内容的for 循环
295. } //外部循环体，对应的是void loop

### 7.3.4 用不同的颜色模式控制灯光
（案例7-10～案例7-14）

以上用到的各种颜色（如Red，Green，Black，Blue，Purple，Yellow等）都是fastLED库自带的颜色，尽管有很多颜色名称可以调用，但是相对还是比较单一（就像我们绘画时调色盘里有二十几种颜色，但仍然需要根据我们创作的需要进行调色），原色不一定是我们真正想要的颜色，如果想要一种特定的颜色，就要进行自定义。通常有两种方法进行颜色的自定义，分别为RGB和HSV。

（1）案例7-10: 用RGB自定义灯光颜色RGB颜色模型是一种用于显示彩色的模型，它基于红色（Red）、绿色（Green）和蓝色（Blue）三种原色的组合。这种模型基于加法混色原理，通过不同强度的红、绿和蓝光的组合来产生所见的各种颜色。在RGB 颜色模型中，每种原色的强度可以用一个数字值来表示，通常范围从0到255。其中，0表示没有该原色的光，而 255 表示该原色的最大强度。通过调整每种原色的强度，可以得到不同的颜色。

通过将不同强度的红、绿和蓝光以各种比例叠加，可以产生几乎所有可见的颜色。例如，红色的光强度为 255，而绿色和蓝色的光强度为0时，会产生纯红色。而当红、绿、蓝三种原色的光强度都为255时，会产生白色光。

RGB 颜色模型在计算机图形学、显示设备和数字图像处理中被广泛使用。通过调整RGB原色的强度，可以精确控制所需的颜色和色彩效果。

以下程序仍然分为定义对象、初始化环境和主程序3个部分，定义颜色主要在第1部分。

296. [[include]]" FastLED.h" //调用FastLED 库，此示例程序需要使用FastLED 库
297. [[define]] NUM_LEDS 30 // 定义 LED 灯珠数量
- . [[define]] LED_DT 9 // 定义 Arduino 输出控制信号引脚
298. [[defne]] LED_TYPE WS2812 //定义LED灯带型号
299. [[define]] COLOR_ORDER GRB // 定义 GRB 灯珠中红色、绿色、蓝色LED 的排列顺序
300. uint8_t max_bright $_{=128}$ //LED亮度控制变量，可使用数值0\~255，数值越大则光带亮度越高
301. CRGB leds[NUM_LEDS]; //建立灯带 leds
302. /\*下面是利用 RGB 方法定义颜色的案例，此处自定义了一个以
303. myRGBcolor 为名字的颜色，后面会调用这个颜色名称，其中括号
304. 里面的三个值分别为（50,0,50）就是r,g,b 的数值 $\ast_{/}$
305. CRGB myRGBcolor(50,0,50)；// 此处定义了myRGBcolor 的色板，其r,g,b值分别为（50,0,50).
306. //其中r,g,b 的Value均为: 0\~255
307. void setup(){
308. LEDS.addLeds<LED_TYPE,LED_DT,COLOR_ORDER>(leds,NUM_LEDS); / / 初始化光带
309. FastLED.setBrightness(max_bright); //设置光带亮度
310. }
311. /\*循环部分如下，演示如何使用CRGB颜色名称（红色数值，绿色数
312. 值，蓝色数值）方法\*/
313. void loop(){
314. fll_solid(leds,NUM_LEDS,myRGBcolor); / / 填充了名称为 myRGBcolor 的色板
315. FastLED.show(); //刷新
316. delay(500); // 延时 500 毫秒
23.}

（2）案例7-11: 用RGB 模式让灯带颜色发生闪烁循环部分修改如下，修改了r和b 的值，然后再将它们改回来，不停循环形成整条灯带的闪烁效果。

1 /\*循环部分如下，演示如何使用CRGB 颜色名称（红色数值，绿色数
317. 值，蓝色数值）方法\*/
- . void loop(){
318. /\*演示如何使用CRGB 颜色名称（红色数值，绿色数值，蓝色数值）
319. 方法，就是利用色板名称后面重新定义一个颜色的数值。语句如
320. myRGBcolor.r（这就是修改原来色板中r的值）\*/
321. myRGBcolor. $r=\theta$ /\*myRGBcolor(0,0,50)，把原来色板中（50，0，50）中的r修
322. 改成0\*/
323. myRGBcolor. $b=0$ /\*myRGBcolor(0,0,0)，把原来色板中（50，0，50）中的b修改
324. 成了0，此处都是0就是熄灭\*/
325. fll_solid(leds,NUM_LEDS,myRGBcolor)； // 重新再填充这个 myRGBcolor 色板
326. FastLED.show(); //刷新
327. delay(500);
328. // 停500毫秒之后再把r和b改回原来的值
329. myRGBcolor. $\mathord{\Gamma}=5\theta$ / /myRGBcolor（50,0,0）此句话把r的值重新改回了 50
330. myRGBcolor. $_{\circ=5\theta}$ / /myRGBcolor（50,0,50）此句话把b的值重新改回了50
331. fll_solid(leds,NUM_LEDS,myRGBcolor);
332. FastLED.show(); // 刷新
333. delay(500); // 延时500毫秒
334. }

(3）案例 7-12: 用 HSV 模式定义灯光颜色CHSV(hVal，sVal，vVal),HSV(Hue，Saturation，Value）是根据颜色的直观特性，由A.R.Smith在1978年创建的一种颜色表达方法。该方法中的三个参数分别是: Hue色调（H），Saturation饱和度（S），Value明亮度（V）。取值范围分别为0～255。如图7-13所示。

H（色调）: 从红色开始按逆时针方向计算。红色为0，绿色为85，蓝色为 170。

2 S（饱和度）: 表示颜色的纯度或鲜艳程度，取值范围为0～255。255纯度最高。

- √（明亮度）: 取值范围为0\~255。该数值越大，灯带的亮度越亮，反之数值越小。

![images/62fe563024f746c1cdb9b41c97b0ee3890567488c2fa66f4c771a7357a59d7d4.jpg](https://i.imgur.com/FeBbzTB.jpeg)
图7-13HUE色相环的色号位置

335. [[include]]" FastLED.h" //此实例程序需要使用FastLED 库
336. [[define]] NUM_LEDS 30 // 定义 LED 灯珠数量
- . [[define]] LED_DT 9 // 定义 Arduino 输出控制信号引脚
337. [[define]] LED_TYPE WS2812 //定义LED灯带型号
338. [[define]] COLOR_ORDER GRB //定义 RGB 灯珠中红色、绿色、蓝色LED 的排列顺序
339. uint8_t max_bright $=128$ /\*LED 亮度控制变量，uint8_t 这种类型是可以使用数值0\~255 来
340. 定义灯光亮度的，数值越大则光带亮度越高\*/
341. CRGB leds[NUM_LEDS]; // 建立名称为 1eds，灯珠数量为 NUM_LEDS 的 CRGB 灯带
342. /\*CHSVcolorName用 HSV 的方法定义颜色（CHSV相当于--个内
343. 置函数)\*/
344. CHSV myHSVcolor(50,50,50)；//定义名字为 myHSVcolor（色相，饱和度，亮度）的色板
345. void setup(){
346. LEDS.addLeds<LED_TYPE,LED_DT,COLOR_ORDER>(leds,NUM_LEDS);// 初始化灯带的各项参数
347. FastLED.setBrightness(max_bright);// 初始化灯带的亮度为 max_bright
348. }
349. //利用fll_solid（填充色板函数）点亮灯带
350. void loop(){
351. fll_solid(leds，NUM_LEDS，myHSVcolor);//填充（led 名称，光珠数字，色板名）
352. FastLED.show(); //刷新
353. delay(500); // 延时500毫秒
21.

（4）案例7-13: 用HSV模式显示渐变色原理: 循环1次，色相h 值加1，由此实现颜色渐变（同理亮度、色度也可逐渐变化）。循环部分如下:

354. void loop(){
355. // 演示如何使用.h方法改变 CHSV颜色的某一个数值
- . myHSVcolor.h++; $/^{*}$ 修改HSV定义颜色的单一数值，此处可以把 $\mathfrak{h}$ 改成 $S/V$ 进行修改，观
356. 察效果变化\*/
357. fll_solid(leds, NUM_LEDS, myHSVcolor);
358. //填充（led 名称，灯珠数量，色板名）
359. FastLED.show(); // 刷新
360. delay(10); // 延时10毫秒
361. }

（5）案例7-14: 用HS√模式让渐变色的灯带运动起来本案例实现了一条灯带上从开头处点亮3个灯，一边运动一边改变颜色，并在灯带上反复摆动。原理: 此处完成了两个for 循环，当满足第1个条件时进行第一个for循环（从头到尾运动，同时改变颜色），直到不满足条件后进入第2个for循环（从结尾到开头运动，同时改变颜色）。循环部分代码如下:

362. void loop(){ //利用fill_solid（填充色板函数）
363. // 以下演示变色条反复摆动
- . for(int i=0;i<NUM_LEDS-3; ${\bf i}{+}+$ ){//（三个灯珠从头部到尾部运动的同时产生颜色的变化）
364. myHSVcolor. $^{\mathsf{h}++}$ // 修改HSV定义颜色的h的值
365. fll_solid(leds+i,3,myHSVcolor)；//填充（起始位置，点亮个数，颜色色板）
366. FastLED.show(); //刷新
367. delay(50); // 延时50毫秒
368. }
369. /\*进入第二个循环（三个灯珠从尾部到头部运动的同时产生
370. 颜色的变化）\*/
371. for(int ${\dot{\mathbf{1}}}=$ NUM_LEDS-3; $\dot{1}>=0$ i--){
372. myHSVcolor. $\hslash++$ // 修改HSV定义颜色的单一数值
373. fll_solid(leds+i,3,myHSVcolor)；// 填充（起始位置，点亮个数，颜色色板）
374. FastLED.show(); // 刷新
375. delay(50); // 延时50 毫秒
376. }
17.

### 7.3.5 常用灯光控制的内置函数
（案例7-15～案例7-18）

为了快速设计丰富的灯光效果，FaStLED内置大量的函数，通过调用函数就可以方便地实现多种灯光效果的设计，以下列举了部分内置函数的应用。

（1）案例7-15: （Fil_rainbow）静态彩虹灯带可快速将一条完整的灯带填充成彩虹色，或将一条灯带的某一段填成彩虹色，函数与功能如表7-3 所示。其中 beginHue 为起始色调数值；deltaHue为相邻LED灯珠色调差。

表7-3fill_rainbow函数的功能


<html><body><table><tr><td>函数举例</td><td>功能</td></tr><tr><td>fill_rainbow（LEDs,30,beginHue,deltaHue)</td><td>将LED灯带从头数30个灯珠（一共30个灯珠）设 置为渐变彩虹色</td></tr><tr><td>fillrainbow(LEDs+5,30,0,1)</td><td>将LED灯带从第5个处数30个灯珠设置为渐变彩 虹色，起始色调数值为O，相邻LED灯珠色调差为1</td></tr></table></body></html>

**完整程序如下** ::

377. [[include]] “FastLED.h" //加载FastLED 库，此示例程序需要使用FastLED 库
378. [[define]] NUM_LEDS 30 // 定义LED 灯珠数量
- . [[define]] LED_DT 9 // 定义Arduino输出控制信号引脚
379. [[define]] LED_TYPE WS2812 //指定LED灯带型号
380. [[defne]] COLOR_ORDER GRB// 定义 RGB 灯珠中红色、绿色、蓝色 LED 的排列顺序
381. uint8_t max_bright=128;//定义 LED 亮度控制变量，可使用数值为0～ 255，数值越大则光带亮度
越高
382. CRGB leds[NUM_LEDS]; // 建立名称为 leds 的光带
383. uint8_t beginHue $=6$ // 定义了起始色调数值，通过修改该数值可以定义开始的颜色
384. uint8_t deltaHue $=~1$ //定义了相邻灯珠色差，通过修改可以更改颜色变化的程度（中间隔了儿
个色号）
10.
385. void setup() {
12。 LEDS.addLeds<LED_TYPE，LED_DT，COLOR_ORDER>(leds，NUM_LEDS);// 初始化灯带
13。 FastLED.setBrightness(max_bright）；//设置灯带亮度

14.}

15.void loop （){
386. //fll_rainbow演示
387. fill_rainbow(leds,NUM_LEDS,beginHue,deltaHue)；//灯带名称、数量，开始色值，相邻灯珠间的
色值差
388. FastLED.show(); //更新LED色彩
389. delay(25); //等待25毫秒
20.}

（2）案例7-16: （Fill_rainbow）动态彩虹灯带该案例让彩虹灯带运动起来，将起始颜色修改为可以变化的数值，彩虹就由静止变成了运动的样子。

完整程序如下。

390. [[include]] “FastLED.h" //加载FastLED库，此示例程序需要使用FastLED库
391. [[define]] NUM_LEDS 30 // 定义 LED 灯珠数量
- . [[define]] LED_DT 9 //定义 Arduino输出控制信号引脚
392. [[define]] LED_TYPE WS2812 //指定LED灯带型号
393. [[defineCOLOR_ORDERGRB]] //定义RGB 灯珠中红色、绿色、蓝色LED的排列顺序
394. uint8_t max_bright $=$ 128；//定义LED亮度控制变量，可使用数值为0～255，数值越大则灯带亮
度越高
395. CRGB leds[NUM_LEDS]; //建立名称为 leds 的灯带
396. uint8_t beginHue $=0$ //定义了起始色调数值，通过修改该数值可以定义开始的颜色
397. uint8_t deltaHue $\L=\L~1$ //定义了相邻灯珠色差，通过修改可以更改颜色变化的程度（中间隔了几
个色号）
10.
398. void setup(){
399. LEDS.addLeds<LED_TYPE，LED_DT，COLOR_ORDER>(leds，NUM_LEDS)；// 初始化灯带
400. FastLED.setBrightness(max_bright)；//设置灯带亮度
401. }
402. void loop（）{
403. beginHue $^{++}$ /\*此处执行了一个起始值自加1的命令，使得起始值从0\~255不断发生变化，
404. 因为其变量类型是uint8_t，所以会在加到 255之后直接再从0 重新开始 $^{\ast}/$
fll_rainbow(leds,NUM_LEDS,beginHue,9)；//灯带名称、数量，开始色值，相邻灯珠间的色值差9
405. FastLED.show(); //更新LED色彩
20． delay(25); //等待25毫秒

21.

（3）案例7-17: （fill_Gradient）静态渐变色灯带（RGB 模式） 以下代码可以快速将一条完整的灯带填充成渐变色，或者将一条灯带的某一段填充成渐变色，函数功能与含义见表7-4。

表 7-4 fill_gradient 函数的功能


<html><body><table><tr><td>函数举例</td><td>功能</td></tr><tr><td>fill_gradient_RGB(LEDs,O, CRGB:Red, 29, CRGB:Blue)</td><td>（灯带名，起始灯珠位置，起始灯珠颜色，结束灯珠位 置，结束灯珠颜色）</td></tr></table></body></html>

**完整程序如下** ::

406. [[include]] “FastLED.h" // 加载 FastLED 库，此示例程序需要使用 FastLED 库
407. [[define]] NUM_LEDS 30 // 定义 LED 灯珠数量
- . [[define]] LED_DT 9 // 定义 Arduino 输出控制信号引脚
408. [[define]] LED_TYPE WS2812 // 定义 LED 灯带型号
409. [[define]] COLOR_ORDER GRB //定义了 RGB 灯珠中红色、绿色、蓝色LED 的排列顺序
410. uint8_t max_bright $=~128$ // LED 亮度控制变量，可使用数值为～ 255， 数值越大则灯带亮
度越高
411. CRGB leds[NUM_LEDS]; //建立灯带 leds
8.
412. void setup(){
413. LEDS.addLeds<LED_TYPE，LED_DT，COLOR_ORDER>(leds，NUM_LEDS);// 初始化灯带各项参数
414. FastLED.setBrightness(max_bright)；//设置灯带亮度
12.
13.
415. void loop（）{
416. // fill_gradient_RGB 利用 RGB 颜色填充两种颜色之间的渐变
417. fll_gradient_RGB(leds,0,CRGB==Red,29,CRGB==Blue)；/\*5 个参数（灯带名称，起始灯珠号，起始
418. RGB 色彩，结束灯珠号，结束 RGB 色彩）\*/
419. FastLED.show(); // 更新 LED 色彩
420. delay(50); //等待500毫秒
421. }

（4）案例7-18: （fill_gradient）静态渐变色灯带（HSV模式） 利用这个函数填充可以增加第6个参数，含义如表7-5。

表7-5fill_gradient 的举例与功能


<html><body><table><tr><td>举例</td><td></td></tr><tr><td>功能</td><td>以上含义为，将LEDs灯带的第0号灯以CHSV（50，255，255）填充，第30个灯用CHSV （150，255，255）色填充，中间用最短的距离中的颜色填充 第6个参数有SHORTESTHUES和LONGESTHUES两种填充方式，即用最远或最近方式进行 过渡（色相环上两者之间的相对距离）</td></tr></table></body></html>

**完整程序如下** ::

422. [[include]] “FastLED.h" //加载FastLED 库，此示例程序需要使用FastLED 库
423. [[define]] NUM_LEDS 30 // 定义 LED 灯珠数量
- . [[define]] LED_DT 9 //定义Arduino输出控制信号引脚
424. [[define]] LED_TYPE WS2812 //定义LED灯带型号
425. [[define]] COLOR_ORDER GRB //定义了RGB灯珠中红色、绿色、蓝色LED 的排列顺序
426. uint8_t max_bright $=~128$ ；//LED亮度控制变量，可使用数值为0～255，数值越大则灯带亮度越高
427. CRGB leds[NUM_LEDS]; //建立灯带leds
8: void setup(）{
428. LEDS.addLeds<LED_TYPE，LED_DT，COLOR_ORDER>(leds，NUM_LEDS);// 初始化灯带各项参数
429. FastLED.setBrightness(max_bright)；//设置灯带亮度

11.
430. void loop() {
431. fll_gradient(leds, 0, CHSV(50,255,255), 29, CHSV(150,255,255), LONGEST_HUES);
432. /\*6个参数（灯带名称，起始灯珠号，起始CHSV色彩，结束灯珠号，结束CHSV
433. 色彩，以色相环上短距离或长距离进行过渡）\*/
434. FastLED.show(); // 更新 LED 色彩
435. delay(50); //等待50毫秒
18.

### 7.3.6 FastLED库的内置色板的调用
（案例7-19\~案例7-21）

除了以上诸如彩虹和渐变色的内置函数外，FaStLED库还有大量内置的色板可以快速调用，实现灯带颜色的控制，以下列举了部分内置的色板，并进行逐个测试，观察每个色板的特点，色板名称直接描述了颜色效果，色板函数的调用如表7-6所示。

表7-6内置函数的调用与含义


<html><body><table><tr><td>函数举例</td><td>fil_palette（LEDs,+5，30,0,8,OceanColorS_p,255,LINEARBLEND）</td></tr><tr><td>参数含义</td><td>一共有8个参数: LED灯带名称，从第5个灯珠开始，灯珠数量，起始颜色号，灯珠间的色差， 色板名称，亮度，过渡方式 最后一个参数有两种方式，分别为LINEARBLEND（线性混合）和NOBLEND（非混合）</td></tr></table></body></html>

（1）案例7-19: 静态的内置色板 列举了系统自带的8种色板，可以分别测试其效果。

436. [[include]] “FastLED.h" //加载FastLED库，此示例程序需要使用FastLED库
437. [[define]] NUM_LEDS 30 //定义LED 灯珠数量
- . [[define]] LED_DT 9 //定义Arduino输出控制信号引脚
438. [[define]] LED_TYPE WS2812 //定义 LED 灯带型号
439. [[defineCOLOR_ORDERGRB//定义了RGB灯珠中红色、绿色、蓝色LED的排列顺序]]
440. uint8_t max_bright $=$ 128；//LED亮度控制变量，可使用数值为0～255，数值越大亮度越高
441. CRGB leds[NUM_LEDS]; //建立灯带leds
442. void setup(）{
443. LEDS.addLeds<LED_TYPE，LED_DT，COLOR_ORDER>(leds，NUM_LEDS)；// 初始化灯带各项参数
444. FastLED.setBrightness(max_bright)；//设置灯带亮度
445. }
446. void loop （){
447. fll_palette (leds, NUM_LEDS,0, 8, OceanColors_P, 255, LINEARBLEND);
448. /\*填充色板（灯带名称，灯珠数量，起始灯珠位置，灯珠间的色值差，色板名
449. 亮度，混合类型)\*/
450. FastLED.show(); //更新LED色彩
451. delay(25); // 等待25毫秒
452. }
19。／\*以下是系统自带的色板共有8种类型，相当于8种配色方案，可以用色板名称逐个测试看下效果。
453. Cloudcolors_p（云彩）
454. LavaColors_p（熔岩）
455. OceanColors_p（海洋）
456. Forestcolors_p（森林）
24。 RainbowColors_p （彩虹）
25。 RainbowStripeColors_p（彩虹条）
457. PartyColors_p（聚会亮丽）
458. HeatColors_p（微暖热烈）\*/

（2）案例7-20: 动态的内置色板修改下面初始化和循环部分，在初始化前增加一个变量 uint8_t colorlndex，然后在循环部分调用这个变量实现流动的效果，函数的实例与含义如表 7-7 所示。

表7-7内置函数的调用与参数含义


<html><body><table><tr><td>实例</td><td>fill_palette (LEDs, NUM_LEDS,0, 8, OceanColorS_p,255,LINEARBLEND)</td></tr><tr><td>含义</td><td>灯带名称，灯珠数量，起始灯珠位置，灯珠间的色值差，色板名，亮度，线性混合类型</td></tr></table></body></html>

459. [[include]] “FastLED.h" //加载FastLED库，此示例程序需要使用FastLED库
460. [[define]] NUM_LEDS 30 // 定义 LED 灯珠数量
- 。 [[define]] LED_DT 9 // 定义Arduino 输出控制信号引脚
461. [[define]] LED_TYPE WS2812 //定义LED灯带型号
462. [[define]] COLOR_ORDER GRB //定义了RGB灯珠中红色、绿色、蓝色LED 的排列顺序
463. uint8_t max_bright $=128$ $//\$ LED亮度控制变量，可使用数值为0～255，数值越大则灯带亮度越高
464. CRGB leds[NUM_LEDS]; //建立灯带leds
465. uint8_t colorIndex $=0$ // 定义颜色索引变量为0
466. void setup(){
467. LEDS.addLeds<LED_TYPE，LED_DT，COLOR_ORDER>(leds，NUM_LEDS);/／ 初始化灯带各项参数
468. FastLED.setBrightness(max_bright)；//设置灯带亮度
469. }
470. void loop （){
471. colorIndex++; //初始化定义的变量（定义的是0），在此处循环部分不停地加1
472. fll_palette(leds, NUM_LEDS, colorIndex, 5, ForestColors_P, 255, LINEARBLEND );
473. /\*填充色板（灯带名称，灯珠数量，起始灯珠位置，灯珠间的色值差，色板名，
474. 亮度，混合类型)\*/
475. FastLED.show(); //更新LED 色彩
476. delay(25); // 等待 25毫秒
20.}

（3）案例7-21: 自定义色板的方法·如果以上内置色板的颜色效果仍然不够用，还可以自定义自己的色板，编写自己独特的渐变色。以下列举了用三种方式自定义色板，分别为CRGBPalette16；CHSVPalette16以及myProgmemPalette。16指的是利用16个关键颜色来代表0～255色阶的颜色，中间颜色是自动补上的。程序对三种自定义的色板进行了测试，

三种色板的优缺点如表7-8所示。

表7-8三种不同模式自定义色板的优缺点比较


<html><body><table><tr><td>CRGB16</td><td>比较容易定义所需要的色彩变化</td></tr><tr><td>CHSV16</td><td>动态内存占用最多，也可以改变色板中颜色的信息</td></tr><tr><td>PROGMEM</td><td>动态内存占用最少，色板存放在程序内存中，色板中的颜色信息不能改变（因为它利用的是内 置色彩名）</td></tr></table></body></html>

注: 动态内存指Arduino板子上的内存，程序内存指IDE编辑器中内存。

**完整程序如下** ::

477. [[include]] “FastLED.h" //加载 FastLED 库，此示例程序需要使用 FastLED 库
478. [[define]] NUM_LEDS 30 // 定义 LED 灯珠数量
- . [[define]] LED_DT 9 // 定义 Arduino 输出控制信号引脚
479. [[define]] LED_TYPE WS2812 // 定义 LED 灯带型号
480. [[define]] COLOR_ORDER GRB //定义 RGB 灯珠中红色、绿色、蓝色LED 的排列顺序
481. uint8_t max_bright $=~128$ // LED 亮度控制变量，可使用数值为～255，数值越大则灯带亮度越高
482. CRGB leds[NUM_LEDS]; //建立灯带leds
483. uint8_t colorIndex;
484. //以下是第--个色板CRGBPalette16
485. CRGBPalette16 myColorPalette $=$ CRGBPalette16 $/^{*}$ 用户目定义的RGB色板，从0～255号颜色，16个颜色
486. 就是色板的形状，其对应的同样的是0～ 255，每个颜色之间是16种颜色，详
487. 见下面的注释\*/
488. /\* 0\~ 15 GREEN, 16 \~ 31 GREEN, 32 \~\~ 47 Black, 48 \~ 63 Black,(4个颜色用
489. 来64个色号）\*/
490. CRGB==Purple, CRGB==Purple, CRGB==Black, CRGB==Black,
491. // 64 \~ 79 Purple, 80 \~ 95 Purple, 96 \~ 111 Black, 112 \~ 127 Black,
492. CRGB==Green, CRGB==Green, CRGB==Black, CRGB==Black,
493. // 128 \~ 143 Green,144 \~ 159 Green, 160 \~ 175 Black,176 $\sim$ 191 Black,
494. CRGB==Purple, CRGB==Purple, CRGB==Black, CRGB==Black );
495. // 192 \~ 207 Purple,208 \~ 223 Purple,224 \~ 239 Black,240 \~ 255 Black
496. //以下是第二个色板CHSVPalette16
497. CHSVPalette16 myHSVColorPalette $=$ CHSVPalette16//用户自定义的HSV色板
498. CHSV(0, 255,200), CHSV(15, 255,200), CHSV(31, 255,200), CHSV(47, 255,200),
499. CHSV(0, 255,0)， CHSV(15， 255,0)， CHSV(31, 255,0)， CHSV(47,255,0),
500. CHSV(0, 255, 200)， CHSV(15, 255,200)， CHSV(31, 255, 200)， CHSV(47,255, 200),
501. CHSV(0,0,200)， CHSV(15,0,200), CHSV(31,0,200)， CHSV(47,0, 200));
27.
502. //以下是第三个色板PROGMEM色板
503. Progmem Palette16 myProgmemPalette $=$ PROGMEM{
- 0. CRGB==Red, CRGB==Gray, CRGB==Blue, CRGB==Black,
- 1. CRGB==Red, CRGB==Gray, CRGB==Blue, CRGB==Black,
- 2. CRGB==Red, CRGB==Red, CRGB==Gray, CRGB==Gray,
- 3. CRGB==Blue, CRGB==Blue, CRGB==Black, CRGB==Black };
- 4. void setup(）{
- 5. LEDS.addLeds<LED_TYPE, LED_DT, COLOR_ORDER>(leds, NUM_LEDS);
- 6. //初始化光带各项参数
- 7. FastLED.setBrightness(max_bright);
- 8. //设置灯带亮度
- 9.
504. void loop（）{
505. fll_palette (leds, NUM_LEDS, 0, 8, myProgmemPalette, 255, LINEARBLEND);
506. /\*填充色板（灯带名称，灯珠数量，起始灯珠位置，灯珠间的色值差，
507. 色板名，亮度，混合类型)\*/
508. //注释掉上面的，可以用下面两个色板测试，观察其效果。
509. //fll_palette (leds, NUM_LEDS, 128, 8, myColorPalette, 255, LINEARBLEND );
510. //fll_palette (leds, NUM_LEDS, 128, 8, myHSVColorPalette, 255, LINEARBLEND );
511. FastLED.show(); //更新LED色彩
512. delay(25); // 等待25毫秒
49.

### 7.3.7 常用灯光控制函数的综合应用
（案例7-22、案例7-23）

除了以上用到的灯光控制函数，FaStLED库还有大量控制函数，其函数名称与功能如表 7-9 所示。

表7-9常用函数的功能举例与含义


<html><body><table><tr><td>函数名</td><td>功能</td><td>举例</td><td>含义</td></tr><tr><td>ColorFromPalette</td><td>从一个色板中选 取一个颜色填充到 固定的灯珠上</td><td>LEDs[O] = ColorFrom Palette(RainbowColors_ p, 0, 128, LINEARBLEND);</td><td>将LED灯带的第1个灯珠设置 为RainbowColors_p色板中颜色 序号为O的颜色（红色）。LED亮 度为128，色彩过渡为线性过渡效 果为线性混合（LINEARBLEND）</td></tr><tr><td>EVERY_N_ SECONDS</td><td>时间间隔函数， 程序内容将定时执 行（亳秒）</td><td>EVERY_N_SECONDS （10)</td><td>执行时间间隔为10秒</td></tr><tr><td>fadeToBlackBy</td><td>将某一个灯珠的 颜色亮度值调到一 个固定值</td><td>fadeToBlackBy (LEDs, 30,10);</td><td>将LED灯带的30个灯珠亮度调 到10</td></tr></table></body></html>

续表


<html><body><table><tr><td>函数名</td><td>功能</td><td>举例</td><td>含义</td></tr><tr><td>random8</td><td>返回一个随机数</td><td>random8(10)</td><td>返回0~9之间的随机数值</td></tr><tr><td>millis ()</td><td>回自Arduino开发 板开始运行到当前 经过的毫秒数，大 约50天后，该数字</td><td></td><td>unsignedlong，如果程序员尝试 使用较小的数据类型进行算术，则 可能会发生逻辑错误int。偶数签名 long可能会遇到错误，因为其最大</td></tr><tr><td>beatsin8()</td><td>器，它的返回值会 沿着正弦曲线返回 数值</td><td>beatsin8(10,0,255)</td><td>每分钟产生循环次数</td></tr></table></body></html>

以下为beatsin8（10,0,255）返回值示意图（图7-14）。

这一示例中第一个参数为10。说明此函数所产生的正弦曲线周期时间为6秒（1分钟有60 秒，60除以参数10 等于 6 秒）。第 2个参数为 0，这说明此函数所产生的正弦曲线最小返回值为0（图7-14），如绿色数字所示。第3个参数为255，说明此函数所产生的正弦曲线最大返回值为255（图中红色数字所示）。也就是最终在6秒内返回的数值是沿着这条正弦曲线有序分布的。

![images/1e9d40e2b57d7d4b4f87814273688a5fb276c9ab0c9be5af8ed4c17505169c60.jpg](https://i.imgur.com/wlWZdtv.jpeg)
图7-14beatsin8函数的返回值形态

（1）案例7-22: 间隔闪烁的小星星（一）本例利用多个函数实现了在灯带上随机选取几个不固定的灯珠进行闪烁，类似天空中的星星。案例用到的几个函数分别为:Random8，colorFromPalette，EVERY_N_SECONDS，FadeToBlackBy 等，完整代码如下: 

513. [[include]] “FastLED.h" //加载FastLED库，此示例程序需要使用FastLED库
514. [[define]] NUM_LEDS 30 // 定义 LED 灯珠数量
- . [[define]] DATA_PIN 9 // 定义 Arduino 输出控制信号引脚
4。 [[define]] LED_TYPE WS2812 // 定义 LED 灯带型号
515. [[define]] COLOR_ORDER GRB//定义了 RGB 灯珠中红色、绿色、蓝色 LED 的排列顺序
516. [[define]] twinkleInterval100//闪烁间隔时间（毫秒）
- . [[define]] twinkleChance 80//闪烁数量，数值越大闪烁越多（0～255）
517. uint8_t max_bright $_{=128}$ ；/\*LED 亮度控制变量，可使用数值 ～255，数值越
518. 大则灯带亮度越高\*/
519.  CRGB leds[NUM_LEDS]; //建立灯带leds
520.  void setup(）{
521.  Serial.begin(9600); //启动串行通信
522.  delay(1000); // 稳定性等待
523. LEDS.addLeds<LED_TYPE,DATA_PIN, COLOR_ORDER>(leds ,NUM_LEDS);
524. //初始化灯带
525. FastLED.setBrightness(max_bright);
526. //设置灯带亮度
527. }
528. void loop(）{
529. int pos $=$ random8(NUM_LEDS) ; $/^{*}$ 将随机函数获取的值赋给了一个名字为pos 的整数
530. 类型变量\*/
531. EVERY_N_MILLISECONDS(twinkleInterval) $\{/^{*}$ 每隔几毫秒执行一次，这里定义的
532. 是100毫秒（见最上部）\*/
533. if(random8()<twinkleChance){
534. //如果获取到的随机数小于 80，（见上部 twinkleChance 80)
535. leds[pos] $=$ ColorFromPalette(PartyColors_P, random8(255),128,LINEARBLEND);
536. /\*把随机的一个灯珠（pos）用partycolors 色板中，第randor
537. （0～255）个灯，以128的亮度，线性混合的方式点亮\*/
25.
538. }
539. EVERY_N_MILLISECONDS(20){//每20毫秒执行一次下面的内容
540. fadeToBlackBy(leds,NUM_LEDS,10)；// 将灯带上30 个灯珠的亮度调到 10（基本灭掉了
541. }
- 0. FastLED.show(); // 更新LED 色彩
- 1. delay(50); //等待50毫秒
- 2. }

（2）案例7-23: 间隔闪烁的小星星（二） 代码如下。

- 7. [[include]] “FastLED.h" //加载FastLED 库，此示例程序需要使用FastLED 库
- 8. [[define]] NUM_LEDS 30 //定义LED 灯珠数量
- 9. [[define]] LED_DT 9 //定义 Arduino输出控制信号引脚
542. [[define]] LED_TYPE WS2812 //定义LED 灯带型号
[[define]] COLOR_ORDER GRB //定义了RGB灯珠中红色、绿色、蓝色LED的排列顺序
42．uint8_t max_bright= 128；// LED 亮度控制变量，可使用数值为 θ～ 255，数值越大则灯带亮度越高
43.CRGB leds[NUM_LEDS]; //建立灯带leds

543. void setup(){

544. LEDS.addLeds<LED_TYPE，LED_DT，COLOR_ORDER>(leds，NUM_LEDS)；//初始化灯带各项参数
545. FastLED.setBrightness(max_bright); //设置灯带亮度
47.
546. void loop(）{
547. fll_gradient(leds, 0, CHSV(50, 255, 255), 29, CHSV(150, 255, 255), LONGEST_HUES);
548. //光滑过渡显示两种颜色
549. addGlitter(60)；/\*Glitter 是一个闪烁的内置函数，60 是一个参数，数字大小会影响闪烁灯珠
550. 的数量\*/
551. FastLED.show()；//更新LED色彩
552. delay(50); //等待50毫秒
553. }
554. /\*_-addGlitter 函数说明-
555. random8(）的返回值是θ～ 255 之间的随机整数。当 random8(）返回值小于用户传递到 addGlitter 函数中的
556. chanceOfGlitter 参数时，Arduino 将在任意 leds 灯带上的任意序号灯珠(leds[random8(NUM_LEDS)])
557. 上显示白色（CRGB::White）。否则 addGlitter 函数将不进行任何操作而返回。基于以上原因，如果用户传
558. 递到 addGlitter 函数中的 chanceOfGlitter 参数越大，则产生随机点亮闪烁效果的机会也就越大。通过以上
559. 操作，灯带将产生随机点亮LED 为白色的效果，犹如星光闪烁\*/
560. void addGlitter(uint8_t chance0fGlitter) {
561. if (random8() $\textless$ chance0fGlitter){
562. /\*当 random8（）返回值小于用户传递到 addGlitter 函数中的 chanceOfGlitter
563. 参数时\*/
564. leds[random8(NUM_LEDS)] $=$ CRGB::White;
565. /\*Arduino 将在任意 leds 灯带上的任意序号灯珠（leds[random8(NUM_LEDS)])
566. 上显示白色（CRGB::White）\*/
69.
70.

## 7.4 灯光控制之图像映射

在灯光控制领域，程序控制与图像映射是两个基本的思路和技术路径，通过程序控制需要设计师有良好的程序编写能力，而用图像映射的方式控制灯光将变得更加轻松友好。但不同的控制方式有其不同的优缺点，通过对图像映射方式的学习，再系统对比两种控制方式的差异。

### 7.4.1 Touchdesigner矩阵屏图像映射
（案例7-24）

本节用Art-Net控制器点亮矩阵屏。根据上面灯光映射的原理，我们可以用灯带做面积较大的矩阵屏结构，用来实现更加丰富的表现效果，这也是LED 屏幕的基本原理。将Touchdesigner 里面的颜色和图形映射到矩阵屏上，实现更复杂的图形信息显示。

如果要将一个完整的图像映射到灯光矩阵上，需要将画面处理成多幅画面，每一幅图像对应一条灯带，然后按照顺序进行排列，然后将文件中的图像同步映射到实体灯带上。在正式设计文件前需要先确定物理灯板的走线方式为蛇形（图7-15），这影响着下一步图像映射的顺序和方向。

![images/b27635a5a94c517d4d23dbfcfccab4772c559f59a195ab2d2f0739dc18555577.jpg](https://i.imgur.com/cDSlcdo.jpeg)
图7-15灯带的接线方式

程序设计: 具体的步骤是先建立一个与实体环境中一样大小的二维图像TOP（像素信息） $>$ 图像裁剪（把完整的图像分成多条和灯带一样长的像素行） $>$ CHOP（利用toCHOP元件获取 RGB 通道数据） $>$ Shuffle(分离所有通道信息） $>$ Reorder（重新排列RGB的顺序，保证RGB三个通道成为一个独立的组） $>$ Merge（将所有排列好的通道数据合并在一起） $>$ Select选择可以输出的最大通道数量），此处选择了 $169\times3{=}507$ 个通道为一个单元$>$ DMX0Ut输出，通过DMX元件调整输出口将控制信号输出给灯带（图7-16）。

![images/e653669c4d016e6cc2dba576549875f4f0e3948fa214c15e7a5153b4b4d1b5f0.jpg](https://i.imgur.com/J9mpHSW.jpeg)
图7-16灯带的数据设计与输出

建立原始图像ramp1，相关设置见图7-17。

![images/b17fddfdddaff0e9688a4e720eeabdecad7f86398ca0c2e8e71eccb22ae16512.jpg](https://i.imgur.com/CE95j4A.jpeg)
图7-17颜色设置

- 设定渐变色，形成一个渐变色环。

- 在 Phase 中输入 absTime.seconds，让色环运动起来。

- 分辨率设定成 $16\times16$ （灯板的尺寸大小，像素大小和实际灯板的尺寸一致）。

增加Level TOP 调整明度，防止光太亮刺眼，后面添加 null备份。

图像裁剪（Crop TOP 元件）: 将 $16\times16$ 的图像裁成16 份，一般通过四个方向裁剪后剩下一个固定的行，Touchdesigner 中的坐标原点在左下角（图7-18）。

![images/8aaaae4d6260cb4891bb0934e36e0e6b5290815b520bb5c2ef1f3489ff96f08c.jpg](https://i.imgur.com/WTv2Mqe.jpeg)
图7-18·Touchdesigner的坐标规范

crOp1TOP: 第一个裁切元件（图7-19）。

![images/03551485501127b648a773460a7a6d3c6c6e9aee5ac8febfa0ba8e18d4eb159d.jpg](https://i.imgur.com/XnkjSGU.jpeg)
图7-19裁切元件设置

- CropLeft（剪裁左边）: 图像的左边坐标为 0。
- Crop Right（剪裁右边）: 图像的右边坐标16。
- Crop Bottom（剪裁底部）: 图像的底部坐标为 0。
- Crop Top（剪裁上方）: 图像的上方坐标1。
这样得到一个最底部的一条图像，高度像素为1。
用同样的方法把整个图像裁切完备。

- Flip TOP: 翻转方向，因为实体灯板是蛇形接线结构，因此每一条图片要进行×方向的翻转，此处第一条无需翻转（图7-20），下面每个元件都需间隔翻转一下，后面增加 null备份。

![images/6141c1aa651b212a7702656728e4df59b9a3563492b75d1879d3cbd7ec5d9f44.jpg](https://i.imgur.com/54buaWv.jpeg)
图7-20翻转元件设置

- 此处×，y方向没有做任何调整。

- Flop: 翻转指两个方向调换，将×坐标替换为y，把y坐标替换为×（此处不做替换）。

注意: 下一个翻转元件需要翻转×坐标。

top to1CHOP: 数据转换，将图像信息转换为通道数据（图7-21）。

![images/83798a286f48aa13ecab094b593a3675ebf7a880ee235fd79d35d378c606c92d.jpg](https://i.imgur.com/gfkGXni.jpeg)
图7-21数据转换设置

RGBAUnits: 四个通道的数值取0\~255（灯的亮度值）。

SampleRate:采样率为60,变化更流畅，一般30也可以。

Export Method: 输出方法，根据名字输出数据。

shuffle1CHOP: 把前面元件中的数据重新排列，将R抽离出来排完再排G，最后排B（图7-22）。

![images/77eb01b915a4d1feb75b0bd419ed6d15eff5fc16639a1402a07ee905a8174931.jpg](https://i.imgur.com/XyjbWCE.jpeg)
图7-22数据分离重新排序设置

排列方法: 分离所有采样的数据，把所有数据按照顺序排列好。

Reorder CHOP: 重新排列通道数据（图7-23）。

![images/746640afb2c4b5b9762185c314392b90a5c62897c1a3b4246200a05943e43bfd.jpg](https://i.imgur.com/63TpGPI.jpeg)
图7-23重新排序设置

- Channel Reorder Method: 通道重新排序方法，此处选择合并成N个群组。

下面的NValue定义的是一组有几个通道，此处选择一组有 3个通道（rgb）。

下面将所有裁剪的数据进行相同的处理后进行合并输出。

MergeCHOP: 合并所有数据，将所有数据合并到一起（图7-24）。

![images/ab1471190ac6caca22fe18d97a70112c4ed914d170d8b69c222dee287731f11a.jpg](https://i.imgur.com/jO9YFWU.jpeg)
图7-24数据合并方式设置

Align: 对齐方式，此处选择自动对齐。

Duplicate Names: 重复的名称，此处将其保持唯一性（Make Unique）。

添加 null后分成两组输出。

select1 CHOP: 选择第一组输出数据（Art-Net 协议中一个Universe 最多 512 个通道，3个通道一个灯珠的话，最多可以输出 $170\times3{=}510$ 个通道），因此将其定为170个灯珠一组输出（图7-25）。

![images/51912fef634fb1b003c3636935c0d61818db9a5e7a0838a708df4283d54f0ec1.jpg](https://i.imgur.com/EiaTsBu.jpeg)
图7-25数据选择设置

Channel Names:[rgb][0-169] ，表示输出170 个灯珠。

以上设计完成了一个 $16\times16$ 的矩阵屏工程文件，根据这个原理，理论上可以制作无限大的矩阵屏，以映射的方式投射到LED上面。

### 7.4.2 用LED控制器点亮矩阵屏
（案例7-25）

LED 控制领域有大量的专业控制器解决方案，它们具有更强大的信号处理和传输能力,在 LED 控制方面有着独特的优势。大部分此类控制器都支持 Art-Net 传输协议。本节重点讲解一款专门用于LED控制的分控器（华灿兴H801RC分控器），它的配置相对简单，综合性价比和稳定性高，如图7-26所示，其基本特点如下。

![images/e26ab11c917eb056fd4c71391619f40ce754fa627fbdd8e7f363f891b84bf1de.jpg](https://i.imgur.com/8tQQLv7.jpeg)
图7-26H801RC分控器

良好的光源兼容性。支持如 LPD6803、LPD8806、LPD6812、LPD6813、LPD1882、LPD1889、LPD1883、LPD1886、DMX512、HDMX、APA102、MY9221、P9813、LD1510、LD1512、LD1530、LD1532、UCS6909、UCS6912、UCS1903、UCS1909、UCS1912、WS2801、WS2803、WS2811、WS2812、DZ2809、SM16716、TLS3001、TLS3002、TM1812、TM1809、TM1804、TM1803、TM1914、TM1926、TM1829、TM1906、INK1003、BS0825、BS0815、BS0901、LY6620、

DM412、DM413、DM114、DM115、DM13C、DM134、DM135、DM136、74HC595、6B595、MBI6023、MBI6024、MBI5001、MBI5168、MBI5016、MBI5026、MBI5027、TB62726、TB62706、ST2221A、ST2221C、XLT5026、ZQL9712、ZQL9712HV 等几十种驱动芯片型号，适用于较小的外墙广告、舞台背景等场景。

2 良好的软件兼容性。支持多种灯光控制软件，如 MADRIX、FreeStyler、MagicQ、Touchdesign 等一切支持 Art-Net 输出的控制软件。

- 强大的控制力。一般每台控制器都能输出控制近万个LED灯珠，根据项目需要也可以通过自定义IP地址，将其连入到路由器或交换机中实现多台分控器同时工作，以便控制更多的像素点。

567) 此类控制器在出厂时都有固定的IP地址（此款控制器的 $\Vdash$ 地址最后一组数字默认为18，前面三组数字自适应，可以利用自带软件对其IP地址进行自定义）。

（1）硬件连接方案

灯带排列: 选择可以被控制器兼容的灯带按顺序排列成行，单行长度不够可以串接，根据矩阵屏的大小确定所需灯珠的数量和长度，本案例选择了WS2812灯珠、 $16\times16$ 的矩阵屏，硬件连接的两种情况如下。

②单台控制器的连接: 在灯珠数量不多的情况下（通常一台控制器都能控制 8000 个以上的灯珠）选择单台控制器即可，电脑－控制器－灯带（灯板）的连接方式见图7-27，利用网线将电脑与控制器连接。

![images/e1827eb3b26a19d9d62cbf93b5df6ca26c5f83b27c85999f900ab240d37a4e88.jpg](https://i.imgur.com/hSRPVTK.jpeg)
图7-27单台控制器的连接

- 多台控制器的连接: 如控制数量不足可利用路由器或交换机进行多台控制器连接，用网线把一台电脑与路由器或交换机连接，然后用网线把多台控制器与路由器或交换机进行连接（图7-28）。多台连接时需要把路由器或交换机设置成固定IP地址，同时把控制器设置成独立的IP地址。

注: 控制器、路由器（交换机）的 $\Vdash$ 地址需要在同一个域中（IP地址的前三组数字相同，后一组数字不同）。控制器的IP地址需要通过软件进行修改，本控制器可以利用官方提供的软件进行IP地址的修改，软件为LEDStudio_V4_95。具体修改方法: 用网线将控制器与电脑进行连接，打开LEDStudio 软件 $>$ 设置菜单>Art-Net 设置 $>$ 搜索控制器 $>$ 输入新的IP地址 $>$ 保存到控制器即可。

![images/0dffcf3a77c8b321049841848755ae2b2215b253fb3a92e4df4b4dbd50408b97.jpg](https://i.imgur.com/57RhpvL.jpeg)
图7-28多台控制器的连接

（2）通信与效果测试硬件连接好后进行输出测试，此处仍然采用案例7-24 的案例文件，在Touchdesigner打开文件后进行数据输出设置。文件内容与输出终端均为 $16\times16$ 灯的矩阵屏，在DMXOutCHOP元件中设置好控制器的 $|{\mathsf{P}}$ 地址与电脑的 $\Vdash$ 地址（图7-29），即可以实现数据通信，此时文件的内容直接会传输到矩阵屏上。

![images/6adc3914c1fd265e53d9901e2304ff382aa46a6fa516b064f5c40cfc1deecedc.jpg](https://i.imgur.com/3H8W66c.jpeg)
图7-29通信设置

（3）优缺点分析优点: 控制器部分的性价比较高，稳定性得到了很大的提升。缺点:$①$ 项目规模比较有限。虽然控制器可以支持控制巨量的LED灯，但通过工程文件可以看出，这种利用Touchdesigner 进行灯光控制的方案对计算机的硬件算力要求很高，要在该软件中控制几万甚至几十万个灯的时候根本无法完成。 $②$ 硬件成本和技术门槛较高。这种图像映射的方式无法脱离计算机硬件与软件，非专业人士较难完成。

如果仅从灯光控制角度看，大量控制器厂商提供的软件已经具有了强大的灯光编程能力，软件内部有很多内置的灯光效果可以选择，几乎可以胜任所有的灯光创作项目，下一节利用控制器自带程序进行灯光控制便是其中非常主流的解决方案。

### 7.4.3 控制器图像映射控制方案

（1）控制器介绍针对不同的控制需求，目前市场上已经有几十款不同的控制器产品，它们在运行时可以脱离计算机软硬件，把自身配套软件编写的灯光控制程序存入SD卡，利用控制器本身就可以对灯光效果进行控制，不仅极大降低了硬件成本，还提升了运行的稳定性，同时还有定时播放等更多实用功能，可以广泛应用于户外景观照明和商业环境照明中。相比依靠专业的第三方软件，极大降低了灯光秀创作的技术门槛，为艺术专业背景的设计师进行灯光秀创作提供了另一种解决方案。华灿兴的H803SA是一款非常主流的控制器产品（图7-30），配套控制软件为LEDBuild，该软件可通过官方获得教育版授权码，其基本特点如下:

控制量大，单机八口输出，最多控制8192点。SD卡支持FAT32、FAT16格式，最大容量为64G，最多允许64个DAT文件，播放顺序根据文件名按字母进行排序。

- 控制简单，有三个按钮和LCD显示屏，便于设置操作。

兼容性广，可接DMX控制台和多种灯光控制软件，支持常见的几十种驱动芯片的灯带。

![images/56b49504f3aa27be6da64c3e9f98abc46574e3f0a04562ba7b26be0b2d8e95dd.jpg](https://i.imgur.com/QSdcWeh.jpeg)
图7-30LED电源同步控制器H803SA

（2）控制器的基本操作

三个按键分别是“mode”键、“_”键、“+”键。按“mode”键，切换模式，按一′或 $^{\mathrm{~\small~{~\chi~}~}}+$ 键进行设置，按下按键LCD 屏背光亮，停止按键2秒后自动保存修改的参数，

8秒后背光灭。

FileX: ×为序号，显示当前播放的DAT文件名。按“+”键跳到下一个文件，按“_”键跳到上一个文件。

CIkRate: 扫描时钟频率，范围是 $12.5{\sim}0.1$ MHz。

4 Speed: 播放速度，范围是1\~100帧每秒。多台同步使用时，每台控制器的播放速度必须设置一样。

5 Bright:设置亮度，范围是0\~15。LPD6813、P9813不能调节亮度。

?CycleMode: 循环模式，All 表示连续循环播放 SD 卡中所有 DAT 文件；Single 表示只循环播放当前文件，当前文件可由“-”或“ $"+"$ 键更换。

7 PortOutMode:若是单线芯片，设置端口输出模式，可用245输出或用RS485输出。8 InvertColors: 颜色是否取反。9 DMXAddreSS: DMX起始地址设置，默认为1。共占用三个通道，依次为文件、速度和亮度，取值范围为0\~255。

（3）LCD报错提示含义

“Please insert SD”: 未插入 SD 卡，或 SD卡未插好。“Reading.."”: 正在读取 SD 卡。
-  “NotDATFile!”: SD卡内无有效DAT文件。"Used timeover”: 控制器已加密并且使用次数已完。
5 “Port number err”: 端口数目错误。“Pixel is too much”: 控制的点数太多。“Init..”: SD卡读取成功，正在进行其他初始化。

### 7.4.4 软件介绍

由于LED控制的任务和需求相对比较单一，围绕灯光控制的技术已经非常成熟，国内外专业LED控制软件的编写思路基本相同，此类软件体量相对较小。本书以华灿兴控制器配套的软件LEDBuild为例讲解LED控制的基本思路和技术细节。掌握基本的创作思路后，即可根据具体的软件快速上手。

（1）界面总览界面总体分为菜单栏、工具栏和控制面板三个部分。软件功能包括三个基本模块，即灯光设置、花样编辑（灯效）和效果演示，每个模块对应的菜单功能、工具栏与控制板参数均不相同。软件打开时默认开启的是花样（灯效）模块的界面(图7-31）。

![images/52744d7098b60b9dd3fbfc71790a0130e2a57f6227c27ef80bbc47e629dbd7e2.jpg](https://i.imgur.com/4gP3Sxg.jpeg)
图7-31花样编辑界面的基本功能和布局

（2）模块切换 目前本软件的主要功能是灯光设置和花样编辑（灯效）模块。

从花样编辑模块进入灯光编辑模块，方法: 从花样编辑（灯效）模块中的设置菜单>点击设置造型，即可进入到灯光设置模块（或者执行Shif $+S$ ），主要完成实际环境中中灯具的排列方式、灯光属性及控制器的相关设置。

从灯光编辑模块进入花样编辑模块，执行工具栏中的返回按钮即可（图7-32）。

![images/f48fda5deafe33062913b5d37efe6584da51c5042eba4cab524536f20259dd38.jpg](https://i.imgur.com/JsJrBoO.jpeg)
图7-32工具栏

### 7.4.5 灯光造型设置模块

依据灯光控制的基本逻辑，先从灯光设置讲起，从花样界面的设置菜单 $>$ 设置造型(Shift +  S ），进入灯光造型界面（图7-3- ）。本界面中“文件、编辑和视图”菜单均为软件常见的基本功能，此处重点讲解设置菜单和控制栏的相关功能，主要解决实际环境中的灯光排列和造型的问题，这是灯光作品设计的基础。

![images/8402b5c10b5a05ad2355e4e5a9312fd2732aeb5b75d2a9b1c0ac907e0e5d4bb6.jpg](https://i.imgur.com/x1VbSNR.jpeg)
图7-3- 灯光造型界面

（1）灯光设置菜单详解 在灯光设置界面下，设置菜单下的各条命令及功能如表7-10所示。

表7-10灯光设置的菜单与功能


<html><body><table><tr><td>菜单</td><td>功能</td></tr><tr><td>设置背景</td><td>二级菜单有设置背景的方式，包括画板自由绘制、输入文字、从文件导入和导入</td></tr><tr><td>删除背景</td><td>如对制作好的背景不满意，可以执行“删除背景”</td></tr><tr><td>背景连线</td><td>注意: 框选时鼠标要先点选工具栏上的“添加”图标，点选“垃圾桶”图标再框</td></tr><tr><td>背景图片大小</td><td>调整背景图片的尺寸</td></tr><tr><td>端口操作</td><td>对端口进行交换、合并和删除、移动、复制操作</td></tr><tr><td>线路设置</td><td>根据线路可以独立设置灯具类型，项目中尽量使用同一种灯具</td></tr></table></body></html>

续表


<html><body><table><tr><td>菜单</td><td>功能</td></tr><tr><td>控制器设置</td><td>弹出“控制器设置”对话框，设置亮度、时钟速度（根据控制芯片选择）、灰度 级别（0~255）、Gamma、灯具类型、驱动芯片类型及颜色是否取反，最后选择控 制器类型（指控制器型号后面的字母），见图7-34</td></tr><tr><td>多控制器设置</td><td>项目灯珠数量多时可以添加多个控制器，此处配置多台控制器，分控编号指分控 机的序号 分控数目是指带多少个分控，若是单机，数目只能是1，若是主控，可以1个或 若干个（图7-35）</td></tr><tr><td>粘贴设置</td><td>对剪贴板中的数据进行镜像和旋转操作</td></tr><tr><td>允许像素点重复</td><td>若选中这个命令，在同一位置可以重叠多个点</td></tr><tr><td>边框调整</td><td>修改造型的宽和高（在现有造型基础上向四周增加一定数量的灯珠）</td></tr><tr><td>2D转3D</td><td>转换成3D空间阵列</td></tr><tr><td>控制器密码</td><td>添加密码或解除密码</td></tr><tr><td>鼠标滚轮功能</td><td>定义鼠标的基本功能</td></tr><tr><td>开始实时描点</td><td>实时显示灯珠连线的状态</td></tr><tr><td>通信设置</td><td>选择通信方式是网口、串口或是互联网等，并做相应设置</td></tr><tr><td>设置端口最大点数</td><td>根据控制器不同设定该数值</td></tr></table></body></html>

![images/a8f520027627146af61a2e69b9ab80e48db8cbabb891c654eee588f9ed3f8d8a.jpg](https://i.imgur.com/XBvpXw4.jpeg)
图7-34控制器设置
图7-35多控制器设置

（2）灯光造型面板介绍 灯光造型控制板主要规定了灯珠的连接方式和如何输出（图7-36）。

- 接线方式: 几种主要的接线方式见图7-37。
最短距离: 线路按最近点连接。

![images/80ebae1364cfb2d627f0c8ba58e8a3a25aef38e794906a59acd6744381be1187.jpg](https://i.imgur.com/2hcldqz.jpeg)
图7-37接线方式

- 分控设置: 此处主要根据选择的控制器进行选择，线路是指端口数量，不同的控制器其端口数量不同。“一条线路一个分控”指1个单独控制器上只有1个输出端口；“四条线路一个分控”指1个控制器上有4个输出端口。设定好这个可以看到下面显示栏里的灯珠数量和分控器的状态。

- 显示模块: 添加线路时，将选择的显示模块铺在设置的区域（需要先定义模块）。

![images/d33ebf2ebf90b2f491f59e026c5138d14fb018d3f361b7a130221a521ac69701.jpg](https://i.imgur.com/ASGQOsN.jpeg)
图7-36光源硬件连接设置

- 线路限定点数: 便于自动布线，与控制器实际控制像素点无关（即每一条现实中的线路上有多少个灯珠）。添加线路时，当前线路灯光点数达到这个限定数目时，会自动添加一条新的线路。在列表第二栏处显示了当前每条线路已添加的像素点数。

总端口数: 显示了所用的端口数量。

- 合并区域: 需要先定义区域。

$④$ 分组: 打开编辑菜单可以创建分组（可以连续添加对象），分组创建完之后可以在此处查看。

完成所有灯光设置后，保存＊.SCU文件以备后续调用，返回花样（灯效）设计界面，进行灯光效果的设计。

### 7.4.6 花样（灯效）设置模块

在造型设置界面中的工具栏上单击第1个按钮“返回”，回到花样界面，在这里完成整个花样（灯效）的制作。界面包括菜单栏、控制栏和操作区（图7-38）。

![images/9ddce19601e94f48b0ba243489e7307730e3710491adf1779c10a51c7123ff1d.jpg](https://i.imgur.com/vJ7qAia.jpeg)
图7-38花样设置界面

（1）花样（灯效）菜单介绍该界面中文件、编辑和视图菜单均与一般图形软件相同，主要是对文件的操作和视图设定，此部分重点讲解工具、设置和内置花样菜单。

首先，工具菜单提供了一系列动态画面播放、制作相关的工具和设置（图7-39）。

![images/3cdd7b61c50b61a427f8b68cc3c44aadbfee8aba13495833ab85a1c20e95dc9e.jpg](https://i.imgur.com/b40O9cS.jpeg)
图7-39工具菜单

- 播放／停止: 对应工具栏上的“播放和停止”按钮。

画笔编辑: 使用Windows系统自带的画笔工具，对某一个单独的帧进行编辑。

-  视频采集转换: 捕获电脑显示器上某一区域，转换成帧数据，可连续采集，还可进行播放预览等相关操作（具体参数见采集窗口）。也可直接打开视频文件或SWF文件。

批量录制: 类似采集，可以独立存储。

- 时间表: 定义了文件播放的具体时间列表。

- 发送文件: 通过互联网向控制器远程发送文件内容。

- Dat文件属性: 可显示Dat文件的芯片类型、总帧数、端口数等属性信息。

其次，设置菜单，对工作区域、灯光造型、效果、系统等进行相关设置（图7-40）。

![images/f5061d6197d1c273376b4c2dadd34ebf9834d01ebf1f4b3094edda778f62d24a.jpg](https://i.imgur.com/ylO0bi2.jpeg)
图7-40设置菜单

- 区域: 设置操作区域，否则操作区域为整个范围。

- 选择分组区域: 需要先在“造型设置”模块中创建分组。方法: 编辑菜单 $>$ 创建分组。

覆盖模式: 覆盖模式与插入模式的切换（不选择即插入模式）。

- 设置造型: 进入灯光造型窗口界面。

- 设置简易造型: 快速设定几何形灯板。

- 设置效果: 进入动画效果设置窗口，主要演示用（较少使用）。

- 系统设置: 设置软件系统参数。

$\mathfrak{o}$ 保存设置: 设定自动保持时间间隔。

- 语言设置: 可以选择软件操作界面的语言。

（2）花样（灯效）面板介绍花样编辑面板包括花样、颜色和视频3个面板。此面板规定了花样（灯效）设计的两种方式，分别为“内置效果”组合设计和“视频导入”方式生成花样（灯效）。

内置效果组合设计: 用已有的动态花样（灯效）进行组合设计，逻辑是先选颜色再选择花样效果（图7-41）。

定义颜色（图7-41）: 

- 清空所有颜色。

- 过渡模式，定义了两种颜色之间的过渡方式。

- 定义颜色，按自己需要的顺序点选色板中的颜色（可以随时删除）这时几种颜色之间会根据过渡模式自动过渡。

![images/5bddcb82c77b72dd767dbb1672691a86502421d3ccfd99b973b5c924d83d5a3f.jpg](https://i.imgur.com/8bXciYX.jpeg)
图7-41颜色设置

- 保存，保存后可以从颜色库样例中查看到，也可以选择后移除。

- 调用，可以从颜色样例库中选择已有的颜色和自己定义的颜色。

![images/48c19dc8aece799c6f748f6110dfcccb6b37cf79034490a422e2f5cc2ecad682.jpg](https://i.imgur.com/II6dtx1.jpeg)
图7-42动态设置

定义动作（图7-42）: 

此处规定了10余种常见的运动方式，在动作选项窗口中可以依次选择自己需要的运动方式。每种动作形态都有各自的二级选项控制具体的变化（图7-42）。

循环使用前一帧颜色，可以让过渡更加自然。

- 生成帧数，定义自己所需要的总时长（根据帧率可以计算出精确的时长）。

步长，两种颜色之间的过渡大小。

### 7.4.7 灯光效果编辑
（案例7-26）

任务: 仍然在 $16\times16$ 的灯板上制作一个动态的画面效果并显示出来，设置前先确认好灯板的布线方案（是否折返型，即蛇形布线）。总体思路与步骤: 灯光布线设置 $>$ 花样（灯效）设计 $>$ 文件输出 $>$ 测试播放。

（1）灯光布线设置·在软件中设计一个与实体灯光分布完全一致的灯光布线方案，首先切换到“设置造型”模块，启动软件后依次点击，［设置］菜单 $>$ 设置造型。布线设置整体分为以下6个步骤（图7-43）。

![images/6d7dbf20729682f244d3f7ec927311e09d2160e0ed859c9b02524221201f8906.jpg](https://i.imgur.com/9VOcVjS.jpeg)
图7-43灯具布线设置

新建文件（灯光造型），定义灯光矩阵的大小（即分辨率共有多少个灯珠，横向为行，竖向为列），此处选择 $16\times16$

568) 设定接线方式，常见的有单向行优先、单向列优先、折返行优先、折返列优先、最短距离、最短距离行优先等，具体可以通过不同软件预览接线的方式。此处选择“折返行优先”。

显示模块: 选择单点。

- 线路限定点数: 选择512（ $16\times16=256$ ，不超过512，也可输入每个端口输出的最大数字），代表一条线路上有256个灯珠，此处只有1条线。

5 设定控制方案，选择8条线路一个分控（此例选择的H803SA控制器就是一个控制器8个端口，8条线路代表的就是8个端口）。

- 绘制接线，单击工具栏上的“添加”按钮，框选灯珠区域实现自动接线，检查接线方式与实际灯板是否一致（通常一种颜色代表一路，此例只用了一条线路所以全部显示红色）。

（2）控制器设置

设置〉控制器设置，选择对应的光源型号和控制器类型具体设置（图7-44）。

![images/07d92428bcdc6fadad1b4df4c2acdbcc24a7232b61180fcb48766aec689ddf9d.jpg](https://i.imgur.com/pbkbEz0.jpeg)
图7-44控制器设置

时钟，一般以兆赫为单位（MHz）。

- 灯具类型: 指灯光色彩的排列顺序设定，一般有三种或四种颜色（如三色的排序有RGB，RBG，GBR，GRB 等）。此处选择RGB，如果颜色不对可以调整顺序。

Gamma: 选择默认（表达的是输出值与输入值的关系），代表亮度。

5 灯光驱动芯片的类型: 常见的有LPD6803，LPD8806，WS2801等，此处选择WS2812。

选择控制器类型: 一般有TA，TB，TC，SA，SB，SC，SD，SE等（指控制器型号后面的字符），此处选择SA（本例使用的控制器是H803SA）。

保存灯光设定的文件以备后续再次调用，不同软件的格式扩展名不同（此处的文件为\*Scu)。

（3）花样（灯效）编辑

- 单击工具栏上的“返回”按钮，回到花样编辑模块。

- 新建效果文件: 选择分辨率大小，软件会根据前一步骤的灯光设置自动选择对应分辨率，此处 $16\times16$

$\mathbf{\delta}$ 定义颜色: 选择控制板上的“颜色”标签，清空现有的颜色，过渡模式默认，从色板上选择 $_{3\sim5}$ 个同一色系的颜色（根据自己喜好选择），现有色板不满足时可以从当前色右下方的三角打开更多色板，然后用最下方的填充工具进行填充，颜色选择好后可以保存以便后续继续使用（图7-45）。

4 返回“花样”标签，勾选循环使用前一帧颜色，生成帧数选择100，点选“椭圆扩散”，即可生成100帧动画（图7-46），将播放速度降低到5，点击工具栏上的播放与停止按钮预览效果。

预览效果后，可以对帧数进行精细修剪、二次编辑、删除多余帧、增加空帧、复制同样顿等。

同样也可以利用“视频”标签中的内置效果或重新导入已有的动态效果（图7-47）。

![images/3c0cda93c74f05367f6276732d0576b37ac0e2da8f4cb423a362cb3b9fc623e6.jpg](https://i.imgur.com/RGDAEb9.jpeg)
图7-45颜色设置

![images/728d28bf1e5e1de3152747463a59666978740d076b638657dc6042b0c91f8b26.jpg](https://i.imgur.com/mTL6P2t.jpeg)
图7-46动态设置

![images/f5f38f940550453a9279aacbe3880df0514468850d6fd1a01a8f909eb908e3a2.jpg](https://i.imgur.com/Ivy1lNQ.jpeg)
图7-47内置视频设置

- 内置花样自定义，利用菜单中的“内置花样”命令，重新自定义属于自己独特的灯光运动形态，对于每一种动作都有非常详细的控制参数可以选择，以便可以制作出自己想要的效果（图7-48）。

![images/8feb7ec70dea02857f8497cb94ebb3863c6933d4a5c1c03ad41bf1250fbe8fee.jpg](https://i.imgur.com/YZvUl8J.jpeg)
图7-48内置花样编辑

（4）花样（灯效）编辑技巧

此处可以添加几个不同的效果，通过右键剪切固定帧范围将其粘贴到想要的位置形成前后关系。

也可以粘贴到固定帧范围处，选择覆盖后再选择不同的覆盖模式，形成更加丰富的视觉效果。

-  也可以通过右键精确修剪，复制添加某些固定帧，以便达成更加丰富和想要的效果，比如连续增加多帧可以实现画面静止，不同模式的叠加可以形成更加丰富的变化。

4 利用以上方法，可以尝试与一首乐曲进行音画同步，让不同的灯光运动效果与音乐的节奏和韵律产生同步，关键是计算好每一个音节的时长，用不同的灯光效果与之对应。

（5）效果播放设置效果编辑完成后，单击“文件”菜单，选择输出控制器数据，选择存放位置，将其拷贝到SD卡中即可实现自动播放（控制器的设置可以参见7.3.2节）。

优势: 性能稳定、使用灵活、性价比高。
不足: 深度交互方面还需要借助其他的系统和软硬件。

如果仅仅是LED灯光矩阵屏的控制，以上方案已经具有很高的性价比和稳定性，但是对于一些需要实时渲染和深度交互的项目而言，则需要更多传感器和专业软件的支持，单纯依靠存储卡的方式显然无法解决，这时需要一种能够将计算机画面实时映射到LED 矩阵或其他输出终端上的方案，下面通过此类控制器提供的一种主控 $^+$ 分控的方案来满足这种需求。

### 7.4.8 主控分控图像映射系统
（案例7-27）

从以上案例中可以看出,LED编程软件(如LEDBuild)已经能够完成较为复杂的灯光效果，但不足之处是难以实现足够的交互性，因此需要寻找更进一步的解决方案，以便能够利用灯光这种媒介进行深度的交互设计，其中主控+分控的方式即是一种性价比很高且非常稳定的方案，它极大减少交互项目对计算机硬件算力的要求。

基本原理: 将计算机屏幕上的特定位置（即利用xy 坐标定义一块区域）直接映射给主控器，由主控器分配内容给其他分控器，由分控器直接输出控制LED。

（1）主控制器介绍 此处以华灿兴的H803T√主控制器（图7-49）为例讲解主控 $^+$ 分控的设置与实现过程，影像内容可以通过 DVI 输入，也可以通过 DVI 转 HDMI直接由电脑输入给主控器。

图7-49H803TV控制器

配套软件: “LED演播软件”V3.97或以上版本。该主控机具有传输速度快、控制LED 多等特点,既可以连接电脑，也可以脱离电脑连接任何能够输出DVI/HDMI信号的设备（如视频播放器等），配套分控器有H802RA、H801RC 等。该主控器有如下特点:

每台最大控制 40万像素点，4个输出网口，每个网口最多控制10万点，可控制几十个芯片型号的灯具，支持单、双通道灯具。

4 个网口独立配置，每个网口最多连接255个分控，每台H803TV最多连接1020个分控。

-  使用DVI视频分配器，多台主控分区控制，数量不限，实际控制能力取决于DVI输出设备，如一台双显电脑最大可控制384万点。

支持多种分辨率 $1024\times768$ $1280\times720$ 、1280×960、1280×1024、1360×765、1360×1020、1600×900、1600×1200。

屏幕刷新频率建议设置为 $60\mathsf{H}Z$ 。

- 采用免驱动USB传输控制数据，32位和64位操作系统都可使用。

传输信号采用快速以太网协议，标称距离为100m。可通过 $\Vdash$ 转换器和光电转换器，使得传输距离达到25km 以上。

（2）硬件连接本案例以 $60\times100$ 的一块屏为例进行主控分控设置（用60个灯珠 $/$ m的灯带共计100条组成一块竖向屏幕），由于需要使用较多的LED灯带，可视硬件条件做改动。（此案例主要模拟大型灯光项目，实际灯珠数为 $60\times100{=}6000$ 个灯珠，用2台H802RA分控器即可完成，每台可以控制 $1024\times4{=}4096$ 。）视频信号通过HDMI接口直接对计算机与主控器进行连接（图7-50）。

![images/4adc023757b6ddc31d05f0e9df70698bcaa9f3cbcfec4a830dd4d9ddd2b74dba.jpg](https://i.imgur.com/YGJEFsz.jpeg)
图7-50硬件连接方案

（3）设置主控器与电脑连接

![images/6cdcac7438c68e11e7074d36eb62b65b15e21cd91128beb5cee98720017859d1.jpg](https://i.imgur.com/8f5dAHD.jpeg)
图7-51选择显示器

将设备与电脑连接好并通电，查看电脑是否检测到两块屏幕，并进行分辨率设置（图7-51）。此时主控器相当于一个显示器。

![images/7b1da66e312733f46236694e0bb91cc69e17778bac456559918fcdf64a35fa1a.jpg](https://i.imgur.com/rrKOVwR.jpeg)
图7-52显示器分辨率设置

- 设置主控器的分辨率（图7-52），右击桌面选择“NVIDIA控制面板”，先设置多个显示器，选择“复制模式”，单击“应用”后DVI指示灯就会闪烁，然后更改分辨率。

一定要选择两个显示器都兼容的分辨率，不同的电脑设置界面会不一样，一般都是从显卡驱动软件端进行设置。

（4）选择主控器 打开LED演播软件（可通过购买设备取得官方软件授权）。

点击“设置” $>$ “系统设置”（图7-53）。

选择H803TV-DVI>点击“应用”〉“确定”（图7-54）。

![images/8c9b2a63e6af8c1c322bb9048a9c71be2284c8d5824a2b6a3da5a1b1a16fc8a7.jpg](https://i.imgur.com/TFezzvK.jpeg)
图7-53系统设置

图7-54选择主控器

（5）灯光硬件造型设置

- 设置>设置造型，点击“确定”，无需密码（图7-55）。

- 进入造型窗口界面后，选择“四条线路一个分控”（H802RA控制器有四个端口）

（图7-56）。

![images/3e1ce1592e17aa326ff42836e148ceabccafee22a43f6381e86e90df13b0249c.jpg](https://i.imgur.com/1vxIyVx.jpeg)
图7-55设置造型命令
图7-56灯光造型设置

（6）选择端口并布点 按照灯具走线方向进行布点。

![images/297bdfdc7e814d9544839643b8d776dfa3221ca065b1b3a53834356865e2c9e9.jpg](https://i.imgur.com/720b9M4.jpeg)
图7-57灯具走线设置

选择工具栏上的“添加”按钮，在灯珠区域框选自动连线。

这里使用的是H802RA，所以是四条线路一个分控，即4个端口一个分控，每个端口最多输出给1024个灯珠，因此将线路限定数改为1024（图7-57），从灯珠的分布情况可以看出。

1，2，3，4条线路放到了第一个分控上的四个端口；5，6条线路放到了第二个分控器上的第1，2个端口上。

（7）多网口设置 点击设置>多网口设置后，使用哪个网口就在哪个网口添加分控编号（图7-58、图7-59）。

IP: 是指分控器的IP 地址，主控机上如果连接四个分控器，IP地址即是这四个分控器的地址，在连接H803TV时，分别指H803TV上的四个网口。

分控编号: 如图7-36下方的序号。

-  分控数目: 分控数目是指带多少个分控，若是单机，数目只能是1，若是主控，可以1个或若干个。

![images/1b2393244049184a44974fa94f4f1c151595b4a964f0113361f0405758a8644d.jpg](https://i.imgur.com/aqjmIBu.jpeg)
图7-58多网口设置
图7-59网口设置

（8)控制器设置点击“设置”菜单，打开“分控器设置”（或点击工具栏上的“小铁锤”图标），完成设置后点击“应用”（图7-60）。

![images/cc62c957b1b331831e8aac05ead87d55da664bf7e1c2425290d9d1a17b9730f6.jpg](https://i.imgur.com/OnU24th.jpeg)
图7-60分控器设置

（9）图像输出设置点击“文件” $>$ “发送到H803TV”后会弹出截取坐标，此时选择要截取的坐标与刷新率，点击“确定”（一般显示器的坐标原点在左上角），见图7-61。

![images/83f9fd9791e9440ca944b2f362cf7a472226518750165aa32e4aa2178e142a0d.jpg](https://i.imgur.com/3FubdjC.jpeg)
Untitled 3LED演播软件
图7-61 画面输出设置

![images/65744542ab90d5a582b0f4dfcc313dd65905fe56f9d82020f0f5ec5e0ffe83e8.jpg](https://i.imgur.com/HsMdRry.jpeg)

弹出下面窗口时点击“确定”（图7-62），H803TV设置完成，当在设定好的区域放置画面时，灯带矩阵则会对应亮起。

![images/4f2f9ab669cdfdb66c90d89c170c377abd9ffa4290ae126c828eb60c66552a43.jpg](https://i.imgur.com/mYv9qhc.jpeg)
图7-62确认最终输出

## 7.5 灯光控制之机械灯

DMX机械灯是一种使用DMX512协议的数字照明灯具，它可以通过DMX512协议实现灵活控制，主要用来控制灯光的亮度、颜色和动态效果。

### 7.5.1 灯具介绍及控制原理

常见的机械灯整体上分为两种类型（图7-63）。

1 光束灯（Spotlight）是一种具有聚光效果的摇头灯，通过特殊的反射器和透镜系统，将光线聚焦成一束强而集中的光束，能够远距离照亮前方道路或目标物体。在灯光艺术中通常

被用于创造明亮、集中的光束效果，用于突出或照亮特定区域或物体。

569) 帕灯（FogLight）是一种具有散射效果的摇头灯，通过特殊的反射器和透镜系统，使光线呈现出散射和扩散的特性，可有效地提供近距离照明和扩大范围的照明。在灯光艺术中帕灯更多地用于泛光照明，提供均匀、柔和的照明。

灯光控制原理: 在摇头帕灯中，通过DMX信号的不同通道来分别控制灯具内部的电机和传感器，实现灯具的旋转和上下摆动。需要注意的是，不同厂家生产的DMX摇头帕灯可能具有不同的控制方式和参数，因此在使用时需要根据具体说明书进行操作。

![images/ba10d0aeec8cfb9bdefa7e77cf3a734fe51ac9092195305650c8c272bf0d7c19.jpg](https://i.imgur.com/KcB4gyu.jpeg)
图7-63DMX机械控制摇头帕灯

### 7.5.2 用TD控制机械摇头帕灯
（案例7-28）

（1）硬件连接本例需要准备的设备有: 笔记本电脑、摇头帕灯1台（本节案例所用为七颗型摇头帕灯）、Art-Net控制器一台、卡侬线和网线，接线方式如图7-64 所示。利用卡侬线将摇头帕灯和Art-Net控制器连接，用网线将笔记本电脑与Art-Net 控制器连接，各自设备上通电。

![images/967399b97208f7291c07ae856c1427cc50c54cd6a1d27afb4fc4a3fbe315d99e.jpg](https://i.imgur.com/2FaHBU9.jpeg)
图7-64机械灯的连接方式

需要注意的是摇头帕灯一般常见两种通道模式，分别为9通道和14通道，每个通道的名称和参数代表的功能如表7-11、表7-12。常规采用9通道即可。

表7-119通道灯具的功能描述


<html><body><table><tr><td>Channel （通道名称）</td><td>Value (值)</td><td>Function (功能)</td></tr><tr><td>1CH</td><td>0~255</td><td>Pan（X轴）</td></tr><tr><td>2CH</td><td>0~255</td><td>Tilt（Y轴）</td></tr><tr><td rowspan="4">3CH</td><td>0~7</td><td>OFF（关闭）</td></tr><tr><td>8~134</td><td>MasterDimmer（总调光）</td></tr><tr><td>135~239</td><td>Strobefromslowtofast（频闪由慢到快）</td></tr><tr><td>240~255</td><td>Open（打开）</td></tr><tr><td>4CH</td><td>0~255</td><td>Red dimmer （红色调光）</td></tr><tr><td>5CH</td><td>0~255</td><td>Greendimmer（绿色调光）</td></tr><tr><td>6CH</td><td>0~255</td><td>Bluedimmer（蓝色调光）</td></tr><tr><td>7CH</td><td>0~255</td><td>Whitedimmer（白色调光）</td></tr><tr><td>8CH</td><td>0~255</td><td>XY Speed（xy 速度)</td></tr><tr><td>9CH</td><td>150~200</td><td>Reset（复位）</td></tr></table></body></html>

表7-1214通道灯具的功能描述


<html><body><table><tr><td>Channel （通道名称）</td><td>Value (值)</td><td>Function(功能)</td></tr><tr><td>1CH</td><td>0~255</td><td>Pan（x轴）</td></tr><tr><td>2CH</td><td>0~255</td><td>PanFine（x轴微调）</td></tr><tr><td>3CH</td><td>0~255</td><td>Tilt（y轴）</td></tr><tr><td>4CH</td><td>0~255</td><td>Tilt Fine（y轴微调）</td></tr><tr><td>5CH</td><td>0~255</td><td>XY Speed（xy 速度）</td></tr><tr><td rowspan="4">6CH</td><td>0~7</td><td>OFF（关闭）</td></tr><tr><td>8~134</td><td>MasterDimmer（总调光）</td></tr><tr><td>135~239</td><td>Strobe from slow to fast（频闪由慢到快）</td></tr><tr><td>240~255</td><td>Open(打开）</td></tr><tr><td>7CH</td><td>0~255</td><td>Red dimmer（红色调光）</td></tr><tr><td>8CH</td><td>0~255</td><td>Greendimmer（绿色调光）</td></tr><tr><td>9CH</td><td>0~255</td><td>Blue dimmer（蓝色调光）</td></tr><tr><td>10CH</td><td>0~255</td><td>Whitedimmer（白色调光）</td></tr></table></body></html>

续表


<html><body><table><tr><td>Channel（通道名称）</td><td>Value (值）</td><td>Function（功能）</td></tr><tr><td rowspan="3">11CH</td><td>0~7</td><td>Colorselect（颜色选择）</td></tr><tr><td>8~231</td><td>Color combiner（颜色组合）</td></tr><tr><td>232~255</td><td>Colorjumping（颜色跳变）</td></tr><tr><td>12CH</td><td>0~255</td><td>Colorjumping speed（颜色跳变速度）</td></tr><tr><td rowspan="2">13CH</td><td>0~142</td><td>auto running（自走）</td></tr><tr><td>143~255</td><td>Sound（声控）</td></tr><tr><td>14CH</td><td>150~200</td><td>Reset（复位）</td></tr></table></body></html>

（2）光源系统设置简介光源模式调整见图7-65，其中MODE/ESC 键为进入设置和退出设置，UP和DOWN 键为上下选择键，ENTER键为确认功能。

![images/9ba21194f9a3b9cd90fadb20ba797c85c39e608b32545b4ccfe6a0cbf2b37902.jpg](https://i.imgur.com/X0M0zMk.jpeg)
图7-65光源模式调整

（3）模式选择 将灯光由出厂的14 通道模式改为 9 通道模式。通过按键的组合操作选中 9CH 后按 RNTER 键来确认。

（4）学习目标该方案通过 Touchdesigner 对 DMX摇头灯进行控制，使之在 60°范围内随音乐的律动上下左右摇摆，同时不停地发生颜色的变化，闪烁绿色的灯光。重点学习如何对摇头灯进行控制。程序结构见图7-66。

整体框架思路: 建立总控数据〉引引入音乐〉分析选择数据〉数据重定义〉动作设置〉输出设置>通信输出。

![images/284fbe70963fc89f335c7debe3e068eef05e6613f4e39a2f8fa02f6766293d44.jpg](https://i.imgur.com/6oZXxry.jpeg)
图7-66 “绿色瞭望”摇头灯控制程序

（5）建立总控数据创建constant1.CHOP，增加9个通道，并按照9CH 帕灯的通道名称进行命名，便于后续控制，这个元件相当于总控台（图7-67）。

![images/f6ecb25afd1a08d95c177478383b607b4d4cad091a687655fab0f0fbca0a33de.jpg](https://i.imgur.com/vgEkzIy.jpeg)
图7-67控制器元件设置

（6）引入音乐 创建audiofilein1CHOP导入外部音乐，继续在后面添加audiodevout1CHOP（音频输出）和audioAnalysis（音频分析器）自动分析出音乐的各个

数据。

（7）分析选择数据在 audioAnalysis COMP 中打开所有音频参数选项，利用select1 CHOP 选择 mid（中音），select2 CHOP 选择high（高音），select3 CHOP 选择 kick（节拍）、Snare（军鼓）和 rythm（节奏）。

（8）数据重定义把上面选择的三组数据根据实际使用需求，用 Math CHOP 进行各自的范围映射，添加各自的 Null后，分别将其命名为 green，y，master dimmer（绿色通道,上下摆动通道，总调光）。

（9）动作设置 创建 LFO CHOP 作为×通道（左右摆动通道），用 Math CHOP进行范围映射，添加 Null将其命名为X。

（10）输出设置．将以上命名好的通道数据赋值给 constant1 CHOP 的对应参数中（点击右下角 $^+$ 号后直接拖动到相应参数栏中），再在 constant1 CHOP 后面添加 dmxout1CHOP进行通信输出设置。

（11）通信输出打开Art-Net控制器，将其IP 地址和计算机的 IP 地址填入 DMX outCHOP 元件中，选择 Art-Net输出方式完成通信设置，详见 Art-Net控制器与计算机的连接。

练习扩展: 可以进一步尝试使用 Leapmotion 和 Kincet 传感器与摇头帕灯进行交互效果创作。

## 7.6 其他专业灯光控制软件

### 7.6.1 MADRIX灯光控制

（1）基本功能介绍．专业的灯光控制软件能够快速编辑并输出各种动态丰富的灯光效果，能够在真正输出前完成效果的预览，并以可视化的方式进行灯光的程序设计，降低了灯光控制艺术的技术门槛，极大方便了灯光艺术的创作。麦爵士（MADRIX）是业内领先的LED照明控制软件，不仅能够方便地进行平面灯光动态效果的控制，还能进行3D 立体空间的灯光控制，给灯光艺术创作带来了更大的空间。它的基本功能如下。

灯光特效设计: MADRIX提供了丰富的视觉效果，如颜色混合、移动、形状变换等，还拥有强大的实时预览功能，用户可以在设计和编程过程中随时查看效果。

2 生成工具: 内置许多强大的生成工具，用户可以使用这些工具创建自定义图形、文本、形状和动画。

-  像素映射: 支持高级像素映射技术，可在 2D 或 3D 空间中通过像素映射进行灯光控制，因此用户可以在LED 灯光系统中实现非常复杂的图形与动画效果。

4多设备管理与通信: 支持多种设备的管理和控制，支持包括 DMX、Art-Net等多种协议，这意味着用户可以使用同一台电脑控制更多LED 的照明。（2）软件的安装与概览访问 MADRIX 官网，在 support 中找到下载页面，根据操作系统（Windows 或 macOS）选择相应的版本下载，运行 MADRIX 安装程序，按照提示进行安装。安装过程中可以选择安装目录和语言等（图7-68）。

![images/d40deb7ba43be8b0041645091d286ffd7c548d6420e19c93ef161723ee314208.jpg](https://i.imgur.com/BxCgJft.jpeg)
图7-68MADRIX软件的下载

### 7.6.2 软件界面介绍

安装完成后启动软件，整体操作界面见图7-69。

![images/bbdad54e7e0e00e22a0b0ccc1d1c9fd4e29aea8f34665dad41662813db2aff2a.jpg](https://i.imgur.com/DkwMzlZ.jpeg)
图7-69MADRIX软件的界面与功能分区

![images/f6e284e202486721cf7628677513ef8108a03258d8498bd91cbe1d113d75f0c2.jpg](https://i.imgur.com/XM3HCZz.jpeg)

(1)A:菜单栏 界面上方的菜单栏为软件的基本功能索引，包含文件管理、设计工具、系统设置等。

- 文件: 用于打开和保存工程文件、导入导出素材。

查看: 用于调整显示模式，有全屏、触摸和默认模式。

首选项: 主要使用矩阵生成器、配接编辑器和设备管理器，完成灯具和设备的配置。

工具: 用于查看场景列表、灯具的控制、DMX 和 MIDI 的通道变化等。

- 预览: 对预览窗口的显示进行相关设置。

- 语言: 界面语言的设置。

（2）B，C: 左右预览与储存区 该区域主要完成灯光效果的控制预览和存储等（图7-70）。

![images/dd791481f46394bc045169ebf288a31d9e84c8c0bfd55cae7b31403b23a3839a.jpg](https://i.imgur.com/aQDX1Hw.jpeg)
图7-70左右预览与储存区功能

- 从上到下依次为: 调节亮度、图层滤镜颜色选择器、效果编辑。

画面预览区域。

调节效果的播放速度和暂停。

- 用于选择场景和排列方式以及效果编辑。

- 可进行多达256个效果的暂存，可滑动底部滚轮查看所有场景效果，每新建一个效果会自动保存，也可以随时通过右键删除。

（3）D，E: 左右效果编辑区 该区域主要完成效果编辑与控制。

![images/2da365278410182f74e283ffed5968e2bfe0a15e08d34f5d6529bda14e53d172.jpg](https://i.imgur.com/MPEFrZc.jpeg)
图7-71左右效果编辑区功能

如图7-71所示。

- 可方便地选择大量系统内置的灯光效果。

- 从左到右依次为: 播放或暂停效果参数。启动或停止图层宏。重置效果参数。

从左到右依次为: 集控，控制画面整体显示亮度（范围为0\~255）。用于对效果进行集中控制的工具（效果显示范围为0\~255）。地图，定义画面的映射尺寸，将虚拟的灯光像素与实际物理灯光位置相对应，能以更直观的方式展示实际灯光安装位置和布局。图层混合模式（默认为正常）。链接，将当前图层链接到下方图层。图层滤镜（默认为无效果）。

![images/12a036ada3c75afb60b35ea2a2e1c6107d6ef92aa830118abf48c18d96baabb5.jpg](https://i.imgur.com/6BOcJMF.jpeg)
图7-72效果控制

- 从左到右依次为: 不透明度，控制画面整体不透明度（范围为0\~255）。设置不显示图层。设置独显图层。

- 效果的各项可调节参数。
- 切换图层和效果的英文名。
效果控制如图7-72所示。

（4）F: 主预览窗口 该区域是左右储存区的叠加预览窗口（图7-73）。

![images/79f962844e7b352ee9e1b871c0799a32898a6d97fe55b4196b48bdf7e324d459.jpg](https://i.imgur.com/CtEviLa.jpeg)
图7-73主预览窗口区

- 双击可快速进入触摸模式。

- 从上到下依次为: 图层滤镜颜色选择器。效果编辑。

5 画面显示区域。

- 从上到下依次为: 频闪颜色选择器，用于选择画面频闪的图层底色。频闪频率，控制画面效果的频闪频率。控制频闪效果，左键长按可以模拟画面频闪效果。

用于左右预览窗口的效果过渡，内置很多过渡效果。

- 从左到右依次为: 录制效果。操作模式选择，编程人员和运算符两种。查看三种模式类型，图层控制、场景列表和组控制。

（5）G: 总控台 对整体画面进行总体控制（图7-74）。

- 用于冻结主输出。

- 自动增益控制器（AGC）: 常用于调节音频信号的增益以实现动态范围的控制，使得输出信号的音量保持相对稳定。

![images/55a885c3481113634331d4eb42845cba7cb343162b8dfe0ae4293babdaa7bd93.jpg](https://i.imgur.com/eajuc1R.jpeg)
图7-74总控台

- 主画面显示控制: 左键单击可实现画面显示和关闭。

- 音频总输出。

- 音频总输入。

### 7.6.3 3D灯光矩阵光影秀
（案例7-29）

（1）概念创意与学习重点

1 概念创意: 本案例用9条 LED灯带组成 $3\times3$ 的空间阵列，以“落花流水”为题，制造一种自然浪漫的光影秀，把流动的灯光效果融入 3D 空间矩阵中，灯光效果更加丰富立体。通过灯带的特殊效果，模拟流水的视觉景象。

2 学习重点: 主要掌握 3D 空间表现技术（以往案例均为 2D 空间），同时掌握控制器端口的独立控制方法。

（2）硬件连接硬件清单: 笔记本电脑，Art-Net控制器（本节案例使用16口，单口1024通道的控制器），WS2812BLED灯带9条（30个灯珠／条），5V电源，网线,导线若干（可使用双绞网线）。

接线方式: 用网线将笔记本电脑与Art-Net控制器连接；用导线把控制器与灯带连接（信号线和GND）；用导线将5V电源和每条灯带连接（图7-75）。

![images/71b966d68859523333213ae4101d5786a6ce9221bcb1d98ebb11025391c16eb0.jpg](https://i.imgur.com/yy152eI.jpeg)
图7-75灯光矩阵的硬件连接

（3）配置控制器 首先，在麦爵士中配置控制器（图7-76）。

![images/494c820408ed89ab127558bd51e9967f81778a2b676cb0c200b1c41e0c70da5d.jpg](https://i.imgur.com/zst6SyC.jpeg)
图7-76 配置控制器

打开菜单栏的“首选项” $>$ “设备管理器”

2 选择“Art-Net”标签页，点击左下角的放大镜图标进行设备搜索，找到设备后检查所有端口和对应的空间是否准确。空间指的是一个Univese（512个通道）。

其次，配置输出端口（图7-77）。

![images/007e0488d8dc6a7cba4d2f8ee213d9c579ad71b35fce9b69668835737a8ca517.jpg](https://i.imgur.com/TQIsvxS.jpeg)
图7-77端口配置

选择“DMX设备”标签页，配置本案例需要使用的端口，在右侧面板中点击启用进行开启，由于本案例一条灯带的数量较少，所以每个端口只需要一个Universe 即可（512个通道），可以依次关闭其他多余的空间（即 UniverSe）。

此处的1个空间是指一个Universe（它与硬件端口对应，此处一个端口有两个Universe 即两个空间，因为一个端口是1024个通道），名称可以自定义。

再次，重命名空间名（图7-78）。

![images/358f213a0d365b2759cc54e73ca6cd9fb93671683c11755038ccd84bc8b86919.jpg](https://i.imgur.com/w9aZoxT.jpeg)
图7-78通道集合命名

关闭完多余的Universe 后，顺位将间隔的空间（Universe）进行重新命名（分别设为 1\~9，代表9个输出端口输出给9条灯带），这样方便后期管理，按“确定”完成控制器配置。

（4）构建信息输出地图麦爵士的灯光信号输出分为两种主要的方式，一是DMX地图，LED 控制器只是作为信息输出的功能；二是 DVI 地图，LED 控制器可以作为独立的播放终端进行信号输出，该种方案更适合灯光秀的应用场景。此处案例采用的是DMX地图的方式进行的信号输入。

![images/b4f165b62fce1963e3e6b79a9e5c5f492cefca851d47471ab89d6bc820b068c0.jpg](https://i.imgur.com/ANxn4Xz.jpeg)
图7-79空间矩阵设置

第一步: 空间显示设置，相当于设置一个视图空间（图7-79）。

- 打开菜单栏的“首选项 $v>{^{\circ}}$ 配接编辑器”

选择“矩阵设置”，对显示区域进行范围设置，将 $\times,\times,Z$ 数值分别修改为30,3,3( $\bigtimes$ 对应单条灯带的灯珠数量，丫对应行数，乙对应列数）。

设置完后，按 $\mathsf{C t r}|+\mathsf{A}$ 全选默认的灯具网格，随后按键盘Del键全部删除，为创建自定义灯具做准备。

![images/97686f8455fe0257be5dec56e821a62ed9f09f7bc93ecd95ae94cdcc6a953070.jpg](https://i.imgur.com/bW9ktOR.jpeg)
图7-80灯具矩阵设置

第二步: 灯具设置，设定一个矩阵灯带空间（图7-80）。

- 选择“添加”菜单，添加灯具。

- 在“产品”标签栏中选择“genericRGB Light 1 pixel"

-  在“计数 $\times/\Upsilon/\overline{{Z}}^{\mathfrak{N}}$ 中将 $\times,\ Y,Z$ 数值分别修改为30,3,3 ( $\bigtimes$ 对应单条灯带的灯珠数量，丫对应行数，乙对应列数）。

勾选“应用到每个空间”

- 在“各个空间的灯具计数”中将数值改为 30（意为每个通道只使用30个灯珠的通道数），点击“添加”。

![images/f6e59eb1ad19cb956a643cf56768ac4751b7d4f289b413308c0e505936255755.jpg](https://i.imgur.com/8expkRh.jpeg)
图7-81端口输出验证

第三步: 验证端口分配情况: 9个端口是否单独输出给9条灯带（图7-81）。

方法:

- 选择“DMX地图”菜单。

- 在界面中的“查看起点”中可以进行DMX 空间的翻页，查看是否有 9 个 DMX 空间。

- 左侧下方的灯具面板中是否有 30个灯珠。

（5）效果制作

![images/22b3287a16fce391c2f6854eff01cf71b2e0adae14daf1af0cf3dc82e13b5a8d.jpg](https://i.imgur.com/YNUjLlb.jpeg)
图7-82模式选择

打开3D视图（图7-82）。

打开菜单栏“预览”中的“PreviewDeckA”，将 2D 模式改为 3D模式，弹出提示后，点击使用3D模式。

![images/7c8c6f8167f29ae0bb52c686749ae24d4d7740a75efc4eb4fc4e76e21c0393cd.jpg](https://i.imgur.com/ZIHcIQN.jpeg)
图7-83效果设置

效果设置见图7-83。

- 在左效果编辑区中选择“SCE”中的“SCE波形/径向”效果。

- 下方参数栏将BPM参数修改为882，长度参数修改为358，宽度参数修改为70（参数可依据具体效果调整）。

在右侧形状中选择3D形状中八面体。

（6）效果测试 设置完效果会同步显示在实体灯珠上，根据效果需要可以进一步对二级参数进行相应调整。

### 7.6.4 Depence 软件简介

一般灯光控制软件能够方便地预览灯光的动态效果，但缺乏对使用环境的表达，比如灯光秀、水秀这类的作品的最终效果表现需要后期进行合成，为了更加形象地展示灯光作品在特定环境下的效果，软件公司开发了集效果表现与程序设计于一体的软件，Depence就是其中的优秀代表。作为一款专业的秀场设计软件，它提供了先进的视觉化工具，可以帮助用户创建逼真的照片级效果，同时可以动态模拟各种灯光效果。设备的所有物理和控制特性都可以得到实时且精确的模拟，可以使秀展的设计和可视化过程更加直接，真正所见即所得。借助时间线管理，可以对多种媒介进行整合设计。借助Depence2 可以专注于设计、故事和编程，并实时查看结果。

Depence支持多种照明控制协议，如DMX、Art-Net和SACN等，可以与各种灯光设备进行通信。此外，还提供了实时预览、音频同步、多屏幕输出等功能，已被广泛应用到了舞台灯光、灯光秀、喷泉水秀及激光等。其环境渲染功能还可以将多媒体节目集成到自然的建筑场景中去。

Depence 官方网站为 https: //www.syncronorm.com。

该软件由多个模块构成，每种模块都有自己独特的功能，均需要独立授权，可以将其整合起来创作集多种媒介于一体的综合作品（图7-84）。

![images/e22c78bf3271cd7589ad2ff848fcfceed31053805495c29bbb299ee629ad8ca7.jpg](https://i.imgur.com/nnwMlpj.jpeg)
图7-84Depence的主要模块及功能

![images/f3c191119971915aee729ea483e828e0a1acdaefb95637130f46e3e67340dbc4.jpg](https://i.imgur.com/xzCnrEL.jpeg)

# 附录

附录1 Touchdesigner常用表达式
附录2 元件索引
附录3 学习资源
附录 4 材料列表

# 附录1Touchdesigner常用表达式

（1）常用元件表达式me.digits//获取自身元件的参数。

me.par.tx // 查询同一 OP 中的参数。

me.name // 获得 OP 的名字。

me.parent().digits // 获取元件父级的参数。

parent().name // 获得OP的父级的名字。

parent(）或../lI/获得OP的父级。

parent(2)//获得OP的祖父级。

op（‘s’)[‘speed’].eval(）//op(）意为获取一个数值。其中 s为元件名，speed 为元件中的通道名，eval（）代表数值（注: 获取的对象须为chop元件）。op（‘constant1’)[‘chan1’].eval(）//获取 constant1 元件中’chan1’通道的值。op（‘constant1’).numChans // 获取constant1元件的通道数量。op（‘constant1’）.numSamples // 获取constant1元件的采样数量。op（‘constant1’)[2]//从constant1元件中获取第3个通道的值。op（‘constant1’)[1].name // 获取 constant1 元件中第 2 个通道的名称。op（‘constant1’)[‘chan1’].index // 获取 constant1 元件中的通道索引l。len(op(‘switch1’).inputs) / len(）是Python 的内置函数，len()意为返回对象的长度。获取Switch元件的输入值。

（2）时间表达式

absTime.frame//检索帧中的绝对时间（多用于旋转）。
absTime.seconds//以秒为单位检索绝对时间（多数用于位移与形变）。
me.time.seconds//以秒为单位获取时间轴上的实时时间，是一个动态的值。
me.time.frame//以帧为单位获取时间轴上的实时帧数，是一个动态的值。
注: “绝对时间”是启动Touchdesigner后到当前的时间长度，不受工程文件暂停的影响

（3）DAT元件表达式

op（‘table1’)[2,3]//获取table1的第 2行第3列（第一个参数是行，第二个参数是列）。
op（‘table1’)[‘r1’，‘c1’]// 获取table1的r1行和从列。
Op（‘table1’)[2，‘product’]// 按行索引l，列标签获取单元格值。int(op（‘table1’)[‘month’，3]）// 将table1表格中特定的数值转换为整数。
float(op（‘table1’)[‘speed’，4])// 将table1表格中特定的数值转换为浮点数。

# 附录2 元件索引

附录2为本书使用的元件索引，通过案例领会这些元件的基本功能和用法，进一步学习更多元件功能。

（1）TOP类型元件介绍


<html><body><table><tr><td>Blur</td><td>P98</td><td>Monochrome</td><td>P78</td></tr><tr><td>Composite</td><td>P80</td><td>Movie File In</td><td>P146</td></tr><tr><td>Crop</td><td>P187</td><td>Movie File Out</td><td>P86</td></tr><tr><td>Displace</td><td>P99</td><td>Noise</td><td>P99</td></tr><tr><td>Edge</td><td>P79</td><td>Over</td><td>P115</td></tr><tr><td>Feed back</td><td>P79</td><td>Ramp</td><td>P98</td></tr><tr><td>Flip</td><td>P188</td><td>Render</td><td>P105</td></tr><tr><td>Function</td><td>P115</td><td>Text</td><td>P107</td></tr><tr><td>Kinect</td><td>P123</td><td>Threshold</td><td>P123</td></tr><tr><td>Level</td><td>P114</td><td>TOP to CHOP</td><td>P188</td></tr><tr><td>Look up</td><td>P139</td><td>Transform</td><td>P100</td></tr></table></body></html>

（2）CHOP类型元件介绍


<html><body><table><tr><td>Analyze</td><td>P109</td><td>Limit</td><td>P97</td></tr><tr><td>Audio File in</td><td>P121</td><td>Logic</td><td>P152</td></tr><tr><td>Audio dev out</td><td>P96</td><td>Math</td><td>P109</td></tr><tr><td>Audio Filter</td><td>P108</td><td>Merge</td><td>P188</td></tr><tr><td>Audio Spectrum</td><td>P121</td><td>Mouse in</td><td>P149</td></tr><tr><td>Constant</td><td>P212</td><td>Reorder</td><td>P188</td></tr><tr><td>DMX Out</td><td>P191</td><td>Select</td><td>P97</td></tr><tr><td>Datto</td><td>P132</td><td>Shuffle</td><td>P188</td></tr><tr><td>Filter</td><td>P97</td><td>TOP to</td><td>P188</td></tr><tr><td>Lag</td><td>P122</td><td>LFO</td><td>P213</td></tr><tr><td>Leap Motion</td><td>P109</td><td></td><td></td></tr></table></body></html>

（3）SOP 类型元件介绍


<html><body><table><tr><td>AttributeCreate</td><td>P134</td><td>Tube</td><td>P106</td></tr><tr><td>Extrude</td><td>P124</td><td>Point</td><td>P120</td></tr><tr><td>File in</td><td>P102</td><td>Sort</td><td>P119</td></tr><tr><td>Grid</td><td>P119</td><td>Switch</td><td>P104</td></tr><tr><td colspan="2">Noise P104</td><td>Trace</td><td>P124</td></tr><tr><td>1no</td><td>P104</td><td>Transform</td><td>P103</td></tr><tr><td>Particle</td><td>P120</td><td></td><td></td></tr></table></body></html>

（4）MAT类型元件介绍


<html><body><table><tr><td>Constant</td><td>P84</td><td>Phong</td><td>P107</td></tr><tr><td>PBR</td><td>P105</td><td>Pointsprite</td><td>P126</td></tr></table></body></html>

（5）DAT类型元件介绍


<html><body><table><tr><td>CHOP Execute P151</td><td>Serial P132</td></tr></table></body></html>

（6）COMP类型元件介绍

<html><body><table><tr><td>Base</td><td>P104</td><td>Light</td><td>P83</td></tr><tr><td>Camera</td><td>P81</td><td>Window</td><td>P87</td></tr><tr><td>Container</td><td>P87</td><td>Kantanmapper</td><td>P154</td></tr><tr><td>Geometry</td><td>P84</td><td></td><td></td></tr></table></body></html>

# 附录3 学习资源

（1）Arduino 官方论坛

该论坛有大量关于软硬件及问题方面的交流，可进行Arduino 问题讨论和求助，有大量的项目案例，并有不同硬件的专题讨论。

（2）Arduino爱好者

Arduino在社区动力上的交流平台。该平台有大量交流资源，可以进行相互讨论，有很多不同主题可供选择，也有大量Arduino的教程，在这里可以找到使用过程中的各种问题与解

决方案。

（3）Arduino 实验室

该网站是国内重要的Arduino学习交流平台，有大量的教学资源与创客商店，可以方便地购买各类硬件产品，还可以将自己的创作进行发布与投稿。

（4）GitHub 开源社区

GitHub是一个开源社区，开发者们可以找到各种各样的开源项目，它是一个基于互联网的代码托管平台，可以帮助开发者们更方便地进行代码管理、版本控制、协作开发等操作。在GitHub上，用户可以创建自己的代码仓库，将代码上传到仓库中，并与其他用户进行分享和协作。

（5）Mind+官方网站

该网站含有大量关于Mind $^+$ 的技术资料、软件的下载安装与常见问题、创客资源以及问题交流，有不同主题的交流社区，在这里可以找到丰富权威的教程与前沿的问题分享。

（6）MANA新媒体交流平台

MANA是专业聚焦新媒体作品发布的交流平台。平台上有来自全球各地的新媒体艺术家、高校及设计机构实时发布最新作品，从中可了解交互设计的前沿，同时提供了大量视频学习教程，并提供活动、设计竞赛与就业资讯。

（7）TEA新媒体教育社区

TEA新媒体教育社区是一个跨平台、多领域的技术开源和资源共享群体。社区以“科技 $^+$ 艺术”领域的教育和研发应用为核心架构。

（8）太极创客

太极创客主攻方向是物联网、创客机器人和人工智能领域。团队对多种开发板的应用和编程有详细系统的视频学习教程并配有相应的文本教程。团队在B站、微信公众号、微博等社区账号持续更新研究成果和教程，提供了大量优质的教学资源。

（9）灯光控制相关软件与学习资源

FreeStyler
PC_DIMMER
DMXControl
MADRIX（LED屏播放软件2D/3D麦爵士）
Sunlite/EasyView3D软件
DasLight
Martin Lightjockey

LumiDesk Chromateg VenueMagic ShowMagic

# 附录 4 材料列表

本书所用的设备、元件及相关材料的内容与数量如下。产品图片仅做参考，不同品牌产品外观不同，请根据产品名称和具体功能介绍购买。

<html><body><table><tr><td>序号</td><td>设备名称</td><td>数量</td><td>实物参考</td><td>序号</td><td>设备名称</td><td>数量</td><td>实物参考</td></tr><tr><td colspan="6">1开发板</td><td></td><td></td></tr><tr><td></td><td>Uno 板</td><td></td><td></td><td>2</td><td>Uno 扩展板</td><td></td><td></td></tr><tr><td>3</td><td>ESP32 开发板</td><td></td><td>ESP32-EZ Board MINI YURBOT</td><td>4</td><td>Nano 板</td><td></td><td></td></tr><tr><td colspan="8">2信息输入传感器</td></tr><tr><td></td><td>Kinect2代</td><td></td><td></td><td>2</td><td>G4激光雷达</td><td></td><td></td></tr><tr><td>3</td><td>Leapmotion 传感器</td><td></td><td></td><td>4</td><td>超声波 测距仪</td><td></td><td></td></tr><tr><td>5</td><td>模拟声音 传感器</td><td></td><td></td><td>6</td><td>数字振动 传感器</td><td></td><td></td></tr><tr><td></td><td>模拟光线 传感器</td><td></td><td></td><td>8</td><td>模拟压电 传感器</td><td></td><td></td></tr><tr><td>9</td><td>红外入侵 检测仪</td><td></td><td></td><td>10</td><td>红外传感器</td><td></td><td></td></tr></table></body></html>

续表


<html><body><table><tr><td colspan="8">3控制器类</td></tr><tr><td colspan="6"></td><td rowspan="2"></td><td rowspan="2"></td></tr><tr><td></td><td>Art-Net 控制器 华灿兴</td><td></td><td></td><td>2</td><td>华灿兴 LED 控制器 H803SA 华灿兴</td></tr><tr><td>3</td><td>LED分控器 H801RC</td><td></td><td>LES GNTRRAES</td><td>4 4信息输出模块</td><td>LED主控机 H803TV</td><td></td><td></td></tr><tr><td colspan="8"></td></tr><tr><td></td><td>DMX单点单 控灯带</td><td></td><td></td><td>2</td><td>16 ×16 LED矩阵屏</td><td></td><td></td></tr><tr><td>3</td><td>蜂鸣器模块</td><td></td><td></td><td>4</td><td>伺服电机 （舵机）</td><td></td><td></td></tr><tr><td>5</td><td>Digital LED RGB</td><td></td><td></td><td>6</td><td>步进电机 （含ADC 转换器）</td><td></td><td></td></tr><tr><td></td><td>WS 2812B</td><td>10</td><td></td><td>8</td><td>摇头帕灯</td><td></td><td></td></tr><tr><td>9</td><td>RGB灯珠 （四脚）</td><td>10</td><td></td><td>10</td><td>LED灯珠 （两脚单色）</td><td>10</td><td></td></tr><tr><td>11</td><td>I2C LCD1602 液晶模块</td><td></td><td></td><td>12</td><td>音乐播放喇叭</td><td></td><td></td></tr><tr><td>13</td><td>MP3音乐播放 模块</td><td></td><td>DAC</td><td></td><td></td><td></td><td></td></tr><tr><td colspan="6">5电阻中继</td><td></td><td></td></tr><tr><td></td><td>220Ω电阻</td><td>2</td><td></td><td>2</td><td>滑动变阻器</td><td></td><td></td></tr></table></body></html>

续表


<html><body><table><tr><td>序号</td><td>设备名称</td><td>数量</td><td>实物参考</td><td>序号</td><td>设备名称</td><td>数量</td><td>实物参考</td></tr><tr><td colspan="8">6开关类</td></tr><tr><td></td><td>按钮开关</td><td></td><td></td><td>2</td><td>继电器</td><td></td><td></td></tr><tr><td colspan="8">7连接线</td></tr><tr><td></td><td>双母杜邦线</td><td>20</td><td></td><td>2</td><td>公母杜邦线</td><td>20</td><td></td></tr><tr><td>3</td><td>双公杜邦线</td><td>20</td><td></td><td>4</td><td>面包板</td><td></td><td></td></tr><tr><td>5</td><td>扩展板组合连接 线</td><td>10</td><td></td><td>6</td><td>TypeC 数据线</td><td></td><td></td></tr><tr><td></td><td>MicroB数据 线</td><td></td><td></td><td>8</td><td>Type B 数据线</td><td></td><td></td></tr><tr><td colspan="8">8其他类</td></tr><tr><td></td><td>写码器</td><td></td><td></td><td>2</td><td>5V2A电源</td><td></td><td></td></tr><tr><td>3</td><td>5V80A 400W电源</td><td></td><td></td><td></td><td>SD内存卡 读卡器</td><td></td><td></td></tr></table></body></html>

# 参考文献

[1顾振宇.交互设计原理与方法[M].北京: 清华大学出版社，2016.[2]Digital FUN.TouchDesigner全新交互设计及开发平台[M].北京: 人民日报出版社，2020.[3]  Mind $^+$ 官方教程 mindplus.dfrobot.com.cn.[4] 太极创客 www.taichi-maker.com.[5]由芳，王建民，蔡泽佳.交互设计: 设计思维与实践 2.0[M].北京: 电子工业出版社，2020.[6][美 ]Alan Cooper. 交互设计之路: 让高科技产品回归人性[M]. 北京: 电子工业出版社，2006.[7]吴亚东，张晓蓉，王赋攀．人机交互技术及应用[M].北京: 机械工业出版社,2020.[8]韦艳丽.新媒体交互艺术[M].北京: 化学工业出版社，2018.[9]［美］詹妮·普瑞斯（Jenny Preece），[英］伊温妮·罗杰斯（Yvonne Rogers），[英］海伦·夏普（Helennarp）.交互设计: 超越人机交互[M].刘伟，赵路，郭晴，等，译.北京: 机械工业出版社，2020.

# 后记

当下的信息技术与人工智能已开始对各个领域产生颠覆性的影响，作为从事艺术设计教学的专业老师和创作者，笔者深刻感受并领略到了技术对艺术设计专业发展产生的巨大影响。而让笔者更感兴趣的是，如何让感性思维主导的艺术设计专业的学生适应这种变化，如何快速补充信息技术方面存在的短板，如何克服技术学习的困难，如何掌握必要的技术推动自我的艺术创作，解决这些问题是本书编写的初衷和目的。笔者带领研究团队历时两年多的时间反复打磨完成了本书的编写。由于交互艺术与技术领域的广阔性与复杂性，本书的编写面临着资料匮乏等诸多困难，大量内容是在研究和实践过程中得以完成。回顾这个过程，既是一次全新的挑战，也充满着我们对设计与技术的无限热情，更是研究团队锲而不舍、勇于坚持的结果。

本书出版之时，首先要感谢初期阅读并参与内容校对、图文处理等工作的王婷婷、谢柯烨、徐冬梅、陈诺、杨田莉、郝新宇等，以及提供实践案例的于淼、洪晓如、焦文博、魏梦圆等。你们的积极反馈和努力工作为本书的不断优化提供了重要依据，也让本书的内容逻辑更加贴近未来学生们的使用需求。作为这本书的受益者，你们对知识的期待与渴望是本书内容不断得以改进与完善的动力来源。希望这本书能为你们今后在交互技术领域的学习与研究提供帮助，激发你们的创新潜力与创作热情。未来你们在这个领域的发展将会让这本书变得更加有意义。

其次，要感谢南京工业大学和艺术设计学院领导们为我们提供的研究条件，是你们持续不断的鼓励、支持和期待让本书能够如期完成，同时要感谢业界的技术专家们在技术方面给予的具体指导和帮助，还要感谢管理、教育、创作领域的前辈们给予的肯定。

毫无疑问，在交互技术的探索过程中还存在这样那样的诸多问题，但令我们欣慰的是，艺术专业背景的我们终于跨越过了这关键的一步，从我们的教学实践中也看到了，艺术专业背景学生学习掌握交互技术的可行性。让务实求真的探索精神照亮我们不断前行，让终身学习伴随我们每一个人。

编著者